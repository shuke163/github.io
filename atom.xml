<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>shuke&#39;s Blog</title>
  
  <subtitle>技术 管理 生活 格局 人生</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://shuke163.github.io/"/>
  <updated>2020-04-20T08:41:23.097Z</updated>
  <id>https://shuke163.github.io/</id>
  
  <author>
    <name>shuke</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>kafka专题</title>
    <link href="https://shuke163.github.io/2020/04/20/index/"/>
    <id>https://shuke163.github.io/2020/04/20/index/</id>
    <published>2020-04-20T08:35:51.000Z</published>
    <updated>2020-04-20T08:41:23.097Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kafka专题"><a href="#kafka专题" class="headerlink" title="kafka专题"></a>kafka专题</h1><blockquote><p><a href="https://www.cnblogs.com/BYRans/p/6054930.html" target="_blank" rel="noopener">Kafka简介</a></p></blockquote><h2 id="消息系统介绍"><a href="#消息系统介绍" class="headerlink" title="消息系统介绍"></a>消息系统介绍</h2><p>一个消息系统负责将数据从一个应用传递到另外一个应用，应用只需关注于数据，无需关注数据在两个或多个应用间是如何传递的。分布式消息传递基于可靠的消息队列，在客户端应用和消息系统之间异步传递消息。有两种主要的消息传递模式：点对点传递模式、发布-订阅模式。大部分的消息系统选用发布-订阅模式。</p><h2 id="点对点消息系统"><a href="#点对点消息系统" class="headerlink" title="点对点消息系统"></a>点对点消息系统</h2><p>在点对点消息系统中，消息持久化到一个队列中。此时，将有一个或多个消费者消费队列中的数据。但是一条消息只能被消费一次。当一个消费者消费了队列中的某条数据之后，该条数据则从消息队列中删除。该模式即使有多个消费者同时消费数据，也能保证数据处理的顺序.</p><h2 id="发布-订阅消息系统"><a href="#发布-订阅消息系统" class="headerlink" title="发布-订阅消息系统"></a>发布-订阅消息系统</h2><p>在发布-订阅消息系统中，消息被持久化到一个topic中。与点对点消息系统不同的是，消费者可以订阅一个或多个topic，消费者可以消费该topic中所有的数据，同一条数据可以被多个消费者消费，数据被消费后不会立马删除。在发布-订阅消息系统中，消息的生产者称为发布者，消费者称为订阅者。该模式的示例图如下：</p><h2 id="Kafka概述"><a href="#Kafka概述" class="headerlink" title="Kafka概述"></a>Kafka概述</h2><p>Apache Kafka是一个分布式的发布-订阅消息系统，能够支撑海量数据的数据传递。在离线和实时的消息处理业务系统中，Kafka都有广泛的应用。Kafka将消息持久化到磁盘中，并对消息创建了备份保证了数据的安全。Kafka在保证了较高的处理速度的同时，又能保证数据处理的低延迟和数据的零丢失。</p><p>Kafka的优势在于：</p><p>可靠性：Kafka是一个具有分区机制、副本机制和容错机制的分布式消息系统<br>可扩展性：Kafka消息系统支持集群规模的热扩展<br>高性能：Kafka在数据发布和订阅过程中都能保证数据的高吞吐量。即便在TB级数据存储的情况下，仍然能保证稳定的性能。</p><h2 id="Kafka-专用术语"><a href="#Kafka-专用术语" class="headerlink" title="Kafka 专用术语"></a>Kafka 专用术语</h2><p>一个topic配置了3个partition。Partition1有两个offset：0和1。Partition2有4个offset。Partition3有1个offset。副本的id和副本所在的机器的id恰好相同。</p><p>如果一个topic的副本数为3，那么Kafka将在集群中为每个partition创建3个相同的副本。集群中的每个broker存储一个或多个partition。多个producer和consumer可同时生产和消费数据。</p><p>各个术语的详细介绍如下:</p><ul><li>Topic：在Kafka中，使用一个类别属性来划分数据的所属类，划分数据的这个类称为topic。如果把Kafka看做为一个数据库，topic可以理解为数据库中的一张表，topic的名字即为表名。</li><li>Partition：topic中的数据分割为一个或多个partition。每个topic至少有一个partition。每个partition中的数据使用多个segment文件存储。partition中的数据是有序的，partition间的数据丢失了数据的顺序。如果topic有多个partition，消费数据时就不能保证数据的顺序。在需要严格保证消息的消费顺序的场景下，需要将partition数目设为1。</li><li>Partition offset：每条消息都有一个当前Partition下唯一的64字节的offset，它指明了这条消息的起始位置。</li><li>Replicas of partition：副本是一个分区的备份。副本不会被消费者消费，副本只用于防止数据丢失，即消费者不从为follower的partition中消费数据，而是从为leader的partition中读取数据。</li><li>Broker：<ul><li>Kafka 集群包含一个或多个服务器，服务器节点称为broker。</li><li>broker存储topic的数据。如果某topic有N个partition，集群有N个broker，那么每个broker存储该topic的一个partition。</li><li>如果某topic有N个partition，集群有(N+M)个broker，那么其中有N个broker存储该topic的一个partition，剩下的M个broker不存储该topic的partition数据。</li><li>如果某topic有N个partition，集群中broker数目少于N个，那么一个broker存储该topic的一个或多个partition。在实际生产环境中，尽量避免这种情况的发生，这种情况容易导致Kafka集群数据不均衡。</li></ul></li><li>Producer：生产者即数据的发布者，该角色将消息发布到Kafka的topic中。broker接收到生产者发送的消息后，broker将该消息追加到当前用于追加数据的segment文件中。生产者发送的消息，存储到一个partition中，生产者也可以指定数据存储的partition。</li><li>Consumer：消费者可以从broker中读取数据。消费者可以消费多个topic中的数据。</li><li>Leader：每个partition有多个副本，其中有且仅有一个作为Leader，Leader是当前负责数据的读写的partition。</li><li>Follower：Follower跟随Leader，所有写请求都通过Leader路由，数据变更会广播给所有Follower，Follower与Leader保持数据同步。如果Leader失效，则从Follower中选举出一个新的Leader。当Follower与Leader挂掉、卡住或者同步太慢，leader会把这个follower从“in sync replicas”（ISR）列表中删除，重新创建一个Follower。</li></ul><h2 id="Kafka架构"><a href="#Kafka架构" class="headerlink" title="Kafka架构"></a>Kafka架构</h2><ul><li>Broker：Kafka的broker是无状态的，broker使用Zookeeper维护集群的状态。Leader的选举也由Zookeeper负责。</li><li>Zookeeper：Zookeeper负责维护和协调broker。当Kafka系统中新增了broker或者某个broker发生故障失效时，由ZooKeeper通知生产者和消费者。生产者和消费者依据Zookeeper的broker状态信息与broker协调数据的发布和订阅任务。</li><li>Producer：生产者将数据推送到broker上，当集群中出现新的broker时，所有的生产者将会搜寻到这个新的broker，并自动将数据发送到这个broker上。</li><li>Consumer：因为Kafka的broker是无状态的，所以consumer必须使用partition offset来记录消费了多少数据。如果一个consumer指定了一个topic的offset，意味着该consumer已经消费了该offset之前的所有数据。consumer可以通过指定offset，从topic的指定位置开始消费数据。consumer的offset存储在Zookeeper中。</li></ul><h2 id="Kafka工作流程"><a href="#Kafka工作流程" class="headerlink" title="Kafka工作流程"></a>Kafka工作流程</h2><p>Kafka将某topic的数据存储到一个或多个partition中。一个partition内数据是有序的，每条数据都有一个唯一的index，这个index叫做offset。新来的数据追加到partition的尾部。每条数据可以在不同的broker上做备份，从而保证了Kafka使用的可靠性。</p><p>生产者将消息发送到topic中，消费者可以选择多种消费方式消费Kafka中的数据。下面介绍两种消费方式的流程。</p><h3 id="一个消费者订阅数据："><a href="#一个消费者订阅数据：" class="headerlink" title="一个消费者订阅数据："></a>一个消费者订阅数据：</h3><ul><li>生产者将数据发送到指定topic中</li><li>Kafka将数据以partition的方式存储到broker上。Kafka支持数据均衡，例如生产者生成了两条消息，topic有两个partition，那么Kafka将在两个partition上分别存储一条消息</li><li>消费者订阅指定topic的数据</li><li>当消费者订阅topic中消息时，Kafka将当前的offset发给消费者，同时将offset存储到Zookeeper中</li><li>消费者以特定的间隔（如100ms）向Kafka请求数据</li><li>当Kafka接收到生产者发送的数据时，Kafka将这些数据推送给消费者</li><li>消费者受到Kafka推送的数据，并进行处理</li><li>当消费者处理完该条消息后，消费者向Kafka broker发送一个该消息已被消费的反馈</li><li>当Kafka接到消费者的反馈后，Kafka更新offset包括Zookeeper中的offset。</li><li>以上过程一直重复，直到消费者停止请求数据</li><li>消费者可以重置offset，从而可以灵活消费存储在Kafka上的数据</li></ul><h3 id="消费者组数据消费流程"><a href="#消费者组数据消费流程" class="headerlink" title="消费者组数据消费流程"></a>消费者组数据消费流程</h3><p>Kafka支持消费者组内的多个消费者同时消费一个topic，一个消费者组由具有同一个Group ID的多个消费者组成。具体流程如下：</p><ol><li>生产者发送数据到指定的topic</li><li>Kafka将数据存储到broker上的partition中</li><li>假设现在有一个消费者订阅了一个topic，topic名字为“test”，消费者的Group ID为“Group1”</li><li>此时Kafka的处理方式与只有一个消费者的情况一样</li><li>当Kafka接收到一个同样Group ID为“Group1”、消费的topic同样为“test”的消费者的请求时，Kafka把数据操作模式切换为分享模式，此时数据将在两个消费者上共享。</li><li>当消费者的数目超过topic的partition数目时，后来的消费者将消费不到Kafka中的数据。因为在Kafka给每一个消费者消费者至少分配一个partition，一旦partition都被指派给消费者了，新来的消费者将不会再分配partition。即一个partition只能分配给一个消费者，一个消费者可以消费多个partition。</li></ol><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="http://kafka.apache.org/" target="_blank" rel="noopener">Apache Kafka</a></p><h2 id="安装zookeeper依赖"><a href="#安装zookeeper依赖" class="headerlink" title="安装zookeeper依赖"></a>安装zookeeper依赖</h2><p><a href="http://zookeeper.apache.org/" target="_blank" rel="noopener">Apache ZooKeeper - Home</a><br>启动kafka很简单，配置好前置的操作后，先进入zookeeper的目录下，启动zookeeper,可以单独安装,也可以使用kafka中集成的zookeeper,默认在bin目录下有zookeeper的启动脚本,zookeeper和kafka的配置均在kafka安装包下的config目录下,下面采用单独安装kafka的方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;data&#x2F;soft&#x2F;zookeeper</span><br><span class="line">&#x2F;&#x2F; 启动脚本使用方法</span><br><span class="line">Usage: .&#x2F;bin&#x2F;zkServer.sh &#123;start|start-foreground|stop|restart|status|upgrade|print-cmd&#125;</span><br><span class="line">&#x2F;&#x2F; 启动Zookeeper</span><br><span class="line">.&#x2F;bin&#x2F;zkServer.sh  start</span><br><span class="line">&#x2F;&#x2F; 关闭Zookeeper</span><br><span class="line">.&#x2F;bin&#x2F;zkServer.sh  stop</span><br><span class="line">&#x2F;&#x2F; 查看进程是否启动</span><br><span class="line">ps -ef | grep zookeepe</span><br></pre></td></tr></table></figure><p>PS：因为kafka是需要注册在zookeeper上面，通过zookeeper进行管理和调度的，所以启动kafka之前，我们必须要启动zookeeper。</p><h2 id="2-kafka安装"><a href="#2-kafka安装" class="headerlink" title="2. kafka安装"></a>2. kafka安装</h2><p>随后我们进入Kafka目录下，启动kafka，具体操作命令如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;kafka_2.11-1.0.0</span><br><span class="line">&#x2F;&#x2F; 修改配置</span><br><span class="line">vim &#x2F;usr&#x2F;local&#x2F;kafka&#x2F;config&#x2F;server.properties  kafka配置</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;kafka&#x2F;config&#x2F;zookeeper.properties   kafka集成的zookeeper配置</span><br><span class="line">&#x2F;&#x2F; 启动kafka</span><br><span class="line">.&#x2F;bin&#x2F;kafka-server-start.sh -daemon .&#x2F;config&#x2F;server.properties</span><br><span class="line">&#x2F;&#x2F; 查看</span><br><span class="line">jps -lm</span><br><span class="line">11776 &#x2F;usr&#x2F;local&#x2F;cerebro-0.7.2&#x2F;lib&#x2F;cerebro.cerebro-0.7.2-launcher.jar</span><br><span class="line">1392 &#x2F;usr&#x2F;share&#x2F;jenkins&#x2F;jenkins.war --webroot&#x3D;&#x2F;var&#x2F;cache&#x2F;jenkins&#x2F;war --httpPort&#x3D;8080</span><br><span class="line">24209 sun.tools.jps.Jps -lm</span><br><span class="line">20867 com.github.ltsopensource.startup.jobtracker.JobTrackerStartup &#x2F;data&#x2F;soft&#x2F;lts&#x2F;conf&#x2F;zoo</span><br><span class="line">20755 com.github.ltsopensource.startup.admin.JettyContainer &#x2F;data&#x2F;soft&#x2F;lts</span><br><span class="line">7972 org.apache.zookeeper.server.quorum.QuorumPeerMain &#x2F;data&#x2F;soft&#x2F;zookeeper-3.3.6&#x2F;bin&#x2F;..&#x2F;conf&#x2F;zoo.cfg</span><br><span class="line">10486 kafka.Kafka ..&#x2F;config&#x2F;server.properties</span><br><span class="line">12029 com.quantifind.kafka.offsetapp.OffsetGetterWeb --zk 127.0.0.1:2181 --port 9001 --refresh 10.seconds --retain 2.days</span><br><span class="line">11471 org.elasticsearch.bootstrap.Elasticsearch</span><br><span class="line">PS: 可以看到zookeeper和kafka都已经运行起来了，当然这个是单机的命令，集群的命令后面再讲。</span><br></pre></td></tr></table></figure><h2 id="kafka常用命令总结"><a href="#kafka常用命令总结" class="headerlink" title="kafka常用命令总结"></a>kafka常用命令总结</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">1. 查看topic的详细信息</span><br><span class="line">bin&#x2F;kafka-topics.sh -zookeeper 127.0.0.1:2181 -describe -topic testKJ1</span><br><span class="line">2. 为topic增加副本</span><br><span class="line">bin&#x2F;kafka-reassign -partitions.sh -zookeeper 127.0.0.1:2181 -reassignment-json-file json&#x2F;partitions-to-move.json -execute</span><br><span class="line">3. 创建topic</span><br><span class="line">bin&#x2F;kafka-topics.sh --create --zookeeper localhost:2181 --replication -factor1 --partitions 1 --topic testKJ1</span><br><span class="line">4. 为topic增加partition</span><br><span class="line">bin&#x2F;bin&#x2F;kafka-topics.sh –zookeeper 127.0.0.1:2181 –alter –partitions2 –topic testKJ1</span><br><span class="line">5. kafka生产者客户端命令</span><br><span class="line">bin&#x2F;kafka-console-producer.sh --broker-list localhost:9092 --topic testKJ1</span><br><span class="line">6. kafka消费者客户端命令</span><br><span class="line">bin&#x2F;kafka-console-consumer.sh -zookeeper localhost:2181 --from-beginning --topic testKJ1</span><br><span class="line">7. kafka服务启动</span><br><span class="line">bin&#x2F;kafka-server-start.sh -daemon ..&#x2F;config&#x2F;server.properties</span><br><span class="line">8. 下线broker</span><br><span class="line">bin&#x2F;kafka-run-class.sh kafka.admin.ShutdownBroker --zookeeper 127.0.0.1:2181 --broker #brokerId# --num.retries3--retry.interval.ms 60</span><br><span class="line">shutdown broker</span><br><span class="line">9. 删除topic,只会删除zookeeper中的元数据，消息文件须手动删除</span><br><span class="line">bin&#x2F;kafka-run-class.sh kafka.admin.DeleteTopicCommand --topic testKJ1 --zookeeper 127.0.0.1:2181</span><br><span class="line">10. 查看topic消费进度</span><br><span class="line">这个会显示出consumer group的offset情况， 必须参数为--group， 不指定--topic，默认为所有topic</span><br><span class="line">查看consumer组内消费的offset</span><br><span class="line">bin&#x2F;kafka-run-class.sh kafka.tools.ConsumerOffsetChecker --zookeeper localhost:2181 --group test --topic testKJ1</span><br><span class="line">bin&#x2F;kafka-consumer-offset-checker.sh --zookeeper 192.168.0.201:12181 --group group1 --topic group1</span><br><span class="line">11. 列出所有的TOPIC</span><br><span class="line">bin&#x2F;kafka-topics.sh --zookeeper 127.0.0.1:2181 --list</span><br></pre></td></tr></table></figure><h2 id="Connecting-to-ZooKeeper"><a href="#Connecting-to-ZooKeeper" class="headerlink" title="Connecting to ZooKeeper"></a>Connecting to ZooKeeper</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. check status</span><br><span class="line">$ bin&#x2F;zkServer.sh status</span><br><span class="line">2. connect</span><br><span class="line">$ bin&#x2F;zkCli.sh -server 127.0.0.1:2181</span><br></pre></td></tr></table></figure><p>更多信息: <a href="http://zookeeper.apache.org/doc/current/zookeeperStarted.html" target="_blank" rel="noopener">ZooKeeper Getting Started Guide</a></p>]]></content>
    
    <summary type="html">
    
      kafka专题
    
    </summary>
    
    
      <category term="Kafka" scheme="https://shuke163.github.io/categories/Kafka/"/>
    
    
      <category term="Kafka" scheme="https://shuke163.github.io/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>利用P2P软件(Murder)大规模分发大文件</title>
    <link href="https://shuke163.github.io/2020/04/20/index/"/>
    <id>https://shuke163.github.io/2020/04/20/index/</id>
    <published>2020-04-20T08:35:21.000Z</published>
    <updated>2020-04-20T08:35:38.678Z</updated>
    
    <content type="html"><![CDATA[<h2 id="利用P2P软件-Murder-大规模分发大文件"><a href="#利用P2P软件-Murder-大规模分发大文件" class="headerlink" title="利用P2P软件(Murder)大规模分发大文件"></a>利用P2P软件(Murder)大规模分发大文件</h2><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>当服务器多时，为了管理方便和提升效率，就会用到自动化管理工具（如Ansible）来自动部署和批量分发文件。</p><blockquote><p>场景描述：目前有50+台服务器，已部署Ansible用于自动化部署和批量分发文件。批量分发文件时，一般把文件传到 Ansible 所在的服务器并通过 copy或者synchronize 模块传输，文件小于100M时，分发正常。当传输大文件时（100M+），受单节点及其带宽的影响，整个分发过程变得非常缓慢，甚至出现Ansible卡死。</p></blockquote><p>使用 Ansible 来分发小文件速度很快，但对于大文件，文件分发就是一个很大的问题。在使用单一分布点和固定出口带宽的情况下，经常存在带宽拥堵、耗费时间长的问题。</p><p>对于大文件分发，首先想到的是 BitTorrent ，利用 P2P 协议实现快速分发，节省带宽，提高效率。</p><h2 id="P2P软件介绍"><a href="#P2P软件介绍" class="headerlink" title="P2P软件介绍"></a>P2P软件介绍</h2><p>为了解决上面的问题，这里我们使用 Murder </p><p><a href="https://github.com/lg/murder" target="_blank" rel="noopener">Murder</a>是 Twitter 的开源项目，很适合大文件分发。（该项目还能用，但官方已经不再继续维护）</p><p>项目介绍中有这么一段话：Large scale server deploys using BitTorrent and the BitTornado library</p><p>根据 Murder 开发者的博客，可以知道这个项目的来龙去脉：</p><blockquote><p>Twitter 在早期便依赖 Capistrano 来进行应用程序的部署，每当有新版本需要发布时，Capistrano 会根据预设好的各种设置和流程到 Twitter 所有的服务器上进行更新的操作。<br>在过去服务器还不多的情況下一切都很美好，但随着 Twitter 服务器数量的增长，到了几百台服务器时，事情已经不再像过去一样美好，甚至到后来拥有数千台服务器时，更新的操作会耗费 40 分钟。<br>Twitter 针对这个问题，认为问题的关键在于：使用集中式的系统，也就是所有的服务器要轮流排队到同一台版本控制系统上进行代码更新。</p></blockquote><p>Twitter 最初的想法是将版本控制系统也做出分散式的架构，服务器的代码更新就可以分散到不同的机器来压缩部署时间，但事实上版本控制系统即使分散在多台服务器上，这些服务器要更新文件也同样需要时间。<br>因此 Twitter 发现或许需要一个完全去中心化、最好是像 BitTorrent 这样的，利用 P2P 的特点让所有的节点都可以协助进行程序代码的更新。</p><p>从结果来看，在采用了 BitTorrent 的方式来更新代码，部署的时间从 40 分钟大幅减少到只要 12 秒！实在是非常惊人的改善，数千台服务器的代码更新居然只要短短 12 秒就能完成。</p><p>集中式架构和Murder架构对比:</p><p><img src="https://note.youdao.com/yws/api/personal/file/WEBb17ecf2d648c399a8e681511fbeb8997?method=download&shareKey=7c1ea1579628222596f0e3e3f2d106ce" alt="image"></p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB7aa1edd58d4910b55f320ba6f7c19327?method=download&shareKey=357ea31cc3b84346b9f99004fb033aef" alt="image"></p><h2 id="部署Murder"><a href="#部署Murder" class="headerlink" title="部署Murder"></a>部署Murder</h2><h3 id="Murder-组件介绍"><a href="#Murder-组件介绍" class="headerlink" title="Murder 组件介绍"></a>Murder 组件介绍</h3><p>Murder 是基于 BitTornado 来实现的。有以下几个主要组件：</p><ol><li>torrent tracker: tracker 使用 murder_tracker.py 运行，tracker 实际上是运行中一台服务器上的单个服务，其他任何成员都要依赖它。Murder为了保持简单，并没有实现tracker-less distribution（DHT）功能。tracker 实际上是个迷你的 httpd 服务，存放着BitTorrent客户端需要更新状态的路径。</li><li>seeder ：sender 是存放要分发到其他主机的文件的服务器。这些文件存放在 seeder 的一个目录中，Murder 会将这个目录打包成 tgz 格式并创建一个 .torrent 文件（非常小的文件，包含有关这个tgz文件的基本hash信息）。这个 .torrent 文件让各个 peer 节点知道他们下载的是什么文件。同时，tracker 会保持跟踪有哪些 .torrent 文件正在被分发。一旦 Murder 开始传输文件，seeder 服务器将是各个 peer 节点获取种子的地方。</li><li>peers ：peer 是成百上千需要接收文件的服务器，并且它们之间可以相互传输文件（下载、上传）。一旦一个peer节点下载完整个 tgz 文件，还将继续 seeding 一段时间，防止蜜罐效应。</li></ol><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>在 tracker 服务器下载并安装 Murder，写成脚本运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">cd &#x2F;usr&#x2F;local&#x2F;src</span><br><span class="line">wget https:&#x2F;&#x2F;codeload.github.com&#x2F;lg&#x2F;murder&#x2F;zip&#x2F;master</span><br><span class="line">mv master murder.zip</span><br><span class="line">unzip murder.zip</span><br><span class="line">mv murder-master &#x2F;usr&#x2F;local&#x2F;murder</span><br></pre></td></tr></table></figure><p>配置好 ansible 服务，连通各个 peer 节点。</p><p>通过 ansible 将tracker服务器下的 master.zip 分发到各个 peer 节点的家目录下，并解压安装 Murder ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ansible all -m copy -a &quot;src&#x3D;&#x2F;usr&#x2F;local&#x2F;src&#x2F;murder.zip dest&#x3D;~&quot;</span><br><span class="line"># ansible all -m shell -a &quot;unzip murder.zip ; mv murder-master murder&quot;</span><br></pre></td></tr></table></figure><p>各个节点ip和环境说明：</p><ul><li>tracker : 192.168.1.100</li><li>seeder : 192.168.1.100</li><li>peers : 192.168.1.101-111</li><li>服务器都在同一个机房</li><li>都是 CentOS 6.5 系统</li></ul><h2 id="启动-tracker-服务"><a href="#启动-tracker-服务" class="headerlink" title="启动 tracker 服务"></a>启动 tracker 服务</h2><p>在 Tracker 服务器，启动 tracker 服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># python &#x2F;usr&#x2F;local&#x2F;murder&#x2F;dist&#x2F;murder_tracker.py &gt; &#x2F;var&#x2F;log&#x2F;murder_tracker.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><p>检查端口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># netstat -tnlp|grep 8998</span><br></pre></td></tr></table></figure><p>实时查看日志输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># tailf &#x2F;var&#x2F;log&#x2F;murder_tracker.log</span><br></pre></td></tr></table></figure><p>配置防火墙（如果防火墙是关闭的，则不用此操作）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># iptables -I INPUT -s 192.168.100.0&#x2F;24 -p tcp --dport 8998 -j ACCEPT</span><br></pre></td></tr></table></figure><p>murder_tracker.py 实际上是调用 BitTornado/BT1/track.py 这个文件。 track.py 有很多参数，如果需要添加参数，可以修改 murder_tracker.py。</p><p>几个重要参数：</p><ul><li>port ：tracker 监听的端口，默认 8998</li><li>dfile ：存储近期下载信息的文件</li><li>logfile ：tracker 日志文件，默认是标准输出</li></ul><h2 id="在-seeder-服务器上准备要分发的文件并创建种子"><a href="#在-seeder-服务器上准备要分发的文件并创建种子" class="headerlink" title="在 seeder 服务器上准备要分发的文件并创建种子"></a>在 seeder 服务器上准备要分发的文件并创建种子</h2><p>这里将 seeder 和 tracker 服务 放在同一台服务器。<br>准备分发文件，并放在 /home/data/murder/ 目录下。</p><p>生成种子文件的脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"># 定义变量</span><br><span class="line">deploy_file&#x3D;&#x2F;home&#x2F;data&#x2F;murder&#x2F;deploy.test.tar.gz</span><br><span class="line"># 因所有peer节点已经打通内网，这里用seeder服务器的内网地址</span><br><span class="line">Seeder_IP&#x3D;192.168.1.100</span><br><span class="line">make_torrent_command&#x3D;&#x2F;usr&#x2F;local&#x2F;murder&#x2F;dist&#x2F;murder_make_torrent.py</span><br><span class="line"># 生成种子</span><br><span class="line">python $&#123;make_torrent_command&#125; $&#123;deploy_file&#125; $&#123;Seeder_IP&#125;:8998 $&#123;deploy_file&#125;.torrent</span><br></pre></td></tr></table></figure><h2 id="分发种子文件给所有的peer节点"><a href="#分发种子文件给所有的peer节点" class="headerlink" title="分发种子文件给所有的peer节点"></a>分发种子文件给所有的peer节点</h2><p>利用 ansible 分发seeder服务器上的种子文件给所有的 peer 节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ansible all -m synchronize -a &quot;src&#x3D;&#x2F;home&#x2F;data&#x2F;murder&#x2F;deploy.test.tar.gz.torrent dest&#x3D;~&quot;</span><br></pre></td></tr></table></figure><h2 id="启动-seeder-服务"><a href="#启动-seeder-服务" class="headerlink" title="启动 seeder 服务"></a>启动 seeder 服务</h2><p>启动 seeder 服务的脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"># 定义变量</span><br><span class="line">deploy_file&#x3D;&#x2F;home&#x2F;data&#x2F;murder&#x2F;deploy.test.tar.gz</span><br><span class="line">start_ip&#x3D;192.168.1.100</span><br><span class="line">make_torrent_command&#x3D;&#x2F;usr&#x2F;local&#x2F;murder&#x2F;dist&#x2F;murder_client.py</span><br><span class="line"></span><br><span class="line"># 启动 seeder，放到后台运行</span><br><span class="line">python $&#123;make_torrent_command&#125; seed $&#123;deploy_file&#125;.torrent $&#123;deploy_file&#125; $&#123;start_ip&#125; &amp;</span><br></pre></td></tr></table></figure><p>要确保 seeder 服务在启动状态，否则 peer 节点下载时连接不到。</p><p>在各个peer节点执行下载任务<br>编写下载脚本 peer_download.sh ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"># 用于各个 peer 节点根据种子文件信息，执行下载任务</span><br><span class="line"># 定义变量</span><br><span class="line">torrent_file&#x3D;~&#x2F;deploy.test.tar.gz.torrent</span><br><span class="line">download_file&#x3D;~&#x2F;download&#x2F;deploy.test.tar.gz</span><br><span class="line"># 这里获取各个 peer 节点自己的内网IP</span><br><span class="line">local_ip&#x3D;$(hostname -I|awk &#39;&#123;print $2&#125;&#39;)</span><br><span class="line">murder_client_bin&#x3D;~&#x2F;murder&#x2F;dist&#x2F;murder_client.py</span><br><span class="line"># 在各个 peer 节点执行 P2P 下载命令</span><br><span class="line">python  $murder_client_bin peer $torrent_file $download_file $local_ip</span><br></pre></td></tr></table></figure><p>利用ansible远程操控，在每个peer节点都执行下载脚本。使用ansible的 script 模块，在本地写一个脚本，然后在远程服务器执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># ansible all -m script -a &quot;peer_download.sh&quot;</span><br></pre></td></tr></table></figure><h2 id="下载速度分析"><a href="#下载速度分析" class="headerlink" title="下载速度分析"></a>下载速度分析</h2><p>Murder 默认是服务器都存于一个数据中心的彼此相互信任的内网，并且每台服务器都是关闭防火墙的。</p><p>Murder 封装的是 BitTornado，在 BitTornado/download_bt1.py 代码中默认是启动一个 10000-60000 范围的随机端口，每个 peer 在下载的同时向其他 peer 提供下载服务也是通过这个随机端口。</p><p>对于端口的配置，把防火墙关了当然好，当然为了安全，还是开放端口更好。然而开放这个大的端口范围，肯定是不行的，这里选择开放 10000-10500 500个端口，只允许内网IP访问。</p><p>在各个 peer 节点中配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># iptables -I INPUT -s 192.168.1.0&#x2F;24 -p tcp --dport 10000:10500 -j ACCEPT</span><br></pre></td></tr></table></figure><p>并且在 dist/BitTornado/download_bt1.py 中修改代码的端口范围：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(&#39;minport&#39;, 10000, &#39;minimum port to listen on, counts up if unavailable&#39;),</span><br><span class="line">(&#39;maxport&#39;, 10500, &#39;maximum port to listen on&#39;),</span><br><span class="line">(&#39;random_port&#39;, 1, &#39;whether to choose randomly inside the port range &#39; + &#39;instead of counting up linearly&#39;)</span><br></pre></td></tr></table></figure><blockquote><p>这一步最好在把Murder代码分发到各个peer节点前做，如果已经做了，只能重新分发覆盖了。</p></blockquote><p>分发测试的机器有11台，都是内网IP，千兆路由器，但防火墙开启，测试文件有 560 M 大小。</p><ul><li>第一次分发：没有配好防火墙，用时 5m 分发完成。</li><li>第二次分发：配好了防火墙，用时 2m30s 分发完成。</li><li>第三次分发：不用Murder，用 ansible 直接分发，用时 36s 分发完成。<br>这里测试的服务器还是太少，服务器越多时，P2P方式分发文件速度越快。服务器不超过50+时，还是用 ansible 直接分发更快。</li></ul><p>文件都下载完后，关闭 seeder 服务器进程<br>kill 掉 seeder 的进程PID，避免它一直做种子和提升安全性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># pgrep -f seed|xargs kill -9</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.51cto.com/john88wang/1793080" target="_blank" rel="noopener">结合P2P软件使用Ansible分发大文件</a><br><a href="http://jaminzhang.github.io/p2p/use-Murder-to-distribute-big-software-package-in-production-environment/" target="_blank" rel="noopener">Murder 在生产环境中分发大软件包的应用</a><br><a href="https://wuyanteng.github.io/2017/10/12/%E5%9C%A8%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%ADP2P%E5%88%86%E5%8F%91%E5%A4%A7%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%9A%84%E5%BA%94%E7%94%A8-Murder/" target="_blank" rel="noopener">在生产环境中-P2P分发大软件包的应用-Murder</a>  </p>]]></content>
    
    <summary type="html">
    
      利用P2P软件(Murder)大规模分发大文件
    
    </summary>
    
    
      <category term="PYTHON" scheme="https://shuke163.github.io/categories/PYTHON/"/>
    
    
      <category term="PYTHON" scheme="https://shuke163.github.io/tags/PYTHON/"/>
    
  </entry>
  
  <entry>
    <title>阿里巴巴 DevOps 转型后的运维平台建设</title>
    <link href="https://shuke163.github.io/2020/04/20/index/"/>
    <id>https://shuke163.github.io/2020/04/20/index/</id>
    <published>2020-04-20T08:34:34.000Z</published>
    <updated>2020-04-20T08:35:02.229Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实战-阿里巴巴-DevOps-转型后的运维平台建设"><a href="#实战-阿里巴巴-DevOps-转型后的运维平台建设" class="headerlink" title="实战:阿里巴巴 DevOps 转型后的运维平台建设"></a>实战:阿里巴巴 DevOps 转型后的运维平台建设</h2><blockquote><p>导读：阿里巴巴DevOps转型之后，运维平台是如何建设的？阿里巴巴高级技术专家陈喻结合运维自身的理解，业务场景的分析和业界方法论的一些思考，得出来一些最佳实践分享给大家.</p></blockquote><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>“我是这个应用的 Owner”是阿里巴巴DevOps转型的重要策略，运维有了这个策略以后，PE大量的日常工作就可以释放出来，会有更多的时间去思考沉淀，去做编码，去做以前不曾做的事情。</p><h3 id="运维的三个阶段"><a href="#运维的三个阶段" class="headerlink" title="运维的三个阶段"></a>运维的三个阶段</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEBbf3865e31808fe00f15398bbcc41424f?method=download&shareKey=f5bd11f6b941ca6316940227c22768bc" alt="运维三个阶段">  </p><ol><li>第一阶段：黑屏，三角形是代表整个运维给用户的一些体感或者给研发的体感，人工运维，目前很多企业可能还是这样。</li><li>第二阶段：白屏,自动化运维，以前把脚本做成工具去弄，有什么特征，人push机器去干活，自助运维。</li><li>第三阶段：用户对运维体感很少，但是运维这个领域是不变的。最重要的是人机交互变少了，无屏虽说是不可能的，非常极端，但是个趋势，少量的人机交互，它有自决策、自驱动。</li></ol><h3 id="自动化运维基础"><a href="#自动化运维基础" class="headerlink" title="自动化运维基础"></a>自动化运维基础</h3><p>做自动化运维，我认为有四大基础。</p><h4 id="第一-运维标准与规范"><a href="#第一-运维标准与规范" class="headerlink" title="第一: 运维标准与规范"></a>第一: 运维标准与规范</h4><p>我们的标准有什么好处，让研发 follow 这个标准，标准会在工具里固化。</p><h4 id="第二-泛监控，运行时，静态，数据化，可视化"><a href="#第二-泛监控，运行时，静态，数据化，可视化" class="headerlink" title="第二: 泛监控，运行时，静态，数据化，可视化"></a>第二: 泛监控，运行时，静态，数据化，可视化</h4><p>泛监控，不是说传统的监控，是把线上想知道的一切都数据化，最终数据不是给人看的，是给机器去消费的，数据是我们的生产资料，不是可视化，那不是我们的目标。</p><h4 id="第三-CMDB"><a href="#第三-CMDB" class="headerlink" title="第三: CMDB"></a>第三: CMDB</h4><p>1.CMDB 应该放什么，一般放服务器相关的、网络相关的、应用相关的这三个维度的相关信息。<br>2.经常有人会说 CMDB 不准，数据不准是因为没有把数据生产和数据消费形成闭环，如果形成了闭环数据不准，那是因为你不用这个数据，所以不准。</p><h4 id="第四-高效的CI-CD"><a href="#第四-高效的CI-CD" class="headerlink" title="第四: 高效的CI/CD"></a>第四: 高效的CI/CD</h4><p>我们一定要具备快速的交付能力，主要体现这两个方面：第一，新开发的能力能不能快速上线，第二，想扩容一台机器能不能快速扩出来。这两个能力抽象出来是三块。<br>持续集成(CI)，很多人说持续集成工具不好用，效率低，其实持续集成的本质是要自动化测试。如果研发部不具备自动化测试的能力，持续集成怎么做都是失败的。<br>持续集成里最重要的一点就是要推行单元测试、集成测试还有系统测试，单测是保证自己没问题，集成测试是保证跟上下游没问题，系统测试是保证整个系统没问题。<br>持续交付(CD)，有很多人说持续交付本质是一个 Pipeline，CI的目标是什么？快速正确打一个包出来。CD的目标是什么？能够快速把一个包在不同的环境验证它是ok的，可以放到线上去，这就是持续交付要干的事。持续交付里很关键的一点我们要解决，就是它的环境一致性、配置一致性。环境一致性可以用Docker解决，Docker 本身就是一种标准化的东西。所以说第一条用 Docker，肯定是标准化的，另外一个问题，配置是不是一致性，是不是动静分离。<br>持续部署(CD)，是一种能力，这种能力非常重要，就是把一个包快速部署在你想要的地方。</p><p>PS：持续部署的几个痛点。</p><ol><li>对包的文件的分发，阿里有一个叫蜻蜓的产品，是做了 SP2P，在 P2P 的基础上加了一个 Super。</li><li>应用启动，很多应用启动的时候要两三分钟，这是很有问题的。</li><li>部署起来以后这个业务是不是正确的，大家一定要做一个 HealthCheck，不是运维做，是PE做，一定要把这个要求说出来，执行 HealthCheck 这个脚本。</li></ol><h3 id="运维系统的重要特性"><a href="#运维系统的重要特性" class="headerlink" title="运维系统的重要特性"></a>运维系统的重要特性</h3><p>中间件研发首先关注稳定性，其次是效率，然后是易扩展。运维研发里面的六个重要特征，每一个都非常重要，以下是我感触比较深的几个。<br><img src="https://note.youdao.com/yws/api/personal/file/WEB620101a1629a2fdfbd0c36d6564055ff?method=download&shareKey=08971d6ce40134622e0c64456099e2ae" alt="运维系统重要特性">  </p><ol><li><p>高可用<br>在做同城容灾演练的时候，我把关一切，结果发现运维系统挂了，救命的东西没有了怎么办？所以说运维系统一定要是高可用，不一定是高并发。</p></li><li><p>幂等性<br>幂等性是分布式系统设计中十分重要的概念，这个也非常重要。</p></li><li><p>可回滚<br>这个是做运维最基本的一个 sense，你做的任何操作是不是可控的。如果真正做可回滚，其实事情没有这么复杂。</p></li><li><p>高效率<br>如果你的企业发展非常快速，你的规模性效应已经来了，你的运维系统一定要具备很高效率，快速扩容、快速部署这个效率我们要追求极致。</p></li></ol><h3 id="研发定义运维，配置驱动变更"><a href="#研发定义运维，配置驱动变更" class="headerlink" title="研发定义运维，配置驱动变更"></a>研发定义运维，配置驱动变更</h3><ol><li><p>从最下面看，是我们的基础设施，提供三种能力，包括集散、存储、网络。从右下角的位置看，画的是一个泛监控，它会知道系统、应用等，在旁边标了一个字，现状，我要通过这个现状把线上的系统全部数据化，然后放到决策中心。</p></li><li><p>左上角有 CMDB，现在很多变更系统，很多强调流程。我本人是做研发出身，非常抵触流程，流程不是一个效率工具，它是阻碍效率的。</p></li><li><p>比如故障搞完以后就是一堆的流程，非常阻碍效率，是质量控制的一个工具。流程不是不要，是把流程做到系统里面去，让系统帮人做决策，而不是人在那里点。</p></li><li><p>CMDB 定义了我刚才说的目标，现状通过监控拿到了，目标也知道了，这个时候还觉得这个事情很复杂吗？我认为这看你怎么去做。想做成人工还是做成自动或者做成智能，都取决于这个地方。所以智能里一定要有数据。</p></li><li><p>举个例子，通过智能分析出目标状态是使这个应用有100个VM，但是现在状态只有80个，一看这两个不一样，要扩容20台，如果系统做得更智能一点，通过图上左边的事件中心提示我20台负载较轻的放在哪，可以调度过去，然后去做执行变更。</p></li></ol><p>基于这些东西得出来两个结论，“研发定义运维”，“配置驱动变更”。</p><h3 id="为什么是研发定义运维？"><a href="#为什么是研发定义运维？" class="headerlink" title="为什么是研发定义运维？"></a>为什么是研发定义运维？</h3><p>研发定义运维（DDO），研发最贴近业务，最应该清楚这个业务应该具备什么样的能力，只有研发才知道这个业务KPS是多少。</p><h3 id="为什么是配置驱动变更"><a href="#为什么是配置驱动变更" class="headerlink" title="为什么是配置驱动变更?"></a>为什么是配置驱动变更?</h3><p>配置就是把目标改变一下，你跟我说一个运维场景，我可以在这个图里面 run 起来，配置只需要改你的目标状态，比如把你的状态10VM 变成15个VM。<br>这就是”研发定义运维，配置驱动变更”前因后果的思考。</p><h3 id="运维工具与方法论"><a href="#运维工具与方法论" class="headerlink" title="运维工具与方法论"></a>运维工具与方法论</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEB9c904e2294e2fc84199992da72822695?method=download&shareKey=ebfc4a36f6d42bca917684b002fd174d" alt="运维工具及方法论">  </p><h4 id="精益发现价值"><a href="#精益发现价值" class="headerlink" title="精益发现价值"></a>精益发现价值</h4><p>价值来源于用户的需求，而不是自己的YY，我们的价值来源于用户。</p><p>精益对我最大的感触就是要发现价值。精益思想，什么东西是有价值的，能够对用户带来物质上的或者身体上的愉悦的东西就是有价值的。</p><p>今天也有人问，DevOps 团队是该拆还是该合，我想他应该首先弄清楚面对的是什么样的问题，问题的优先级是什么？如果只解决一个问题，也许并不是DevOps 团队拆不拆的问题。</p><h4 id="敏捷交付价值"><a href="#敏捷交付价值" class="headerlink" title="敏捷交付价值"></a>敏捷交付价值</h4><p>敏捷也是对我影响很多的。很多人谈敏捷，我们团队里也搞敏捷，敏捷是要快速交付价值，它是一系列的方法论。但是在引入的时候千万注意，别人行的东西你不一定行，你需要的东西并不一定是敏捷，要因团队而异，形成一个环，持续反馈。</p><h4 id="OODA环"><a href="#OODA环" class="headerlink" title="OODA环"></a>OODA环</h4><p>OODA 环，就是形成闭环，让价值快速流动。</p><h3 id="应用运维平台ATOM"><a href="#应用运维平台ATOM" class="headerlink" title="应用运维平台ATOM"></a>应用运维平台ATOM</h3><p>应用运维平台的基础设施是一层，二层是运维中台，最上面一块是要做的 PaaS 平台，这个平台分几步。<br><img src="https://note.youdao.com/yws/api/personal/file/WEBcf540b68ea94cc7580696604fdd19476?method=download&shareKey=0a14435fa7c2bae87259c1ca63a072ff" alt="ATOM平台产品架构">  </p><h4 id="第一块，预算、容量、资源、弹性"><a href="#第一块，预算、容量、资源、弹性" class="headerlink" title="第一块，预算、容量、资源、弹性"></a>第一块，预算、容量、资源、弹性</h4><p>这个是PaaS 平台上非常重要的一块，目的就是让资源快速流动起来，流向正确的方向来产生价值。资源如果常年不增不减，是有问题的。</p><h4 id="第二块，应用管理"><a href="#第二块，应用管理" class="headerlink" title="第二块，应用管理"></a>第二块，应用管理</h4><p>这是日常要做的操作，规模化，要快速对一个单元建站、扩容、缩容。</p><h4 id="第三块，数据化运营"><a href="#第三块，数据化运营" class="headerlink" title="第三块，数据化运营"></a>第三块，数据化运营</h4><p>一定要讲数据，数据不是可视化出来一些报表，是要给结论，告诉用户这个数据完了以后应该是什么，规则中心是什么，是所有运维同学日常的运维经验沉淀。</p><h3 id="批量腾挪工具"><a href="#批量腾挪工具" class="headerlink" title="批量腾挪工具"></a>批量腾挪工具</h3><p>批量腾挪工具-背景</p><ul><li>痛点: <ul><li>机房搬迁</li><li>机器过保替换</li><li>机器故障频发,替换</li></ul></li><li>目标:<ul><li>规模化,系统化资源腾挪,提升运维效率</li><li>减少批量腾挪投入的人力,时间资源</li><li>单机替换自动化处理<br>这个工具不是所有人都需要，可以解决机房的搬迁，凑框迁移。<br>弹性伸缩是我们的决策中心。它决定你的资源往哪个地方流，非常关键。<br>最后，这里是运维领域技术含量最深的一个地方，要搞机器学习、深度学习、强化学习、算法等。<br>弹性一般有水平伸缩、垂直伸缩，对线上做管理，当然我们有额度，这是比较精细化的管理。弹性有观察者模式还有自动化执行，每次弹性完以后有一个控制台，双11做全年压测的时候一般情况下不看这个。</li></ul></li></ul><p>个人觉得本文内容总结的相当好,具有很高的参考意义和价值,故做整理,方便阅读!</p><p><a href="https://segmentfault.com/a/1190000014088336" target="_blank" rel="noopener">原文链接</a><br><a href="http://dbaplus.cn/news-134-1876-1.html" target="_blank" rel="noopener">参考文章</a>  </p>]]></content>
    
    <summary type="html">
    
      阿里巴巴 DevOps 转型后的运维平台建设
    
    </summary>
    
    
      <category term="DevOps" scheme="https://shuke163.github.io/categories/DevOps/"/>
    
    
      <category term="DevOps" scheme="https://shuke163.github.io/tags/DevOps/"/>
    
  </entry>
  
  <entry>
    <title>Swagger介绍</title>
    <link href="https://shuke163.github.io/2020/04/20/index/"/>
    <id>https://shuke163.github.io/2020/04/20/index/</id>
    <published>2020-04-20T08:33:22.000Z</published>
    <updated>2020-04-20T08:34:22.058Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Swagger介绍"><a href="#Swagger介绍" class="headerlink" title="Swagger介绍"></a>Swagger介绍</h2><blockquote><p>Swagger是一种REST APIs的简单但强大的表示方式，标准的，语言无关，这种表示方式不但人可读，而且机器可读。可以作为REST APIs的交互式文档，也可以作为REST APIs的形式化的接口描述，生成客户端和服务端的代码。<br> <a href="https://swagger.io/" target="_blank" rel="noopener">官网</a><br> <a href="https://github.com/swagger-api/swagger-ui" target="_blank" rel="noopener">GitHub - swagger-api/swagger-ui</a>)<br> <a href="https://github.com/swagger-api/swagger-editor" target="_blank" rel="noopener">GitHub - swagger-api/swagger-editor: Swagger Editor</a><br> <a href="https://github.com/Swagger2Markup/swagger2markup" target="_blank" rel="noopener">GitHub - Swagger2Markup/swagger2markup: Swagger2Markup</a>  </p></blockquote><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>在没有产品经理或者项目经理的情况下，对于前端和后端打交道来说，无非就是对接口的争争吵吵，字段多多少少的事。大多时候前端都喜欢直接使用后端提供的接口，而后端有时候却不知道前端到底要什么数据，就这样，Swagger这样的神器被我找到了，对于Swagger高级的应用，比如集成到IDE中自动生成文档,支持GO/python/Java等多种语言的IDE集成环境!</p><h3 id="2-Swagger-UI和Swagger-Editor"><a href="#2-Swagger-UI和Swagger-Editor" class="headerlink" title="2. Swagger UI和Swagger Editor"></a>2. Swagger UI和Swagger Editor</h3><ol><li>swagger ui是一个API在线文档生成和测试的利器,目前发现最好用的。</li></ol><ul><li>支持API自动生成同步的在线文档</li><li>这些文档可用于项目内部API审核</li><li>方便测试人员了解API</li><li>这些文档可作为客户产品文档的一部分进行发布</li><li>支持API规范生成代码，生成的客户端和服务器端骨架代码可以加速开发和测试速度</li></ul><ol start="2"><li>使用Swagger Editor编写API文档</li></ol><ul><li>Swagger Editor上的是基于yaml/JSON的语法</li></ul><h3 id="3-为什么选择Swagger"><a href="#3-为什么选择Swagger" class="headerlink" title="3. 为什么选择Swagger"></a>3. 为什么选择Swagger</h3><ol><li>使用Swagger UI生成的界面比Javadoc生成的界面美观</li><li>swagger可以实时同步API文档(代码修改后，文档同步修改)</li><li>swagger解析速度快，效率高(使用轻量级数据交换格式JSON)</li><li>对现有SpringMVC工程支持友好</li><li>Swagger可以充当前后端交流的重要桥梁，方便快捷。很实用。</li><li>Swagger项目允许你生产，显示和消费你自己的RESTful服务。不需要代理和第三方服务。是一个依赖自由的资源集合，它能通过Swagger-API动态的生成漂亮的文档和沙盒,因为Swagger-UI没有依赖，你可以把他部署到任何服务器环境或者是你自己的机器</li></ol><h3 id="4-Swagger组件介绍"><a href="#4-Swagger组件介绍" class="headerlink" title="4. Swagger组件介绍"></a>4. Swagger组件介绍</h3><ol><li>部署安装略,可自行在github中查找,建议使用Docker方式安装部署,简单方便;</li><li>Swagger生态工具组件较多,本文主要介绍Swagger-Editor以及Swagger-UI的使用,Editor用于生成各语言客户端/服务端的依赖文件,UI部分主要针对客户端工具生成的swagger.json或swagger.yml文件进行接口的查看和接口测试;</li><li>Swagger也有支持生成MarkDown文档格式的组件(Swagger2Markup);<br>PS: Swgger UI的站点域名要和发送请求的域名一样,不然浏览器会报跨域错误。</li><li>示例Demo<br><a href="http://10.21.26.240:81/" target="_blank" rel="noopener">Swagger Editor</a><br><a href="http://10.21.26.240" target="_blank" rel="noopener">Swagger UI</a>  </li></ol><h3 id="5-Swagger-Editor使用说明"><a href="#5-Swagger-Editor使用说明" class="headerlink" title="5. Swagger Editor使用说明"></a>5. Swagger Editor使用说明</h3><h4 id="5-1-我们可以在Swagger-Editor中编辑swagger-json-swagger-yaml文件-编写项目的API-编写完成后下载文件-通过Swagger-UI进行展示和调试相关操作"><a href="#5-1-我们可以在Swagger-Editor中编辑swagger-json-swagger-yaml文件-编写项目的API-编写完成后下载文件-通过Swagger-UI进行展示和调试相关操作" class="headerlink" title="5.1 我们可以在Swagger Editor中编辑swagger.json/swagger.yaml文件,编写项目的API,编写完成后下载文件,通过Swagger UI进行展示和调试相关操作;"></a>5.1 我们可以在Swagger Editor中编辑swagger.json/swagger.yaml文件,编写项目的API,编写完成后下载文件,通过Swagger UI进行展示和调试相关操作;</h4><p>Swagger API语法说明:   <a href="https://huangwenchao.gitbooks.io/swagger/content/" target="_blank" rel="noopener">参考-Swagger从入门到精通</a>  </p><h4 id="5-2-如何下载文件"><a href="#5-2-如何下载文件" class="headerlink" title="5.2 如何下载文件?"></a>5.2 如何下载文件?</h4><p><img src="https://note.youdao.com/yws/api/personal/file/WEB1525428cb3824945193555edd9a8dc3b?method=download&shareKey=84d50c122964b88eda3ec345c896515d" alt="Swagger-json/Swagger-yaml">  </p><h4 id="5-3-下载CLient包"><a href="#5-3-下载CLient包" class="headerlink" title="5.3 下载CLient包?"></a>5.3 下载CLient包?</h4><p><img src="https://note.youdao.com/yws/api/personal/file/WEBbb49e77b2635fcf8fd33179488526763?method=download&shareKey=a5191b45239cdf1c76c23727074e0c4c" alt="Swagger-cleint">  </p><h3 id="6-Swagger-UI"><a href="#6-Swagger-UI" class="headerlink" title="6. Swagger UI"></a>6. Swagger UI</h3><p>主要用于展示Swagger-json/Swagger-yaml文件内容<br><img src="https://note.youdao.com/yws/api/personal/file/WEBabf5c04995f32e14e0092062760de81a?method=download&shareKey=f725621241eb4e9bb7ab95d5b5f73318" alt="Web接口展示"><br><img src="https://note.youdao.com/yws/api/personal/file/WEB5cdc68f7e2d3f84f766a18c34adf2e94?method=download&shareKey=41b341528ab6e9d0bbf981adcbb79c6a" alt="Web接口测试">  </p>]]></content>
    
    <summary type="html">
    
      Swagger介绍
    
    </summary>
    
    
      <category term="swagger" scheme="https://shuke163.github.io/categories/swagger/"/>
    
    
      <category term="swagger" scheme="https://shuke163.github.io/tags/swagger/"/>
    
  </entry>
  
  <entry>
    <title>nginx配置http强制跳转https</title>
    <link href="https://shuke163.github.io/2020/04/20/index/"/>
    <id>https://shuke163.github.io/2020/04/20/index/</id>
    <published>2020-04-20T08:32:21.000Z</published>
    <updated>2020-04-20T08:32:50.310Z</updated>
    
    <content type="html"><![CDATA[<h2 id="nginx配置http强制跳转https"><a href="#nginx配置http强制跳转https" class="headerlink" title="nginx配置http强制跳转https"></a>nginx配置http强制跳转https</h2><blockquote><p>很多网站虽然支持 https, 但是直接在浏览器地址栏输入网址后, 默认仍是以 http 协议去访问的, http 强制跳转 https 的需求应运而生, 以下介绍三种实现的方式</p></blockquote><h3 id="rewrite-方法"><a href="#rewrite-方法" class="headerlink" title="rewrite 方法"></a>rewrite 方法</h3><p>这是最常用的实现方法, 将所有 http 请求通过 rewrite 重定向到 https 即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">server &#123;  </span><br><span class="line">    listen  80;</span><br><span class="line">    server_name docs.lvrui.io</span><br><span class="line">      </span><br><span class="line">    rewrite ^(.*)$  https:&#x2F;&#x2F;$host$1 permanent; </span><br><span class="line">    # return 302 https:&#x2F;&#x2F;$host$request_uri;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name docs.lvrui.io;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line">    access_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;docs.log  main;</span><br><span class="line">    ssl on;</span><br><span class="line">    ssl_certificate &#x2F;etc&#x2F;ssl&#x2F;docs.20150509.cn.crt;</span><br><span class="line">    ssl_certificate_key  &#x2F;etc&#x2F;ssl&#x2F;docs.20150509.cn.key;</span><br><span class="line">    error_page 404 &#x2F;404.html;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">    root &#x2F;var&#x2F;www&#x2F;html&#x2F;docs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>497 状态码<br>error code 497: normal request was sent to HTTPS</p><p>在一个站点只允许 https 访问时, 如果使用 http 访问会报出497错误码</p><p>利用497状态码重定向到 https</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name docs.lvrui.io</span><br><span class="line">    </span><br><span class="line">    error_page 497  https:&#x2F;&#x2F;$host$uri?$args;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name docs.lvrui.io;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line">    access_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;docs.log  main;</span><br><span class="line">    ssl on;</span><br><span class="line">    ssl_certificate &#x2F;etc&#x2F;ssl&#x2F;docs.20150509.cn.crt;</span><br><span class="line">    ssl_certificate_key  &#x2F;etc&#x2F;ssl&#x2F;docs.20150509.cn.key;</span><br><span class="line">    error_page 404 &#x2F;404.html;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">    root &#x2F;var&#x2F;www&#x2F;html&#x2F;docs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="index-html-刷新网页"><a href="#index-html-刷新网页" class="headerlink" title="index.html 刷新网页"></a>index.html 刷新网页</h3><p>上面两种方法均会耗费服务器资源, 我们使用 curl 来看下百度是如何实现的 baidu.com 向 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 的跳转</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ curl baidu.com -vv </span><br><span class="line">* Rebuilt URL to: baidu.com&#x2F;</span><br><span class="line">*   Trying 220.181.57.217...</span><br><span class="line">* TCP_NODELAY set</span><br><span class="line">* Connected to baidu.com (220.181.57.217) port 80 (#0)</span><br><span class="line">&gt; GET &#x2F; HTTP&#x2F;1.1</span><br><span class="line">&gt; Host: baidu.com</span><br><span class="line">&gt; User-Agent: curl&#x2F;7.51.0</span><br><span class="line">&gt; Accept: *&#x2F;*</span><br><span class="line">&gt; </span><br><span class="line">&lt; HTTP&#x2F;1.1 200 OK</span><br><span class="line">&lt; Date: Sat, 01 Apr 2017 06:32:35 GMT</span><br><span class="line">&lt; Server: Apache</span><br><span class="line">&lt; Last-Modified: Tue, 12 Jan 2010 13:48:00 GMT</span><br><span class="line">&lt; ETag: &quot;51-47cf7e6ee8400&quot;</span><br><span class="line">&lt; Accept-Ranges: bytes</span><br><span class="line">&lt; Content-Length: 81</span><br><span class="line">&lt; Cache-Control: max-age&#x3D;86400</span><br><span class="line">&lt; Expires: Sun, 02 Apr 2017 06:32:35 GMT</span><br><span class="line">&lt; Connection: Keep-Alive</span><br><span class="line">&lt; Content-Type: text&#x2F;html</span><br><span class="line">&lt; </span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;meta http-equiv&#x3D;&quot;refresh&quot; content&#x3D;&quot;0;url&#x3D;http:&#x2F;&#x2F;www.baidu.com&#x2F;&quot;&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line">* Curl_http_done: called premature &#x3D;&#x3D; 0</span><br><span class="line">* Connection #0 to host baidu.com left intact</span><br></pre></td></tr></table></figure><p>可以看到百度很巧妙的利用meta的刷新作用，将baidu.com跳转到<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a><br>同理, 我们也可以用这个特性来实现http向https的跳转</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># index.html</span><br><span class="line">&lt;html&gt;  </span><br><span class="line">    &lt;meta http-equiv&#x3D;&quot;refresh&quot; content&#x3D;&quot;0;url&#x3D;https:&#x2F;&#x2F;docs.lvrui.io&#x2F;&quot;&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name docs.lvrui.io;</span><br><span class="line">    </span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        # 将 index.html 文件放到下面的目录下</span><br><span class="line">        root &#x2F;var&#x2F;www&#x2F;html&#x2F;refresh&#x2F;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name docs.lvrui.io;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line">    access_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;docs.log  main;</span><br><span class="line">    ssl on;</span><br><span class="line">    ssl_certificate &#x2F;etc&#x2F;ssl&#x2F;docs.20150509.cn.crt;</span><br><span class="line">    ssl_certificate_key  &#x2F;etc&#x2F;ssl&#x2F;docs.20150509.cn.key;</span><br><span class="line">    error_page 404 &#x2F;404.html;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">    root &#x2F;var&#x2F;www&#x2F;html&#x2F;docs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      nginx配置http强制跳转https
    
    </summary>
    
    
      <category term="Nginx" scheme="https://shuke163.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="https://shuke163.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>JVM调优命令</title>
    <link href="https://shuke163.github.io/2020/04/20/index/"/>
    <id>https://shuke163.github.io/2020/04/20/index/</id>
    <published>2020-04-20T08:31:47.000Z</published>
    <updated>2020-04-20T08:32:07.171Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM调优命令"><a href="#JVM调优命令" class="headerlink" title="JVM调优命令"></a>JVM调优命令</h2><blockquote><p>运用jvm自带的命令可以方便的在生产监控和打印堆栈的日志信息帮忙我们来定位问题！虽然jvm调优成熟的工具已经有很多：jconsole、大名鼎鼎的VisualVM，IBM的Memory Analyzer等等，但是在生产环境出现问题的时候，一方面工具的使用会有所限制，另一方面喜欢装X的我们，总喜欢在出现问题的时候在终端输入一些命令来解决。所有的工具几乎都是依赖于jdk的接口和底层的这些命令，研究这些命令的使用也让我们更能了解jvm构成和特性。<br>Sun JDK监控和故障处理命令有jps jstat jmap jhat jstack jinfo下面做一一介绍</p></blockquote><h3 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h3><blockquote><p>JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。</p></blockquote><p>命令格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps [options] [hostid]</span><br></pre></td></tr></table></figure><p>option参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-l : 输出主类全名或jar路径</span><br><span class="line">-q : 只输出LVMID</span><br><span class="line">-m : 输出JVM启动时传递给main()的参数</span><br><span class="line">-v : 输出JVM启动时显示指定的JVM参数</span><br></pre></td></tr></table></figure><p>其中<code>[option]、[hostid]</code>参数也可以不写</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@jav-collection01br-p001:~# jps -mlv</span><br><span class="line">1808 &#x2F;data&#x2F;services&#x2F;brazil_DivisionCaseTools&#x2F;DivisionCaseTools_br-1.0.jar --spring.profiles.active&#x3D;br-prod -Xmx1024M -Duser.timezone&#x3D;America&#x2F;Sao_Paulo</span><br><span class="line">8196 &#x2F;data&#x2F;services&#x2F;brazil_phonebook&#x2F;phonebook_br-0.0.1-SNAPSHOT.jar --spring.profiles.active&#x3D;br-prod -Xmx1024M -Duser.timezone&#x3D;America&#x2F;Sao_Paulo</span><br><span class="line">4756 org.apache.catalina.startup.Bootstrap start -Djava.util.logging.config.file&#x3D;&#x2F;data&#x2F;services&#x2F;brazil_AuthCenter&#x2F;conf&#x2F;logging.properties -Djava.util.logging.manager&#x3D;org.apache.juli.ClassLoaderLogManager -Xmx1G -Xms1G -XX:MetaspaceSize&#x3D;128M -XX:MaxMetaspaceSize&#x3D;128M -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath&#x3D;&#x2F;data&#x2F;services&#x2F;brazil_AuthCenter&#x2F;logs&#x2F;dump -XX:+PrintClassHistogram -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintHeapAtGC -Xloggc:&#x2F;data&#x2F;services&#x2F;brazil_AuthCenter&#x2F;logs&#x2F;gc.log -Djdk.tls.ephemeralDHKeySize&#x3D;2048 -Djava.protocol.handler.pkgs&#x3D;org.apache.catalina.webresources -Djava.endorsed.dirs&#x3D;&#x2F;data&#x2F;services&#x2F;brazil_AuthCenter&#x2F;endorsed -Dcatalina.base&#x3D;&#x2F;data&#x2F;services&#x2F;brazil_AuthCenter -Dcatalina.home&#x3D;&#x2F;data&#x2F;services&#x2F;brazil_AuthCenter -Djava.io.tmpdir&#x3D;&#x2F;data&#x2F;services&#x2F;brazil_AuthCenter&#x2F;temp</span><br><span class="line">3928 &#x2F;data&#x2F;soft&#x2F;lts&#x2F;lts-task-tracker&#x2F;prod&#x2F;lts-tasktracker-springboot-1.6.9.jar -Duser.timezone&#x3D;America&#x2F;Sao_Paulo -Xmx256M</span><br></pre></td></tr></table></figure><h3 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3><blockquote><p>jstat(JVM statistics Monitoring)是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。</p></blockquote><h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat [option] LVMID [interval] [count]</span><br></pre></td></tr></table></figure><p>补充:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">堆内存 &#x3D; 年轻代 + 年老代 + 永久代 + 元数据区</span><br><span class="line">年轻代 &#x3D; Eden区 + 两个Survivor区（From和To）</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; jstat -options</span><br><span class="line"></span><br><span class="line">-class 显示ClassLoad的相关信息；</span><br><span class="line">-compiler 显示JIT编译的相关信息；</span><br><span class="line">-gc 显示和gc相关的堆信息；</span><br><span class="line">-gccapacity 　　 显示各个代的容量以及使用情况；</span><br><span class="line">-gcmetacapacity 显示metaspace的大小</span><br><span class="line">-gcnew 显示新生代信息；</span><br><span class="line">-gcnewcapacity 显示新生代大小和使用情况；</span><br><span class="line">-gcold 显示老年代和永久代的信息；</span><br><span class="line">-gcoldcapacity 显示老年代的大小；</span><br><span class="line">-gcutil　　 显示垃圾收集信息；</span><br><span class="line">-gccause 显示垃圾回收的相关信息（通-gcutil）,同时显示最后一次或当前正在发生的垃圾回收的诱因；</span><br><span class="line">-printcompilation 输出JIT编译的方法信息</span><br></pre></td></tr></table></figure><p>参数名称 | 参数说明<br>—|—|—<br>class | 用于查看类加载情况的统计，显示加载class的数量，及所占空间等信息。<br>compiler | 查看HotSpot中即时编译器编译情况的统计<br>gc | 查看JVM中堆的垃圾收集情况的统计，可以显示gc的信息，查看gc的次数，及时间。其中最后五项，分别是young gc的次数，young gc的时间，full gc的次数，full gc的时间，gc的总时间。<br>gccapacity | 查看新生代、老生代及持久代的存储容量情况，可以显示，VM内存中三代（young,old,perm）对象的使用和占用大小<br>gccause | 查看垃圾收集的统计情况（这个和-gcutil选项一样），如果有发生垃圾收集，它还会显示最后一次及当前正在发生垃圾收集的原因<br>gcmetacapacity | 显示关于metaspace大小的统计信息。<br>gcnew | 查看新生代垃圾收集的情况，new对象的信息<br>gcnewcapacity | 用于查看新生代的存储容量情况，new对象的信息及其占用量<br>gcold | 用于查看老生代及持久代发生GC的情况，old对象的信息<br>gcoldcapacity | 用于查看老生代的容量，old对象的信息及其占用量<br>gcpermcapacity | 用于查看持久代的容量，perm对象的信息及其占用量<br>gcutil | 查看新生代、老生代及持代垃圾收集的情况<br>printcompilation | 当前VM执行的信息</p><h3 id="参数使用示例"><a href="#参数使用示例" class="headerlink" title="参数使用示例"></a>参数使用示例</h3><ol><li>jstat -gc  pid  垃圾回收统计<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">root@jav-collection01br-p001:~# jstat -gc 1808</span><br><span class="line"> S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line">1536.0 1536.0 288.0   0.0   346112.0 136222.0  233472.0   151382.5  60416.0 58963.1 6912.0 6587.0  32144   93.009   5      0.469   93.478</span><br><span class="line">- S0C：第一个幸存区的大小</span><br><span class="line"></span><br><span class="line">- S1C：第二个幸存区的大小</span><br><span class="line"></span><br><span class="line">- S0U：第一个幸存区的使用大小</span><br><span class="line"></span><br><span class="line">- S1U：第二个幸存区的使用大小</span><br><span class="line"></span><br><span class="line">- EC：伊甸园区的大小</span><br><span class="line"></span><br><span class="line">- EU：伊甸园区的使用大小</span><br><span class="line"></span><br><span class="line">- OC：老年代大小</span><br><span class="line"></span><br><span class="line">- OU：老年代使用大小</span><br><span class="line"></span><br><span class="line">- MC：方法区大小</span><br><span class="line"></span><br><span class="line">- MU：方法区使用大小</span><br><span class="line"></span><br><span class="line">- CCSC:压缩类空间大小</span><br><span class="line"></span><br><span class="line">- CCSU:压缩类空间使用大小</span><br><span class="line"></span><br><span class="line">- YGC：年轻代垃圾回收次数</span><br><span class="line"></span><br><span class="line">- YGCT：年轻代垃圾回收消耗时间</span><br><span class="line"></span><br><span class="line">- FGC：老年代垃圾回收次数</span><br><span class="line"></span><br><span class="line">- FGCT：老年代垃圾回收消耗时间</span><br><span class="line"></span><br><span class="line">- GCT：垃圾回收消耗总时间</span><br></pre></td></tr></table></figure></li><li>jstat -gcutil pid  总垃圾回收统计<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">root@jav-collection01br-p001:~# jstat -gcutil 1808</span><br><span class="line">  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line"> 18.75   0.00  39.38  64.84  97.60  95.30  32144   93.009     5    0.469   93.478</span><br><span class="line"> S0：幸存1区当前使用比例</span><br><span class="line"></span><br><span class="line">S1：幸存2区当前使用比例</span><br><span class="line"></span><br><span class="line">E：伊甸园区使用比例</span><br><span class="line"></span><br><span class="line">O：老年代使用比例</span><br><span class="line"></span><br><span class="line">M：元数据区使用比例</span><br><span class="line"></span><br><span class="line">CCS：压缩使用比例</span><br><span class="line"></span><br><span class="line">YGC：年轻代垃圾回收次数</span><br><span class="line"></span><br><span class="line">FGC：老年代垃圾回收次数</span><br><span class="line"></span><br><span class="line">FGCT：老年代垃圾回收消耗时间</span><br><span class="line"></span><br><span class="line">GCT：垃圾回收消耗总时间</span><br></pre></td></tr></table></figure></li><li>jstat -gcnew  pid 新生代垃圾回收统计<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">root@jav-collection01br-p001:~# jstat -gcnew 1808</span><br><span class="line"> S0C    S1C    S0U    S1U   TT MTT  DSS      EC       EU     YGC     YGCT</span><br><span class="line">1536.0 1536.0  288.0    0.0 15  15 1536.0 346112.0 136299.9  32144   93.009</span><br><span class="line">- S0C：第一个幸存区大小</span><br><span class="line"></span><br><span class="line">- S1C：第二个幸存区的大小</span><br><span class="line"></span><br><span class="line">- S0U：第一个幸存区的使用大小</span><br><span class="line"></span><br><span class="line">- S1U：第二个幸存区的使用大小</span><br><span class="line"></span><br><span class="line">- TT:对象在新生代存活的次数</span><br><span class="line"></span><br><span class="line">- MTT:对象在新生代存活的最大次数</span><br><span class="line"></span><br><span class="line">- DSS:期望的幸存区大小</span><br><span class="line"></span><br><span class="line">- EC：伊甸园区的大小</span><br><span class="line"></span><br><span class="line">- EU：伊甸园区的使用大小</span><br><span class="line"></span><br><span class="line">- YGC：年轻代垃圾回收次数</span><br><span class="line"></span><br><span class="line">- YGCT：年轻代垃圾回收消耗时间</span><br></pre></td></tr></table></figure></li><li>jstat -gccapacity pid 堆内存统计<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"> 记忆这个命令可以根据单词组合记忆</span><br><span class="line"> -gc &#x3D;&gt; 名称</span><br><span class="line"> capacity &#x3D;&gt; 容量</span><br><span class="line">root@jav-collection01br-p001:~# jstat -gccapacity 1808</span><br><span class="line"> NGCMN    NGCMX     NGC     S0C   S1C       EC      OGCMN      OGCMX       OGC         OC       MCMN     MCMX      MC     CCSMN    CCSMX     CCSC    YGC    FGC</span><br><span class="line"> 40960.0 349184.0 349184.0 1536.0 1536.0 346112.0    81920.0   699392.0   233472.0   233472.0      0.0 1103872.0  60416.0      0.0 1048576.0   6912.0  32144     5</span><br><span class="line">NGCMN：新生代最小容量</span><br><span class="line"></span><br><span class="line">NGCMX：新生代最大容量</span><br><span class="line"></span><br><span class="line">NGC：当前新生代容量</span><br><span class="line"></span><br><span class="line">S0C：第一个幸存区大小</span><br><span class="line"></span><br><span class="line">S1C：第二个幸存区的大小</span><br><span class="line"></span><br><span class="line">EC：伊甸园区的大小</span><br><span class="line"></span><br><span class="line">OGCMN：老年代最小容量</span><br><span class="line"></span><br><span class="line">OGCMX：老年代最大容量</span><br><span class="line"></span><br><span class="line">OGC：当前老年代大小</span><br><span class="line"></span><br><span class="line">OC:当前老年代大小</span><br><span class="line"></span><br><span class="line">MCMN:最小元数据容量</span><br><span class="line"></span><br><span class="line">MCMX：最大元数据容量</span><br><span class="line"></span><br><span class="line">MC：当前元数据空间大小</span><br><span class="line"></span><br><span class="line">CCSMN：最小压缩类空间大小</span><br><span class="line"></span><br><span class="line">CCSMX：最大压缩类空间大小</span><br><span class="line"></span><br><span class="line">CCSC：当前压缩类空间大小</span><br><span class="line"></span><br><span class="line">YGC：年轻代gc次数</span><br><span class="line"></span><br><span class="line">FGC：老年代GC次数</span><br></pre></td></tr></table></figure></li><li>jstat -gcmetacapacity pid   元数据空间统计<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">root@jav-collection01br-p001:~# jstat -gcmetacapacity 1808</span><br><span class="line">   MCMN       MCMX        MC       CCSMN      CCSMX       CCSC     YGC   FGC    FGCT     GCT</span><br><span class="line">       0.0  1103872.0    60416.0        0.0  1048576.0     6912.0 32144     5    0.469   93.478</span><br><span class="line">MCMN:最小元数据容量</span><br><span class="line"></span><br><span class="line">MCMX：最大元数据容量</span><br><span class="line"></span><br><span class="line">MC：当前元数据空间大小</span><br><span class="line"></span><br><span class="line">CCSMN：最小压缩类空间大小</span><br><span class="line"></span><br><span class="line">CCSMX：最大压缩类空间大小</span><br><span class="line"></span><br><span class="line">CCSC：当前压缩类空间大小</span><br><span class="line"></span><br><span class="line">YGC：年轻代垃圾回收次数</span><br><span class="line"></span><br><span class="line">FGC：老年代垃圾回收次数</span><br><span class="line"></span><br><span class="line">FGCT：老年代垃圾回收消耗时间</span><br><span class="line"></span><br><span class="line">GCT：垃圾回收消耗总时间</span><br></pre></td></tr></table></figure></li><li>jstat -gcnewcapacity pid 新生代内存空间统计<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">root@jav-collection01br-p001:~# jstat -gcnewcapacity 1808</span><br><span class="line">  NGCMN      NGCMX       NGC      S0CMX     S0C     S1CMX     S1C       ECMX        EC      YGC   FGC</span><br><span class="line">   40960.0   349184.0   349184.0 116224.0   1536.0 116224.0   1536.0   348160.0   346112.0 32144     5</span><br><span class="line">NGCMN：新生代最小容量</span><br><span class="line"></span><br><span class="line">NGCMX：新生代最大容量</span><br><span class="line"></span><br><span class="line">NGC：当前新生代容量</span><br><span class="line"></span><br><span class="line">S0CMX：最大幸存1区大小</span><br><span class="line"></span><br><span class="line">S0C：当前幸存1区大小</span><br><span class="line"></span><br><span class="line">S1CMX：最大幸存2区大小</span><br><span class="line"></span><br><span class="line">S1C：当前幸存2区大小</span><br><span class="line"></span><br><span class="line">ECMX：最大伊甸园区大小</span><br><span class="line"></span><br><span class="line">EC：当前伊甸园区大小</span><br><span class="line"></span><br><span class="line">YGC：年轻代垃圾回收次数</span><br><span class="line"></span><br><span class="line">FGC：老年代回收次数</span><br></pre></td></tr></table></figure></li><li>jstat -gcoldcapacity pid 老年代内存空间统计<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 每隔2秒采集一次数据</span><br><span class="line">root@jav-collection01br-p001:~# jstat -gcoldcapacity 1808 2000</span><br><span class="line">   OGCMN       OGCMX        OGC         OC       YGC   FGC    FGCT     GCT</span><br><span class="line">    81920.0    699392.0    233472.0    233472.0 32144     5    0.469   93.478</span><br><span class="line">OGCMN：老年代最小容量</span><br><span class="line"></span><br><span class="line">OGCMX：老年代最大容量</span><br><span class="line"></span><br><span class="line">OGC：当前老年代大小</span><br><span class="line"></span><br><span class="line">OC：老年代大小</span><br><span class="line"></span><br><span class="line">YGC：年轻代垃圾回收次数</span><br><span class="line"></span><br><span class="line">FGC：老年代垃圾回收次数</span><br><span class="line"></span><br><span class="line">FGCT：老年代垃圾回收消耗时间</span><br><span class="line"></span><br><span class="line">GCT：垃圾回收消耗总时间</span><br></pre></td></tr></table></figure></li></ol><h2 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h2><p><a href="https://www.cnblogs.com/ityouknow/p/5714703.html" target="_blank" rel="noopener">jvm系列(四):jvm调优-命令大全（jps jstat jmap jhat jstack jinfo） - 纯洁的微笑 - 博客园</a><br><a href="https://blog.csdn.net/u010758410/article/details/80315927" target="_blank" rel="noopener">JVM 堆内存设置原理 - 木子木泗的博客 - CSDN博客</a><br><a href="https://www.jianshu.com/p/ff46acfad03f" target="_blank" rel="noopener">jvm堆内存设置讲解 - 简书</a><br><a href="https://www.jianshu.com/p/845924a1b8f2" target="_blank" rel="noopener">jstat命令总结 - 简书</a><br><a href="https://www.jianshu.com/p/a09e08065720" target="_blank" rel="noopener">阿里员工都是这样排查Java问题的，附工具单 - 简书</a></p>]]></content>
    
    <summary type="html">
    
      JVM调优命令
    
    </summary>
    
    
      <category term="JVM" scheme="https://shuke163.github.io/categories/JVM/"/>
    
    
      <category term="JVM" scheme="https://shuke163.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Kong-api-gateway</title>
    <link href="https://shuke163.github.io/2020/04/20/index/"/>
    <id>https://shuke163.github.io/2020/04/20/index/</id>
    <published>2020-04-20T08:30:37.000Z</published>
    <updated>2020-04-20T08:31:18.793Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kong-api-gateway"><a href="#Kong-api-gateway" class="headerlink" title="Kong-api-gateway"></a>Kong-api-gateway</h1><hr><p><a href="https://getkong.org" target="_blank" rel="noopener">Kong官方网站</a></p><h2 id="1-Install"><a href="#1-Install" class="headerlink" title="1. Install"></a>1. Install</h2><p><a href="https://konghq.com/install/" target="_blank" rel="noopener">install-kong</a></p><h2 id="2-postgresql"><a href="#2-postgresql" class="headerlink" title="2. postgresql"></a>2. postgresql</h2><ol><li>安装<br>sudo apt-get install postgresql-9.6<br>安装完成后，默认会：</li></ol><p>（1）创建名为”postgres”的Linux用户</p><p>（2）创建名为”postgres”、不带密码的默认数据库账号作为数据库管理员</p><p>（3）创建名为”postgres”的表</p><p>安装完成后的一些默认信息如下：</p><p>config /etc/postgresql/9.5/main<br>data /var/lib/postgresql/9.5/main<br>locale en_US.UTF-8<br>socket /var/run/postgresql<br>port 5432</p><p>安装完后会有PostgreSQL的客户端psql，通过 sudo -u postgres psql 进入，提示符变成： postgres=#<br>在这里可用执行SQL语句和psql的基本命令。可用的基本命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">\password：设置密码</span><br><span class="line">\q：退出</span><br><span class="line">\h：查看SQL命令的解释，比如\h select。</span><br><span class="line">\?：查看psql命令列表。</span><br><span class="line">\l：列出所有数据库。</span><br><span class="line">\c [database_name]：连接其他数据库。</span><br><span class="line">\d：列出当前数据库的所有表格。</span><br><span class="line">\d [table_name]：列出某一张表格的结构。</span><br><span class="line">\du：列出所有用户。</span><br><span class="line">\e：打开文本编辑器。</span><br><span class="line">\conninfo：列出当前数据库和连接的信息。</span><br></pre></td></tr></table></figure><ol start="2"><li><p>修改默认管理员密码<br>以Linux用户”postgres”的身份（此时只有该用户有psql命令）执行psql客户端，进入该客户端的提示符界面（这里系统用户名、数据库用户名、数据库名都为postgres，故可采用简写形式）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo -u postgres psql</span><br><span class="line">postgres&#x3D;# alter user postgres with password &#39;123456&#39;;</span><br></pre></td></tr></table></figure><p>若要删除该管理员的密码，则可用命令：sudo -u postgres psql -d postgres</p></li><li><p>配置远程连接<br>安装完成后，默认只能本地才能连接数据库，其他机子访问不了，需要进行配置。（以下示例开放了最大连接权限，实际配置根据你的需要而定）</p></li><li><p>1 修改监听地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit &#x2F;etc&#x2F;postgresql&#x2F;9.5&#x2F;main&#x2F;postgresql.conf </span><br><span class="line">将 #listen_addresses &#x3D; &#39;localhost&#39; 的注释去掉并改为 listen_addresses &#x3D; &#39;*&#39;</span><br></pre></td></tr></table></figure></li><li><p>修改可访问用户的IP段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo gedit &#x2F;etc&#x2F;postgresql&#x2F;9.5&#x2F;main&#x2F;pg_hba.conf </span><br><span class="line">在文件末尾添加： host all all 0.0.0.0 0.0.0.0 md5 ，表示允许任何IP连接</span><br></pre></td></tr></table></figure></li><li><p>启动数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;init.d&#x2F;postgresql start</span><br></pre></td></tr></table></figure></li><li><p>添加用户及授权</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">运行系统用户&quot;postgres&quot;的psql命令，进入客户端：</span><br><span class="line">sudo -u postgres psql</span><br><span class="line">创建用户&quot;kong&quot;并设置密码：</span><br><span class="line">postgres&#x3D;# create user kong with password &#39;123456&#39;;</span><br><span class="line">创建数据库kong，所有者为kong：</span><br><span class="line">postgres&#x3D;# create database kong owner kong;</span><br><span class="line">将konhg数据库的所有权限赋予kong用户，否则kong只能登录psql，没有任何数据库操作权限：</span><br><span class="line">grant all privileges on database kong to kong;. 添加用户及授权</span><br></pre></td></tr></table></figure></li><li><p>查看<br>postgres=# \du 得到用户列表<br>postgres=# \l  得到数据库列表<br>删除<br>postgres=# drop database kong<br>postgres=# drop user kong</p></li><li><p>常用操作命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 创建新表 </span><br><span class="line">CREATE TABLE user_tbl(name VARCHAR(20), signup_date DATE);</span><br><span class="line"># 插入数据 </span><br><span class="line">INSERT INTO user_tbl(name, signup_date) VALUES(&#39;张三&#39;, &#39;2013-12-22&#39;);</span><br><span class="line"># 选择记录 </span><br><span class="line">SELECT * FROM user_tbl;</span><br><span class="line"># 更新数据 </span><br><span class="line">UPDATE user_tbl set name &#x3D; &#39;李四&#39; WHERE name &#x3D; &#39;张三&#39;;</span><br><span class="line"># 删除记录 </span><br><span class="line">DELETE FROM user_tbl WHERE name &#x3D; &#39;李四&#39; ;</span><br><span class="line"># 添加栏位 </span><br><span class="line">ALTER TABLE user_tbl ADD email VARCHAR(40);</span><br><span class="line"># 更新结构 </span><br><span class="line">ALTER TABLE user_tbl ALTER COLUMN signup_date SET NOT NULL;</span><br><span class="line"># 更名栏位 </span><br><span class="line">ALTER TABLE user_tbl RENAME COLUMN signup_date TO signup;</span><br><span class="line"># 删除栏位 </span><br><span class="line">ALTER TABLE user_tbl DROP COLUMN email;</span><br><span class="line"># 表格更名 </span><br><span class="line">ALTER TABLE user_tbl RENAME TO backup_tbl;</span><br><span class="line"># 删除表格 </span><br><span class="line">DROP TABLE IF EXISTS backup_tbl;</span><br></pre></td></tr></table></figure></li></ol><h2 id="3-Kong-Dashboard"><a href="#3-Kong-Dashboard" class="headerlink" title="3. Kong-Dashboard"></a>3. Kong-Dashboard</h2><ul><li><a href="https://github.com/pantsel/konga" target="_blank" rel="noopener">Konga</a></li><li><a href="https://www.npmjs.com/package/kong-dashboard" target="_blank" rel="noopener">Kong-dashboard-node</a></li><li><a href="https://github.com/PGBI/kong-dashboard" target="_blank" rel="noopener">Kong-dashboard-github</a></li></ul>]]></content>
    
    <summary type="html">
    
      Kong-api-gateway
    
    </summary>
    
    
      <category term="Kong" scheme="https://shuke163.github.io/categories/Kong/"/>
    
    
      <category term="Kong" scheme="https://shuke163.github.io/tags/Kong/"/>
    
  </entry>
  
  <entry>
    <title>Salt API</title>
    <link href="https://shuke163.github.io/2020/04/20/index/"/>
    <id>https://shuke163.github.io/2020/04/20/index/</id>
    <published>2020-04-20T08:11:48.000Z</published>
    <updated>2020-04-20T08:25:57.360Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Salt-API"><a href="#Salt-API" class="headerlink" title="Salt API"></a>Salt API</h2><blockquote><p>使用salt执行原生linux命令</p></blockquote><ol><li><p>安装salt-ssh</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install salt-ssh</span><br></pre></td></tr></table></figure></li><li><p>使用底层API执行shell命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from salt.client.ssh.shell import Shell</span><br><span class="line"></span><br><span class="line">shell &#x3D; Shell(&#123;&quot;_ssh_version&quot;: (4,9)&#125;,&quot;192.168.1.100&quot;,&quot;root&quot;,22,&quot;root123&quot;,timeout&#x3D;60)</span><br><span class="line">result &#x3D; shell.exec_cmd(&quot;df -h&quot;)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><h3 id="salt-shell-api"><a href="#salt-shell-api" class="headerlink" title="salt shell api"></a>salt shell api</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from salt.client.ssh.client import SSHClient</span><br><span class="line"></span><br><span class="line">clinet &#x3D; SSHClient()</span><br><span class="line"></span><br><span class="line">ret &#x3D; client.cmd(&quot;*&quot;,&quot;cmd.run&quot;,(&quot;df -h&quot;,),30)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      Salt API
    
    </summary>
    
    
      <category term="Salt" scheme="https://shuke163.github.io/categories/Salt/"/>
    
    
      <category term="Salt" scheme="https://shuke163.github.io/tags/Salt/"/>
    
  </entry>
  
  <entry>
    <title>运维知识体系</title>
    <link href="https://shuke163.github.io/2020/04/20/index/"/>
    <id>https://shuke163.github.io/2020/04/20/index/</id>
    <published>2020-04-20T08:06:50.000Z</published>
    <updated>2020-04-20T08:44:29.518Z</updated>
    
    <content type="html"><![CDATA[<p><img src="%E8%BF%90%E7%BB%B4%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E8%BF%90%E7%BB%B4%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BBV1.0.jpg" alt="运维知识体系"></p>]]></content>
    
    <summary type="html">
    
      运维知识体系
    
    </summary>
    
    
      <category term="SRE" scheme="https://shuke163.github.io/categories/SRE/"/>
    
    
      <category term="SRE" scheme="https://shuke163.github.io/tags/SRE/"/>
    
  </entry>
  
  <entry>
    <title>常用Git命令清单-v0.1</title>
    <link href="https://shuke163.github.io/2020/04/20/index/"/>
    <id>https://shuke163.github.io/2020/04/20/index/</id>
    <published>2020-04-20T08:02:43.000Z</published>
    <updated>2020-04-20T08:02:58.942Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常用Git命令清单"><a href="#常用Git命令清单" class="headerlink" title="常用Git命令清单"></a>常用Git命令清单</h2><blockquote><p>一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。</p></blockquote><h3 id="名次解释"><a href="#名次解释" class="headerlink" title="名次解释"></a>名次解释</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEB392fff8491cd94960a8296d7607e51b4?method=download&shareKey=e5b3ec746227b33cc6120efe14ca3fde" alt="image"><br>下面是我整理的常用 Git 命令清单。几个专用名词的译名如下:<br>Workspace：工作区<br>Index / Stage：暂存区<br>Repository：仓库区（或本地仓库）<br>Remote：远程仓库</p><h3 id="一-新建代码库"><a href="#一-新建代码库" class="headerlink" title="一. 新建代码库"></a>一. 新建代码库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 在当前目录新建一个Git代码库</span><br><span class="line">$ git init</span><br><span class="line"></span><br><span class="line"># 新建一个目录，将其初始化为Git代码库</span><br><span class="line">$ git init [project-name]</span><br><span class="line"></span><br><span class="line"># 下载一个项目和它的整个代码历史</span><br><span class="line">$ git clone [url]</span><br></pre></td></tr></table></figure><h3 id="二-配置"><a href="#二-配置" class="headerlink" title="二.配置"></a>二.配置</h3><p>Git的设置文件为.gitconfig，它可以在用户主目录下(全局配置)，也可以在项目目录下(项目配置)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 显示当前的Git配置</span><br><span class="line">$ git config --list</span><br><span class="line"></span><br><span class="line"># 编辑Git配置文件</span><br><span class="line">$ git config -e [--global]</span><br><span class="line"></span><br><span class="line"># 设置提交代码时的用户信息</span><br><span class="line">$ git config [--global] user.name &quot;[name]&quot;</span><br><span class="line">$ git config [--global] user.email &quot;[email address]&quot;</span><br><span class="line"></span><br><span class="line"># 颜色设置</span><br><span class="line">git config --global color.ui true                         # git status等命令自动着色</span><br><span class="line">git config --global color.status auto</span><br><span class="line">git config --global color.diff auto</span><br><span class="line">git config --global color.branch auto</span><br><span class="line">git config --global color.interactive auto</span><br><span class="line">git config --global --unset http.proxy                    # remove  proxy configuration on git</span><br></pre></td></tr></table></figure><h3 id="三-增加-删除文件"><a href="#三-增加-删除文件" class="headerlink" title="三. 增加/删除文件"></a>三. 增加/删除文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 添加指定文件到暂存区</span><br><span class="line">$ git add [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"># 添加指定目录到暂存区，包括子目录</span><br><span class="line">$ git add [dir]</span><br><span class="line"></span><br><span class="line"># 添加当前目录的所有文件到暂存区</span><br><span class="line">$ git add .</span><br><span class="line"></span><br><span class="line"># 添加每个变化前，都会要求确认</span><br><span class="line"># 对于同一个文件的多处变化，可以实现分次提交</span><br><span class="line">$ git add -p</span><br><span class="line"></span><br><span class="line"># 删除工作区文件，并且将这次删除放入暂存区</span><br><span class="line">$ git rm [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"># 停止追踪指定文件，但该文件会保留在工作区</span><br><span class="line">$ git rm --cached [file]</span><br><span class="line"></span><br><span class="line"># 改名文件，并且将这个改名放入暂存区</span><br><span class="line">$ git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure><h3 id="四-代码提交"><a href="#四-代码提交" class="headerlink" title="四. 代码提交"></a>四. 代码提交</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 提交暂存区到仓库区</span><br><span class="line">$ git commit -m [message]</span><br><span class="line"></span><br><span class="line"># 提交暂存区的指定文件到仓库区</span><br><span class="line">$ git commit [file1] [file2] ... -m [message]</span><br><span class="line"></span><br><span class="line"># 提交工作区自上次commit之后的变化，直接到仓库区</span><br><span class="line">$ git commit -a</span><br><span class="line"></span><br><span class="line"># 提交时显示所有diff信息</span><br><span class="line">$ git commit -v</span><br><span class="line"></span><br><span class="line"># 将add和commit合为一步</span><br><span class="line">$ git commit -am &#39;message&#39;</span><br><span class="line"></span><br><span class="line"># 使用一次新的commit，替代上一次提交</span><br><span class="line"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span><br><span class="line">$ git commit --amend -m [message]</span><br><span class="line"></span><br><span class="line"># 重做上一次commit，并包括指定文件的新变化</span><br><span class="line">$ git commit --amend [file1] [file2] ...</span><br></pre></td></tr></table></figure><h3 id="五-分支"><a href="#五-分支" class="headerlink" title="五. 分支"></a>五. 分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"># 列出所有本地分支</span><br><span class="line">$ git branch</span><br><span class="line"></span><br><span class="line"># 列出所有远程分支</span><br><span class="line">$ git branch -r</span><br><span class="line"></span><br><span class="line"># 列出所有本地分支和远程分支</span><br><span class="line">$ git branch -a</span><br><span class="line"></span><br><span class="line"># 新建一个分支，但依然停留在当前分支</span><br><span class="line">$ git branch [branch-name]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，并切换到该分支</span><br><span class="line">$ git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，指向指定commit</span><br><span class="line">$ git branch [branch] [commit]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，与指定的远程分支建立追踪关系</span><br><span class="line">$ git branch --track [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"># 切换到指定分支，并更新工作区</span><br><span class="line">$ git checkout [branch-name]</span><br><span class="line"></span><br><span class="line"># 切换到上一个分支</span><br><span class="line">$ git checkout -</span><br><span class="line"></span><br><span class="line"># 建立追踪关系，在现有分支与指定的远程分支之间</span><br><span class="line">$ git branch --set-upstream [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"># 合并指定分支到当前分支</span><br><span class="line">$ git merge [branch]</span><br><span class="line"></span><br><span class="line"># 选择一个commit，合并进当前分支</span><br><span class="line">$ git cherry-pick [commit]</span><br><span class="line"></span><br><span class="line"># 删除分支</span><br><span class="line">$ git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line"># 删除远程分支</span><br><span class="line">$ git push origin --delete [branch-name]</span><br><span class="line">$ git branch -dr [remote&#x2F;branch]</span><br><span class="line"></span><br><span class="line"># 检出版本v2.0</span><br><span class="line">$ git checkout v2.0</span><br><span class="line"></span><br><span class="line"># 从远程分支develop创建新本地分支devel并检出</span><br><span class="line">$ git checkout -b devel origin&#x2F;develop</span><br><span class="line"></span><br><span class="line"># 检出head版本的README文件（可用于修改错误回退）</span><br><span class="line">git checkout -- README</span><br></pre></td></tr></table></figure><h3 id="六-标签"><a href="#六-标签" class="headerlink" title="六. 标签"></a>六. 标签</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 列出所有tag</span><br><span class="line">$ git tag</span><br><span class="line"></span><br><span class="line"># 新建一个tag在当前commit</span><br><span class="line">$ git tag [tag]</span><br><span class="line"></span><br><span class="line"># 新建一个tag在指定commit</span><br><span class="line">$ git tag [tag] [commit]</span><br><span class="line"></span><br><span class="line"># 删除本地tag</span><br><span class="line">$ git tag -d [tag]</span><br><span class="line"></span><br><span class="line"># 删除远程tag</span><br><span class="line">$ git push origin :refs&#x2F;tags&#x2F;[tagName]</span><br><span class="line"></span><br><span class="line"># 查看tag信息</span><br><span class="line">$ git show [tag]</span><br><span class="line"></span><br><span class="line"># 提交指定tag</span><br><span class="line">$ git push [remote] [tag]</span><br><span class="line"></span><br><span class="line"># 提交所有tag</span><br><span class="line">$ git push [remote] --tags</span><br><span class="line"></span><br><span class="line"># 新建一个分支，指向某个tag</span><br><span class="line">$ git checkout -b [branch] [tag]</span><br></pre></td></tr></table></figure><h3 id="七-查看信息"><a href="#七-查看信息" class="headerlink" title="七. 查看信息"></a>七. 查看信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"># 显示有变更的文件</span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"># 显示当前分支的版本历史</span><br><span class="line">$ git log</span><br><span class="line"></span><br><span class="line"># 显示commit历史，以及每次commit发生变更的文件</span><br><span class="line">$ git log --stat</span><br><span class="line"></span><br><span class="line"># 搜索提交历史，根据关键词</span><br><span class="line">$ git log -S [keyword]</span><br><span class="line"></span><br><span class="line"># 显示某个commit之后的所有变动，每个commit占据一行</span><br><span class="line">$ git log [tag] HEAD --pretty&#x3D;format:%s</span><br><span class="line"></span><br><span class="line"># 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件</span><br><span class="line">$ git log [tag] HEAD --grep feature</span><br><span class="line"></span><br><span class="line"># 显示某个文件的版本历史，包括文件改名</span><br><span class="line">$ git log --follow [file]</span><br><span class="line">$ git whatchanged [file]</span><br><span class="line"></span><br><span class="line"># 显示指定文件相关的每一次diff</span><br><span class="line">$ git log -p [file]</span><br><span class="line"></span><br><span class="line"># 显示过去5次提交</span><br><span class="line">$ git log -5 --pretty --oneline</span><br><span class="line"></span><br><span class="line"># 显示所有提交过的用户，按提交次数排序</span><br><span class="line">$ git shortlog -sn</span><br><span class="line"></span><br><span class="line"># 显示指定文件是什么人在什么时间修改过</span><br><span class="line">$ git blame [file]</span><br><span class="line"></span><br><span class="line"># 显示暂存区和工作区的差异</span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line"># 显示暂存区和上一个commit的差异</span><br><span class="line">$ git diff --cached [file]</span><br><span class="line"></span><br><span class="line"># 显示工作区与当前分支最新commit之间的差异</span><br><span class="line">$ git diff HEAD</span><br><span class="line"></span><br><span class="line"># 显示两次提交之间的差异</span><br><span class="line">$ git diff [first-branch]...[second-branch]</span><br><span class="line"></span><br><span class="line"># 显示今天你写了多少行代码</span><br><span class="line">$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;</span><br><span class="line"></span><br><span class="line"># 显示某次提交的元数据和内容变化</span><br><span class="line">$ git show [commit]</span><br><span class="line"></span><br><span class="line"># 显示某次提交发生变化的文件</span><br><span class="line">$ git show --name-only [commit]</span><br><span class="line"></span><br><span class="line"># 显示某次提交时，某个文件的内容</span><br><span class="line">$ git show [commit]:[filename]</span><br><span class="line"></span><br><span class="line"># 显示当前分支的最近几次提交</span><br><span class="line">$ git reflog</span><br></pre></td></tr></table></figure><h3 id="八-远程同步"><a href="#八-远程同步" class="headerlink" title="八. 远程同步"></a>八. 远程同步</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 下载远程仓库的所有变动</span><br><span class="line">$ git fetch [remote]</span><br><span class="line"></span><br><span class="line"># 显示所有远程仓库</span><br><span class="line">$ git remote -v</span><br><span class="line"></span><br><span class="line"># 显示某个远程仓库的信息</span><br><span class="line">$ git remote show [remote]</span><br><span class="line"></span><br><span class="line"># 增加一个新的远程仓库，并命名</span><br><span class="line">$ git remote add [shortname] [url]</span><br><span class="line"></span><br><span class="line"># 取回远程仓库的变化，并与本地分支合并</span><br><span class="line">$ git pull [remote] [branch]</span><br><span class="line"></span><br><span class="line"># 上传本地指定分支到远程仓库</span><br><span class="line">$ git push [remote] [branch]</span><br><span class="line"></span><br><span class="line"># 强行推送当前分支到远程仓库，即使有冲突</span><br><span class="line">$ git push [remote] --force</span><br><span class="line"></span><br><span class="line"># 推送所有分支到远程仓库</span><br><span class="line">$ git push [remote] --all</span><br></pre></td></tr></table></figure><h3 id="九-撤销"><a href="#九-撤销" class="headerlink" title="九. 撤销"></a>九. 撤销</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># 恢复暂存区的指定文件到工作区</span><br><span class="line">$ git checkout [file]</span><br><span class="line"></span><br><span class="line"># 恢复某个commit的指定文件到暂存区和工作区</span><br><span class="line">$ git checkout [commit] [file]</span><br><span class="line"></span><br><span class="line"># 恢复暂存区的所有文件到工作区</span><br><span class="line">$ git checkout .</span><br><span class="line"></span><br><span class="line"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span><br><span class="line">$ git reset [file]</span><br><span class="line"></span><br><span class="line"># 重置暂存区与工作区，与上一次commit保持一致</span><br><span class="line">$ git reset --hard</span><br><span class="line"></span><br><span class="line"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br><span class="line">$ git reset [commit]</span><br><span class="line"></span><br><span class="line"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br><span class="line">$ git reset --hard [commit]</span><br><span class="line"></span><br><span class="line"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span><br><span class="line">$ git reset --keep [commit]</span><br><span class="line"></span><br><span class="line"># 新建一个commit，用来撤销指定commit</span><br><span class="line"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span><br><span class="line">$ git revert [commit]</span><br><span class="line"></span><br><span class="line"># 暂时将未提交的变化移除，稍后再移入</span><br><span class="line">$ git stash</span><br><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure><h3 id="十-其他"><a href="#十-其他" class="headerlink" title="十. 其他"></a>十. 其他</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">git init                                                  # 初始化本地git仓库（创建新仓库）</span><br><span class="line">git config --global user.name &quot;xxx&quot;                       # 配置用户名</span><br><span class="line">git config --global user.email &quot;xxx@xxx.com&quot;              # 配置邮件</span><br><span class="line">git config --global color.ui true                         # git status等命令自动着色</span><br><span class="line">git config --global color.status auto</span><br><span class="line">git config --global color.diff auto</span><br><span class="line">git config --global color.branch auto</span><br><span class="line">git config --global color.interactive auto</span><br><span class="line">git config --global --unset http.proxy                    # remove  proxy configuration on git</span><br><span class="line">git clone git+ssh:&#x2F;&#x2F;git@192.168.53.168&#x2F;VT.git             # clone远程仓库</span><br><span class="line">git status                                                # 查看当前版本状态（是否修改）</span><br><span class="line">git add xyz                                               # 添加xyz文件至index</span><br><span class="line">git add .                                                 # 增加当前子目录下所有更改过的文件至index</span><br><span class="line">git commit -m &#39;xxx&#39;                                       # 提交</span><br><span class="line">git commit --amend -m &#39;xxx&#39;                               # 合并上一次提交（用于反复修改）</span><br><span class="line">git commit -am &#39;xxx&#39;                                      # 将add和commit合为一步</span><br><span class="line">git rm xxx                                                # 删除index中的文件</span><br><span class="line">git rm -r *                                               # 递归删除</span><br><span class="line">git log                                                   # 显示提交日志</span><br><span class="line">git log -1                                                # 显示1行日志 -n为n行</span><br><span class="line">git log -5</span><br><span class="line">git log --stat                                            # 显示提交日志及相关变动文件</span><br><span class="line">git log -p -m</span><br><span class="line">git show dfb02e6e4f2f7b573337763e5c0013802e392818         # 显示某个提交的详细内容</span><br><span class="line">git show dfb02                                            # 可只用commitid的前几位</span><br><span class="line">git show HEAD                                             # 显示HEAD提交日志</span><br><span class="line">git show HEAD^                                            # 显示HEAD的父（上一个版本）的提交日志 ^^为上两个版本 ^5为上5个版本</span><br><span class="line">git tag                                                   # 显示已存在的tag</span><br><span class="line">git tag -a v2.0 -m &#39;xxx&#39;                                  # 增加v2.0的tag</span><br><span class="line">git show v2.0                                             # 显示v2.0的日志及详细内容</span><br><span class="line">git log v2.0                                              # 显示v2.0的日志</span><br><span class="line">git diff                                                  # 显示所有未添加至index的变更</span><br><span class="line">git diff --cached                                         # 显示所有已添加index但还未commit的变更</span><br><span class="line">git diff HEAD^                                            # 比较与上一个版本的差异</span><br><span class="line">git diff HEAD -- .&#x2F;lib                                    # 比较与HEAD版本lib目录的差异</span><br><span class="line">git diff origin&#x2F;master..master                            # 比较远程分支master上有本地分支master上没有的</span><br><span class="line">git diff origin&#x2F;master..master --stat                     # 只显示差异的文件，不显示具体内容</span><br><span class="line">git remote add origin git+ssh:&#x2F;&#x2F;git@192.168.53.168&#x2F;VT.git # 增加远程定义（用于push&#x2F;pull&#x2F;fetch）</span><br><span class="line">git branch                                                # 显示本地分支</span><br><span class="line">git branch --contains 50089                               # 显示包含提交50089的分支</span><br><span class="line">git branch -a                                             # 显示所有分支</span><br><span class="line">git branch -r                                             # 显示所有原创分支</span><br><span class="line">git branch --merged                                       # 显示所有已合并到当前分支的分支</span><br><span class="line">git branch --no-merged                                    # 显示所有未合并到当前分支的分支</span><br><span class="line">git branch -m master master_copy                          # 本地分支改名</span><br><span class="line">git checkout -b master_copy                               # 从当前分支创建新分支master_copy并检出</span><br><span class="line">git checkout -b master master_copy                        # 上面的完整版</span><br><span class="line">git checkout features&#x2F;performance                         # 检出已存在的features&#x2F;performance分支</span><br><span class="line">git checkout --track hotfixes&#x2F;BJVEP933                    # 检出远程分支hotfixes&#x2F;BJVEP933并创建本地跟踪分支</span><br><span class="line">git checkout v2.0                                         # 检出版本v2.0</span><br><span class="line">git checkout -b devel origin&#x2F;develop                      # 从远程分支develop创建新本地分支devel并检出</span><br><span class="line">git checkout -- README                                    # 检出head版本的README文件（可用于修改错误回退）</span><br><span class="line">git merge origin&#x2F;master                                   # 合并远程master分支至当前分支</span><br><span class="line">git cherry-pick ff44785404a8e                             # 合并提交ff44785404a8e的修改</span><br><span class="line">git push origin master                                    # 将当前分支push到远程master分支</span><br><span class="line">git push origin :hotfixes&#x2F;BJVEP933                        # 删除远程仓库的hotfixes&#x2F;BJVEP933分支</span><br><span class="line">git push --tags                                           # 把所有tag推送到远程仓库</span><br><span class="line">git fetch                                                 # 获取所有远程分支（不更新本地分支，另需merge）</span><br><span class="line">git fetch --prune                                         # 获取所有原创分支并清除服务器上已删掉的分支</span><br><span class="line">git pull origin master                                    # 获取远程分支master并merge到当前分支</span><br><span class="line">git mv README README2                                     # 重命名文件README为README2</span><br><span class="line">git reset --hard HEAD                                     # 将当前版本重置为HEAD（通常用于merge失败回退）</span><br><span class="line">git rebase</span><br><span class="line">git branch -d hotfixes&#x2F;BJVEP933                           # 删除分支hotfixes&#x2F;BJVEP933（本分支修改已合并到其他分支）</span><br><span class="line">git branch -D hotfixes&#x2F;BJVEP933                           # 强制删除分支hotfixes&#x2F;BJVEP933</span><br><span class="line">git ls-files                                              # 列出git index包含的文件</span><br><span class="line">git show-branch                                           # 图示当前分支历史</span><br><span class="line">git show-branch --all                                     # 图示所有分支历史</span><br><span class="line">git whatchanged                                           # 显示提交历史对应的文件修改</span><br><span class="line">git revert dfb02e6e4f2f7b573337763e5c0013802e392818       # 撤销提交dfb02e6e4f2f7b573337763e5c0013802e392818</span><br><span class="line">git ls-tree HEAD                                          # 内部命令：显示某个git对象</span><br><span class="line">git rev-parse v2.0                                        # 内部命令：显示某个ref对于的SHA1 HASH</span><br><span class="line">git reflog                                                # 显示所有提交，包括孤立节点</span><br><span class="line">git show HEAD@&#123;5&#125;</span><br><span class="line">git show master@&#123;yesterday&#125;                               # 显示master分支昨天的状态</span><br><span class="line">git log --pretty&#x3D;format:&#39;%h %s&#39; --graph                   # 图示提交日志</span><br><span class="line">git show HEAD~3</span><br><span class="line">git show -s --pretty&#x3D;raw 2be7fcb476</span><br><span class="line">git stash                                                 # 暂存当前修改，将所有至为HEAD状态</span><br><span class="line">git stash list                                            # 查看所有暂存</span><br><span class="line">git stash show -p stash@&#123;0&#125;                               # 参考第一次暂存</span><br><span class="line">git stash apply stash@&#123;0&#125;                                 # 应用第一次暂存</span><br><span class="line">git grep &quot;delete from&quot;                                    # 文件中搜索文本“delete from”</span><br><span class="line">git grep -e &#39;#define&#39; --and -e SORT_DIRENT</span><br><span class="line">git gc</span><br><span class="line">git fsck</span><br><span class="line"># 生成一个可供发布的压缩包</span><br><span class="line">$ git archive</span><br></pre></td></tr></table></figure><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="noopener">常用 Git 命令清单 - 阮一峰的网络日志</a><br><a href="http://www.cnblogs.com/wupeiqi/p/7295372.html" target="_blank" rel="noopener">老铁，这年头不会点Git真不行</a><br><a href="https://gist.github.com/guweigang/9848271" target="_blank" rel="noopener">一些命令-github</a><br><a href="https://github.com/geeeeeeeeek/git-recipes/wiki" target="_blank" rel="noopener">Home-geeeeeeeeek/git-recipes Wiki-GitHub</a>  </p>]]></content>
    
    <summary type="html">
    
      常用Git命令清单-v0.1
    
    </summary>
    
    
      <category term="Git" scheme="https://shuke163.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="https://shuke163.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>值得看的7本书</title>
    <link href="https://shuke163.github.io/2020/04/20/index/"/>
    <id>https://shuke163.github.io/2020/04/20/index/</id>
    <published>2020-04-20T08:02:09.000Z</published>
    <updated>2020-04-20T08:11:11.554Z</updated>
    
    <content type="html"><![CDATA[<h2 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h2><ol><li>穷爸爸富爸爸</li><li>见识</li><li>被讨厌的勇气</li><li>情绪勒索</li><li>苏菲的世界</li><li>秘密</li><li>就这样，我睡了全世界的沙发</li></ol>]]></content>
    
    <summary type="html">
    
      值得看的7本书
    
    </summary>
    
    
      <category term="Book" scheme="https://shuke163.github.io/categories/Book/"/>
    
    
      <category term="Book" scheme="https://shuke163.github.io/tags/Book/"/>
    
  </entry>
  
  <entry>
    <title>简洁的Bash Programming技巧(三)</title>
    <link href="https://shuke163.github.io/2020/04/20/index/"/>
    <id>https://shuke163.github.io/2020/04/20/index/</id>
    <published>2020-04-20T08:01:16.000Z</published>
    <updated>2020-04-20T08:01:39.101Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简洁的Bash-Programming技巧-一"><a href="#简洁的Bash-Programming技巧-一" class="headerlink" title="简洁的Bash Programming技巧(一)"></a>简洁的Bash Programming技巧(一)</h2><h3 id="1-bash中alias的使用"><a href="#1-bash中alias的使用" class="headerlink" title="1. bash中alias的使用"></a>1. bash中alias的使用</h3><p>alias其实是给常用的命令定一个别名，比如很多人会定义一下的一个别名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias ll&#x3D;&#39;ls -l&#39;</span><br></pre></td></tr></table></figure><p>以后就可以使用ll，实际展开后执行的是ls -l。现在很多发行版都会带几个默认的别名，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alias grep&#x3D;&#39;grep --color&#x3D;auto&#39;  # 带颜色显示</span><br><span class="line">alias ls&#x3D;&#39;ls --color&#x3D;auto&#39; # 同上</span><br><span class="line">alias rm&#x3D;&#39;rm -i&#39;  # 删除文件需要确认</span><br></pre></td></tr></table></figure><p>alias在某些方面确实提高了很大的效率，但是也是有隐患的，这点可以看我以前的一篇文章终端下肉眼看不见的东西。那么如何不要展开alias，而是用本来的意思呢？答案是使用转义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\ls</span><br><span class="line">\grep</span><br></pre></td></tr></table></figure><p>在命令前面加一个反斜杠后就可以了。 这里要插一段故事，前两天我在shell脚本中定义了下面的一个alias，假设位于文件util.sh：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">alias ssh&#x3D;&#39;ssh -o StrictHostKeyChecking&#x3D;no -o LogLevel&#x3D;quiet -o BatchMode&#x3D;yes&#39;</span><br></pre></td></tr></table></figure><p>后面这串ssh选项是为了去掉一些warning的信息，不提示输入密码等等。具体可以看ssh的文档说明。我自己测试的时候好好的，当时我同事跑得时候却依然有报Warning。我对比了下我们两个人的用法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sh util.sh  # 方式一</span><br><span class="line">.&#x2F;util.sh   # 方式二</span><br></pre></td></tr></table></figure><p>大家应该知道，直接./util.sh执行，shell会去找脚本第一行的shebang中给定的解释器去执行改脚本，所以第二种用法相当于直接用bash来执行。那想必是bash/sh对alias是否默认展开这一点上是有区别的了。翻阅了下Bash的man手册，发现可以通过设置expand_aliases选项来打开alias展开的功能，默认在非交互式Shell下是关闭的（什么是交互式登录Shell)<br>修改下util.sh，打开这个选项就Ok了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"># Expand aliases in script</span><br><span class="line">shopt -s expand_aliases</span><br><span class="line">alias ssh&#x3D;&#39;ssh -o StrictHostKeyChecking&#x3D;no -o LogLevel&#x3D;quiet -o BatchMode&#x3D;yes&#39;</span><br></pre></td></tr></table></figure><h3 id="2-awk打印除第一列之外的其他列"><a href="#2-awk打印除第一列之外的其他列" class="headerlink" title="2. awk打印除第一列之外的其他列"></a>2. awk打印除第一列之外的其他列</h3><p>awk用来截取输入行中的某几列很有用，当时如果要排除某几列呢？ 例如有如下的一个文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat &#x2F;tmp&#x2F;test.txt</span><br><span class="line">1 2 3 4 5</span><br><span class="line">10 20 30 40 50</span><br></pre></td></tr></table></figure><p>可以用下面的代码解决:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#39;&#123;$1&#x3D;&quot;&quot;;print $0&#125;&#39; &#x2F;tmp&#x2F;test.txt</span><br><span class="line"> 2 3 4 5</span><br><span class="line"> 20 30 40 50</span><br></pre></td></tr></table></figure><p>但是前面多了一个空格，可以用cut命令稍微调整下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ awk &#39;&#123;$1&#x3D;&quot;&quot;;print $0&#125;&#39; &#x2F;tmp&#x2F;test.txt | cut -c2-</span><br><span class="line">2 3 4 5</span><br><span class="line">20 30 40 50</span><br></pre></td></tr></table></figure><h3 id="3-巧用bash的命令展开功能备份文件"><a href="#3-巧用bash的命令展开功能备份文件" class="headerlink" title="3. 巧用bash的命令展开功能备份文件"></a>3. 巧用bash的命令展开功能备份文件</h3><p>假设要备份文件/your/path/to/file.list为/your/path/to/file.list.20121106，常规的方法是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp &#x2F;your&#x2F;path&#x2F;to&#x2F;file.list &#x2F;your&#x2F;path&#x2F;to&#x2F;file.list.20121106</span><br></pre></td></tr></table></figure><p>这样重复写上一长串的路径，是不是很麻烦，这里利用bash的展开特性可以这样做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp &#x2F;your&#x2F;path&#x2F;to&#x2F;file.list&#123;,.20180406&#125;</span><br></pre></td></tr></table></figure><p>/your/path/to/file.list{,.20121106}这一部分会展开为/your/path/to/file.list /your/path/to/file.list.20121106,再将此传给cp命令，就达到了与前面同样的效果。（思路同ls *）。具体可以man bash中的Brace Expansion这一段。</p><h3 id="4-你知道sed的这个特性吗？"><a href="#4-你知道sed的这个特性吗？" class="headerlink" title="4. 你知道sed的这个特性吗？"></a>4. 你知道sed的这个特性吗？</h3><p>假设一个文件的每一行为一个路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat &#x2F;tmp&#x2F;test.txt</span><br><span class="line">&#x2F;home&#x2F;kodango&#x2F;hello</span><br><span class="line">&#x2F;home&#x2F;kodango&#x2F;hello&#x2F;world</span><br><span class="line">&#x2F;home&#x2F;kodango&#x2F;good</span><br><span class="line">&#x2F;home&#x2F;kodango&#x2F;good&#x2F;bye</span><br></pre></td></tr></table></figure><p>现在要把/home/kodango/good替换成/home/kodango/bad，普通的作法是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sed -n &#39;s&#x2F;\&#x2F;home\&#x2F;kodango\&#x2F;good&#x2F;\&#x2F;home\&#x2F;kodango\&#x2F;bye&#x2F;p&#39; &#x2F;tmp&#x2F;test.txt </span><br><span class="line">&#x2F;home&#x2F;kodango&#x2F;bye</span><br><span class="line">&#x2F;home&#x2F;kodango&#x2F;bye&#x2F;bye</span><br></pre></td></tr></table></figure><p>因为路径中的分隔符与sed的替换命令的分隔符都是’/‘，所以需要转义，非常麻烦。幸运的是，sed可以更改分隔符，例如使用#：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sed -n &#39;s#&#x2F;home&#x2F;kodango&#x2F;good#&#x2F;home&#x2F;kodango&#x2F;bad#p&#39; &#x2F;tmp&#x2F;test.txt </span><br><span class="line">&#x2F;home&#x2F;kodango&#x2F;bad</span><br><span class="line">&#x2F;home&#x2F;kodango&#x2F;bad&#x2F;bye</span><br></pre></td></tr></table></figure><p>这样就清爽多了。 补充，如果是在地址对中使用，首个分隔符前面要加反斜杠：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sed -n &#39;\#&#x2F;home&#x2F;kodango&#x2F;#p&#39; &#x2F;tmp&#x2F;test.txt </span><br><span class="line">&#x2F;home&#x2F;kodango&#x2F;hello</span><br><span class="line">&#x2F;home&#x2F;kodango&#x2F;hello&#x2F;world</span><br><span class="line">&#x2F;home&#x2F;kodango&#x2F;good</span><br><span class="line">&#x2F;home&#x2F;kodango&#x2F;good&#x2F;bye</span><br></pre></td></tr></table></figure><h3 id="5-合并连续重复的字符（即squeeze操作）"><a href="#5-合并连续重复的字符（即squeeze操作）" class="headerlink" title="5. 合并连续重复的字符（即squeeze操作）"></a>5. 合并连续重复的字符（即squeeze操作）</h3><p>例如要合并一个字符串中连续的多个空格，假设字符串为’print hello, world’。 第一种方法，使用sed命令，扫描整个字符串，替换2个以上的空格为1格:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo &#39;print  hello,   world  &#39; | sed -r &#39;s&#x2F; &#123;2,&#125;&#x2F; &#x2F;g&#39;</span><br><span class="line">print hello, world</span><br></pre></td></tr></table></figure><p>第二种方法，使用tr命令的-s选项，专门就是为了合并连续重复的字符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo &#39;print  hello,   world  &#39; | tr -s &#39; &#39;</span><br><span class="line">print hello, world</span><br></pre></td></tr></table></figure><p>第三种方法，使用awk的域赋值来完成该目的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo &#39;print  hello,   world  &#39; | awk &#39;$1&#x3D;$1&#39;</span><br><span class="line">print hello, world</span><br></pre></td></tr></table></figure><h3 id="6-将文本中某列相同的行输出到不同的文件中"><a href="#6-将文本中某列相同的行输出到不同的文件中" class="headerlink" title="6. 将文本中某列相同的行输出到不同的文件中"></a>6. 将文本中某列相同的行输出到不同的文件中</h3><p>标题有点绕口，我们以实际例子来讲解，假设我们有以下的一个文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat &#x2F;tmp&#x2F;test.txt</span><br><span class="line">a char</span><br><span class="line">1 int</span><br><span class="line">2 int</span><br><span class="line">b char</span><br><span class="line">abc string</span><br></pre></td></tr></table></figure><p>我们的目标是将该文本中的行按第二列的值归类，并且输出到相应的文件中，文件名为第二列的名称。例如第2行、第3行会输出到int.txt文件中，而第1行、第4行则输出到char.txt，以此类推。</p><p>我没有找到其它简单的方法，只找到一种用awk来处理的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &#39;&#123;print $1 &gt; $2 &quot;.txt&quot;&#125;&#39; &#x2F;tmp&#x2F;test.txt</span><br></pre></td></tr></table></figure><p>我们来检查结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">grep -nH . *</span><br><span class="line">char.txt:1:a</span><br><span class="line">char.txt:2:b</span><br><span class="line">int.txt:1:1</span><br><span class="line">int.txt:2:2</span><br><span class="line">string.txt:1:abc</span><br></pre></td></tr></table></figure><h3 id="7-用exec命令来完成重定向"><a href="#7-用exec命令来完成重定向" class="headerlink" title="7. 用exec命令来完成重定向"></a>7. 用exec命令来完成重定向</h3><p>以一个简单的例子开始，现在需要一个脚本，它可以接受一个文件名作为参数，然后按行读取该文件的内容并打印到标准输出。如果不指定文件名，则默认从标准输入读。首先按上面的功能需求写出一个可以完成功能的脚本:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ cat test.sh </span><br><span class="line"></span><br><span class="line">filename&#x3D;$1</span><br><span class="line"></span><br><span class="line">if [ -z &quot;$filename&quot; ]; then</span><br><span class="line">    while read line; do</span><br><span class="line">        echo $line</span><br><span class="line">    done</span><br><span class="line">else</span><br><span class="line">    while read line; do</span><br><span class="line">        echo $line</span><br><span class="line">    done &lt; $filename</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>如果换exec来实现重定向，可以把脚本写得更优雅：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ cat test1.sh </span><br><span class="line"></span><br><span class="line">filename&#x3D;$1</span><br><span class="line"></span><br><span class="line">if [ -n &quot;$filename&quot; ]; then</span><br><span class="line">    exec 0&lt; $filename</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">while read line; do</span><br><span class="line">    echo $line</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>这里的关键在第5行代码，exec命令不仅可以用于执行命令，还可以用于打开、关闭或者复制文件描述符，这里就是利用exec将指定的文件名打开重定向到标准输入。类似地可以用exec &gt;$filename将文件重定向到标准输出。我们可以在命令行上做一个试验：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ exec 3&gt;&amp;1                   # 首先将fd 3重定向到标准输出，作为标准输出的一个备份</span><br><span class="line"></span><br><span class="line">$ ls &#x2F;proc&#x2F;629&#x2F;fd&#x2F;&#123;1,3&#125; -l    # 现在fd 3和fd 1指向同一个设备文件</span><br><span class="line">lrwx------ 1 kodango kodango 64 Nov 10 00:26 &#x2F;proc&#x2F;629&#x2F;fd&#x2F;1 -&gt; &#x2F;dev&#x2F;pts&#x2F;1</span><br><span class="line">lrwx------ 1 kodango kodango 64 Nov 10 00:26 &#x2F;proc&#x2F;629&#x2F;fd&#x2F;3 -&gt; &#x2F;dev&#x2F;pts&#x2F;1</span><br><span class="line"></span><br><span class="line">$ exec &gt;stdout               # 现在把标准输出重定向到stdout这个文件中</span><br><span class="line"></span><br><span class="line">$ ls &#x2F;proc&#x2F;629&#x2F;fd&#x2F;1 -l        # 如果你此刻在同一个终端下执行本命令是没有返回的</span><br><span class="line"></span><br><span class="line">$ ls &#x2F;proc&#x2F;629&#x2F;fd&#x2F;1 -l        # 现在重新打开一个终端看看，确实已经重定向到stdout这个文件</span><br><span class="line">l-wx------ 1 kodango kodango 64 Nov 10 00:26 &#x2F;proc&#x2F;629&#x2F;fd&#x2F;1 -&gt; &#x2F;home&#x2F;kodango&#x2F;stdout</span><br><span class="line"></span><br><span class="line">$ exec 1&gt;&amp;3                   # 现在重新把标准输出重定向到之前备份的fd 3上</span><br><span class="line">$ ls &#x2F;proc&#x2F;629&#x2F;fd&#x2F;&#123;1,3&#125; -l  # 现在屏幕可以看到输出了，但是fd 3这个描述符还打开，需要关闭</span><br><span class="line">lrwx------ 1 kodango kodango 64 Nov 10 00:26 &#x2F;proc&#x2F;629&#x2F;fd&#x2F;1 -&gt; &#x2F;dev&#x2F;pts&#x2F;1</span><br><span class="line">lrwx------ 1 kodango kodango 64 Nov 10 00:26 &#x2F;proc&#x2F;629&#x2F;fd&#x2F;3 -&gt; &#x2F;dev&#x2F;pts&#x2F;1</span><br><span class="line"></span><br><span class="line">$ exec 3&gt;&amp;-                   # 关闭fd 3</span><br><span class="line">$ ls &#x2F;proc&#x2F;629&#x2F;fd&#x2F;3 -l</span><br><span class="line">ls: cannot access &#x2F;proc&#x2F;629&#x2F;fd&#x2F;3: No such file or directory</span><br><span class="line"></span><br><span class="line">$ cat stdout                  # 检查stdout文件，确实有之前被吃掉的输出</span><br><span class="line">l-wx------ 1 kodango kodango 64 Nov 10 00:26 &#x2F;proc&#x2F;629&#x2F;fd&#x2F;1 -&gt; &#x2F;home&#x2F;kodango&#x2F;stdout</span><br></pre></td></tr></table></figure><p>这一点在while read; do xxx; done &lt; file内部仍需要从标准输入读取内容时非常有用，此时必须要将循环外部的重定向和内部的剥离开来。</p><h3 id="8-引号之间的区别"><a href="#8-引号之间的区别" class="headerlink" title="8. 引号之间的区别"></a>8. 引号之间的区别</h3><p>Shell中比较让人抓狂的是各种引号的处理，其中，反引号(cmd)是最容易掌握的，它其实和$(cmd)是差不多的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">引号的作用有几点，一个是为了将多个因为空格或者回车等分隔符隔开的字符串合在一起，避免被命令行解析分开，例如&quot;one two three&quot;就是一整个字符串，而不是像one two three会被解析成三个单独的字符串；另外一方面，引号可以让一些特殊符号保持原义。</span><br><span class="line"></span><br><span class="line">其中，单引号的处理是比较简单的，被单引号包括的所有字符都保留原有的意思，例如&#39;$a&#39;不会被展开, &#39;cmd&#39;也不会执行命令；而双引号，则相对比较松，在双引号中，以下几个字符$, , \依然有其特殊的含义，比如$可以用于变量展开, 反引号可以执行命令，反斜杠可以用于转义。但是，在双引号包围的字符串里，反斜杠的转义也是有限的，它只能转义$, &#96;, &quot;, 或者newline（回车）这几个字符，后面如果跟着的不是这几个字符，只不会被黑底，反斜杠会被保留，例如：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ echo &quot;\$,\&quot;,\&#96;,\&#39;,\t&quot;</span><br><span class="line">$,&quot;,&#96;,\&#39;,\t</span><br></pre></td></tr></table></figure><p>到此为止，其实双引号和单引号的区别已经说得差不多了。不过还可以再说几个特殊的用法，前面说过可以在双引号内部使用单引号，你有想过在单引号里面使用单引号吗？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo &#39;\&#39;&#39;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>是不是发现不能用，因为单引号中反斜杠是没有转义的效果的，任何字符都没有特殊的含义。那就没有办法了吗？方法总是有的，可以在第一个单引号前面加个$符号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo $&#39;\&#39;&#39;</span><br><span class="line">&#39;</span><br></pre></td></tr></table></figure><h3 id="9-特殊用法-’string’"><a href="#9-特殊用法-’string’" class="headerlink" title="9. 特殊用法$’string’"></a>9. 特殊用法$’string’</h3><p>前面一点中已经介绍了 $’string’这种用法，比如 $’’’，之所以可以这样用，通俗地讲，就是在这种语法里一些转义字符串是被认可的，事实上有效地的转义底字符串列表可以看这里，例如b，’,n,f,nnn,xhh等等，是不是很熟悉。 $’string’的这个特性，其实为我们提供了一种很有用的技巧：</p><p>$ echo $’\x41’<br>A<br>他可以将ASCII对应的字符赋值给某个变量或者输出。</p><h3 id="10-用双引号比不用更加安全"><a href="#10-用双引号比不用更加安全" class="headerlink" title="10. 用双引号比不用更加安全"></a>10. 用双引号比不用更加安全</h3><p>双引号除了前面第10点讲到的去除特殊涵义的作用外，还可以避免字符串被分隔解析，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ echo &#96;ls -l&#96;</span><br><span class="line">total 4.0K -rw-r--r-- 1 kodango kodango 4 Nov 10 20:09 1 -rw-r--r-- 1 kodango kodango 0 Nov 10 20:09 2</span><br><span class="line">$ echo &quot;&#96;ls -l&#96;&quot;</span><br><span class="line">total 4.0K</span><br><span class="line">-rw-r--r-- 1 kodango kodango 4 Nov 10 20:09 1</span><br><span class="line">-rw-r--r-- 1 kodango kodango 0 Nov 10 20:09 2</span><br></pre></td></tr></table></figure><p>前者没有加双引号，ls -l输出行之间的回车就被吃掉了。原因是，当ls -l返回的结果传递给echo之前，会先被shell进行参数解析，而shell是用IFS定义的分隔符来分隔字符串的，一般包括n，所以它把解析后的结果再传递给echo，就成为echo “line 1….” “line 2…”这种形式了，结果就像上面一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">而用双引号包括起来可以避开字符串被拆开解析，因为shell认为它是一个单独的字符串。所以一般情况下，多用引号包括变量是好的，&quot;$var&quot;比$var更安全。</span><br></pre></td></tr></table></figure><h3 id="11-显示一个文件并且在每行开头添加行号"><a href="#11-显示一个文件并且在每行开头添加行号" class="headerlink" title="11. 显示一个文件并且在每行开头添加行号"></a>11. 显示一个文件并且在每行开头添加行号</h3><p>有两种做法，第一种借助cat和nl命令来完成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cat test.txt | nl</span><br><span class="line">     1    line 1 </span><br><span class="line">     2    line 2</span><br><span class="line">$ cat -n test.txt</span><br><span class="line">     1    line 1 </span><br><span class="line">     2    line 2</span><br><span class="line">$ nl test.txt     </span><br><span class="line">     1    line 1 </span><br><span class="line">     2    line 2</span><br></pre></td></tr></table></figure><p>另外一种做法是用sed命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed &#39;&#x3D;&#39; test.txt | sed &#39;N;s&#x2F;\n&#x2F;\t&#x2F;&#39;</span><br></pre></td></tr></table></figure><p>还有一种方法是通过cat -n或者cat -b命令，两者的区别是后者不会给空行增加行号,nl命令特别方便,而且空行没有行号;</p><h3 id="12-分别输出两个文件相同的行和不同的行"><a href="#12-分别输出两个文件相同的行和不同的行" class="headerlink" title="12. 分别输出两个文件相同的行和不同的行"></a>12. 分别输出两个文件相同的行和不同的行</h3><p>假设我们有以下两个文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ echo test&#123;,2&#125;.txt;paste test&#123;,2&#125;.txt</span><br><span class="line">test.txt test2.txt</span><br><span class="line">line 1     line 11</span><br><span class="line">line 2    line 2</span><br></pre></td></tr></table></figure><p>如果要输出两个文件之间相同的行，只有test.txt拥有的行以及只有test2.txt拥有的行，怎么做？首先可以使用grep -f：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ grep -f test&#123;,2&#125;.txt</span><br><span class="line">line 2</span><br><span class="line">$ grep -vf test&#123;,2&#125;.txt</span><br><span class="line">line 11</span><br><span class="line">$ grep -vf test&#123;2,&#125;.txt</span><br><span class="line">line 1</span><br></pre></td></tr></table></figure><p>还有一种选择是comm命令，这个命令就是专门用于比较文件的： comm - compare two sorted files line by line。 使用方法也很简单，comm比较两个排序好的文件返回的结果有三列，第一列是只有在文件A中有的行，第二列是只有在文件B中有的行，第三列则是两个文件共有的行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ comm test.txt test2.txt                </span><br><span class="line">line 1 </span><br><span class="line">    line 11</span><br><span class="line">        line 2</span><br></pre></td></tr></table></figure><p>要得到最初要求的结果，则只需要取相应的列就可以了。comm命令非常人性化地考虑到这个需求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ comm test.txt test2.txt -1 -2</span><br><span class="line">line 2</span><br><span class="line">$ comm test.txt test2.txt -2 -3</span><br><span class="line">line 1 </span><br><span class="line">$ comm test.txt test2.txt -1 -3</span><br><span class="line">line 11</span><br></pre></td></tr></table></figure><p>其中，=1, -2与-3这个参数分别表示不输出第1、2或者3列。</p><h3 id="13-获取被source的脚本的名称"><a href="#13-获取被source的脚本的名称" class="headerlink" title="13. 获取被source的脚本的名称"></a>13. 获取被source的脚本的名称</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一般的情况下，脚本的名称可以通过$0获取，但是这在被source导入的脚本中却不成立。假设A脚本中source了B脚本，那么它是把B的代码导入到A的环境中直接执行的，因此A和B的代码其实是在同一个执行环境下分不开的，B的代码中访问到的$0，甚至$1, $2等位置参数都是与A脚本是一致的。</span><br></pre></td></tr></table></figure><p>因此$0并非是被导入的脚本的名称，实际上，Bash将被source的脚本名称保存在一个叫BASH_SOURCE的数组中，该数组的第一个元素正是当前被source的脚本的名称。该变量与我在bash获取当前函数名中介绍的FUNCNAME是类似的，当一个脚本被source时，它的名称就被压入到这个数组的第一个位置上，举个实际的例子，假设有三个脚本a.sh,b.sh,c.sh，它们的内容如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ cat a.sh </span><br><span class="line">. .&#x2F;b.sh</span><br><span class="line">echo &quot;\$0&#x3D;$0&quot;</span><br><span class="line">echo &quot;\$&#123;BASH_SOURCE[0]&#125;&#x3D;$&#123;BASH_SOURCE[0]&#125;&quot;</span><br><span class="line">echo &quot;\$BASH_SOURCE&#x3D;($&#123;BASH_SOURCE[@]&#125;)&quot;</span><br><span class="line"></span><br><span class="line">$ cat b.sh </span><br><span class="line">. .&#x2F;c.sh</span><br><span class="line">. .&#x2F;c.sh</span><br><span class="line">echo &quot;\$0&#x3D;$0&quot;</span><br><span class="line">echo &quot;\$&#123;BASH_SOURCE[0]&#125;&#x3D;$&#123;BASH_SOURCE[0]&#125;&quot;</span><br><span class="line">echo &quot;\$BASH_SOURCE&#x3D;($&#123;BASH_SOURCE[@]&#125;)&quot;</span><br><span class="line"></span><br><span class="line">$ cat c.sh </span><br><span class="line">$ cat c.sh </span><br><span class="line">echo &quot;\$0&#x3D;$0&quot;</span><br><span class="line">echo &quot;\$&#123;BASH_SOURCE[0]&#125;&#x3D;$&#123;BASH_SOURCE[0]&#125;&quot;</span><br><span class="line">echo &quot;\$BASH_SOURCE&#x3D;($&#123;BASH_SOURCE[@]&#125;)&quot;</span><br></pre></td></tr></table></figure><p>现在执行a.sh这个脚本，实际的输出是（为了方便理解，我在实际的输出中加了一些注释和空行）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ bash a.sh</span><br><span class="line"># c.sh的输出</span><br><span class="line">$0&#x3D;a.sh</span><br><span class="line">$&#123;BASH_SOURCE[0]&#125;&#x3D;.&#x2F;c.sh</span><br><span class="line">$BASH_SOURCE&#x3D;(.&#x2F;c.sh .&#x2F;b.sh a.sh)</span><br><span class="line"></span><br><span class="line"># b.sh的输出</span><br><span class="line">$0&#x3D;a.sh</span><br><span class="line">$&#123;BASH_SOURCE[0]&#125;&#x3D;.&#x2F;b.sh</span><br><span class="line">$BASH_SOURCE&#x3D;(.&#x2F;b.sh a.sh)</span><br><span class="line"></span><br><span class="line"># a.sh的输出</span><br><span class="line">$0&#x3D;a.sh</span><br><span class="line">$&#123;BASH_SOURCE[0]&#125;&#x3D;a.sh</span><br><span class="line">$BASH_SOURCE&#x3D;(a.sh)</span><br></pre></td></tr></table></figure><p>此外，我们还可以利用BASH_SOURCE的值，在脚本中判断是被直接执行还是被导入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if [ -n &quot;$BASH_SOURCE&quot; -a &quot;$BASH_SOURCE&quot; !&#x3D; &quot;$0&quot; ]</span><br><span class="line">then</span><br><span class="line">    echo &quot;be sourced by other scripts&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;be run in shell&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h3 id="14-参数展开"><a href="#14-参数展开" class="headerlink" title="14. ${}参数展开"></a>14. ${}参数展开</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们知道$&#123;parameter&#125;是展开变量parameter这个值，在上一篇简洁的bash编程技巧中也曾经介绍过$&#123;parameter:-word&#125;这种用法，用于给变量赋一个默认值。 事实上除此之外，参数展开还有许多形式，在此之前，首先要说明一下变量的几种值的形式：</span><br></pre></td></tr></table></figure><p>unset： 变量未设置，即变量从未声明，或者被unset命令重置；<br>null: 变量声明但未被赋值（var=）或者被赋值成空（var=””）；<br>not null： 变量被赋值；<br>unset和null在参数展开的时候还是有很大的区别的，以下是参数展开的各种形式：</p><p>${parameter:-word}：假如parameter为unset或者null，则展开后返回word的值；<br>${parameter-word}：假如parameter为unset时，则展开后返回word的值;<br>${parameter:=word}：假如parameter为unset或者null，将word赋值给parameter；<br>${parameter=word}：假如parameter为unset，将word赋值给parameter；<br>${parameter:?word}：假如parameter为unset或者null，则将word作为错误输出到标准输出；<br>${parameter?word}：假如parameter为unset，则将word作为错误输出到标准输出；<br>${parameter:+word}：假如parameter为unset或者null，则不做展开，返回为空；（刚好与:-相反）<br>${parameter:word}：假如parameter为unset，则不做展开，返回为空；（刚好与-相反）<br>上面其实准确地应该是分成2组，一组带:，一组不带:，不带:的这组更加严格，只检查unset这种情况。以:+为例子, unset的情况均无返回：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ unset var &amp;&amp; echo $&#123;var:+hello&#125;</span><br><span class="line">$ unset var &amp;&amp; echo $&#123;var+hello&#125;</span><br></pre></td></tr></table></figure><p>当var为空时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ var&#x3D; &amp;&amp; echo &quot;$&#123;var:+hello&#125;&quot;</span><br><span class="line">$ var&#x3D; &amp;&amp; echo &quot;$&#123;var+hello&#125;&quot;</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><p>当var为非空时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ var&#x3D;1 &amp;&amp; echo &quot;$&#123;var:+hello&#125;&quot;</span><br><span class="line">hello</span><br><span class="line">$ var&#x3D;1 &amp;&amp; echo &quot;$&#123;var+hello&#125;&quot;</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><h3 id="15-冒号的多种使用场景"><a href="#15-冒号的多种使用场景" class="headerlink" title="15. 冒号的多种使用场景"></a>15. 冒号的多种使用场景</h3><p>冒号是一个比较奇怪的符号，它的用途有很多，这里介绍几种常用的：</p><ol><li>内置命令null command：nop，表示什么都不做，也可以被当作true值使用；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ :</span><br><span class="line">$ echo $?    # return 0</span><br></pre></td></tr></table></figure>它也可以在循环中当作true值，例如:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">while :; do   # 等价于 while true; do</span><br><span class="line">    take-some-action</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">if condition</span><br><span class="line">then :</span><br><span class="line">else </span><br><span class="line">    take-some-action</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li><li>占位符 冒号可以在很多场景下充当占位符，例如之前介绍的${parameter=var}，如果直接执行会报错，表示找不到命令；这时可以借用冒号来完成赋值：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">: $&#123;parameter&#x3D;var&#125;</span><br></pre></td></tr></table></figure>同样地，可以来判断变量是否赋值：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">: $&#123;parameter1?&#125; $&#123;parameter2?&#125;</span><br></pre></td></tr></table></figure><h3 id="16-扩展的括号展开功能"><a href="#16-扩展的括号展开功能" class="headerlink" title="16. 扩展的括号展开功能"></a>16. 扩展的括号展开功能</h3>这个功能不能说鸡肋，也可以了解下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ echo &#123;0..3&#125;</span><br><span class="line">0 1 2 3</span><br><span class="line">$ echo &#123;z..a&#125;</span><br><span class="line">z y x w v u t s r q p o n m l k j i h g f e d c b a</span><br><span class="line">$ echo &#123;a..z&#125;</span><br><span class="line">a b c d e f g h i j k l m n o p q r s t u v w x y z</span><br></pre></td></tr></table></figure><h3 id="17-安全的中括号"><a href="#17-安全的中括号" class="headerlink" title="17. 安全的中括号"></a>17. 安全的中括号</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[[]]的功能比[]更加多，使用起来也更加安全。</span><br><span class="line"></span><br><span class="line">1. 首先[[]]内部不会发生文件名展开和单词分隔。 例如：</span><br><span class="line"></span><br><span class="line">$ touch hello\ world</span><br><span class="line">$ [[ -f $file ]] &amp;&amp; echo yes</span><br><span class="line">yes</span><br><span class="line">$ [ -f $file ] &amp;&amp; echo yes</span><br><span class="line">-bash: [: hello: binary operator expected</span><br><span class="line"></span><br><span class="line">2. 进制之间自动转化 当一个十进制与八进制做比较时，会自动计算两个数的值，统一后做比较：</span><br><span class="line">$ o&#x3D;017</span><br><span class="line">$ h&#x3D;0x0f</span><br><span class="line">$ [[ $o -eq $h ]] &amp;&amp; echo yes</span><br><span class="line">yes</span><br><span class="line">$ [[ $o -eq 15 ]] &amp;&amp; echo yes</span><br><span class="line">yes</span><br><span class="line"></span><br><span class="line">3. [[]]支持&amp;&amp;，||等运算符</span><br><span class="line">$ a&#x3D;1;b&#x3D;3</span><br><span class="line">$ [[ $a &gt; 0 &amp;&amp; $b &lt; 4 ]] &amp;&amp; echo yes</span><br><span class="line">yes</span><br></pre></td></tr></table></figure><h3 id="18-获取Bash脚本的最后一个参数"><a href="#18-获取Bash脚本的最后一个参数" class="headerlink" title="18. 获取Bash脚本的最后一个参数"></a>18. 获取Bash脚本的最后一个参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们都知道可以用$0，$1等来获取传递给脚本或者函数的参数，也可以用$*或者$@获取所有的参数，但是如果我只想要获取最后一个参数呢？</span><br></pre></td></tr></table></figure>首先，你可能想到用遍历地方法（这里为了方便，我们使用set命令来设置位置参数）：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ set -- arg1 arg2 arg3</span><br><span class="line">$ for i in $@; do :; done</span><br><span class="line">$ echo $i</span><br><span class="line">arg3</span><br></pre></td></tr></table></figure>这里的循环什么事情都没做，我用冒号（:）完成这个任务；循环结束后, $i就是保存着最后一个参数的值。 下面是两种更加简单的方法的：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo $&#123;@: -1&#125;</span><br><span class="line">$ echo $&#123;!#&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">上面的第一种方法事实上就是Parameter Expansion中的$&#123;parameter:offset:length&#125;这种形式，只不过offset为-1表示最后一个元素，忽略length表明是从offset开始往后直到最后一个元素，即只取最后一个元素。这里要注意的一点是，在冒号和短横之间的空格不能少，否则就变成15. $&#123;&#125;参数展开中介绍的$&#123;parameter:-var&#125;这种用法了。</span><br><span class="line"></span><br><span class="line">而第二种方法则是indirect referencing的一种表现，#这个特殊的变量存放参数的个数，!#则是对最后一个变量的引用。</span><br></pre></td></tr></table></figure></li></ol><h3 id="19-Bash中的引用-indirect-referencing"><a href="#19-Bash中的引用-indirect-referencing" class="headerlink" title="19. Bash中的引用(indirect referencing)"></a>19. Bash中的引用(indirect referencing)</h3><p>有没有想法在Bash中也可以达到C++引用的效果？你可能不知道，但是你可能曾经有这种需求，我就有过：</p><p>有时候，我想要一个变量存放另外一个变量的名称，然后在后面我想通过这个变量的名称引用它的值<br>例子是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ a&#x3D;b</span><br><span class="line">$ b&#x3D;1</span><br><span class="line">$ echo $a</span><br><span class="line">b</span><br><span class="line">$ eval &quot;echo \$a&quot;</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>但是利用indirect referencing的用法，你可以这样获取b的值:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ echo $&#123;!a&#125;</span><br><span class="line">1</span><br><span class="line">$ b&#x3D;2</span><br><span class="line">$ echo $&#123;!a&#125;</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p><a href="https://yq.aliyun.com/articles/68540?spm=a2c4e.11153959.teamhomeleft.71.7e4c8bc1kg1JeI" target="_blank" rel="noopener"> 原文地址</a></p>]]></content>
    
    <summary type="html">
    
      简洁的Bash Programming技巧(三)
    
    </summary>
    
    
      <category term="SHELL" scheme="https://shuke163.github.io/categories/SHELL/"/>
    
    
      <category term="SHELL" scheme="https://shuke163.github.io/tags/SHELL/"/>
    
  </entry>
  
  <entry>
    <title> Mysql 表设计规范及开发</title>
    <link href="https://shuke163.github.io/2020/04/20/index/"/>
    <id>https://shuke163.github.io/2020/04/20/index/</id>
    <published>2020-04-20T07:59:37.000Z</published>
    <updated>2020-04-20T08:00:39.326Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mysql-规范"><a href="#Mysql-规范" class="headerlink" title="Mysql 规范"></a>Mysql 规范</h2><p>1.命名规范<br>(1)库名、表名、字段名必须使用小写字母,并采用下划线分割。</p><p>(2)库名、表名、字段名禁止超过32个字符。</p><p>(3)库名、表名、字段名必须见名知意。命名与业务、产品线等相关联。</p><p>(4)库名、表名、字段名禁止使用MySQL保留字。</p><p>(5)表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint（1 表示是， 0 表示否）</p><p>(6)表名不使用复数名词</p><p>(7)临时库、表名必须以tmp为前缀,并以日期为后缀。例如 tmp_test01_20130704。</p><p>(8)备份库、表必须以bak为前缀,并以日期为后缀。例如 bak_test01_20130704。</p><p>2.基础规范<br>(1)使用INNODB存储引擎。</p><p>(2)表字符集使用utf8字符集。如果要使用表情，那么使用 utf8mb4 来进行存储.</p><p>(3)所有表都需要添加注释;所有字段都需要增加注释。推荐采用英文标点,避免出现乱码。</p><p>(4)禁止在数据库中存储图片、文件等大数据。</p><p>(5)每张表数据量建议控制在5000W以内。</p><p>(6)禁止在线上做数据库压力测试。</p><p>(7)禁止从测试、开发环境直连生产数据库。</p><p>3.库表设计<br>(1)禁止使用分区表。</p><p>(2)将大字段、访问频率低的字段拆分到单独的表中存储,分离冷热数据。</p><p>(3)按日期时间分表需符合YYYY[MM][DD][HH]格式,例如2013071601。年份必须用4位数字表示。例如按日散表user_20110209、 按月散表user_201102。</p><p>(4)采用合适的分库分表策略。例如千库十表、十库百表等。</p><p>4.字段设计<br>(1)建议使用UNSIGNED存储非负数值。</p><p>(2)建议使用INT UNSIGNED存储IPV4。</p><p>(3)用DECIMAL代替FLOAT和DOUBLE存储精确浮点数。例如与货币、金融相关的数据。</p><p>(4)INT类型固定占用4字节存储,例如INT(4)仅代表显示字符宽度为4位,不代表存储长度。</p><p>(5)区分使用TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT数据类型。例如取值范围为0-80时,使用TINYINT UNSIGNED。</p><p>(6)强烈建议使用TINYINT来代替ENUM类型。</p><p>(7)尽可能不使用TEXT、BLOB类型。</p><p>(8)禁止在数据库中存储明文密码。</p><p>(9)使用VARBINARY存储大小写敏感的变长字符串或二进制内容。</p><p>(10)使用尽可能小的VARCHAR字段。VARCHAR(N)中的N表示字符数而非字节数。</p><p>(11)区分使用DATETIME和TIMESTAMP。存储年使用YEAR类型。存储日期使用DATE类型。 存储时间(精确到秒)建议使用TIMESTAMP类型。</p><p>(12)所有字段均定义为NOT NULL。</p><p>(13)字段允许适当冗余，以提高性能</p><p> 5.索引规范<br>(1)单张表中索引数量不超过5个。</p><p>(2)单个索引中的字段数不超过5个。</p><p>(3)索引名必须全部使用小写。</p><p>(4)非唯一索引按照“idx_字段名称[_字段名称]”进用行命名。例如idx_age_name。</p><p>(5)唯一索引按照“uniq_字段名称[_字段名称]”进用行命名。例如uniq_age_name。</p><p>(6)组合索引建议包含所有字段名,过长的字段名可以采用缩写形式。例如idx_age_name_add。</p><p>(7)表必须有主键,推荐使用UNSIGNED自增列作为主键。</p><p>(8)唯一键由3个以下字段组成,并且字段都是整形时,可使用唯一键作为主键。其他情况下,建议使用自增列或发号器作主键。</p><p>(9)禁止冗余索引。</p><p>(10)禁止重复索引。</p><p>(11)禁止使用外键。</p><p>(12)联表查询时,JOIN列的数据类型必须相同,并且要建立索引。</p><p>(13)不在低基数列上建立索引,例如“性别”。</p><p>(14)选择区分度大的列建立索引。组合索引中,区分度大的字段放在最前。</p><p>(15)对字符串使用前缀索引,前缀索引长度不超过8个字符。</p><p>(16)不对过长的VARCHAR字段建立索引。建议优先考虑前缀索引,或添加CRC32或MD5伪列并建立索引。</p><p>(17)合理创建联合索引,(a,b,c) 相当于 (a) 、(a,b) 、(a,b,c)。</p><p>(18)合理使用覆盖索引减少IO,避免排序。</p><p>6.SQL设计<br>(1)使用prepared statement,可以提升性能并避免SQL注入。</p><p>(2)使用IN代替OR。SQL语句中IN包含的值不应过多,应少于1000个。</p><p>(3)禁止隐式转换。数值类型禁止加引号;字符串类型必须加引号。</p><p>(4)避免使用JOIN和子查询。必要时推荐用JOIN代替子查询。超过3个表严禁join</p><p>(5)禁止在MySQL中进行数学运算和函数运算。</p><p>(6)减少与数据库交互次数,尽量采用批量SQL语句。</p><p>(7)拆分复杂SQL为多个小SQL,避免大事务。</p><p>(8)获取大量数据时,建议分批次获取数据,每次获取数据少于2000条,结果集应小于1M。</p><p>(9)使用UNION ALL代替UNION。</p><p>(10)统计行数使用COUNT(*)。</p><p>(11)SELECT只获取必要的字段,禁止使用SELECT *。</p><p>(12)SQL中避免出现now()、rand()、sysdate()、current_user()等不确定结果的函数。</p><p>13)INSERT语句必须指定字段列表,禁止使用 INSERT INTO TABLE()。</p><p>(14)禁止单条SQL语句同时更新多个表。</p><p>(15)禁止使用存储过程、触发器、视图、自定义函数等。</p><p>(16)建议使用合理的分页方式以提高分页效率。</p><p>(17)禁止在从库上执行后台管理和统计类功能的QUERY,必要时申请统计类从库。</p><p>(18)程序应有捕获SQL异常的处理机制,必要时通过rollback显式回滚。</p><p>(19)重要SQL必须被索引:update、delete的where条件列、order by、group by、distinct字段、多表join字段。</p><p>(20)禁止使用%前导查询,例如:like “%abc”,无法利用到索引。</p><p>(21)禁止使用负向查询,例如 not in、!=、not like。</p><p>(22)使用EXPLAIN判断SQL语句是否合理使用索引,尽量避免extra列出现:Using File Sort、Using Temporary。</p><p>(23)禁止使用order by rand()。</p><p>7.行为规范<br>(1)表结构变更必须通知DBA进行审核。</p><p>(2)禁止有super权限的应用程序账号存在。</p><p>(3)禁止有DDL、DCL权限的应用程序账号存在。</p><p>(4)重要项目的数据库方案选型和设计必须提前通知DBA参与。</p><p>(5)批量导入、导出数据必须通过DBA审核,并在执行过程中观察服务。</p><p>(6)批量更新数据,如UPDATE、DELETE操作,必须DBA进行审核,并在执行过程中观察服务。</p><p>(7)产品出现非数据库导致的故障时,如被攻击,必须及时通DBA,便于维护服务稳定。</p><p>(8)业务部门程序出现BUG等影响数据库服务的问题,必须及时通知DBA,便于维护服务稳定。</p><p>(9)业务部门推广活动或上线新功能,必须提前通知DBA进行服务和访问量评估,并留出必要时间以便DBA完成扩容。</p><p>(10)出现业务部门人为误操作导致数据丢失,需要恢复数据的,必须第一时间通知DBA,并提供准确时间点、 误操作语句等重要线索。</p><p>(11)提交线上建表改表需求,必须详细注明涉及到的所有SQL语句(包括INSERT、DELETE、UPDATE),便于DBA进⾏行审核和优化。</p><p>(12)对同一个表的多次alter操作必须合并为一次操作。</p><p>(13)不要在MySQL数据库中存放业务逻辑。</p><p>8.FAQ<br>1.库名、表名、字段名必须使用小写字母,并采用下划线分割。<br>a)MySQL有配置参数lower_case_table_names,不可动态更改,linux系统默认为 0,即库表名以实际情况存储,大小写敏感。如果是1,以小写存储,大小写不敏感。如果是2,以实际情况存储,但以小写比较。</p><p>b)如果大小写混合使用,可能存在abc,Abc,ABC等多个表共存,容易导致混乱。</p><p>c)字段名显式区分大小写,但实际使用不区分,即不可以建立两个名字一样但大小写不一样的字段。</p><p>d)为了统一规范, 库名、表名、字段名使用小写字母。</p><p>2.库名、表名、字段名禁止超过32个字符。<br>库名、表名、字段名支持最多64个字符,但为了统一规范、易于辨识以及减少传输量,禁止超过32个字符。 </p><p>3.使用INNODB存储引擎。<br>INNODB引擎是MySQL5.5版本以后的默认引擘,支持事务、行级锁,有更好的数据恢复能力、更好的并发性能,同时对多核、大内存、SSD等硬件支持更好,支持数据热备份等,因此INNODB相比MyISAM有明显优势。</p><p>4.库名、表名、字段名禁止使用MySQL保留字。<br>当库名、表名、字段名等属性含有保留字时,SQL语句必须用反引号引用属性名称,这将使得SQL语句书写、SHELL脚本中变量的转义等变得非常复杂。</p><p>5.禁止使用分区表。<br>分区表对分区键有严格要求;分区表在表变大后,执行DDL、SHARDING、单表恢复等都变得更加困难。因此禁止使用分区表,并建议业务端手动SHARDING。</p><p>6.建议使用UNSIGNED存储非负数值。<br>同样的字节数,非负存储的数值范围更大。如TINYINT有符号为 -128-127,无符号为0-255。</p><p>7.建议使用INT UNSIGNED存储IPV4。<br>UNSINGED INT存储IP地址占用4字节,CHAR(15)则占用15字节。另外,计算机处理整数类型比字符串类型快。使用INT UNSIGNED而不是CHAR(15)来存储IPV4地址,通过MySQL函数inet_ntoa和inet_aton来进行转化。IPv6地址目前没有转化函数,需要使用DECIMAL或两个BIGINT来存储。</p><p>例如:</p><p>SELECT INET_ATON(‘209.207.224.40’); 3520061480</p><p>SELECT INET_NTOA(3520061480); 209.207.224.40</p><p>8.强烈建议使用TINYINT来代替ENUM类型。<br>ENUM类型在需要修改或增加枚举值时,需要在线DDL,成本较大;ENUM列值如果含有数字类型,可能会引起默认值混淆。</p><p>9.使用VARBINARY存储大小写敏感的变长字符串或二进制内容。<br>VARBINARY默认区分大小写,没有字符集概念,速度快。</p><p>10.INT类型固定占用4字节存储,例如INT(4)仅代表显示字符宽度为4位,不代表存储长度。<br>数值类型括号后面的数字只是表示宽度而跟存储范围没有关系,比如INT(3)默认显示3位,空格补齐,超出时正常显示,python、java客户端等不具备这个功能。</p><p>11.区分使用DATETIME和TIMESTAMP。存储年使用YEAR类型。存储日期使用DATE类型。 存储时间(精确到秒)建议使用TIMESTAMP类型。<br>DATETIME和TIMESTAMP都是精确到秒,优先选择TIMESTAMP,因为TIMESTAMP只有4个字节,而DATETIME8个字节。同时TIMESTAMP具有自动赋值以及自动更新的特性。注意:在5.5和之前的版本中,如果一个表中有多个timestamp列,那么最多只能有一列能具有自动更新功能。</p><p>如何使用TIMESTAMP的自动赋值属性?<br>a)自动初始化,并自动更新: column1 TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP</p><p>b)只是自动初始化: column1 TIMESTAMP DEFAULT CURRENT_TIMESTAMP</p><p>c)自动更新,初始化的值为0: column1 TIMESTAMP DEFAULT 0 ON UPDATE CURRENT_TIMESTAMP</p><p>d)初始化的值为0: column1 TIMESTAMP DEFAULT 0</p><p>12.所有字段均定义为NOT NULL。<br>a)对表的每一行,每个为NULL的列都需要额外的空间来标识。</p><p>b)B树索引时不会存储NULL值,所以如果索引字段可以为NULL,索引效率会下降。</p><p>c)建议用0、特殊值或空串代替NULL值。</p><p>13.将大字段、访问频率低的字段拆分到单独的表中存储,分离冷热数据。<br>有利于有效利用缓存,防止读入无用的冷数据,较少磁盘IO,同时保证热数据常驻内存提高缓存命中率。 </p><p>14.禁止在数据库中存储明文密码。<br>采用加密字符串存储密码，并保证密码不可解密，同时采用随机字符串加盐保证密码安全。防止数据库数据被公司内部人员或黑客获取后，采用字典攻击等方式暴力破解用户密码。</p><p>15.表必须有主键,推荐使用UNSIGNED自增列作为主键。<br>表没有主键,INNODB会默认设置隐藏的主键列;没有主键的表在定位数据行的时候非常困难,也会降低基于行复制的效率。</p><p>16.禁止冗余索引。<br>索引是双刃剑,会增加维护负担,增大IO压力。(a,b,c)、(a,b),后者为冗余索引。可以利用前缀索引来达到加速目的,减轻维护负担。</p><p>17.禁止重复索引。<br>primary key a;uniq index a;重复索引增加维护负担、占用磁盘空间,同时没有任何益处。</p><p>18.不在低基数列上建立索引,例如“性别”。<br>大部分场景下,低基数列上建立索引的精确查找,相对于不建立索引的全表扫描没有任何优势,而且增大了IO负担。</p><p>19.合理使用覆盖索引减少IO,避免排序。<br>覆盖索引能从索引中获取需要的所有字段,从而避免回表进行二次查找,节省IO。INNODB存储引擎中, secondary index(非主键索引,又称为辅助索引、二级索引)没有直接存储行地址,而是存储主键值。如果用户需要查询secondary index中所不包含的数据列,则需要先通过secondary index查找到主键值,然后再通过主键查询到其他数据列,因此需要查询两次。覆盖索引则可以在一个索引中获取所有需要的数据,因此效率较高。主键查询是天然的覆盖索引。例如SELECT email,uid FROM user_email WHERE uid=xx,如果uid 不是主键,适当时候可以将索引添加为index(uid,email),以获得性能提升。</p><p>20.用IN代替OR。SQL语句中IN包含的值不应过多,应少于1000个。<br>IN是范围查找,MySQL内部会对IN的列表值进行排序后查找,比OR效率更高。</p><p>21.表字符集使用UTF8,必要时可申请使用UTF8MB4字符集。<br>a)UTF8字符集存储汉字占用3个字节,存储英文字符占用一个字节。</p><p>b)UTF8统一而且通用,不会出现转码出现乱码风险。</p><p>c)如果遇到EMOJ等表情符号的存储需求,可申请使用UTF8MB4字符集。</p><p>22.用UNION ALL代替UNION。<br>UNION ALL不需要对结果集再进行排序。</p><p>23.禁止使用order by rand()。<br>order by rand()会为表增加一个伪列,然后用rand()函数为每一行数据计算出rand()值,然后基于该行排序, 这通常都会生成磁盘上的临时表,因此效率非常低。建议先使用rand()函数获得随机的主键值,然后通过主键获取数据。</p><p>24.建议使用合理的分页方式以提高分页效率。<br>第一种分页写法：</p><p>select *<br>  from t<br> where thread_id = 771025<br>   and deleted = 0<br> order by gmt_create asc limit 0, 15;</p><p> 原理：一次性根据过滤条件取出所有字段进行排序返回。</p><p> 数据访问开销=索引IO+索引全部记录结果对应的表数据IO</p><p> 缺点：该种写法越翻到后面执行效率越差，时间越长，尤其表数据量很大的时候。</p><p>适用场景：当中间结果集很小（10000行以下）或者查询条件复杂（指涉及多个不同查询字段或者多表连接）时适用。</p><p>第二种分页写法：</p><p>select t.* from (</p><pre><code>select id from t where thread_id = 771025 and deleted = 0 order by gmt_create asc limit 0, 15) a, t </code></pre><p> where a.id = t.id;</p><p>前提：假设t表主键是id列，且有覆盖索引secondary key:(thread_id, deleted, gmt_create)</p><p>原理：先根据过滤条件利用覆盖索引取出主键id进行排序，再进行join操作取出其他字段。</p><p>数据访问开销=索引IO+索引分页后结果（例子中是15行）对应的表数据IO。</p><p>优点：每次翻页消耗的资源和时间都基本相同，就像翻第一页一样。</p><p>适用场景：当查询和排序字段（即where子句和order by子句涉及的字段）有对应覆盖索引时，且中间结果集很大的情况时适用。</p><p>25.SELECT只获取必要的字段,禁止使用SELECT *。<br>减少网络带宽消耗;</p><p>能有效利用覆盖索引;</p><p>表结构变更对程序基本无影响。</p><p>26.SQL中避免出现now()、rand()、sysdate()、current_user()等不确定结果的函数。<br>语句级复制场景下,引起主从数据不一致;不确定值的函数,产生的SQL语句无法利用QUERY CACHE。 </p><p>27.采用合适的分库分表策略。例如千库十表、十库百表等。<br>采用合适的分库分表策略,有利于业务发展后期快速对数据库进行水平拆分,同时分库可以有效利用MySQL的多线程复制特性。</p><p>28.减少与数据库交互次数,尽量采用批量SQL语句。<br>使用下面的语句来减少和db的交互次数:</p><p>a)INSERT … ON DUPLICATE KEY UPDATE</p><p>b)REPLACE INTO</p><p>c)INSERT IGNORE</p><p>d)INSERT INTO VALUES()</p><p>29.拆分复杂SQL为多个小SQL,避免大事务。<br>简单的SQL容易使用到MySQL的QUERY CACHE;减少锁表时间特别是MyISAM;可以使用多核CPU。</p><p>30.对同一个表的多次alter操作必须合并为一次操作。<br>mysql对表的修改绝大部分操作都需要锁表并重建表,而锁表则会对线上业务造成影响。为减少这种影响,必须把对表的多次alter操作合并为一次操作。例如,要给表t增加一个字段b,同时给已有的字段aa建立索引, 通常的做法分为两步:</p><p>alter table t add column b varchar(10);</p><p>然后增加索引:</p><p>alter table t add index idx_aa(aa);</p><p>正确的做法是:</p><p>alter table t add column b varchar(10),add index idx_aa(aa);</p><p>31.避免使用存储过程、触发器、视图、自定义函数等。<br>这些高级特性有性能问题,以及未知BUG较多。业务逻辑放到数据库会造成数据库的DDL、SCALE OUT、 SHARDING等变得更加困难。</p><p>32.禁止有super权限的应用程序账号存在。<br>安全第一。super权限会导致read only失效,导致较多诡异问题而且很难追踪。</p><p>33.提交线上建表改表需求,必须详细注明涉及到的所有SQL语句(包括INSERT、DELETE、UPDATE),便于DBA进行审核和优化。<br>并不只是SELECT语句需要用到索引。UPDATE、DELETE都需要先定位到数据才能执行变更。因此需要业务提供所有的SQL语句便于DBA审核。</p><p>34.不要在MySQL数据库中存放业务逻辑。<br>数据库是有状态的服务,变更复杂而且速度慢,如果把业务逻辑放到数据库中,将会限制业务的快速发展。建议把业务逻辑提前,放到前端或中间逻辑层,而把数据库作为存储层,实现逻辑与存储的分离。</p><h2 id="数据库开发规范"><a href="#数据库开发规范" class="headerlink" title="数据库开发规范"></a>数据库开发规范</h2><hr><p>建表栗子：</p><p>CREATE TABLE user (<br><code>id</code> bigint(11) NOT NULL AUTO_INCREMENT,<br><code>user_id</code> bigint(11) NOT NULL COMMENT ‘用户id<br>PRIMARY KEY (<code>id</code>),<br>UNIQUE KEY <code>ind_user_id</code> (<code>user_id</code>),<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=’网站用户基本信息’;</p><hr><p>inception强制限制</p><p>建表&amp;索引</p><p>1．表必须有主键，主键为ID,类型int 或者 bigint。<br>解读：<br>a,无主键的表，在row模式下主从延迟更高。<br>b,主键要选择较短的数据类型，Innodb引擎普通索引都会保存主键的值，主键小则索引小。</p><p>2, 建表时，列没有注释时报错。表没有注释时报错。</p><p>3, 禁止使用中文或者特殊字符或者SQL保留字。</p><p>4，不支持：分区表。仅支持字符集：utf8mb4,utf8。</p><p>5，单表索引个数不超过15个，复合索引列值不超过5个。</p><p>6，支持列设置字符集，支持列值为空。支持BLOB字段，不支持enum set bit。支持外键。（不建议使用BLOB, 不建议使用外键）</p><p>7，当char类型的长度大于36，就必须将其转换为VARCHAR。</p><p>8，timestamp设置为not null之后，默认值不能为’0000-00-00 00:00:00’。</p><p>9，id 为主键时，不能设置默认值</p><p>数据修改</p><p>1，数据修改禁止使用LIMIT，Order By，在DML语句中没有WHERE条件时，报错。</p><p>2，禁止单次修改超过1亿行。</p><p>3，drop truncate操作不支持。</p><p>4，delete需要写where条件。</p><hr><p>非强制，强烈建议。</p><ol><li>库，表，字段名称一律小写。下划线分隔。</li></ol><p>2．禁止使用procedure、view、trigger、Event。<br>解读：业务逻辑放到服务层相比procedure具备更好的扩展性，也降低DB的复杂度。Event显著增加数据库切换难度。</p><p>3．禁止使用BLOB。<br>解读：大文件，大照片，DB的读策略一般不缓存。</p><p>4，禁止使用外键。<br>解读：通过业务逻辑来解决主外键关系已经是主流了。</p><p>5．命名使用英文单词，避免拼音。表名称不能用双引号包含。<br>栗子：t_shiwu, t_foods。你看着选吧。</p><p>6.用DECIMAL代替FLOAT和DOUBLE存储精确浮点数。</p><ol start="7"><li><p>金额相关的数据类型建议设置为bigint，以分计算。<br>解读： 不同的标准计算出来的总金额可能不一致。这可是银子。</p></li><li><p>线上数据只保留固定周期的数据（例如：半年），超过10G的表强制归档。<br>解读：线上数据越少，突然导致的性能问题越少。</p></li></ol><p>9．每个表增加最后更新时间。<br>update_time timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT ‘最后更新时间’<br>解读：数据组要求做增量更新用，此字段也无需维护。</p><ol start="10"><li>新的应用访问DB请告之应用的功能，连接数，重要性等，降低因为缺乏沟通造成的潜在风险。<br>解读：新的mysql版本DBA会控制单用户默认连接数300，避免因程序bug导致的连接风暴。</li></ol><hr><p>性能规范</p><ol><li><p>只使用btree索引。<br>解读：简单，高效。</p></li><li><p>查询的字段建议创建索引。特别是在选择性高的列。<br>解读：SELECT、UPDATE、DELETE语句的WHERE条件列；2、多表JOIN的字段。</p></li><li><p>不在低基数列上建立索引，例如‘性别’。<br>解读：举个栗子：<br>0到100，索引查询1，选择度高，走索引。<br>100个人，50男，50女，选择度低，走索引性能比全表扫描更差，所以选择全表扫描。<br>全表扫描： 加载多个数据块到内存。<br>索引： 加载单个索引块，指针到数据块，加载数据块。</p></li></ol><p>4.避免冗余或重复索引。<br>解读：联合索引IX_a_b_c(a,b,c) 相当于 (a) 、(a,b) 、(a,b,c)，那么索引 (a) 、(a,b) 就是多余的。<br>但是不相当于(b)、（b,c）。</p><p>5.不使用SELECT *，只获取必要的字段。<br>解读：<br>消耗CPU和IO、消耗网络带宽；<br>无法使用覆盖索引。</p><p>6.避免数据类型不一致。<br>SELECT * FROM t WHERE id = ‘19’;<br>SELECT * FROM t WHERE id = 19;</p><p>8.禁止使用INSERT INTO t_xxx VALUES(xxx)，必须显示指定插入的列属性。<br>解读：容易在增加或者删除字段后出现程序BUG</p><p>9.禁止在WHERE条件的属性上使用函数或者表达式。<br>解读：SELECT uid FROM t_user WHERE from_unixtime(day)&gt;=’2017-02-15’ 会导致全表扫描<br>正确的写法是：SELECT uid FROM t_user WHERE day&gt;= unix_timestamp(‘2017-02-15 00:00:00’)</p><ol start="10"><li><p>别用函数在字段上，这样不走索引。<br>数字存储：<br>性能差：FROM_UNIXTIME(pay_time) &gt;= curdate()<br>性能好：pay_time &gt;= UNIX_TIMESTAMP(CURDATE())</p></li><li><p>关键性能点减少表关联，解耦。这样方便拆分。<br>栗子：<br>很多业务都是围绕用户来的，所有很多线上业务都用用户表关联。长此以往，系统就变的不可拆分，而且臃肿。<br>正确的姿势因为是从接口获取用户数据，这样就没有强制的关联关系，方便业务拆分和扩展。</p></li></ol><hr>]]></content>
    
    <summary type="html">
    
       Mysql 表设计规范及开发
    
    </summary>
    
    
      <category term="MySQL" scheme="https://shuke163.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://shuke163.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>简洁的Bash Programming技巧(二)</title>
    <link href="https://shuke163.github.io/2020/04/20/index/"/>
    <id>https://shuke163.github.io/2020/04/20/index/</id>
    <published>2020-04-20T07:58:57.000Z</published>
    <updated>2020-04-20T07:59:11.287Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简洁的Bash-Programming技巧-三"><a href="#简洁的Bash-Programming技巧-三" class="headerlink" title="简洁的Bash Programming技巧(三)"></a>简洁的Bash Programming技巧(三)</h2><p>这一系列的文章专门介绍 Bash 编程中一些简洁的技巧，帮助大家提高平时 Bash 编程的效率。</p><h3 id="1-替换语法-parameter-pattern-string-的妙用"><a href="#1-替换语法-parameter-pattern-string-的妙用" class="headerlink" title="1. 替换语法${parameter/pattern/string}的妙用"></a>1. 替换语法${parameter/pattern/string}的妙用</h3><p>${parameter/pattern/string}将parameter中匹配pattern的部分替换成string，例如下面的例子将字符串中的e替换成x：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ str&#x3D;&quot;three&quot;</span><br><span class="line">$ echo &quot;$&#123;str&#x2F;e&#x2F;x&#125;&quot;</span><br><span class="line">thrxe</span><br></pre></td></tr></table></figure><p>如果pattern部分以/开头，表示替换parameter中所有匹配的内容，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ str&#x3D;&quot;three&quot;</span><br><span class="line">$ echo &quot;$&#123;str&#x2F;&#x2F;e&#x2F;x&#125;&quot;  # thrxx</span><br></pre></td></tr></table></figure><p>如果pattern部分以#开头，表示仅当parameter开始处匹配pattern的时候替换，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str&#x3D;&quot;three&quot;</span><br><span class="line">$ echo &quot;$&#123;str&#x2F;#e&#x2F;x&#125;&quot; # three</span><br><span class="line">$ echo &quot;$&#123;str&#x2F;#t&#x2F;x&#125;&quot; # xhree</span><br></pre></td></tr></table></figure><p>与此对应地是，如果pattern部分以%开头，表示仅当parameter结尾处匹配pattern的时候替换，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ str&#x3D;&quot;three&quot;</span><br><span class="line">$ echo &quot;$&#123;str&#x2F;%e&#x2F;x&#125;&quot; # threx</span><br></pre></td></tr></table></figure><p>如果string部分为空，匹配pattern的部分被删除（替换为空），例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ str&#x3D;&quot;three&quot;</span><br><span class="line">$ echo &quot;$&#123;str&#x2F;h&#x2F;&#125;&quot;  # tree</span><br></pre></td></tr></table></figure><p>这个时候第二个斜杠可以删除，即：echo “${str/h}” 如果parameter是一个数组会怎么样呢？有兴趣的可以看看Bash的man手册说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man -P &#39;less -p &quot;\\$\&#123;parameter&#x2F;pattern&#x2F;string&#125;&quot;&#39; bash</span><br></pre></td></tr></table></figure><h3 id="2-运算符"><a href="#2-运算符" class="headerlink" title="2. +=运算符"></a>2. +=运算符</h3><p>有一天，我看到这样一个用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ arr&#x3D;(1 2 3)</span><br><span class="line">$ arr+&#x3D;(4 5)</span><br></pre></td></tr></table></figure><p>原来数组还可以这样相加，后来我看了下Bash的手册，确实有一段这么说明的，这里未引用这段文字，有兴趣的可以查看<a href="http://www.gnu.org/software/bash/manual/bashref.html?spm=a2c4e.11153959.blogcont68524.12.4dbf3d2foIG0jZ#Shell-Parameters" target="_blank" rel="noopener">Bash Reference Manual</a> 自然地我们会想到如果一个变量是数字，是否也可以用+=作运算呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ i&#x3D;1</span><br><span class="line">$ i+&#x3D;1</span><br></pre></td></tr></table></figure><p>但是，运行后你会发现i的结果并不为2，而是11，这里bash并不认为i是一个整数，而是作为字符串。 这时可以通过declare声明一个变量为整数，上面的问题就解决了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ declare -i int&#x3D;1</span><br><span class="line">$ int+&#x3D;1</span><br><span class="line">$ echo $int</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="3-Here-document不为人知的用法"><a href="#3-Here-document不为人知的用法" class="headerlink" title="3. Here document不为人知的用法"></a>3. Here document不为人知的用法</h3><p>Shell学得越多，越会发现一些神奇的用法，每天都觉得自己实在是一个刚入门的菜鸟。</p><ol><li>Here Document 是在Linux Shell 中的一种特殊的重定向方式，它的基本的形式如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cmd &lt;&lt; delimiter</span><br><span class="line">  Here Document Content</span><br><span class="line">delimiter</span><br></pre></td></tr></table></figure>它的作用就是将两个 delimiter 之间的内容(Here Document Content 部分) 传递给cmd 作为输入参数。</li><li>比如在终端中输入cat &lt;&lt; EOF ，系统会提示继续进行输入，输入多行信息再输入EOF，中间输入的信息将会显示在屏幕上。如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cat &lt;&lt; EOF</span><br><span class="line">&gt;  First Line</span><br><span class="line">&gt; Second Line</span><br><span class="line">&gt; Third Line EOF</span><br><span class="line">&gt; EOF</span><br><span class="line"> First Line</span><br><span class="line">Second Line</span><br><span class="line">Third Line EOF</span><br></pre></td></tr></table></figure>注⚠️： &gt;这个符号是终端产生的提示输入信息的标识符<br>这里要注意几点</li><li>EOF 只是一个标识而已，可以替换成任意的合法字符</li><li>作为结尾的delimiter一定要顶格写，前面不能有任何字符</li><li>作为结尾的delimiter后面也不能有任何的字符（包括空格）</li><li>作为起始的delimiter前后的空格会被省略掉<br>Here Document 不仅可以在终端上使用，在shell 文件中也可以使用，例如下面的here.sh 文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt; EOF &gt; output.sh</span><br><span class="line">echo &quot;hello&quot;</span><br><span class="line">echo &quot;world&quot;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>使用 bash here.sh 运行这个脚本文件，会得到output.sh 这个新文件，里面的内容如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;hello&quot;</span><br><span class="line">echo &quot;world&quot;</span><br></pre></td></tr></table></figure></li><li>delimiter 与变量<br>在Here Document 的内容中，不仅可以包括普通的字符，还可以在里面使用变量,例如将上面的here.sh改为<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cat here.sh</span><br><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">cat &lt;&lt; EOF &gt; output.sh  #没有引号</span><br><span class="line">echo &quot;hello, $USER&quot;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">$ bash here.sh</span><br><span class="line">$ cat output.sh</span><br><span class="line">echo &quot;hello, shuke&quot;</span><br></pre></td></tr></table></figure>使用bash here.sh HereDocument 运行脚本得到output.sh的内容<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat output.sh</span><br><span class="line">echo &quot;hello $USER&quot;</span><br></pre></td></tr></table></figure>在这里 $1 被展开成为了脚本的参数 HereDocument<br>但是有时候不想展开这个变量怎么办呢，可以通过在起始的 delimiter的前后添加 “ 来实现,将EOF有引号括起来就可以：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cat here.sh</span><br><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">cat &lt;&lt; &quot;EOF&quot;     #注意引号</span><br><span class="line">echo &quot;hello, $USER&quot;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">$ bash here.sh</span><br><span class="line">echo &quot;hello, $USER&quot;</span><br></pre></td></tr></table></figure><h3 id="4-«-变为-«"><a href="#4-«-变为-«" class="headerlink" title="4. « 变为 «-"></a>4. « 变为 «-</h3>Here Document 还有一个用法就是将 ‘«’ 变为 ‘«-‘。 使用 &lt;&lt;- 的唯一变化就是Here Document 的内容部分每行前面的 tab (制表符)将会被删除掉，这种用法是为了编写Here Document的时候可以将内容部分进行缩进，方便阅读代码.<br>如果你有强迫症，有时候使用here document的时候会很不爽，因为here document里面每行首部的空格都会被保留，而如果要顶格写，在缩进的地方又会有点打乱结构，例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ cat b.sh</span><br><span class="line"># part 1</span><br><span class="line">if :; then</span><br><span class="line">    cat &lt;&lt; EOF</span><br><span class="line">    hello, $USER    </span><br><span class="line">EOF</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># part 2</span><br><span class="line">if :; then</span><br><span class="line">    if :; then</span><br><span class="line">        cat &lt;&lt; EOF</span><br><span class="line">hello, $USER    </span><br><span class="line">EOF</span><br><span class="line">    fi</span><br></pre></td></tr></table></figure>上面的脚本执行的结果为：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sh b.sh </span><br><span class="line">    hello, kodango   # part 1 result</span><br><span class="line">hello, kodango       # part 2 result</span><br></pre></td></tr></table></figure>有没有办法既兼顾到缩进又能不保留行首空格呢？</li></ol><p>答案也是肯定的，只不过语法又要稍稍变一下，现在在&lt;&lt;的后面加一个短横，这个用法下，行首的Tab字符都会被忽略:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cat b.sh </span><br><span class="line">if :; then</span><br><span class="line">    cat &lt;&lt;- EOF</span><br><span class="line">    hello, $USER    </span><br><span class="line">EOF</span><br><span class="line">fi</span><br><span class="line">$ sh b.sh </span><br><span class="line">hello, shuke</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>一定要是Tab键哦，空格也是不可以的，在vim里面还要注意如果设置了smarttab选项，行首插入的Tab键会替换成相应个数的空格(这里可以按ctrl+v tab插入实际的空格)</p><h3 id="5-使用内置命令declare显示脚本中定义的函数"><a href="#5-使用内置命令declare显示脚本中定义的函数" class="headerlink" title="5. 使用内置命令declare显示脚本中定义的函数"></a>5. 使用内置命令declare显示脚本中定义的函数</h3><p>declare的-F选项可以列出脚本中定义的函数名称：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ cat fun.sh</span><br><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function one()</span><br><span class="line">&#123;</span><br><span class="line">    :</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function two()</span><br><span class="line">&#123;</span><br><span class="line">    :</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">declare -F | sed &#39;s&#x2F;declare -f &#x2F;&#x2F;&#39;</span><br><span class="line">shuke@MacBooKPro:&#x2F;tmp</span><br><span class="line">$ bash fun.sh</span><br><span class="line">one</span><br><span class="line">two</span><br></pre></td></tr></table></figure><h3 id="6-嵌套函数还可以这么用"><a href="#6-嵌套函数还可以这么用" class="headerlink" title="6. 嵌套函数还可以这么用"></a>6. 嵌套函数还可以这么用</h3><p>Bash中可以嵌套函数定义，即在一个函数中定义另外一个函数，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ cat fun.sh</span><br><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">function out()</span><br><span class="line">&#123;</span><br><span class="line">    echo &quot;out&quot;</span><br><span class="line"></span><br><span class="line">    function inner() &#123;</span><br><span class="line">        echo &quot;inner&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">inner</span><br><span class="line">out</span><br><span class="line">inner</span><br></pre></td></tr></table></figure><p>这里out函数里面定义了inner函数，形成嵌套函数。但是，执行上面的例子会出错（nest.sh: line 12: inner: command not found），这是因为这是后inner函数还没定义。一旦out函数执行之后，inner函数就被定义了。整个例子的执行结果是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ bash fun.sh</span><br><span class="line">fun.sh: line 13: inner: command not found</span><br><span class="line">out</span><br><span class="line">inner</span><br></pre></td></tr></table></figure><p>看到这里，你可能会想嵌套函数有什么用？事实上，在大多数情况下，我们基本不会用到嵌套函数。但是它并非一无是处，比如下面的例子就向我们展示了嵌套函数的神奇用法。</p><p>假设，我们要定义一个调试函数，同时需要一个开关控制该函数是否输出调试日志，最简单的写法是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function log()</span><br><span class="line">&#123;</span><br><span class="line">    if [ &quot;$verbose&quot; &#x3D; &quot;1&quot; ]; then</span><br><span class="line">        echo &quot;$@&quot;</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它可以完成任务，但是唯一美中不足的是，每次调用该函数都要判断verbose的值是否为1。这时候可以使用嵌套函数来弥补这个不足：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">$ cat fun.sh</span><br><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">verbose&#x3D;$&#123;1:-1&#125;</span><br><span class="line"></span><br><span class="line">function log()</span><br><span class="line">&#123;</span><br><span class="line">    if [ $verbose -eq 1 ]; then</span><br><span class="line">        function log() &#123;</span><br><span class="line">            echo &quot;$@&quot;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        echo &quot;$@&quot;</span><br><span class="line">    else</span><br><span class="line">        function log() &#123;</span><br><span class="line">            :</span><br><span class="line">        &#125;</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log what is your name</span><br><span class="line">log my name is shuke</span><br><span class="line"></span><br><span class="line">$ bash fun.sh</span><br><span class="line">what is your name</span><br><span class="line">my name is shuke</span><br></pre></td></tr></table></figure><p>上面的例子中，根据verbose的值定义了两个同名的log函数来覆盖之前的旧函数，以后调用的函数就都是后定义的函数了。</p><h3 id="7-删除ps-auxf-grep-python结果中的grep进程"><a href="#7-删除ps-auxf-grep-python结果中的grep进程" class="headerlink" title="7. 删除ps auxf | grep python结果中的grep进程"></a>7. 删除ps auxf | grep python结果中的grep进程</h3><p>在shell脚本中，经常需要利用ps和grep命令一起在查找进程相关的信息，尤其是针对python/java/shell等脚本进程，因为pidof本身不大支持查找脚本进程对应的pid。</p><p>在用ps auxf | grep python的时候，一个很恼人的事情是，经常会出现多余的grep进程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ps aux | grep python</span><br><span class="line">shuke            76718   0.1  0.5  4341192  42404 s001  S+   12:52下午   0:01.32 &#x2F;Users&#x2F;zhao&#x2F;anaconda3&#x2F;envs&#x2F;sloth&#x2F;bin&#x2F;python manage.py runserver 8000</span><br><span class="line">shuke            76732   0.0  0.0  4284136    884 s003  S+   12:53下午   0:00.00 grep python</span><br><span class="line">shuke            76716   0.0  0.4  4329332  32936 s001  S+   12:52下午   0:00.68 python manage.py runserver 8000</span><br></pre></td></tr></table></figure><p>所以我们需要再加一个grep -v grep来排除它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ps aux | grep python | grep -v grep</span><br><span class="line">shuke            76718   0.1  0.5  4341192  42404 s001  R+   12:52下午   0:02.13 &#x2F;Users&#x2F;zhao&#x2F;anaconda3&#x2F;envs&#x2F;sloth&#x2F;bin&#x2F;python manage.py runserver 8000</span><br><span class="line">shuke            76716   0.0  0.4  4329332  32936 s001  S+   12:52下午   0:00.68 python manage.py runserver 8000</span><br></pre></td></tr></table></figure><p>还有一个解决方法是巧用正则表达式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ps aux | grep [p]ython</span><br><span class="line">shuke            76718   0.5  0.5  4341192  42412 s001  S+   12:52下午   0:03.58 &#x2F;Users&#x2F;zhao&#x2F;anaconda3&#x2F;envs&#x2F;sloth&#x2F;bin&#x2F;python manage.py runserver 8000</span><br><span class="line">shuke            76716   0.0  0.4  4329332  32936 s001  S+   12:52下午   0:00.68 python manage.py runserver 8000</span><br></pre></td></tr></table></figure><p> 一个很好的解释: shell在执行以上命令的时候，其实创建了一个管道，并且fork了两个子进程：ps auxf与grep python，并且将管道读的这一端绑定到grep的标准输入，管道写的这一段绑定到ps的标准输出。ps将自己的输出写到管道，grep从管道中读取输入。可能在这个时候，ps与grep是同时执行的，所以ps的结果中也会包含grep进程的信息。</p><h3 id="8-Shell如何实现timeout功能"><a href="#8-Shell如何实现timeout功能" class="headerlink" title="8. Shell如何实现timeout功能"></a>8. Shell如何实现timeout功能</h3><p> 有时候我们不希望某个命令执行太久，所以如果在给定的时间内没有完成，能够杀掉这个命令对应的进程，这就是timeout功能，可惜bash没有提供该功能。所以就得我们自己来实现。</p><p>实现代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function timeout()</span><br><span class="line">&#123;</span><br><span class="line">    local time cmd pid</span><br><span class="line"></span><br><span class="line">    if echo &quot;$1&quot; | grep -Eq &#39;^[0-9]+&#39;; then</span><br><span class="line">        time&#x3D;$1</span><br><span class="line">        shift &amp;&amp; cmd&#x3D;&quot;$@&quot;</span><br><span class="line">    else</span><br><span class="line">        time&#x3D;5</span><br><span class="line">        cmd&#x3D;&quot;$@&quot;</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    $cmd &amp;</span><br><span class="line">    pid&#x3D;$!</span><br><span class="line"></span><br><span class="line">    while kill -0 $pid &amp;&gt;&#x2F;dev&#x2F;null; do</span><br><span class="line">        sleep 1</span><br><span class="line">        let time-&#x3D;1</span><br><span class="line"></span><br><span class="line">        if [ &quot;$time&quot; &#x3D; &quot;0&quot; ]; then</span><br><span class="line">            kill -9 $pid &amp;&gt;&#x2F;dev&#x2F;null</span><br><span class="line">            wait $pid &amp;&gt;&#x2F;dev&#x2F;null</span><br><span class="line">        fi</span><br><span class="line">    done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设有一个测试脚本,内容如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat sleep.sh</span><br><span class="line">echo &quot;sleep $1 seconds&quot;</span><br><span class="line">sleep $1</span><br><span class="line">echo &quot;awake from sleep&quot;</span><br></pre></td></tr></table></figure><p>现在利用我们写的timeout函数来达到超时kill功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ time bash timeout.sh 2 &#39;sh sleep.sh 100&#39;</span><br><span class="line">sleep 100 seconds</span><br><span class="line"></span><br><span class="line">real    0m2.005s</span><br><span class="line">user    0m0.002s</span><br><span class="line">sys    0m0.001s</span><br></pre></td></tr></table></figure><p>看最终执行的时间，差不多就是2秒钟。<br>上面timeout函数实现的代码中，利用了两个技巧：</p><ol><li>kill -0 $pid：发送信号0给进程，可以检查进程是否存活，如果进程不存在或者没有权限，则返回错误，错误码为1；</li><li>wait $pid &amp;&gt;/dev/null：等待某个进程退出返回，这样相对比较优雅，同时将错误重定向到黑洞，从而隐藏后台进程被kill的错误输出；<h3 id="9-利用-etc-inittab实现watchdog"><a href="#9-利用-etc-inittab实现watchdog" class="headerlink" title="9. 利用/etc/inittab实现watchdog"></a>9. 利用/etc/inittab实现watchdog</h3>还在为实现watch dog而头疼吗，其实inittab中已经包含了该功能。可以将自己的脚本或者程序写到inittab文件中：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tt:2345:respawn:&#x2F;home&#x2F;kodango&#x2F;sleep.sh 100</span><br></pre></td></tr></table></figure>然后执行telinit q使其生效，ps看下该脚本是否已经在运行了，尝试kill后，又会被起起来。</li></ol><h3 id="10-慎用波浪号展开"><a href="#10-慎用波浪号展开" class="headerlink" title="10. 慎用波浪号展开"></a>10. 慎用波浪号展开</h3><p>在shell中对比下面两种用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ home1&#x3D;~shuke</span><br><span class="line">$ home2&#x3D;&quot;~shuke&quot;</span><br><span class="line">$ echo -e &quot;$home1\n$home2&quot;</span><br><span class="line">&#x2F;Users&#x2F;zhao</span><br><span class="line">~shuke</span><br></pre></td></tr></table></figure><p>第一个变量赋值，波浪号正确展开，所以我们得到了kodango用户的家目录地址；第二个变量，我们使用了双引号，这个时候波波浪号并没有展开。这是一个比较容易出错的地方。</p><p>还有一点要注意的地方是，波浪号展开只在:或者=号后面才会执行。所以：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ path&#x3D;1~shuke</span><br><span class="line">$ echo &quot;$path&quot;</span><br><span class="line">1~shuke</span><br><span class="line"></span><br><span class="line">$ path&#x3D;1:~shuke</span><br><span class="line">$ echo &quot;$path&quot;</span><br><span class="line">1:&#x2F;Users&#x2F;shuke</span><br></pre></td></tr></table></figure><p>为什么要在:后面也可以展开呢？想想PATH的定义吧。</p><h3 id="11-pushd-popd"><a href="#11-pushd-popd" class="headerlink" title="11. pushd/popd"></a>11. pushd/popd</h3><p>这个在脚本中非常好用，特别是在循环中<br>如下所示，假设你正在写一个进入退出文件夹的for循环：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">for d1 in $(ls -d *&#x2F;)</span><br><span class="line">do</span><br><span class="line"> # Store original working directory.</span><br><span class="line"> original_wd&#x3D;&quot;$(pwd)&quot;</span><br><span class="line"> cd &quot;$d1&quot;</span><br><span class="line"> for d2 in $(ls -d *&#x2F;)</span><br><span class="line"> do</span><br><span class="line">   pushd &quot;$d2&quot;</span><br><span class="line">   # Do something</span><br><span class="line">   popd</span><br><span class="line"> done</span><br><span class="line"> # Return to original working directory</span><br><span class="line"> cd &quot;$&#123;original_wd&#125;&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>你可以像这样使用pushd栈来重写上方代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">for d1 in $(ls -d *)</span><br><span class="line">do</span><br><span class="line"> pushd &quot;$d1&quot;</span><br><span class="line"> for d2 in $(ls  -d *&#x2F;)</span><br><span class="line"> do</span><br><span class="line">   pushd &quot;$d2&quot;</span><br><span class="line">   # Do something</span><br><span class="line">   popd</span><br><span class="line"> done</span><br><span class="line"> popd</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>它可以追踪记录你切换的目录并进行入栈或出栈<br>注意，当使用pushd出现错误时，可能会丢失栈的记录并且popd多次。因此你可能会想要在脚本中使用set -e（见上一篇文章）</p><p>当然也可以用cd -，但是它不会使用栈——仅仅返回前一个目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">cd &#x2F;tmp</span><br><span class="line">cd blah</span><br><span class="line">cd - # Back to &#x2F;tmp</span><br><span class="line">cd - # Back to &#39;blah&#39;</span><br><span class="line">cd - # Back to &#x2F;tmp</span><br><span class="line">cd - # Back to &#39;blah&#39; ...</span><br></pre></td></tr></table></figure><h3 id="12-shopt-vs-set"><a href="#12-shopt-vs-set" class="headerlink" title="12.shopt vs set"></a>12.shopt vs set</h3><p>这两个命令困扰了我一阵子。<br>两者之间有什么不同呢？<br>set在之前的文章已经介绍过了，而shopt看起来与之相似。只输入shopt会显示一系列选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ shopt</span><br><span class="line">cdable_vars    off</span><br><span class="line">cdspell        on</span><br><span class="line">checkhash      off</span><br><span class="line">checkwinsize   on</span><br><span class="line">cmdhist        on</span><br><span class="line">compat31       off</span><br><span class="line">dotglob        off</span><br></pre></td></tr></table></figure><p>从根本上说，似乎有一系列的bash（和其他shells）建立在sh之上，而添加shopt命令则为设置额外的shell选项提供了一种方式</p><h3 id="13-Here-Docs-与-Here-Strings"><a href="#13-Here-Docs-与-Here-Strings" class="headerlink" title="13. Here Docs 与 Here Strings"></a>13. Here Docs 与 Here Strings</h3><p>“Here Docs”是在shell中用一些语句创建的文件。</p><p>“诀窍”很简单。定义一个用于结束的单词，则在这个单词单独出现在一行之前的所有输入行将构成文件。</p><p>像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cat &gt; afile &lt;&lt; SOMEENDSTRING</span><br><span class="line">&gt; here is a doc</span><br><span class="line">&gt; it has three lines</span><br><span class="line">&gt; SOMEENDSTRING alone on a line will save the doc</span><br><span class="line">&gt; SOMEENDSTRING</span><br><span class="line">$ cat afile</span><br><span class="line">here is a doc</span><br><span class="line">it has three lines</span><br><span class="line">SOMEENDSTRING alone on a line will save the doc</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>如果结束单词不是“单独”出现在一行中，那它可以构成文件</li><li>SOMEENDSTRING通常是END，但这仅仅只是习惯<br>更鲜为人知的是”here string”:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat &gt; asd &lt;&lt;&lt; &#39;This file has one line&#39;</span><br></pre></td></tr></table></figure></li></ul><h3 id="14-字符串变量的操作"><a href="#14-字符串变量的操作" class="headerlink" title="14. 字符串变量的操作"></a>14. 字符串变量的操作</h3><p>以前你可能是像下面展示的那样写代码，用sed一类的工具来操作字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ VAR&#x3D;&#39;HEADERMy voice is my passwordFOOTER&#39;</span><br><span class="line">$ PASS&#x3D;&quot;$(echo $VAR | sed &#39;s&#x2F;^HEADER(.*)FOOTER&#x2F;1&#x2F;&#39;)&quot;</span><br><span class="line">$ echo $PASS</span><br></pre></td></tr></table></figure><p>但是你可能不知道bash本身也是可以的。<br>这意味着你可以省去大量的sed和awk。<br>一种重写上述代码的方式如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ VAR&#x3D;&#39;HEADERMy voice is my passwordFOOTER&#39;</span><br><span class="line">$ PASS&#x3D;&quot;$&#123;VAR#HEADER&#125;&quot;</span><br><span class="line">$ PASS&#x3D;&quot;$&#123;PASS%FOOTER&#125;&quot;</span><br><span class="line">$ echo $PASS</span><br></pre></td></tr></table></figure><ul><li>#表示”从字符串开头开始匹配并删除所给的模式串”</li><li>%表示”从字符串结尾开始匹配并删除所给的模式串”</li></ul><p>在我的电脑上，后一种方法比前一种快两倍。并且(令我吃惊的是),他的速度跟类似功能的python脚本速度大致相当<br>如果你想使用通配符（见前文）模式串并采用贪婪模式，你需要双写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ VAR&#x3D;&#39;HEADERMy voice is my passwordFOOTER&#39;</span><br><span class="line">$ echo $&#123;VAR##HEADER*&#125;</span><br><span class="line">$ echo $&#123;VAR%%*FOOTER&#125;</span><br></pre></td></tr></table></figure><h3 id="15-变量的默认值"><a href="#15-变量的默认值" class="headerlink" title="15.变量的默认值"></a>15.变量的默认值</h3><p>这些对写脚本来说非常好用。<br>如果你有一个没有赋值的变量，你可以像这样给它“赋默认值”<br>创建一个default.sh文件，写入如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">FIRST_ARG&#x3D;&quot;$&#123;1:-no_first_arg&#125;&quot;</span><br><span class="line">SECOND_ARG&#x3D;&quot;$&#123;2:-no_second_arg&#125;&quot;</span><br><span class="line">THIRD_ARG&#x3D;&quot;$&#123;3:-no_third_arg&#125;&quot;</span><br><span class="line">echo $&#123;FIRST_ARG&#125;</span><br><span class="line">echo $&#123;SECOND_ARG&#125;</span><br><span class="line">echo $&#123;THIRD_ARG&#125;</span><br></pre></td></tr></table></figure><p>现在执行chmod +x default.sh并用./default.sh first second来运行脚本：<br>观察第三个参数的默认值是如何被分配的，而不是前两个。<br>你也可以直接用${VAR:=defaultval}(等号，不是破折号)，但是注意这不适用于脚本或函数中的位置变量。尝试修改上面的脚本来看它是如何失败的。</p><h3 id="16-Traps"><a href="#16-Traps" class="headerlink" title="16. Traps"></a>16. Traps</h3><p>当一个信号被送到脚本时，内建的trap可以用于“捕获”<br>下面是我用在自己的chepci脚本中的一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function cleanup() &#123;</span><br><span class="line">   rm -rf &quot;$&#123;BUILD_DIR&#125;&quot;</span><br><span class="line">   rm -f &quot;$&#123;LOCK_FILE&#125;&quot;</span><br><span class="line">   # get rid of &#x2F;tmp detritus, leaving anything accessed 2 days ago+</span><br><span class="line">   find &quot;$&#123;BUILD_DIR_BASE&#125;&quot;&#x2F;* -type d -atime +1 | rm -rf</span><br><span class="line">   echo &quot;cleanup done&quot;                                                     &#125;</span><br><span class="line">trap cleanup TERM INT QUIT</span><br></pre></td></tr></table></figure><p>任何使用TERM信号的CTRL-C,CTRL-或终止程序的操作将会首先调用cleanup<br>⚠️ 注意：</p><ul><li>trap的逻辑可能非常棘手（例如处理信号竞争条件）</li><li>KILL信号不能以这种方式捕获<br>但是大多数情况下，我会把它用于类似上述的‘cleanup’中，来达成函数的目的。</li></ul><h3 id="17-Shell变量"><a href="#17-Shell变量" class="headerlink" title="17. Shell变量"></a>17. Shell变量</h3><p>了解可用的标准shell变量是非常值得的。这些是我最喜欢的。<br>RANDOM<br>不要依赖这个来加密堆栈，但你可以生成随机数字，例如在脚本中创建临时文件时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ echo $&#123;RANDOM&#125;</span><br><span class="line">16313</span><br><span class="line">$ # Not enough digits?</span><br><span class="line">$ echo $&#123;RANDOM&#125;$&#123;RANDOM&#125;</span><br><span class="line">113610703</span><br><span class="line">$ NEWFILE&#x3D;&#x2F;tmp&#x2F;newfile_$&#123;RANDOM&#125;</span><br><span class="line">$ touch $NEWFILE</span><br></pre></td></tr></table></figure><p>REPLY<br>不在需要给read一个变量名称</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ read</span><br><span class="line">my input</span><br><span class="line">$ echo $&#123;REPLY&#125;</span><br></pre></td></tr></table></figure><p>LINENO 与 SECONDS<br>方便调试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ echo $&#123;LINENO&#125;</span><br><span class="line">115</span><br><span class="line">$ echo $&#123;SECONDS&#125;; sleep 1; echo $&#123;SECONDS&#125;; echo $LINENO</span><br><span class="line">174380</span><br><span class="line">174381</span><br><span class="line">116</span><br></pre></td></tr></table></figure><p>注意，即便使用;来隔开命令，上面的代码也要分两行</p><p>TMOUT<br>可以用来超时读取，在一些脚本中真的很好用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">TMOUT&#x3D;5</span><br><span class="line">echo You have 5 seconds to respond...</span><br><span class="line">read</span><br><span class="line">echo $&#123;REPLY:-noreply&#125;</span><br></pre></td></tr></table></figure><p>Extglobs</p><p>如果你真的沉迷bash不能自拔，那么你可能想要增强你的通配功能。你可以通过设置shell中的extglob选项。这是设置方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shopt -s extglob</span><br><span class="line">A&#x3D;&quot;12345678901234567890&quot;</span><br><span class="line">B&#x3D;&quot;  $&#123;A&#125;  &quot;</span><br></pre></td></tr></table></figure><p>现在来看看你是否能指出以下这些语句各自的功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;B      |$&#123;B&#125;|&quot;</span><br><span class="line">echo &quot;B#+( ) |$&#123;B#+( )&#125;|&quot;</span><br><span class="line">echo &quot;B#?( ) |$&#123;B#?( )&#125;|&quot;</span><br><span class="line">echo &quot;B#*( ) |$&#123;B#*( )&#125;|&quot;</span><br><span class="line">echo &quot;B##+( )|$&#123;B##+( )&#125;|&quot;</span><br><span class="line">echo &quot;B##*( )|$&#123;B##*( )&#125;|&quot;</span><br><span class="line">echo &quot;B##?( )|$&#123;B##?( )&#125;|&quot;</span><br></pre></td></tr></table></figure><p>虽然它可能很有用，但是很难想象出一种你必须要用这种方式的情况。通常你会使用一些更适合相应任务的工具（像sed）或者直接放弃bash去使用一些像python那样的“合适的”编程语言。</p><h3 id="18-关联数组"><a href="#18-关联数组" class="headerlink" title="18.关联数组"></a>18.关联数组</h3><p>谈到移植到其他语言，一条重要的规则是，如果我需要用到数组，那么我会放弃bash，使用python（为此我甚至创建了一个Docker Container来运行一个专门的工具）</p><p>知道读到它我才知道，在bash中有关联数组</p><p>以下是演示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ declare -A MYAA&#x3D;([one]&#x3D;1 [two]&#x3D;2 [three]&#x3D;3)</span><br><span class="line">$ MYAA[one]&#x3D;&quot;1&quot;</span><br><span class="line">$ MYAA[two]&#x3D;&quot;2&quot;</span><br><span class="line">$ echo $MYAA</span><br><span class="line">$ echo $&#123;MYAA[one]&#125;</span><br><span class="line">$ MYAA[one]&#x3D;&quot;1&quot;</span><br><span class="line">$ WANT&#x3D;two</span><br><span class="line">$ echo $&#123;MYAA[$WANT]&#125;</span><br></pre></td></tr></table></figure><p>注意仅适用于bash4.x+版本</p><h3 id="19-实用的shell文章"><a href="#19-实用的shell文章" class="headerlink" title="19. 实用的shell文章"></a>19. 实用的shell文章</h3><p><a href="http://mywiki.wooledge.org/BashPitfalls?spm=a2c4e.11153959.blogcont68524.18.4dbf3d2foIG0jZ" target="_blank" rel="noopener">BashPitfalls - Greg’s Wiki</a><br><a href="http://mywiki.wooledge.org/ProcessManagement?spm=a2c4e.11153959.blogcont68524.19.4dbf3d2foIG0jZ" target="_blank" rel="noopener">ProcessManagement - Greg’s Wiki</a><br><a href="http://mywiki.wooledge.org/BashGuide?spm=a2c4e.11153959.blogcont68524.20.4dbf3d2foIG0jZ" target="_blank" rel="noopener">BashGuide - Greg’s Wiki</a><br><a href="http://mywiki.wooledge.org/BashFAQ?spm=a2c4e.11153959.blogcont68524.21.4dbf3d2foIG0jZ" target="_blank" rel="noopener">BashFAQ - Greg’s Wiki</a></p><p><a href="https://yq.aliyun.com/articles/68524?spm=a2c4e.11153959.teamhomeleft.136.7e4c8bc1kg1JeI" target="_blank" rel="noopener">原文参考地址</a></p><p><a href="https://yq.aliyun.com/articles/72012?spm=a2c4e.11153959.teamhomeleft.10.7e4c8bc1kg1JeI" target="_blank" rel="noopener">Sed&amp;awk笔记系列-博客</a></p>]]></content>
    
    <summary type="html">
    
      简洁的Bash Programming技巧(二)
    
    </summary>
    
    
      <category term="SHELL" scheme="https://shuke163.github.io/categories/SHELL/"/>
    
    
      <category term="SHELL" scheme="https://shuke163.github.io/tags/SHELL/"/>
    
  </entry>
  
  <entry>
    <title>简洁的Bash Programming技巧(一)</title>
    <link href="https://shuke163.github.io/2020/04/20/index/"/>
    <id>https://shuke163.github.io/2020/04/20/index/</id>
    <published>2020-04-20T07:58:17.000Z</published>
    <updated>2020-04-20T07:58:38.480Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简洁的Bash-Programming技巧-二"><a href="#简洁的Bash-Programming技巧-二" class="headerlink" title="简洁的Bash Programming技巧(二)"></a>简洁的Bash Programming技巧(二)</h2><h3 id="1-检查命令执行是否成功"><a href="#1-检查命令执行是否成功" class="headerlink" title="1. 检查命令执行是否成功"></a>1. 检查命令执行是否成功</h3><p>第一种写法，比较常见：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">echo abcdee | grep -q abcd</span><br><span class="line"></span><br><span class="line">if [ $? -eq 0 ]; then</span><br><span class="line">    echo &quot;Found&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;Not found&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>简洁的写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if echo abcdee | grep -q abc; then</span><br><span class="line">    echo &quot;Found&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;Not found&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>当然你也可以不要if/else,不过这样可读性比较差:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo abcdee | grep -q abc &amp;&amp; echo &quot;Found&quot; || echo &quot;Not found&quot;</span><br><span class="line">Found</span><br></pre></td></tr></table></figure><h3 id="2-将标准输出与标准错误输出重定向到-dev-null"><a href="#2-将标准输出与标准错误输出重定向到-dev-null" class="headerlink" title="2. 将标准输出与标准错误输出重定向到/dev/null"></a>2. 将标准输出与标准错误输出重定向到/dev/null</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 第一种写法，比较常见：</span><br><span class="line">grep &quot;abc&quot; test.txt 1&gt;&#x2F;dev&#x2F;null 2&gt;&amp;1</span><br><span class="line">2. 常见的错误写法：</span><br><span class="line">grep &quot;abc&quot; test.txt 2&gt;&amp;1 1&gt;&#x2F;dev&#x2F;null</span><br><span class="line">3. 简洁的写法：</span><br><span class="line">grep &quot;abc&quot; test.txt &amp;&gt; &#x2F;dev&#x2F;null</span><br></pre></td></tr></table></figure><h3 id="3-awk的使用"><a href="#3-awk的使用" class="headerlink" title="3. awk的使用"></a>3. awk的使用</h3><p>举一个实际的例子，获取Xen DomU的id。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 常见的写法：</span><br><span class="line">sudo xm li | grep vm_name | awk &#39;&#123;print $2&#125;&#39;</span><br><span class="line">2. 简洁的写法：</span><br><span class="line">sudo xm li | awk &#39;&#x2F;vm_name&#x2F;&#123;print $2&#125;&#39;</span><br></pre></td></tr></table></figure><h3 id="4-将一个文本的所有行用逗号连接起来"><a href="#4-将一个文本的所有行用逗号连接起来" class="headerlink" title="4. 将一个文本的所有行用逗号连接起来"></a>4. 将一个文本的所有行用逗号连接起来</h3><p>假设文件内容如下所示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat &#x2F;tmp&#x2F;ip.txt </span><br><span class="line">192.168.1.100</span><br><span class="line">192.168.1.101</span><br><span class="line">192.168.1.102</span><br></pre></td></tr></table></figure><p>使用Sed命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sed &#39;:a;$!N;s&#x2F;\n&#x2F;,&#x2F;;ta&#39; &#x2F;tmp&#x2F;ip.txt</span><br><span class="line">192.168.1.100,192.168.1.101,192.168.1.102</span><br></pre></td></tr></table></figure><p>简洁的写法(一)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ paste -sd, &#x2F;tmp&#x2F;ip.txt</span><br><span class="line">192.168.1.100,192.168.1.101,192.168.1.102</span><br></pre></td></tr></table></figure><p>简洁的写法(二)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat &#x2F;tmp&#x2F;ip.txt | tr &quot;\n&quot; &quot;,&quot;</span><br><span class="line">192.168.1.100,192.168.1.101,192.168.1.102,</span><br><span class="line">⚠️ 结尾的换行符也会被替换为逗号</span><br></pre></td></tr></table></figure><h3 id="5-过滤重复行"><a href="#5-过滤重复行" class="headerlink" title="5. 过滤重复行"></a>5. 过滤重复行</h3><p>假设文件内容如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># sort &#x2F;tmp&#x2F;ip.txt</span><br><span class="line">192.168.1.100</span><br><span class="line">192.168.1.100</span><br><span class="line">192.168.1.101</span><br><span class="line">192.168.1.101</span><br><span class="line">192.168.1.102</span><br></pre></td></tr></table></figure><p>常用的方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># sort &#x2F;tmp&#x2F;ip.txt | uniq</span><br><span class="line">192.168.1.100</span><br><span class="line">192.168.1.101</span><br><span class="line">192.168.1.102</span><br></pre></td></tr></table></figure><p>简单的写法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># sort -u &#x2F;tmp&#x2F;ip.txt</span><br><span class="line">192.168.1.100</span><br><span class="line">192.168.1.101</span><br><span class="line">192.168.1.102</span><br></pre></td></tr></table></figure><h3 id="6-grep查找单词"><a href="#6-grep查找单词" class="headerlink" title="6. grep查找单词"></a>6. grep查找单词</h3><p>假设一个文本的每一行是一个ip地址，例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># cat &#x2F;tmp&#x2F;ip.txt</span><br><span class="line">192.168.1.100</span><br><span class="line">192.168.1.101</span><br><span class="line">192.168.1.102</span><br><span class="line">192.168.1.100</span><br><span class="line">192.168.1.101</span><br></pre></td></tr></table></figure><p>使用grep查找是否包括192.168.1.102这个ip地址。常见的写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># grep &#39;192.168.1.102\&gt;&#39; &#x2F;tmp&#x2F;ip.txt</span><br><span class="line">192.168.1.102</span><br></pre></td></tr></table></figure><p>简单的方法（其实这方法不见得简单，只是为了说明-w这个参数还是很有用的)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># grep -w &#39;192.168.1.102&#39; &#x2F;tmp&#x2F;ip.txt</span><br><span class="line">192.168.1.102</span><br></pre></td></tr></table></figure><p>注⚠️: grep的-n/-H/-v/-f/-c这几参数都很有用.</p><h3 id="7-临时设置环境变量"><a href="#7-临时设置环境变量" class="headerlink" title="7. 临时设置环境变量"></a>7. 临时设置环境变量</h3><p>常见的写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ export LC_ALL&#x3D;zh_CN.UTF-8 </span><br><span class="line"></span><br><span class="line">$ date</span><br><span class="line">2012年 11月 03日 星期六 22:26:55 CST</span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line">简洁的写法:</span><br></pre></td></tr></table></figure><p>$ unset LC_ALL<br>$ LC_ALL=zh_CN.UTF-8 date<br>2012年 11月 03日 星期六 22:27:43 CST</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在命令之前加上环境变更的设置，只是临时改变当前执行命令的环境。</span><br><span class="line">### 8. \$1,\$2...等位置参数的使用</span><br><span class="line">假设只想使用$2,$3..这几个参数，常见的做法是:</span><br></pre></td></tr></table></figure><p>shift<br>echo “$@”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为什么不这样写呢？</span><br></pre></td></tr></table></figure><p>echo “${@:2}”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">### 9. 退而求其次的写法</span><br><span class="line">相信大家会有这种需求，当一个参数值没有提供时，可以使用默认值。常见的写法是：</span><br></pre></td></tr></table></figure><p>arg=$1<br>if [ -z “$arg” ]; then<br>   arg=0<br>fi</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">简洁的写法是这样的:</span><br></pre></td></tr></table></figure><p>arg=${1:-0}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">### 10. bash特殊参数--的用法</span><br><span class="line">假设要用grep查找字符串中是否包含-i，我们会这样尝试：</span><br></pre></td></tr></table></figure><h1 id="echo-‘abc-i’-grep-“-i”"><a href="#echo-‘abc-i’-grep-“-i”" class="headerlink" title="echo ‘abc-i’ | grep “-i”"></a>echo ‘abc-i’ | grep “-i”</h1><p>Usage: grep [OPTION]… PATTERN [FILE]…<br>Try ‘grep –help’ for more information.</p><h1 id="echo-‘abc-i’-grep-“-i”-1"><a href="#echo-‘abc-i’-grep-“-i”-1" class="headerlink" title="echo ‘abc-i’ | grep “-i”"></a>echo ‘abc-i’ | grep “-i”</h1><p>abc-i</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">简洁的方法是：</span><br></pre></td></tr></table></figure><h1 id="echo-‘abc-i’-grep-–-i"><a href="#echo-‘abc-i’-grep-–-i" class="headerlink" title="echo ‘abc-i’ | grep – -i"></a>echo ‘abc-i’ | grep – -i</h1><p>abc-i</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">注⚠️:bash中--后面的参数不会被当作选项解析。</span><br><span class="line">### 11. 函数的返回值默认是最后一行语句的返回值</span><br></pre></td></tr></table></figure><h1 id="Check-whether-an-item-is-a-function"><a href="#Check-whether-an-item-is-a-function" class="headerlink" title="Check whether an item is a function"></a>Check whether an item is a function</h1><h1 id="1-the-function-name"><a href="#1-the-function-name" class="headerlink" title="$1: the function name"></a>$1: the function name</h1><h1 id="Return-0-yes-or-1-no"><a href="#Return-0-yes-or-1-no" class="headerlink" title="Return: 0(yes) or 1(no)"></a>Return: 0(yes) or 1(no)</h1><p>function is_function()<br>{<br>    local func_name=$1<br>    test “<code>type -t $1 2&gt;/dev/null</code>“ = “function”<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">不要画蛇添足再在后面加一行return $?了。</span><br><span class="line">### 12. 将printf格式化的结果赋值给变量</span><br><span class="line">例如将数字转换成其十六进制形式，常见的写法是：</span><br></pre></td></tr></table></figure><p>$ var=$(printf ‘%%%02x’ 111)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">简单的写法是：</span><br></pre></td></tr></table></figure><p>$ printf -v var ‘%%%02x’ 111 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf的help：</span><br></pre></td></tr></table></figure><h1 id="help-printf-grep-A-1-B-1-–-v"><a href="#help-printf-grep-A-1-B-1-–-v" class="headerlink" title="help printf | grep -A 1 -B 1 – -v"></a>help printf | grep -A 1 -B 1 – -v</h1><p>printf: printf [-v var] format [arguments]<br>    Formats and prints ARGUMENTS under control of the FORMAT.<br>–<br>    Options:<br>      -v var    assign the output to shell variable VAR rather than<br>            display it on the standard output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">### 13. 打印文件行</span><br><span class="line">打印文件的第一行：</span><br></pre></td></tr></table></figure><p>head -1 test.txt</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">打印文件的第2行：</span><br></pre></td></tr></table></figure><p>sed -n ‘2p’ test.txt</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">打印文件的第2到5行：</span><br></pre></td></tr></table></figure><p>sed -n ‘2,5p’ test.txt</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">打印文件的第2行始（包括第2行在内）5行的内容：</span><br></pre></td></tr></table></figure><p>sed -n ‘2,+4p’ test.txt</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">打印倒数第二行：</span><br></pre></td></tr></table></figure><p>$ tail -2 test.txt | head -1<br>$ tac test.txt | sed -n ‘2p’</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">### 14.善用let或者(())命令做算术运算</span><br><span class="line">如何对一个数字做++运算，可能你会这样用：</span><br></pre></td></tr></table></figure><p>a=1<br>a=<code>expr a + 1</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为何不用你熟悉的:</span><br></pre></td></tr></table></figure><p>a=1<br>let a++<br>let a+=2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">### 15. 获取软连接指定的真实文件名</span><br><span class="line">如果你不知道，你可能会这样获取：</span><br></pre></td></tr></table></figure><p>$ ls -l /usr/bin/python | awk -F’-&gt;’ ‘{print $2}’ | tr -d ‘ ‘<br>/usr/bin/python2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果你知道有一个叫readlink的命令，那么：</span><br></pre></td></tr></table></figure><p>$ readlink /usr/bin/python<br>/usr/bin/python2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">### 16. 获取一个字符的ASCII码</span><br></pre></td></tr></table></figure><p>$ printf ‘%02x’ “‘+”<br>2b<br>$ echo -n ‘+’ | od -tx1 -An | tr -d ‘ ‘<br>2b</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">### 17. 清空一个文件</span><br><span class="line">常见的用法:</span><br></pre></td></tr></table></figure><p>echo “” &gt; test.txt</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">简单的写法：</span><br></pre></td></tr></table></figure><blockquote><p>test.txt</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">### 18 不要忘记有here document</span><br><span class="line">下面一段代码：</span><br></pre></td></tr></table></figure><p>grep -v 1 /tmp/test.txt | while read line; do<br>    let a++<br>    echo –$line–<br>done<br>echo a:$a</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">执行后有什么问题吗？</span><br></pre></td></tr></table></figure><p>$ sh test.sh<br>–2–<br>–3–<br>a:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">问题: 发现a这个变量没有被赋值，为什么呢？因为管道后面的代码是在在一个子shell中执行的，所做的任何更改都不会对当前shell有影响，自然a这个变量就不会有赋值了。</span><br><span class="line"></span><br><span class="line">换一种思路，可以这样做：</span><br></pre></td></tr></table></figure><p>grep -v 1 /tmp/test.txt &gt; /tmp/test.tmp</p><p>while read line; do<br>    let a++<br>    echo –$line–<br>done &lt; /tmp/test.tmp</p><p>echo a:$a<br>rm -f /tmp/test.tmp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不过多了一个临时文件，最后还要删除。这里其实可以用到here document：</span><br></pre></td></tr></table></figure><p>while read line2; do<br>    let b++<br>    echo ??$line2??<br>done &lt;&lt; EOF<br><code>grep -v 1 /tmp/test.txt</code><br>EOF<br>echo b: $b</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">here document往往用于需要输出一大段文本的地方，例如脚本的help函数</span><br><span class="line"></span><br><span class="line">### 19.删除字符串中的第一个或者最后一个字符</span><br><span class="line">假设字符串为：</span><br></pre></td></tr></table></figure><p>$ str=”aremoveb”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可能你第一个想法是通过sed或者其它命令来完成这个功能，但是其实有很简单的方法,此处利用shell的数组进行处理：</span><br></pre></td></tr></table></figure><p>$ echo “${str#?}”<br>removeb<br>$ echo “${str%?}”<br>aremove</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类似地，你也可以删除2个、3个、4个……</span><br><span class="line"></span><br><span class="line">有没有一次性删除第一个和最后一个字符的方法呢？答案当然是肯定的：</span><br></pre></td></tr></table></figure><p>$ echo “${str:1:-1}”<br>remove</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">关于这些变量替换的内容在bash的man手册中都有说明。</span><br><span class="line">### 20. 使用逗号join数组元素</span><br><span class="line">假设数组元素没有空格，可以用这种方法：</span><br></pre></td></tr></table></figure><p>$ a=(1 2 3)<br>$ b=”${a[*]}”</p><p>$ echo ${b// /,}<br>1,2,3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">注⚠️：当该数组的长度非常长时，使用这种替换的时间开销很高，性能很差，推荐用sed。</span><br><span class="line">假设数组元素包含有空格，可以借用printf命令来达到：</span><br></pre></td></tr></table></figure><p>$ a=(1 “2 3” 4)<br>$ printf “,%s” “${a[@]}” | cut -c2-<br>1,2 3,4</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">### 21. Shell中的多进程</span><br><span class="line">在命令行下，我们会在命令行后面加上&amp;符号来让该命令在后台执行，在shell脚本中，使用&quot;(cmd)&quot;可以让fork一个子shell来执行该命令。利用这两点，可以实现shell的多线程：</span><br></pre></td></tr></table></figure><p>job_num=10</p><p>function do_work()<br>{<br>    echo “Do work..”<br>}</p><p>for ((i=0; i &lt; job_num ;i++)); do<br>    echo “Fork job $i”<br>    (do_work) &amp;<br>done</p><p>wait   # wait for all job done<br>echo “All job have been done!”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">注⚠️: 最后的wait命令，作用是等待所有子进程结束。</span><br><span class="line">附几则小技巧：</span><br></pre></td></tr></table></figure><p>1）sudo iptables -L -n | vim -<br>2）grep -v xxx | vim -<br>3）echo $’&#39;‘<br>4）set – 1 2 3; echo “$@”<br>5）搜索stackoverflow/superuser等站点<br>6）VIM编辑远程文件 vim scp://xxx//etc/vimrc<br>7）远程执行脚本 ssh xxx bash &lt; xxx.sh</p><pre><code>[原文地址](https://yq.aliyun.com/articles/68541?spm=a2c4e.11153959.blogcont72014.7.6f252cb3xPFFVx)</code></pre>]]></content>
    
    <summary type="html">
    
      简洁的Bash Programming技巧(一)
    
    </summary>
    
    
      <category term="SHELL" scheme="https://shuke163.github.io/categories/SHELL/"/>
    
    
      <category term="SHELL" scheme="https://shuke163.github.io/tags/SHELL/"/>
    
  </entry>
  
  <entry>
    <title>SHELL 获取网卡流量</title>
    <link href="https://shuke163.github.io/2020/04/20/index/"/>
    <id>https://shuke163.github.io/2020/04/20/index/</id>
    <published>2020-04-20T07:57:18.000Z</published>
    <updated>2020-04-20T07:57:46.420Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SHELL-获取网卡流量"><a href="#SHELL-获取网卡流量" class="headerlink" title="SHELL 获取网卡流量"></a>SHELL 获取网卡流量</h2><h3 id="1-版本一"><a href="#1-版本一" class="headerlink" title="1. 版本一"></a>1. 版本一</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">#使用方法</span><br><span class="line">usage()</span><br><span class="line">&#123;</span><br><span class="line">  echo &quot;useage: $0 ethname intervel&quot;</span><br><span class="line">  exit 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#网口配置</span><br><span class="line">if [ $# -gt 1 ];then</span><br><span class="line">  ethname&#x3D;$1</span><br><span class="line">  num&#x3D;&#96;ifconfig|grep $&#123;ethname&#125;|wc -l&#96;</span><br><span class="line">  if [ $num -gt 0 ];then</span><br><span class="line">   ethname&#x3D;$1</span><br><span class="line">  else</span><br><span class="line">    echo &quot;Can&#39;t find $ethname,Please Check&quot;</span><br><span class="line">    exit 1</span><br><span class="line">  fi</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">#时间配置</span><br><span class="line">intervel&#x3D;1</span><br><span class="line">if [ $# -gt 0 ]; then</span><br><span class="line">  interval&#x3D;$2</span><br><span class="line">  test&#x3D;&#96;expr &quot;$interval&quot; \* 0&#96;</span><br><span class="line">  if [ &quot;$test&quot; !&#x3D; &quot;0&quot; ]; then </span><br><span class="line">        echo &quot;Invalid &lt;interval&gt; param &#39;$interval&#39; . It should be a integer number. Usage: $0 ethname intervel&quot;</span><br><span class="line">        exit -1  </span><br><span class="line">  fi</span><br><span class="line">  if [ $interval -lt 1 ]; then</span><br><span class="line">        echo &quot;Invalid &lt;interval&gt; param &#39;$interval&#39; . It should be &gt; 0 (seconds). Usage: $0 ethname intervel&quot;</span><br><span class="line">        exit -1</span><br><span class="line">  fi</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">#函数判断</span><br><span class="line">if [ $# -ne 2 ]</span><br><span class="line">then</span><br><span class="line"> usage</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo &quot;$0 is starting,Device is $1,Intervel is $2&quot;</span><br><span class="line">echo -e &quot;\n&quot;</span><br><span class="line"></span><br><span class="line">typeset Rev old_Rev</span><br><span class="line"></span><br><span class="line">eth&#x3D;$1</span><br><span class="line">intervel&#x3D;$2</span><br><span class="line"></span><br><span class="line">old_Rev&#x3D;&#96;cat &#x2F;proc&#x2F;net&#x2F;dev|grep $eth| awk &#39;&#123;print $1&#125;&#39;| awk -F : &#39;&#123;print $2&#125;&#39;&#96;</span><br><span class="line">old_Send&#x3D;&#96;cat &#x2F;proc&#x2F;net&#x2F;dev|grep $eth|awk &#39;&#123;print $9&#125;&#39;&#96;</span><br><span class="line">#echo &quot;old_Rev is $old_Rev&quot;</span><br><span class="line">#echo &quot;Old_send is $old_Send&quot;</span><br><span class="line"></span><br><span class="line">while true</span><br><span class="line"> do</span><br><span class="line"> sleep $intervel</span><br><span class="line"></span><br><span class="line"> Rev&#x3D;&#96;cat &#x2F;proc&#x2F;net&#x2F;dev|grep $eth|awk &#39;&#123;print $1&#125;&#39;|awk -F : &#39;&#123;print $2&#125;&#39;&#96;</span><br><span class="line"> Send&#x3D;&#96;cat &#x2F;proc&#x2F;net&#x2F;dev|grep $eth|awk &#39;&#123;print $9&#125;&#39;&#96;</span><br><span class="line">#echo &quot;Rev is $Rev&quot;</span><br><span class="line">#echo &quot;Send is $Send&quot;</span><br><span class="line"></span><br><span class="line"> diff_1&#x3D;&#96;awk -v Rev&#x3D;$Rev -v old_Rev&#x3D;$old_Rev -v intervel&#x3D;$intervel &#39;BEGIN&#123;printf &quot;Receive is %6.2f&quot;, ( Rev - old_Rev ) &#x2F; 1024 &#x2F; 1024 &#x2F; intervel * 8&#125;&#39;&#96;</span><br><span class="line"></span><br><span class="line"> diff_2&#x3D;&#96;awk -v Send&#x3D;$Send -v old_Send&#x3D;$old_Send -v intervel&#x3D;$intervel &#39;BEGIN&#123;printf &quot;Send is %6.2f&quot;, ( Send - old_Send ) &#x2F; 1024 &#x2F; 1024 &#x2F; intervel * 8&#125;&#39;&#96; </span><br><span class="line"></span><br><span class="line"> echo &quot;&#96;date +&#39;%Y-%m-%d %H:%M:%S&#39;&#96; Speed: IN $&#123;diff_1&#125; mbps OUT $&#123;diff_2&#125; mbps&quot;</span><br><span class="line"></span><br><span class="line"> old_Rev&#x3D;$Rev</span><br><span class="line"> old_Send&#x3D;$Send</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h3 id="2-版本二"><a href="#2-版本二" class="headerlink" title="2. 版本二"></a>2. 版本二</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">#network</span><br><span class="line">#by rocdk890</span><br><span class="line">while : ; do</span><br><span class="line">      time&#x3D;&#96;date +%m&quot;-&quot;%d&quot; &quot;%k&quot;:&quot;%M&#96;</span><br><span class="line">      day&#x3D;&#96;date +%m&quot;-&quot;%d&#96;</span><br><span class="line">      port&#x3D;&#96;ifconfig |grep em|awk &#39;&#123;print $1&#125;&#39;&#96;</span><br><span class="line">      rx_before&#x3D;&#96;ifconfig $port|sed -n &quot;8&quot;p|awk &#39;&#123;print $2&#125;&#39;|cut -c7-&#96;</span><br><span class="line">      tx_before&#x3D;&#96;ifconfig $port|sed -n &quot;8&quot;p|awk &#39;&#123;print $6&#125;&#39;|cut -c7-&#96;</span><br><span class="line">      sleep 2</span><br><span class="line">      rx_after&#x3D;&#96;ifconfig $port|sed -n &quot;8&quot;p|awk &#39;&#123;print $2&#125;&#39;|cut -c7-&#96;</span><br><span class="line">      tx_after&#x3D;&#96;ifconfig $port|sed -n &quot;8&quot;p|awk &#39;&#123;print $6&#125;&#39;|cut -c7-&#96;</span><br><span class="line">      rx_result&#x3D;$[(rx_after-rx_before)&#x2F;256]</span><br><span class="line">      tx_result&#x3D;$[(tx_after-tx_before)&#x2F;256]</span><br><span class="line">      echo &quot;$time Now_In_Speed: &quot;$rx_result&quot;kbps Now_OUt_Speed: &quot;$tx_result&quot;kbps&quot;</span><br><span class="line">      sleep 2</span><br><span class="line">done</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      SHELL 获取网卡流量
    
    </summary>
    
    
      <category term="SHELL" scheme="https://shuke163.github.io/categories/SHELL/"/>
    
    
      <category term="SHELL" scheme="https://shuke163.github.io/tags/SHELL/"/>
    
  </entry>
  
  <entry>
    <title>蓝鲸进程管理脚本参考</title>
    <link href="https://shuke163.github.io/2020/04/20/index/"/>
    <id>https://shuke163.github.io/2020/04/20/index/</id>
    <published>2020-04-20T07:56:21.000Z</published>
    <updated>2020-04-20T07:56:54.653Z</updated>
    
    <content type="html"><![CDATA[<p>蓝鲸进程管理脚本参考</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line"># use bash to execute this script</span><br><span class="line">echo $BASH |grep -q &#39;bash&#39; || &#123; exec bash &quot;$0&quot; &quot;$@&quot; || exit 1; &#125;</span><br><span class="line"></span><br><span class="line"># enable extended pattern matching operators</span><br><span class="line">shopt -s extglob</span><br><span class="line"></span><br><span class="line">VERSION_BK&#x3D;&quot;1.1.1&quot;</span><br><span class="line"></span><br><span class="line">DIR_HOME&#x3D;&quot;$(readlink -f $(dirname $0))&quot;</span><br><span class="line"></span><br><span class="line">DIR_CMDB&#x3D;&quot;$DIR_HOME&#x2F;cmdb&quot;</span><br><span class="line">DIR_JOB&#x3D;&quot;$DIR_HOME&#x2F;job&quot;</span><br><span class="line">DIR_GSE&#x3D;&quot;$DIR_HOME&#x2F;gse&quot;</span><br><span class="line">DIR_ZK&#x3D;&quot;$DIR_HOME&#x2F;common&#x2F;zookeeper&#x2F;zookeeper-3.4.6&quot;</span><br><span class="line">DIR_DOWN&#x3D;&quot;$DIR_HOME&#x2F;index&#x2F;download&quot;</span><br><span class="line">DIR_SESSION&#x3D;&quot;$DIR_HOME&#x2F;.session&quot;</span><br><span class="line"></span><br><span class="line">FILE_CONF&#x3D;&quot;$DIR_HOME&#x2F;bk.conf&quot;</span><br><span class="line">FILE_LOG&#x3D;&quot;$DIR_HOME&#x2F;bk.log&quot;</span><br><span class="line"></span><br><span class="line">FILE_TPL&#x3D;&quot;$DIR_HOME&#x2F;common&#x2F;function.tpl&quot;</span><br><span class="line">FILE_FUNC&#x3D;&quot;$DIR_HOME&#x2F;common&#x2F;function&quot;</span><br><span class="line"></span><br><span class="line">FILE_SETUP&#x3D;&quot;$DIR_HOME&#x2F;init_data&#x2F;setup.sh&quot;</span><br><span class="line">FILE_INITDB&#x3D;&quot;$DIR_HOME&#x2F;init_data&#x2F;init_db.sh&quot;</span><br><span class="line"></span><br><span class="line">FILE_CRT&#x3D;&quot;$DIR_HOME&#x2F;ssl_certificates.tar.gz&quot;</span><br><span class="line">FILE_INIT&#x3D;&quot;$DIR_HOME&#x2F;.bkallowinit&quot;</span><br><span class="line">SO_libaio&#x3D;&quot;&#x2F;lib64&#x2F;libaio.so.1&quot;</span><br><span class="line"></span><br><span class="line">NGINX_LOGS&#x3D;&quot;$DIR_HOME&#x2F;common&#x2F;nginx&#x2F;logs&quot;</span><br><span class="line"></span><br><span class="line">PHP_EXE&#x3D;&quot;$DIR_HOME&#x2F;common&#x2F;php&#x2F;bin&#x2F;php&quot;</span><br><span class="line"></span><br><span class="line">MYSQL_HOME&#x3D;&quot;$DIR_HOME&#x2F;common&#x2F;mysql&quot;</span><br><span class="line">MYSQL_DATA&#x3D;&quot;$MYSQL_HOME&#x2F;data&#x2F;&quot;</span><br><span class="line">MYSQL_BIN&#x3D;&quot;$MYSQL_HOME&#x2F;bin&#x2F;mysql&quot;</span><br><span class="line">MYSOCK&#x3D;&quot;$MYSQL_HOME&#x2F;data&#x2F;mysql.sock&quot;</span><br><span class="line"></span><br><span class="line">TOMCAT_DIR&#x3D;&quot;$DIR_JOB&#x2F;apache-tomcat-7.0.19&quot;</span><br><span class="line">TOMCAT_LOGS&#x3D;&quot;$TOMCAT_DIR&#x2F;logs&quot;</span><br><span class="line">TOMCAT_BIN&#x3D;&quot;$TOMCAT_DIR&#x2F;bin&#x2F;catalina.sh&quot;</span><br><span class="line"></span><br><span class="line">JAVA_HOME&#x3D;&quot;$DIR_HOME&#x2F;common&#x2F;java&quot;</span><br><span class="line">JAVA_BIN&#x3D;&quot;$JAVA_HOME&#x2F;bin&quot;</span><br><span class="line">PATH&#x3D;$JAVA_BIN:$PATH</span><br><span class="line">CLASSPATH&#x3D;.:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar</span><br><span class="line"></span><br><span class="line">LC_ALL&#x3D;C</span><br><span class="line">LANG&#x3D;C</span><br><span class="line"></span><br><span class="line">ACTION&#x3D;&#39;@(start|stop|restart|status|summary|reload|report|init)&#39;</span><br><span class="line">MODULE&#x3D;&#39;@(all|redis-server|nginx|mysqld|zk1|zk2|zk3|gsedba|gsetask|gsebtfilesserver|yydba|gsedata|gsecacheapiserver|gseagent|cmdb|job|-*||)&#39;</span><br><span class="line">GROUP&#x3D;&#39;@(gse|zk)&#39;</span><br><span class="line"></span><br><span class="line">monit() &#123; </span><br><span class="line">    local MONIT_DIR&#x3D;&quot;$DIR_HOME&#x2F;common&#x2F;monit&quot;</span><br><span class="line">    local MONIT_BIN&#x3D;&quot;$MONIT_DIR&#x2F;bin&#x2F;monit&quot;</span><br><span class="line">    local MONIT_RC&#x3D;&quot;$MONIT_DIR&#x2F;conf&#x2F;monitrc&quot;</span><br><span class="line">    local MONIT_EXE&#x3D;&quot;$MONIT_BIN -c $MONIT_RC&quot;</span><br><span class="line">    </span><br><span class="line">    chmod 700 $MONIT_RC</span><br><span class="line">    </span><br><span class="line">    case &quot;$1&quot; in</span><br><span class="line">        self_start)</span><br><span class="line">            log &quot;Info: monit self_start...&quot;</span><br><span class="line">            $MONIT_EXE &amp;&gt;&#x2F;dev&#x2F;null</span><br><span class="line">            wait_check &quot;$MONIT_EXE summary&quot;</span><br><span class="line">            log &quot;Info: monit self_start, ok&quot;</span><br><span class="line">            ;;</span><br><span class="line">        self_stop)</span><br><span class="line">            $MONIT_EXE quit</span><br><span class="line">            ;;</span><br><span class="line">        self_reload) </span><br><span class="line">            $MONIT_EXE reload</span><br><span class="line">            ;;</span><br><span class="line">        self_restart)</span><br><span class="line">            monit self_stop</span><br><span class="line">            monit self_start</span><br><span class="line">            ;;</span><br><span class="line">        wait_stop)</span><br><span class="line">            wait_check &quot;$MONIT_EXE summary |grep -c monitored |grep -q 16&quot;</span><br><span class="line">            ;;  </span><br><span class="line">        *)</span><br><span class="line">            [[ $1 &#x3D;&#x3D; &quot;start&quot; ]] &amp;&amp; [[ $2 &#x3D;&#x3D; &quot;all&quot; ]] &amp;&amp; monit self_start</span><br><span class="line">            $MONIT_EXE &quot;$@&quot;</span><br><span class="line">            [[ $1 &#x3D;&#x3D; &quot;start&quot; ]] &amp;&amp; [[ $2 &#x3D;&#x3D; &quot;all&quot; ]] &amp;&amp; writed_ip</span><br><span class="line">            echo $1 |grep -Eq &#39;start|stop|restart&#39; &amp;&amp; &#123; sleep 3;monit summary; &#125;</span><br><span class="line">            ;;</span><br><span class="line">    esac</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">usage() &#123;</span><br><span class="line">    cat &lt;&lt;EOF</span><br><span class="line">Usage: $0 : &lt;action&gt; &lt;module&gt;</span><br><span class="line">action的取值为：(start|stop|restart|status|summary|reload|report|init)时，需要第二个参数module</span><br><span class="line">module的取值为：(all|redis-server|nginx|mysqld|zk1|zk2|zk3|gsedba|gsetask|gsebtfilesserver|yydba|gsedata|gsecacheapiserver|gseagent|cmdb|job)</span><br><span class="line"></span><br><span class="line">查看所有的进程状态：$0 summary </span><br><span class="line">EOF</span><br><span class="line">    exit 1 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo -en &quot;Current Version: $VERSION_BK \n&quot;</span><br><span class="line"></span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line">    init) </span><br><span class="line">        source $FILE_SETUP || &#123; echo -en &quot;Error: source $FILE_SETUP, failed\n&quot;;exit 1; &#125;</span><br><span class="line">        monit self_start &amp;&amp; monit unmonitor all</span><br><span class="line">        monit stop all &amp;&amp; monit wait_stop</span><br><span class="line">        monit start mysqld</span><br><span class="line">        monit -g zk start </span><br><span class="line">        init_db</span><br><span class="line">        exit $?</span><br><span class="line">        ;;</span><br><span class="line">    $ACTION)</span><br><span class="line">        : ;;</span><br><span class="line">    *)</span><br><span class="line">        usage</span><br><span class="line">        ;;</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line">source $FILE_FUNC || log_exit &quot;Error: source $FILE_FUNC, failed&quot;</span><br><span class="line"></span><br><span class="line">case &quot;$2&quot; in </span><br><span class="line">    $MODULE)</span><br><span class="line">        monit &quot;$@&quot;</span><br><span class="line">        ;;</span><br><span class="line">    $GROUP)</span><br><span class="line">        monit -g $2 $1</span><br><span class="line">        ;;</span><br><span class="line">    monit)</span><br><span class="line">        monit self_$1</span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">        usage</span><br><span class="line">        ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      蓝鲸进程管理脚本参考
    
    </summary>
    
    
      <category term="Linux" scheme="https://shuke163.github.io/categories/Linux/"/>
    
      <category term="SHELL" scheme="https://shuke163.github.io/categories/Linux/SHELL/"/>
    
    
      <category term="Linux" scheme="https://shuke163.github.io/tags/Linux/"/>
    
      <category term="SHELL" scheme="https://shuke163.github.io/tags/SHELL/"/>
    
  </entry>
  
  <entry>
    <title>进程启停自定义脚本</title>
    <link href="https://shuke163.github.io/2020/04/20/index/"/>
    <id>https://shuke163.github.io/2020/04/20/index/</id>
    <published>2020-04-20T07:55:16.000Z</published>
    <updated>2020-04-20T07:55:47.879Z</updated>
    
    <content type="html"><![CDATA[<p>进程启停自定义脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash </span><br><span class="line"></span><br><span class="line">usage()</span><br><span class="line">&#123; </span><br><span class="line">  echo &quot;Usage: $0 &#123;start|stop|restart|status&#125; [lineid]&quot; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">suffix&#x3D;_stable</span><br><span class="line">LINELIST&#x3D;&quot;1 2 3 4 5 6&quot;</span><br><span class="line">LINK_NUM&#x3D;3</span><br><span class="line">UNAMED_ACTIVE&#x3D;0</span><br><span class="line">PROGRAME_ACTIVE&#x3D;0</span><br><span class="line"></span><br><span class="line">start_line()</span><br><span class="line">&#123;</span><br><span class="line">IDLIST&#x3D;$LINELIST</span><br><span class="line">if [ ! -z $1 ]; then</span><br><span class="line">IDLIST&#x3D;$1</span><br><span class="line">fi</span><br><span class="line">SELFID&#x3D;&#96;id -u&#96;</span><br><span class="line">cd gamed</span><br><span class="line">for LN in $IDLIST</span><br><span class="line">do</span><br><span class="line">PIDS&#x3D;&#96;pgrep -u $SELFID -f &quot;.&#x2F;gs$suffix gs.conf gmserver.conf config&#x2F;gsalias$LN.conf&quot;&#96;</span><br><span class="line">if [ -z &quot;$PIDS&quot; ]; then</span><br><span class="line">echo start line $LN</span><br><span class="line">nohup setsid .&#x2F;gs$suffix gs.conf gmserver.conf config&#x2F;gsalias$LN.conf &amp;&gt;..&#x2F;logs&#x2F;game$LN.log &amp;</span><br><span class="line">#nohup setsid .&#x2F;gs_asan$suffix gs.conf gmserver.conf config&#x2F;gsalias$LN.conf  &amp;&gt;..&#x2F;logs&#x2F;game$LN.log &amp;</span><br><span class="line">else</span><br><span class="line">echo line $LN is already running</span><br><span class="line">fi</span><br><span class="line">sleep 1</span><br><span class="line">done</span><br><span class="line">cd ..</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">status() </span><br><span class="line">&#123;</span><br><span class="line">PROGRAME_ACTIVE&#x3D;0;</span><br><span class="line">for LN in $LINELIST</span><br><span class="line">do</span><br><span class="line">check_line $LN</span><br><span class="line">PROGRAME_ACTIVE&#x3D;&#96;expr $PROGRAME_ACTIVE + $?&#96;;</span><br><span class="line">done</span><br><span class="line">check_process zlogd </span><br><span class="line">PROGRAME_ACTIVE&#x3D;&#96;expr $PROGRAME_ACTIVE + $?&#96;;</span><br><span class="line">check_process gdeliveryd</span><br><span class="line">PROGRAME_ACTIVE&#x3D;&#96;expr $PROGRAME_ACTIVE + $?&#96;;</span><br><span class="line">check_process gamedbd</span><br><span class="line">PROGRAME_ACTIVE&#x3D;&#96;expr $PROGRAME_ACTIVE + $?&#96;;</span><br><span class="line"># check_process gonlineinfod</span><br><span class="line"># PROGRAME_ACTIVE&#x3D;&#96;expr $PROGRAME_ACTIVE + $?&#96;;</span><br><span class="line">if [ $UNAMED_ACTIVE -eq 1 ]; then</span><br><span class="line">check_process unamed</span><br><span class="line">PROGRAME_ACTIVE&#x3D;&#96;expr $PROGRAME_ACTIVE + $?&#96;;</span><br><span class="line">fi</span><br><span class="line">check_process glinkd</span><br><span class="line">PROGRAME_ACTIVE&#x3D;&#96;expr $PROGRAME_ACTIVE + $?&#96;;</span><br><span class="line">return $PROGRAME_ACTIVE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">check_process()</span><br><span class="line">&#123;</span><br><span class="line">SELFID&#x3D;&#96;id -u&#96;</span><br><span class="line">PIDS&#x3D;&#96;pgrep -u $SELFID -f &quot;.&#x2F;$1$suffix.*$1.conf&quot;&#96;</span><br><span class="line">if [ ! -z &quot;$PIDS&quot; ]; then</span><br><span class="line">echo service $1 is running, pid $PIDS</span><br><span class="line">return 1;</span><br><span class="line">else</span><br><span class="line">echo service $1 is stopped.</span><br><span class="line">return 0;</span><br><span class="line">fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exists()</span><br><span class="line">&#123;</span><br><span class="line">SELFID&#x3D;&#96;id -u&#96;</span><br><span class="line">PIDS&#x3D;&#96;pgrep -u $SELFID -f &quot;.&#x2F;$1$suffix.*$1.conf&quot;&#96;</span><br><span class="line">if [ ! -z &quot;$PIDS&quot; ]; then</span><br><span class="line">echo service $1 is running, pid $PIDS</span><br><span class="line">return 1</span><br><span class="line">fi</span><br><span class="line">return 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kill_process()</span><br><span class="line">&#123;</span><br><span class="line">NAME&#x3D;$1</span><br><span class="line">SIG&#x3D;$2</span><br><span class="line">SELFID&#x3D;&#96;id -u&#96;</span><br><span class="line">PIDS&#x3D;&#96;pgrep -u $SELFID -f &quot;.&#x2F;$NAME$suffix.*$NAME.conf&quot;&#96;</span><br><span class="line">if [ -n &quot;$PIDS&quot; ]; then</span><br><span class="line">for PID in $PIDS</span><br><span class="line">do</span><br><span class="line">kill -$SIG $PID</span><br><span class="line">echo service $NAME pid $PID is killed.</span><br><span class="line">done</span><br><span class="line">else</span><br><span class="line">echo service $NAME is not running.</span><br><span class="line">fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">check_line()</span><br><span class="line">&#123;</span><br><span class="line">SELFID&#x3D;&#96;id -u&#96;</span><br><span class="line">LN&#x3D;$1</span><br><span class="line">PIDS&#x3D;&#96;pgrep -u $SELFID -f &quot;.&#x2F;gs$suffix gs.conf gmserver.conf config&#x2F;gsalias$LN.conf&quot;&#96;</span><br><span class="line">if [ ! -z &quot;$PIDS&quot; ]; then</span><br><span class="line">echo line $LN is running, pid $PIDS</span><br><span class="line">return 1;</span><br><span class="line">else</span><br><span class="line">echo line $LN is stopped.</span><br><span class="line">return 0;</span><br><span class="line">fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kill_line()</span><br><span class="line">&#123;</span><br><span class="line">SELFID&#x3D;&#96;id -u&#96;</span><br><span class="line">LN&#x3D;$1</span><br><span class="line">PIDS&#x3D;&#96;pgrep -u $SELFID -f &quot;.&#x2F;gs$suffix gs.conf gmserver.conf config&#x2F;gsalias$LN.conf&quot;&#96;</span><br><span class="line">if [ -n &quot;$PIDS&quot; ]; then</span><br><span class="line">for PID in $PIDS</span><br><span class="line">do</span><br><span class="line">kill -9 $PID</span><br><span class="line">echo line $LN pid $PID is killed.</span><br><span class="line">done</span><br><span class="line">else</span><br><span class="line">echo line $LN is not running.</span><br><span class="line">fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kill_grc()</span><br><span class="line">&#123;</span><br><span class="line">kill -9  $(ps -ef|grep grc.jar$suffix |grep -v grep|awk &#39;&#123;print $2&#125;&#39;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">start_grc()</span><br><span class="line">&#123;</span><br><span class="line">cd grc</span><br><span class="line">rm -rf .&#x2F;lib</span><br><span class="line">unzip lib.zip</span><br><span class="line">rm -rf grc.jar$suffix</span><br><span class="line">cp grc.jar grc.jar$suffix</span><br><span class="line">nohup java -jar .&#x2F;grc.jar$suffix  -Xms1G -Xmx2G &gt;&gt;&#x2F;dev&#x2F;null  2&gt;&gt;&#x2F;tmp&#x2F;grc.err$suffix &amp;</span><br><span class="line">cd ..</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">start()</span><br><span class="line">&#123;</span><br><span class="line">mkdir -p logs</span><br><span class="line">        export LD_LIBRARY_PATH&#x3D;.:..&#x2F;..&#x2F;lib</span><br><span class="line">ulimit -c unlimited</span><br><span class="line">ulimit -n 4096</span><br><span class="line"></span><br><span class="line">if [ ! -z $1 ]; then</span><br><span class="line">                start_line $1</span><br><span class="line">return</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">exists zlogd</span><br><span class="line">if [ $? -eq 0 ]; then</span><br><span class="line">cd zlogd</span><br><span class="line">echo &#39;start zlogd service&#39;</span><br><span class="line">nohup setsid .&#x2F;zlogd$suffix zlogd.conf &amp;&gt;&#x2F;dev&#x2F;null &amp;</span><br><span class="line">sleep 2</span><br><span class="line">cd ..</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">exists gdeliveryd</span><br><span class="line">if [ $? -eq 0 ]; then</span><br><span class="line">cd gdeliveryd</span><br><span class="line">echo &#39;start DS service&#39;</span><br><span class="line">nohup setsid .&#x2F;gdeliveryd$suffix gdeliveryd.conf &amp;&gt;..&#x2F;logs&#x2F;gdelivery.log  &amp;</span><br><span class="line">#nohup setsid valgrind --log-file&#x3D;..&#x2F;logs&#x2F;valgrind_ds.log .&#x2F;gdeliveryd$suffix gdeliveryd.conf &amp;&gt;..&#x2F;logs&#x2F;gdelivery.log  &amp;</span><br><span class="line">cd ..</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">exists glinkd</span><br><span class="line">if [ $? -eq 0 ]; then</span><br><span class="line">cd glinkd</span><br><span class="line">echo &#39;start LS service&#39;</span><br><span class="line">nohup setsid .&#x2F;glinkd$suffix --ccs glinkd.conf &amp;&gt;..&#x2F;logs&#x2F;glinkd.ccs.log  &amp;</span><br><span class="line">for ((i &#x3D; 1; i &lt;&#x3D; $LINK_NUM; i++))</span><br><span class="line">do</span><br><span class="line">nohup setsid .&#x2F;glinkd$suffix --cls -i $i glinkd.conf &amp;&gt;..&#x2F;logs&#x2F;glinkd.cls$i.log  &amp;</span><br><span class="line">done</span><br><span class="line">cd ..</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">exists gamedbd</span><br><span class="line">if [ $? -eq 0 ]; then</span><br><span class="line">cd gamedbd</span><br><span class="line">echo &#39;start DB service&#39;</span><br><span class="line">nohup setsid .&#x2F;gamedbd$suffix gamedbd.conf &amp;&gt;..&#x2F;logs&#x2F;gamedbd.log &amp;</span><br><span class="line">cd ..</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ $UNAMED_ACTIVE -eq 1 ]; then</span><br><span class="line">exists unamed</span><br><span class="line">if [ $? -eq 0 ]; then</span><br><span class="line">cd unamed</span><br><span class="line">echo &#39;start unamed service&#39;</span><br><span class="line">nohup setsid .&#x2F;unamed$suffix unamed.conf &amp;&gt;..&#x2F;logs&#x2F;unamed.log &amp;</span><br><span class="line">cd ..</span><br><span class="line">fi</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">#exists gonlineinfod</span><br><span class="line">#if [ $? -eq 0 ]; then</span><br><span class="line">#cd gonlineinfod</span><br><span class="line">#echo &#39;start OL service&#39;</span><br><span class="line">#nohup setsid .&#x2F;gonlineinfod$suffix gonlineinfod.conf &amp;&gt;..&#x2F;logs&#x2F;gonlineinfod.log  &amp;</span><br><span class="line">#cd ..</span><br><span class="line">#fi</span><br><span class="line"></span><br><span class="line">#start_grc</span><br><span class="line"></span><br><span class="line">start_line</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stop()</span><br><span class="line">&#123;</span><br><span class="line">if [ ! -z $1 ]; then</span><br><span class="line">                kill_line $1</span><br><span class="line">return</span><br><span class="line">fi</span><br><span class="line">#kill_grc</span><br><span class="line">kill_process glinkd KILL</span><br><span class="line">kill_process gdeliveryd KILL</span><br><span class="line">kill_process gamedbd USR1</span><br><span class="line">#kill_process gonlineinfod KILL</span><br><span class="line">if [ $UNAMED_ACTIVE -eq 1 ]; then</span><br><span class="line">kill_process unamed USR1</span><br><span class="line">fi</span><br><span class="line">        for LN in $LINELIST</span><br><span class="line">        do</span><br><span class="line">                kill_line $LN</span><br><span class="line">        done</span><br><span class="line">kill_process zlogd KILL</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">wait()</span><br><span class="line">&#123;</span><br><span class="line">for (( i&#x3D;0; i&lt;5; i++))</span><br><span class="line">do</span><br><span class="line">echo -n &quot;.&quot;</span><br><span class="line">sleep 0.2</span><br><span class="line">done</span><br><span class="line">echo &quot;.&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">restart()</span><br><span class="line">&#123;</span><br><span class="line">        stop $1</span><br><span class="line">if [ ! -z $1 ]; then</span><br><span class="line">wait</span><br><span class="line">else</span><br><span class="line">PROGRAME_ACTIVE&#x3D;1;</span><br><span class="line">while [ &quot;$PROGRAME_ACTIVE&quot; !&#x3D; &quot;0&quot; ]</span><br><span class="line">do</span><br><span class="line">wait</span><br><span class="line">status</span><br><span class="line">echo $PROGRAME_ACTIVE program is running</span><br><span class="line">done</span><br><span class="line">fi</span><br><span class="line">        start $1</span><br><span class="line">wait</span><br><span class="line">echo &#39;task accomplished&#39;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">case $1 in </span><br><span class="line">start) </span><br><span class="line">        start $2</span><br><span class="line">        ;; </span><br><span class="line">stop)</span><br><span class="line">        stop $2</span><br><span class="line">        ;; </span><br><span class="line">restart)</span><br><span class="line">        restart $2</span><br><span class="line">        ;; </span><br><span class="line">status)</span><br><span class="line">        status </span><br><span class="line">        ;; </span><br><span class="line">*) </span><br><span class="line">        usage </span><br><span class="line">        ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      进程启停自定义脚本
    
    </summary>
    
    
      <category term="SHELL" scheme="https://shuke163.github.io/categories/SHELL/"/>
    
    
      <category term="SHELL" scheme="https://shuke163.github.io/tags/SHELL/"/>
    
  </entry>
  
  <entry>
    <title>维护JAVA服务脚本示例</title>
    <link href="https://shuke163.github.io/2020/04/20/index/"/>
    <id>https://shuke163.github.io/2020/04/20/index/</id>
    <published>2020-04-20T07:54:29.000Z</published>
    <updated>2020-04-20T07:54:49.492Z</updated>
    
    <content type="html"><![CDATA[<h3 id="维护JAVA服务脚本示例"><a href="#维护JAVA服务脚本示例" class="headerlink" title="维护JAVA服务脚本示例"></a>维护JAVA服务脚本示例</h3><p>start_env.sh</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">CURRENT_PATH&#x3D;$(cd &#96;dirname $0&#96;; pwd)</span><br><span class="line">PARENT_PATH&#x3D;$(cd &#96;dirname $0&#96;; cd ..; pwd)</span><br><span class="line">CURRENT_SERVICE_NAME&#x3D;$(echo $&#123;CURRENT_PATH&#125; | awk -F &#39;&#x2F;&#39; &#39;&#123;print $(NF)&#125;&#39;)</span><br><span class="line"></span><br><span class="line"># USE THOSE VARIABLE</span><br><span class="line">GC_LOG_PATH&#x3D;$&#123;CURRENT_PATH&#125;&#x2F;logs&#x2F;$&#123;CURRENT_SERVICE_NAME&#125;-gcdetail.log</span><br><span class="line">COMMON_CONFIG_PATH&#x3D;$&#123;PARENT_PATH&#125;</span><br><span class="line">CONFIG_PATH&#x3D;$&#123;CURRENT_PATH&#125;&#x2F;config</span><br><span class="line">JAR_PATH&#x3D;$&#123;CURRENT_PATH&#125;&#x2F;jar</span><br><span class="line">LOG_PATH&#x3D;$&#123;CURRENT_PATH&#125;&#x2F;logs</span><br><span class="line"></span><br><span class="line">## MODIFY FOLLOWING LINES</span><br><span class="line">EXECUT_JAR&#x3D;&quot;america-business-auth-impl-1.0-SNAPSHOT-all.jar&quot;</span><br><span class="line">DUBBO_PARAMETER&#x3D;&quot;</span><br><span class="line">-Dapp.id&#x3D;america-business-auth</span><br><span class="line">-Xdebug</span><br><span class="line">-server</span><br><span class="line">-Xmx512m</span><br><span class="line">-Xms512m</span><br><span class="line">-Xnoagent</span><br><span class="line">-XX:+PrintGCDateStamps</span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-XX:NewRatio&#x3D;2</span><br><span class="line">-XX:SurvivorRatio&#x3D;8</span><br><span class="line">-XX:MetaspaceSize&#x3D;128m</span><br><span class="line">-XX:MaxMetaspaceSize&#x3D;128m</span><br><span class="line">-Xloggc:$&#123;GC_LOG_PATH&#125;</span><br><span class="line">-Ddubbo.registry.file&#x3D;$&#123;JAR_PATH&#125;&#x2F;dubbo.cache</span><br><span class="line">-Dconfig.path&#x3D;file:$&#123;COMMON_CONFIG_PATH&#125;&#x2F;common.properties;file:$&#123;CONFIG_PATH&#125;&#x2F;config.properties</span><br><span class="line">$&#123;JAR_PATH&#125;&#x2F;$&#123;EXECUT_JAR&#125;</span><br><span class="line">&quot;</span><br><span class="line">## STOP MODIFY</span><br><span class="line"></span><br><span class="line">java -jar $&#123;DUBBO_PARAMETER&#125; | &#x2F;usr&#x2F;bin&#x2F;cronolog $LOG_PATH&#x2F;out.%Y%m%d.nohup &gt;&gt; &#x2F;dev&#x2F;null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><p>service_control.sh</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">#set -x</span><br><span class="line"></span><br><span class="line">source &#x2F;etc&#x2F;profile</span><br><span class="line"></span><br><span class="line"># USE THOSE VARIABLE</span><br><span class="line">CURRENT_PATH&#x3D;$(cd &#96;dirname $0&#96;; pwd)</span><br><span class="line">PARENT_PATH&#x3D;$(cd &#96;dirname $0&#96;; cd ..; pwd)</span><br><span class="line">CURRENT_SERVICE_NAME&#x3D;$(echo $&#123;CURRENT_PATH&#125; | awk -F &#39;&#x2F;&#39; &#39;&#123;print $(NF)&#125;&#39;)</span><br><span class="line">STOP_WAIT_TIME&#x3D;10</span><br><span class="line">CURRENT_TIME&#x3D;&#96;date +%Y%m%d-%H%M%S&#96;</span><br><span class="line"></span><br><span class="line">DUMP_PATH&#x3D;$&#123;CURRENT_PATH&#125;&#x2F;dump</span><br><span class="line">LOG_PATH&#x3D;$&#123;CURRENT_PATH&#125;&#x2F;logs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">log() &#123;</span><br><span class="line">    echo &quot;$(date +&quot;%Y-%m-%d %H:%M:%S&quot;): $1&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exit_status() &#123;</span><br><span class="line">    if [ $? &#x3D;&#x3D; 0 ]</span><br><span class="line">    then</span><br><span class="line">        echo -e &quot;\\033[1;32m[OK]\\033[0;39m&quot;</span><br><span class="line">    else</span><br><span class="line">        echo -e &quot;\\033[1;31m[Failed]\\033[0;39m&quot;</span><br><span class="line">        log &quot;Error&quot;</span><br><span class="line">        exit 1</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">check_user() &#123;</span><br><span class="line">    if [ &#96;whoami&#96; !&#x3D; &quot;app&quot; || &#96;whoami&#96; !&#x3D; &quot;root&quot; ]; then</span><br><span class="line">        log &quot;Please use app user to run this command.&quot;</span><br><span class="line">        false</span><br><span class="line">        exit_status</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stop_service() &#123;</span><br><span class="line"></span><br><span class="line">    log &quot;Stop Service Service: $&#123;CURRENT_SERVICE_NAME&#125;&quot;</span><br><span class="line">    Service_NUM&#x3D;&#96;ps -ef|grep $&#123;CURRENT_SERVICE_NAME&#125;&#x2F;jar&#x2F;|grep -v grep|grep -v cronolog|grep -v $0|awk &#39;&#123;print $2&#125;&#39;|wc -l&#96;</span><br><span class="line">    if [ $((Service_NUM)) -gt 1 ]</span><br><span class="line">    then</span><br><span class="line">        log &quot;Service: $&#123;CURRENT_SERVICE_NAME&#125; run more than one process&quot;</span><br><span class="line">        false</span><br><span class="line">        exit_status</span><br><span class="line">    fi</span><br><span class="line">    Service_PID&#x3D;&#96;ps -ef|grep $&#123;CURRENT_SERVICE_NAME&#125;&#x2F;jar&#x2F;|grep -v grep|grep -v cronolog|grep -v $0|awk &#39;&#123;print $2&#125;&#39;&#96;</span><br><span class="line">    if [ x$Service_PID &#x3D;&#x3D; x ];then</span><br><span class="line">        log &quot;Service: $&#123;CURRENT_SERVICE_NAME&#125; process is NOT exist&quot;</span><br><span class="line">        exit_status</span><br><span class="line">    else</span><br><span class="line">        log &quot;KILL Service Service: $&#123;CURRENT_SERVICE_NAME&#125;&quot;</span><br><span class="line">        kill  $Service_PID</span><br><span class="line">        exit_status</span><br><span class="line">    fi</span><br><span class="line">    echo &quot;&quot;</span><br><span class="line">    log &quot;Search Service Process ...&quot;</span><br><span class="line">    Check&#x3D;N</span><br><span class="line">    N&#x3D;0</span><br><span class="line">    while [ $Check &#x3D;&#x3D; &quot;N&quot; ]</span><br><span class="line">    do</span><br><span class="line">        N&#x3D;$(($N+1))</span><br><span class="line">        Service_PID&#x3D;&#96;ps -ef|grep $&#123;CURRENT_SERVICE_NAME&#125;&#x2F;jar&#x2F;|grep -v grep|grep -v cronolog|grep -v $0|awk &#39;&#123;print $2&#125;&#39;&#96;</span><br><span class="line"></span><br><span class="line">        if [ &quot;$Service_PID&quot; &#x3D; &quot;&quot; ]</span><br><span class="line">        then</span><br><span class="line">            log &quot;Not found Service PID alive&quot;</span><br><span class="line">            break</span><br><span class="line">        else</span><br><span class="line">            log &quot;$N: Check Service PID:$Service_PID, Sleep 1 Sec Wait Service Exit ...&quot;</span><br><span class="line">        fi</span><br><span class="line"></span><br><span class="line">        if [ $((N)) -gt $STOP_WAIT_TIME ]</span><br><span class="line">        then</span><br><span class="line">            log &quot;Force KILL Service: $&#123;CURRENT_SERVICE_NAME&#125;&quot;</span><br><span class="line">            #jstack $Service_PID &gt;&gt; &#x2F;var&#x2F;log&#x2F;jstack.log</span><br><span class="line">            #skill -9 $Service_PID</span><br><span class="line">            kill -9 $Service_PID</span><br><span class="line">            exit_status</span><br><span class="line">            break</span><br><span class="line">        fi</span><br><span class="line">        sleep 1</span><br><span class="line">    done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">start_service() &#123;</span><br><span class="line"></span><br><span class="line">    log &quot;Start Service Service: $&#123;CURRENT_SERVICE_NAME&#125;&quot;</span><br><span class="line">    Service_NUM&#x3D;&#96;ps -ef|grep $&#123;CURRENT_SERVICE_NAME&#125;&#x2F;jar&#x2F; | grep -v grep |grep -v $0|awk &#39;&#123;print $2&#125;&#39;|wc -l&#96;</span><br><span class="line">    if [ $((Service_NUM)) -gt 0 ]</span><br><span class="line">    then</span><br><span class="line">        log &quot;Service: $&#123;CURRENT_SERVICE_NAME&#125; already running&quot;</span><br><span class="line">        false</span><br><span class="line">        exit_status</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    if [ ! -d $LOG_PATH ]; then</span><br><span class="line">        mkdir -p $LOG_PATH</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    nohup &#x2F;bin&#x2F;bash $CURRENT_PATH&#x2F;start_env.sh &amp;&gt;&gt; &#x2F;dev&#x2F;null &amp;</span><br><span class="line"></span><br><span class="line">    #exit_status</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status() &#123;</span><br><span class="line"></span><br><span class="line">    Service_NUM&#x3D;&#96;ps -ef|grep $&#123;CURRENT_SERVICE_NAME&#125;&#x2F;jar&#x2F;|grep -v grep|grep -v cronolog|grep -v $0|awk &#39;&#123;print $2&#125;&#39;|wc -l&#96;</span><br><span class="line">    if [ $((Service_NUM)) -gt 1 ]</span><br><span class="line">    then</span><br><span class="line">        echo &quot;Service run more than one process,please check&quot;</span><br><span class="line">        false</span><br><span class="line">        exit_status</span><br><span class="line">    fi</span><br><span class="line">    Service_PID&#x3D;&#96;ps -ef|grep $&#123;CURRENT_SERVICE_NAME&#125;&#x2F;jar&#x2F;|grep -v grep|grep -v cronolog|grep -v $0|awk &#39;&#123;print $2&#125;&#39;&#96;</span><br><span class="line">    if [ x$Service_PID &#x3D;&#x3D; x ];then</span><br><span class="line">        echo &quot;Service: $&#123;CURRENT_SERVICE_NAME&#125; process is NOT exist&quot;</span><br><span class="line">        false</span><br><span class="line">        exit_status</span><br><span class="line">    else</span><br><span class="line">        Service_startTime&#x3D;&#96;ps -p $&#123;Service_PID&#125; -o lstart|grep -v &quot;START&quot;&#96;</span><br><span class="line">        echo -e &quot;service: $&#123;CURRENT_SERVICE_NAME&#125; started,\npid: $&#123;Service_PID&#125;,\nstartTime: $&#123;Service_startTime&#125;,\nlogPath: $&#123;LOG_PATH&#125;&#x2F;out.&#96;date +%Y%m%d&#96;.nohup&quot;</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dump() &#123;</span><br><span class="line">    if [ ! -d $DUMP_PATH ]; then</span><br><span class="line">        mkdir -p $DUMP_PATH</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    echo -e &quot;Dumping the $&#123;CURRENT_SERVICE_NAME&#125; ...\c&quot;</span><br><span class="line">    sudo &#x2F;usr&#x2F;local&#x2F;jdk&#x2F;bin&#x2F;jstack $Service_PID &gt; $DUMP_PATH&#x2F;jstack-$Service_PID.$&#123;CURRENT_TIME&#125;.dump 2&gt;&amp;1</span><br><span class="line">    echo -e &quot;.\c&quot;</span><br><span class="line">    sudo &#x2F;usr&#x2F;local&#x2F;jdk&#x2F;bin&#x2F;jinfo $Service_PID &gt; $DUMP_PATH&#x2F;jinfo-$Service_PID.$&#123;CURRENT_TIME&#125;.dump 2&gt;&amp;1</span><br><span class="line">    echo -e &quot;.\c&quot;</span><br><span class="line">    sudo &#x2F;usr&#x2F;local&#x2F;jdk&#x2F;bin&#x2F;jstat -gcutil $Service_PID &gt; $DUMP_PATH&#x2F;jstat-gcutil-$Service_PID.$&#123;CURRENT_TIME&#125;.dump 2&gt;&amp;1</span><br><span class="line">    echo -e &quot;.\c&quot;</span><br><span class="line">    sudo &#x2F;usr&#x2F;local&#x2F;jdk&#x2F;bin&#x2F;jstat -gccapacity $Service_PID &gt; $DUMP_PATH&#x2F;jstat-gccapacity-$Service_PID.$&#123;CURRENT_TIME&#125;.dump 2&gt;&amp;1</span><br><span class="line">    echo -e &quot;.\c&quot;</span><br><span class="line">    sudo &#x2F;usr&#x2F;local&#x2F;jdk&#x2F;bin&#x2F;jmap $Service_PID &gt; $DUMP_PATH&#x2F;jmap-$Service_PID.$&#123;CURRENT_TIME&#125;.dump 2&gt;&amp;1</span><br><span class="line">    echo -e &quot;.\c&quot;</span><br><span class="line">    sudo &#x2F;usr&#x2F;local&#x2F;jdk&#x2F;bin&#x2F;jmap -heap $Service_PID &gt; $DUMP_PATH&#x2F;jmap-heap-$Service_PID.$&#123;CURRENT_TIME&#125;.dump 2&gt;&amp;1</span><br><span class="line">    echo -e &quot;.\c&quot;</span><br><span class="line">    sudo &#x2F;usr&#x2F;local&#x2F;jdk&#x2F;bin&#x2F;jmap -histo $Service_PID &gt; $DUMP_PATH&#x2F;jmap-histo-$Service_PID.$&#123;CURRENT_TIME&#125;.dump 2&gt;&amp;1</span><br><span class="line">    echo -e &quot;.\c&quot;</span><br><span class="line">    if [ -r &#x2F;usr&#x2F;sbin&#x2F;lsof ]; then</span><br><span class="line">    &#x2F;usr&#x2F;sbin&#x2F;lsof -p $Service_PID &gt; $DUMP_PATH&#x2F;lsof-$Service_PID.$&#123;CURRENT_TIME&#125;.dump</span><br><span class="line">    echo -e &quot;.\c&quot;</span><br><span class="line">    fi</span><br><span class="line">    echo -e &quot;\nDump Complete, files in $&#123;DUMP_PATH&#125;\n&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tail_log() &#123;</span><br><span class="line">    if [ ! -n &quot;$1&quot; ] ; then</span><br><span class="line">        tail_num&#x3D;10</span><br><span class="line">    else</span><br><span class="line">        tail_num&#x3D;$1</span><br><span class="line">    fi</span><br><span class="line">    tail -$&#123;tail_num&#125;f $&#123;LOG_PATH&#125;&#x2F;out.&#96;date +%Y%m%d&#96;.nohup</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">help() &#123;</span><br><span class="line">    echo &quot;USAGE: $0 &#123;stop|start|restart|status|dump|log [tail line of numbers:200]|help&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if [ $# -gt 0 ] ; then</span><br><span class="line"></span><br><span class="line">    case $1 in</span><br><span class="line">    start)</span><br><span class="line">        log &quot;Will Start Service ...&quot;</span><br><span class="line">        start_service</span><br><span class="line">        log &quot;Sleep 3 Sec for Status ...&quot;</span><br><span class="line">        sleep 3</span><br><span class="line">        status</span><br><span class="line">        ;;</span><br><span class="line">    stop)</span><br><span class="line">        log &quot;Will Stop Service ...&quot;</span><br><span class="line">        stop_service</span><br><span class="line">        ;;</span><br><span class="line">    restart)</span><br><span class="line">        log &quot;Will Restart Service ...&quot;</span><br><span class="line"></span><br><span class="line">        stop_service</span><br><span class="line">        log &quot;Sleep 3 Sec&quot;</span><br><span class="line">        sleep 3</span><br><span class="line"></span><br><span class="line">        start_service</span><br><span class="line">        log &quot;Sleep 3 Sec for Status ...&quot;</span><br><span class="line">        sleep 3</span><br><span class="line">        status</span><br><span class="line">        ;;</span><br><span class="line">    status)</span><br><span class="line">        status</span><br><span class="line">        ;;</span><br><span class="line">    dump)</span><br><span class="line">        check_user</span><br><span class="line">        status</span><br><span class="line">        if [ $? &#x3D;&#x3D; 0 ]</span><br><span class="line">        then</span><br><span class="line">            dump</span><br><span class="line">        else</span><br><span class="line">            exit 1</span><br><span class="line">        fi</span><br><span class="line"></span><br><span class="line">        ;;</span><br><span class="line">    log)</span><br><span class="line">        tail_log $2</span><br><span class="line">        ;;</span><br><span class="line">    help)</span><br><span class="line">        help</span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">        echo &quot;Bad Parameter: $1&quot;</span><br><span class="line">        help</span><br><span class="line">        exit 1</span><br><span class="line">        ;;</span><br><span class="line">    esac</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line">    help</span><br><span class="line">    exit 1;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      维护JAVA服务脚本示例
    
    </summary>
    
    
      <category term="SHELL" scheme="https://shuke163.github.io/categories/SHELL/"/>
    
    
      <category term="SHELL" scheme="https://shuke163.github.io/tags/SHELL/"/>
    
  </entry>
  
  <entry>
    <title>python操作zabbix API</title>
    <link href="https://shuke163.github.io/2020/04/20/index/"/>
    <id>https://shuke163.github.io/2020/04/20/index/</id>
    <published>2020-04-20T07:53:14.000Z</published>
    <updated>2020-04-20T07:53:32.916Z</updated>
    
    <content type="html"><![CDATA[<h2 id="python操作zabbix-API"><a href="#python操作zabbix-API" class="headerlink" title="python操作zabbix API"></a>python操作zabbix API</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">import json</span><br><span class="line">import urllib2</span><br><span class="line">import sys</span><br><span class="line">class zabbixtools:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.url &#x3D; &quot;http:&#x2F;&#x2F;192.168.1.1&#x2F;zabbix&#x2F;api_jsonrpc.php&quot;</span><br><span class="line">        self.header &#x3D; &#123;&quot;Content-Type&quot;: &quot;application&#x2F;json&quot;&#125;</span><br><span class="line">        self.authID &#x3D; self.user_login()</span><br><span class="line">    def user_login(self):</span><br><span class="line">        data &#x3D; json.dumps(</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;jsonrpc&quot;: &quot;2.0&quot;,</span><br><span class="line">                    &quot;method&quot;: &quot;user.login&quot;,</span><br><span class="line">                    &quot;params&quot;: &#123;</span><br><span class="line">                        &quot;user&quot;: &quot;Admin&quot;,</span><br><span class="line">                        &quot;password&quot;: &quot;admin&quot;</span><br><span class="line">                        &#125;,</span><br><span class="line">                    &quot;id&quot;: 0</span><br><span class="line">                    &#125;)</span><br><span class="line">        request &#x3D; urllib2.Request(self.url,data)</span><br><span class="line">        for key in self.header:</span><br><span class="line">            request.add_header(key,self.header[key])</span><br><span class="line">        try:</span><br><span class="line">            result &#x3D; urllib2.urlopen(request)</span><br><span class="line">        except URLError as e:</span><br><span class="line">            print &quot;Auth Failed, Please Check Your Name And Password:&quot;,e.code</span><br><span class="line">        else:</span><br><span class="line">            response &#x3D; json.loads(result.read())</span><br><span class="line">            result.close()</span><br><span class="line">            authID &#x3D; response[&#39;result&#39;]</span><br><span class="line">            return authID</span><br><span class="line">    def get_data(self,data,hostip&#x3D;&quot;&quot;):</span><br><span class="line">        request &#x3D; urllib2.Request(self.url,data)</span><br><span class="line">        for key in self.header:</span><br><span class="line">            request.add_header(key,self.header[key])</span><br><span class="line">        try:</span><br><span class="line">            result &#x3D; urllib2.urlopen(request)</span><br><span class="line">        except URLError as e:</span><br><span class="line">            if hasattr(e, &#39;reason&#39;):</span><br><span class="line">                print &#39;We failed to reach a server.&#39;</span><br><span class="line">                print &#39;Reason: &#39;, e.reason</span><br><span class="line">            elif hasattr(e, &#39;code&#39;):</span><br><span class="line">                print &#39;The server could not fulfill the request.&#39;</span><br><span class="line">                print &#39;Error code: &#39;, e.code</span><br><span class="line">            return 0</span><br><span class="line">        else:</span><br><span class="line">            response &#x3D; json.loads(result.read())</span><br><span class="line">            result.close()</span><br><span class="line">            return response</span><br><span class="line">    def host_get(self,hostip):</span><br><span class="line">        #hostip &#x3D; raw_input(&quot;\033[1;35;40m%s\033[0m&quot; % &#39;Enter Your Check Host:Host_ip :&#39;)</span><br><span class="line">        data &#x3D; json.dumps(</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;jsonrpc&quot;: &quot;2.0&quot;,</span><br><span class="line">                    &quot;method&quot;: &quot;host.get&quot;,</span><br><span class="line">                    &quot;params&quot;: &#123;</span><br><span class="line">                        &quot;output&quot;:[&quot;hostid&quot;,&quot;name&quot;,&quot;status&quot;,&quot;host&quot;],</span><br><span class="line">                        &quot;filter&quot;: &#123;&quot;host&quot;: [hostip]&#125;</span><br><span class="line">                        &#125;,</span><br><span class="line">                    &quot;auth&quot;: self.authID,</span><br><span class="line">                    &quot;id&quot;: 1</span><br><span class="line">                &#125;)</span><br><span class="line">        res &#x3D; self.get_data(data)[&#39;result&#39;]</span><br><span class="line">        if (res !&#x3D; 0) and (len(res) !&#x3D; 0):</span><br><span class="line">            #for host in res:</span><br><span class="line">            host &#x3D; res[0]</span><br><span class="line">            if host[&#39;status&#39;] &#x3D;&#x3D; &#39;1&#39;:</span><br><span class="line">                print &quot;\t&quot;,&quot;\033[1;31;40m%s\033[0m&quot; % &quot;Host_IP:&quot;,&quot;\033[1;31;40m%s\033[0m&quot; %host[&#39;host&#39;].ljust(15),&#39;\t&#39;,&quot;\033[1;31;40m%s\033[0m&quot; % &quot;Host_Name:&quot;,&quot;\033[1;31;40m%s\033[0m&quot;% host[&#39;name&#39;].encode(&#39;GBK&#39;),&#39;\t&#39;,&quot;\033[1;31;40m%s\033[0m&quot; % u&#39;monitor&#39;.encode(&#39;GBK&#39;)</span><br><span class="line">                return host[&#39;hostid&#39;]</span><br><span class="line">            elif host[&#39;status&#39;] &#x3D;&#x3D; &#39;0&#39;:</span><br><span class="line">                print &quot;\t&quot;,&quot;\033[1;32;40m%s\033[0m&quot; % &quot;Host_IP:&quot;,&quot;\033[1;32;40m%s\033[0m&quot; %host[&#39;host&#39;].ljust(15),&#39;\t&#39;,&quot;\033[1;32;40m%s\033[0m&quot; % &quot;Host_Name:&quot;,&quot;\033[1;32;40m%s\033[0m&quot;% host[&#39;name&#39;].encode(&#39;GBK&#39;),&#39;\t&#39;,&quot;\033[1;32;40m%s\033[0m&quot; % u&#39;unmonitor&#39;.encode(&#39;GBK&#39;)</span><br><span class="line">                return host[&#39;hostid&#39;]</span><br><span class="line">            print</span><br><span class="line">        else:</span><br><span class="line">            print &#39;\t&#39;,&quot;\033[1;31;40m%s\033[0m&quot; % &quot;Get Host Error or cannot find this host,please check !&quot;</span><br><span class="line">            return 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def get_grouphost(self):</span><br><span class="line">        groupid &#x3D; raw_input(&quot;\033[1;35;40m%s\033[0m&quot; % &#39;Enter Your groupid:&#39;)</span><br><span class="line">        data &#x3D; json.dumps(</span><br><span class="line">            &#123;</span><br><span class="line">               &quot;jsonrpc&quot;:&quot;2.0&quot;,</span><br><span class="line">               &quot;method&quot;:&quot;host.get&quot;,</span><br><span class="line">               &quot;params&quot;:&#123;</span><br><span class="line">                   &quot;output&quot;:[&quot;hostid&quot;,&quot;name&quot;,&quot;status&quot;,&quot;host&quot;],</span><br><span class="line">                   #&quot;output&quot;: &quot;extend&quot;,</span><br><span class="line">                   #&quot;filter&quot;: &#123;&quot;host&quot;: [&quot;42.62.121.16&quot;]&#125;</span><br><span class="line">                   &quot;groupids&quot;:groupid,</span><br><span class="line">               &#125;,</span><br><span class="line">               &quot;auth&quot;: self.authID, </span><br><span class="line">               &quot;id&quot;:1,</span><br><span class="line">            &#125;)</span><br><span class="line">        res &#x3D; self.get_data(data)</span><br><span class="line">        if &#39;result&#39; in res.keys():</span><br><span class="line">            res &#x3D; res[&#39;result&#39;]</span><br><span class="line">            if (res !&#x3D;0) or (len(res) !&#x3D; 0):</span><br><span class="line">                print &quot;\033[1;32;40m%s\033[0m&quot; % &quot;Number Of Hosts: &quot;,&quot;\033[1;31;40m%d\033[0m&quot; % len(res)</span><br><span class="line">                for host in res:</span><br><span class="line">                    print &quot;Host ID:&quot;,host[&#39;hostid&#39;],&quot;Visible name:&quot;,host[&#39;name&#39;],&quot;Host-status:&quot;,host[&#39;status&#39;],&quot;HostName:&quot;,host[&#39;host&#39;]</span><br><span class="line">        else:</span><br><span class="line">            print &quot;The groupid does not exist, please check!&quot;</span><br><span class="line">            return 0</span><br><span class="line"></span><br><span class="line">    def get_hostlist(self):</span><br><span class="line">        data &#x3D; json.dumps(</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;jsonrpc&quot;:&quot;2.0&quot;,</span><br><span class="line">                    &quot;method&quot;:&quot;host.get&quot;,</span><br><span class="line">                    &quot;params&quot;:&#123;</span><br><span class="line">                        &quot;output&quot;:[&quot;hostid&quot;,&quot;name&quot;],</span><br><span class="line">                        &quot;filter&quot;:&#123;&quot;host&quot;:&quot;&quot;&#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;auth&quot;:self.authID, </span><br><span class="line">                &quot;id&quot;:1,</span><br><span class="line">            &#125;)</span><br><span class="line">        res &#x3D; self.get_data(data)</span><br><span class="line">        if &#39;result&#39; in res.keys():</span><br><span class="line">            res &#x3D; res[&#39;result&#39;]</span><br><span class="line">            if (res !&#x3D;0) or (len(res) !&#x3D; 0):</span><br><span class="line">                print &quot;\033[1;32;40m%s\033[0m&quot; % &quot;Number Of Hosts: &quot;,&quot;\033[1;31;40m%d\033[0m&quot; % len(res)</span><br><span class="line">                for host in res:</span><br><span class="line">                    print &quot;Host ID:&quot;,host[&#39;hostid&#39;].encode(&#39;UTF-8&#39;),&quot;Host Name:&quot;,host[&#39;name&#39;].encode(&#39;UTF-8&#39;)</span><br><span class="line">        else:</span><br><span class="line">            print &#39;\t&#39;,&quot;\033[1;31;40m%s\033[0m&quot; % &quot;Get hostlist Error or cannot find this host,please check !&quot;</span><br><span class="line">        return 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def host_del(self):</span><br><span class="line">        hostip &#x3D; raw_input(&quot;\033[1;35;40m%s\033[0m&quot; % &#39;Enter Your Check Host:Host_ip :&#39;)</span><br><span class="line">        hostid &#x3D; self.host_get(hostip)</span><br><span class="line">    print hostid</span><br><span class="line">        if hostid &#x3D;&#x3D; 0:</span><br><span class="line">            print &#39;\t&#39;,&quot;\033[1;31;40m%s\033[0m&quot; % &quot;This host cannot find in zabbix,please check it !&quot;</span><br><span class="line">            sys.exit()</span><br><span class="line">        data &#x3D; json.dumps(</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;jsonrpc&quot;: &quot;2.0&quot;,</span><br><span class="line">                    &quot;method&quot;: &quot;host.delete&quot;,</span><br><span class="line">                    &quot;params&quot;: [hostid],</span><br><span class="line">                    &quot;auth&quot;: self.authID,</span><br><span class="line">                    &quot;id&quot;: 1</span><br><span class="line">                &#125;)</span><br><span class="line">        res &#x3D; self.get_data(data)[&#39;result&#39;]</span><br><span class="line">        if &#39;hostids&#39; in res.keys():</span><br><span class="line">            print &quot;\t&quot;,&quot;\033[1;32;40m%s\033[0m&quot; % &quot;Delet Host:%s success !&quot; % hostip</span><br><span class="line">        else:</span><br><span class="line">            print &quot;\t&quot;,&quot;\033[1;31;40m%s\033[0m&quot; % &quot;Delet Host:%s failure !&quot; % hostip</span><br><span class="line">    def hostgroup_get(self):</span><br><span class="line">        data &#x3D; json.dumps(</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;jsonrpc&quot;: &quot;2.0&quot;,</span><br><span class="line">                    &quot;method&quot;: &quot;hostgroup.get&quot;,</span><br><span class="line">                    &quot;params&quot;: &#123;</span><br><span class="line">                        &quot;output&quot;: &quot;extend&quot;,</span><br><span class="line">                        &#125;,</span><br><span class="line">                    &quot;auth&quot;: self.authID,</span><br><span class="line">                    &quot;id&quot;: 1,</span><br><span class="line">                    &#125;)</span><br><span class="line">        res &#x3D; self.get_data(data)</span><br><span class="line">        if &#39;result&#39; in res.keys():</span><br><span class="line">            res &#x3D; res[&#39;result&#39;]</span><br><span class="line">            if (res !&#x3D;0) or (len(res) !&#x3D; 0):</span><br><span class="line">                print &quot;\033[1;32;40m%s\033[0m&quot; % &quot;Number Of Group: &quot;,&quot;\033[1;31;40m%d\033[0m&quot; % len(res)</span><br><span class="line">                for host in res:</span><br><span class="line">                    print&quot;\t&quot;,&quot;HostGroup_id:&quot;,host[&#39;groupid&#39;],&quot;\t&quot;,&quot;HostGroup_Name:&quot;,host[&#39;name&#39;].encode(&#39;GBK&#39;)</span><br><span class="line">        else:</span><br><span class="line">            print &quot;Get HostGroup Error,please check !&quot;</span><br><span class="line">    def template_get(self):</span><br><span class="line">        data &#x3D; json.dumps(</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;jsonrpc&quot;: &quot;2.0&quot;,</span><br><span class="line">                    &quot;method&quot;: &quot;template.get&quot;,</span><br><span class="line">                    &quot;params&quot;: &#123;</span><br><span class="line">                        &quot;output&quot;: &quot;extend&quot;,</span><br><span class="line">                        &#125;,</span><br><span class="line">                    &quot;auth&quot;: self.authID,</span><br><span class="line">                    &quot;id&quot;: 1,</span><br><span class="line">                    &#125;)</span><br><span class="line">        res &#x3D; self.get_data(data)#[&#39;result&#39;]</span><br><span class="line">        if &#39;result&#39; in res.keys():</span><br><span class="line">            res &#x3D; res[&#39;result&#39;]</span><br><span class="line">            if (res !&#x3D;0) or (len(res) !&#x3D; 0):</span><br><span class="line">                print &quot;\033[1;32;40m%s\033[0m&quot; % &quot;Number Of Template: &quot;,&quot;\033[1;31;40m%d\033[0m&quot; % len(res)</span><br><span class="line">                for host in res:</span><br><span class="line">                    print&quot;\t&quot;,&quot;Template_id:&quot;,host[&#39;templateid&#39;],&quot;\t&quot;,&quot;Template_Name:&quot;,host[&#39;name&#39;].encode(&#39;GBK&#39;)</span><br><span class="line">                print</span><br><span class="line">        else:</span><br><span class="line">            print &quot;Get Template Error,please check !&quot;</span><br><span class="line">    def host_create(self):</span><br><span class="line">        hostip &#x3D; raw_input(&quot;\033[1;35;40m%s\033[0m&quot; % &#39;Enter your:Host_ip :&#39;)</span><br><span class="line">        #Visible_name &#x3D; raw_input(&quot;\033[1;35;40m%s\033[0m&quot; % &#39;Enter your:Visible name :&#39;)</span><br><span class="line">        groupid &#x3D; raw_input(&quot;\033[1;35;40m%s\033[0m&quot; % &#39;Enter your:Group_id :&#39;)</span><br><span class="line">        templateid &#x3D; raw_input(&quot;\033[1;35;40m%s\033[0m&quot; % &#39;Enter your:Tempate_id :&#39;)</span><br><span class="line">        g_list&#x3D;[]</span><br><span class="line">        t_list&#x3D;[]</span><br><span class="line">        for i in groupid.split(&#39;,&#39;):</span><br><span class="line">            var &#x3D; &#123;&#125;</span><br><span class="line">            var[&#39;groupid&#39;] &#x3D; i</span><br><span class="line">            g_list.append(var)</span><br><span class="line">        for i in templateid.split(&#39;,&#39;):</span><br><span class="line">            var &#x3D; &#123;&#125;</span><br><span class="line">            var[&#39;templateid&#39;] &#x3D; i</span><br><span class="line">            t_list.append(var)</span><br><span class="line">        if hostip and groupid and templateid:</span><br><span class="line">            data &#x3D; json.dumps(</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;jsonrpc&quot;: &quot;2.0&quot;,</span><br><span class="line">                        &quot;method&quot;: &quot;host.create&quot;,</span><br><span class="line">                        &quot;params&quot;: &#123;</span><br><span class="line">                            &quot;host&quot;: hostip,</span><br><span class="line">                            &quot;interfaces&quot;: [</span><br><span class="line">                                &#123;</span><br><span class="line">                                    &quot;type&quot;: 1,</span><br><span class="line">                                    &quot;main&quot;: 1,</span><br><span class="line">                                    &quot;useip&quot;: 1,</span><br><span class="line">                                    &quot;ip&quot;: hostip,</span><br><span class="line">                                    &quot;dns&quot;: &quot;&quot;,</span><br><span class="line">                                    &quot;port&quot;: &quot;10050&quot;</span><br><span class="line">                                &#125;</span><br><span class="line">                            ],</span><br><span class="line">                            &quot;groups&quot;: g_list,</span><br><span class="line">                            &quot;templates&quot;: t_list,</span><br><span class="line">                    &#125;,</span><br><span class="line">                        &quot;auth&quot;: self.authID,</span><br><span class="line">                        &quot;id&quot;: 1,</span><br><span class="line">                        &#125;)</span><br><span class="line">            res &#x3D; self.get_data(data,hostip)</span><br><span class="line">            if &#39;result&#39; in res.keys():</span><br><span class="line">                res &#x3D; res[&#39;result&#39;]</span><br><span class="line">                if &#39;hostids&#39; in res.keys():</span><br><span class="line">                    print &quot;\033[1;32;40m%s\033[0m&quot; % &quot;Create host success&quot;</span><br><span class="line">            else:</span><br><span class="line">                print &quot;\033[1;31;40m%s\033[0m&quot; % &quot;Create host failure: %s&quot; % res[&#39;error&#39;][&#39;data&#39;]</span><br><span class="line">        else:</span><br><span class="line">            print &quot;\033[1;31;40m%s\033[0m&quot; % &quot;Enter Error: ip or groupid or tempateid is NULL,please check it !&quot;</span><br><span class="line">def main():</span><br><span class="line">    test &#x3D; zabbixtools()</span><br><span class="line">    #test.template_get()</span><br><span class="line">    #test.hostgroup_get()</span><br><span class="line">    #test.host_get()</span><br><span class="line">    #test.host_del()</span><br><span class="line">    #test.host_create()</span><br><span class="line">    #test.get_grouphost()</span><br><span class="line">    #test.get_hostlist()</span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      python操作zabbix API
    
    </summary>
    
    
      <category term="PYTHON" scheme="https://shuke163.github.io/categories/PYTHON/"/>
    
    
      <category term="PYTHON" scheme="https://shuke163.github.io/tags/PYTHON/"/>
    
  </entry>
  
</feed>
