<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>shuke&#39;s Blog</title>
  
  <subtitle>技术 管理 生活 格局 人生</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://shuke163.github.io/"/>
  <updated>2020-04-19T15:33:58.385Z</updated>
  <id>https://shuke163.github.io/</id>
  
  <author>
    <name>shuke</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="https://shuke163.github.io/2020/04/19/hello-world/"/>
    <id>https://shuke163.github.io/2020/04/19/hello-world/</id>
    <published>2020-04-19T15:33:58.385Z</published>
    <updated>2020-04-19T15:33:58.385Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Python 中更优雅的日志记录方案</title>
    <link href="https://shuke163.github.io/2020/04/19/1/"/>
    <id>https://shuke163.github.io/2020/04/19/1/</id>
    <published>2020-04-19T12:27:25.000Z</published>
    <updated>2020-04-19T15:20:58.728Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">优秀的人，不是不合群，而是他们合群的人里面没有你</blockquote><h2 id="Python-中更优雅的日志记录方案"><a href="#Python-中更优雅的日志记录方案" class="headerlink" title="Python 中更优雅的日志记录方案"></a>Python 中更优雅的日志记录方案</h2><p>在 Python 中，一般情况下我们可能直接用自带的 logging 模块来记录日志，包括我之前的时候也是一样。在使用时我们需要配置一些 Handler、Formatter 来进行一些处理，比如把日志输出到不同的位置，或者设置一个不同的输出格式，或者设置日志分块和备份。但其实个人感觉 logging 用起来其实并不是那么好用，其实主要还是配置较为繁琐.</p><h2 id="常见使用"><a href="#常见使用" class="headerlink" title="常见使用"></a>常见使用</h2><p>首先看看 logging 常见的解决方案吧，我一般会配置输出到文件、控制台和 Elasticsearch。输出到控制台就仅仅是方便直接查看的；输出到文件是方便直接存储，保留所有历史记录的备份；输出到 Elasticsearch，直接将 Elasticsearch 作为存储和分析的中心，使用 Kibana 可以非常方便地分析和查看运行情况。<br>所以在这里我基本会对 logging 做如下的封装写法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">mport logging</span><br><span class="line">import sys</span><br><span class="line">from os import makedirs</span><br><span class="line">from os.path import dirname, exists</span><br><span class="line"></span><br><span class="line">from cmreslogging.handlers import CMRESHandler</span><br><span class="line"></span><br><span class="line">loggers &#x3D; &#123;&#125;</span><br><span class="line"></span><br><span class="line">LOG_ENABLED &#x3D; True  # 是否开启日志</span><br><span class="line">LOG_TO_CONSOLE &#x3D; True  # 是否输出到控制台</span><br><span class="line">LOG_TO_FILE &#x3D; True  # 是否输出到文件</span><br><span class="line">LOG_TO_ES &#x3D; True  # 是否输出到 Elasticsearch</span><br><span class="line"></span><br><span class="line">LOG_PATH &#x3D; &#39;.&#x2F;runtime.log&#39;  # 日志文件路径</span><br><span class="line">LOG_LEVEL &#x3D; &#39;DEBUG&#39;  # 日志级别</span><br><span class="line">LOG_FORMAT &#x3D; &#39;%(levelname)s - %(asctime)s - process: %(process)d - %(filename)s - %(name)s - %(lineno)d - %(module)s - %(message)s&#39;  # 每条日志输出格式</span><br><span class="line">ELASTIC_SEARCH_HOST &#x3D; &#39;eshost&#39;  # Elasticsearch Host</span><br><span class="line">ELASTIC_SEARCH_PORT &#x3D; 9200  # Elasticsearch Port</span><br><span class="line">ELASTIC_SEARCH_INDEX &#x3D; &#39;runtime&#39;  # Elasticsearch Index Name</span><br><span class="line">APP_ENVIRONMENT &#x3D; &#39;dev&#39;  # 运行环境，如测试环境还是生产环境</span><br><span class="line"></span><br><span class="line">def get_logger(name&#x3D;None):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    get logger by name</span><br><span class="line">    :param name: name of logger</span><br><span class="line">    :return: logger</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    global loggers</span><br><span class="line"></span><br><span class="line">    if not name: name &#x3D; __name__</span><br><span class="line"></span><br><span class="line">    if loggers.get(name):</span><br><span class="line">        return loggers.get(name)</span><br><span class="line"></span><br><span class="line">    logger &#x3D; logging.getLogger(name)</span><br><span class="line">    logger.setLevel(LOG_LEVEL)</span><br><span class="line"></span><br><span class="line">    # 输出到控制台</span><br><span class="line">    if LOG_ENABLED and LOG_TO_CONSOLE:</span><br><span class="line">        stream_handler &#x3D; logging.StreamHandler(sys.stdout)</span><br><span class="line">        stream_handler.setLevel(level&#x3D;LOG_LEVEL)</span><br><span class="line">        formatter &#x3D; logging.Formatter(LOG_FORMAT)</span><br><span class="line">        stream_handler.setFormatter(formatter)</span><br><span class="line">        logger.addHandler(stream_handler)</span><br><span class="line"></span><br><span class="line">    # 输出到文件</span><br><span class="line">    if LOG_ENABLED and LOG_TO_FILE:</span><br><span class="line">        # 如果路径不存在，创建日志文件文件夹</span><br><span class="line">        log_dir &#x3D; dirname(log_path)</span><br><span class="line">        if not exists(log_dir): makedirs(log_dir)</span><br><span class="line">        # 添加 FileHandler</span><br><span class="line">        file_handler &#x3D; logging.FileHandler(log_path, encoding&#x3D;&#39;utf-8&#39;)</span><br><span class="line">        file_handler.setLevel(level&#x3D;LOG_LEVEL)</span><br><span class="line">        formatter &#x3D; logging.Formatter(LOG_FORMAT)</span><br><span class="line">        file_handler.setFormatter(formatter)</span><br><span class="line">        logger.addHandler(file_handler)</span><br><span class="line"></span><br><span class="line">    # 输出到 Elasticsearch</span><br><span class="line">    if LOG_ENABLED and LOG_TO_ES:</span><br><span class="line">        # 添加 CMRESHandler</span><br><span class="line">        es_handler &#x3D; CMRESHandler(hosts&#x3D;[&#123;&#39;host&#39;: ELASTIC_SEARCH_HOST, &#39;port&#39;: ELASTIC_SEARCH_PORT&#125;],</span><br><span class="line">                                  # 可以配置对应的认证权限</span><br><span class="line">                                  auth_type&#x3D;CMRESHandler.AuthType.NO_AUTH,  </span><br><span class="line">                                  es_index_name&#x3D;ELASTIC_SEARCH_INDEX,</span><br><span class="line">                                  # 一个月分一个 Index</span><br><span class="line">                                  index_name_frequency&#x3D;CMRESHandler.IndexNameFrequency.MONTHLY,</span><br><span class="line">                                  # 额外增加环境标识</span><br><span class="line">                                  es_additional_fields&#x3D;&#123;&#39;environment&#39;: APP_ENVIRONMENT&#125;  </span><br><span class="line">                                  )</span><br><span class="line">        es_handler.setLevel(level&#x3D;LOG_LEVEL)</span><br><span class="line">        formatter &#x3D; logging.Formatter(LOG_FORMAT)</span><br><span class="line">        es_handler.setFormatter(formatter)</span><br><span class="line">        logger.addHandler(es_handler)</span><br><span class="line"></span><br><span class="line">    # 保存到全局 loggers</span><br><span class="line">    loggers[name] &#x3D; logger</span><br><span class="line">    return logger</span><br></pre></td></tr></table></figure><p>定义完了怎么使用呢？只需要使用定义的方法获取一个 logger，然后 log 对应的内容即可:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">logger &#x3D; get_logger()</span><br><span class="line">logger.debug(&#39;this is a message&#39;)</span><br></pre></td></tr></table></figure><p>运行结果如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEBUG - 2019-10-11 22:27:35,923 - process: 99490 - logger.py - __main__ - 81 - logger - this is a message</span><br></pre></td></tr></table></figure><p>我们看看这个定义的基本实现吧。首先这里一些常量是用来定义 <code>logging</code> 模块的一些基本属性的，比如 LOG_ENABLED 代表是否开启日志功能，<code>LOG_TO_E</code>S 代表是否将日志输出到 Elasticsearch，另外还有很多其他的日志基本配置，如 <code>LOG_FORMAT</code> 配置了日志每个条目输出的基本格式，另外还有一些连接的必要信息。这些变量可以和运行时的命令行或环境变量对接起来，可以方便地实现一些开关和配置的更换。</p><p>然后定义了这么一个 <code>get_logger</code> 方法，接收一个参数 name。首先该方法拿到 name 之后，会到全局的 loggers 变量里面查找，loggers 变量是一个全局字典，如果有已经声明过的 logger，直接将其获取返回即可，不用再将其二次初始化。如果 loggers 里面没有找到 name 对应的 logger，那就进行创建即可。创建 logger 之后，可以为其添加各种对应的 Handler，如输出到控制台就用 StreamHandler，输出到文件就用 FileHandler 或 RotatingFileHandler，输出到 Elasticsearch 就用 CMRESHandler，分别配置好对应的信息即可。</p><p>最后呢，将新建的 logger 保存到全局的 loggers 里面并返回即可，这样如果有同名的 logger 便可以直接查找 loggers 直接返回了。<br>在这里依赖了额外的输出到 Elasticsearch 的包，叫做 CMRESHandler，它可以支持将日志输出到 Elasticsearch 里面，如果要使用的话可以安装一下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install CMRESHandler</span><br></pre></td></tr></table></figure><p>其 GitHub 地址是：<code>https://github.com/cmanaha/python-elasticsearch-logger</code>，具体的使用方式可以看看它的官方说明，如配置认证信息，配置 Index 分隔信息等等。<br>好，上面就是我之前常用的 logging 配置，通过如上的配置，我就可以实现将 logging 输出到三个位置，并可以实现对应的效果。比如输出到 Elasticsearch 之后，我就可以非常方便地使用 Kibana 来查看当前运行情况，ERROR Log 的比例等等.<br>也可以在它的基础上做更进一步的统计分析.</p><h2 id="loguru"><a href="#loguru" class="headerlink" title="loguru"></a>loguru</h2><p>上面的实现方式已经是一个较为可行的配置方案了。然而，我还是会感觉到有些 Handler 配起来麻烦，尤其是新建一个项目的很多时候懒得去写一些配置。即使是不用上文的配置，用最基本的几行 logging 配置，像如下的通用配置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line">logging.basicConfig(level &#x3D; logging.INFO,format &#x3D; &#39;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#39;)</span><br><span class="line">logger &#x3D; logging.getLogger(__name__)</span><br></pre></td></tr></table></figure><p>我也懒得去写，感觉并不是一个优雅的实现方式。<br>有需求就有动力啊，这不，就有人实现了这么一个库，叫做 loguru，可以将 log 的配置和使用更加简单和方便。<br>下面我们来看看它到底是怎么用的吧.</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先，这个库的安装方式很简单，就用基本的 pip 安装即可，Python 3 版本的安装如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install loguru</span><br></pre></td></tr></table></figure><p>安装完毕之后，我们就可以在项目里使用这个 loguru 库了.</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>那么这个库怎么来用呢？我们先用一个实例感受下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from loguru import logger</span><br><span class="line"></span><br><span class="line">logger.debug(&#39;this is a debug message&#39;)</span><br></pre></td></tr></table></figure><p>看到了吧，不需要配置什么东西，直接引入一个 logger，然后调用其 debug 方法即可。</p><p>在 loguru 里面有且仅有一个主要对象，那就是 logger，loguru 里面有且仅有一个 logger，而且它已经被提前配置了一些基础信息，比如比较友好的格式化、文本颜色信息等等。</p><p>上面的代码运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2019-10-13 22:46:12.367 | DEBUG    | __main__:&lt;module&gt;:4 - this is a debug message</span><br></pre></td></tr></table></figure><p>可以看到其默认的输出格式是上面的内容，有时间、级别、模块名、行号以及日志信息，不需要手动创建 logger，直接使用即可，另外其输出还是彩色的，看起来会更加友好。</p><p>以上的日志信息是直接输出到控制台的，并没有输出到其他的地方，如果想要输出到其他的位置，比如存为文件，我们只需要使用一行代码声明即可。</p><p>例如将结果同时输出到一个 runtime.log 文件里面，可以这么写:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from loguru import logger</span><br><span class="line"></span><br><span class="line">logger.add(&#39;runtime.log&#39;)</span><br><span class="line">logger.debug(&#39;this is a debug&#39;)</span><br></pre></td></tr></table></figure><p>很简单吧，我们也不需要再声明一个 FileHandler 了，就一行 add 语句搞定，运行之后会发现目录下 runtime.log 里面同样出现了刚刚控制台输出的 DEBUG 信息。</p><p>上面就是一些基本的使用，但这还远远不够，下面我们来详细了解下它的一些功能模块.</p><h2 id="详细使用"><a href="#详细使用" class="headerlink" title="详细使用"></a>详细使用</h2><p>既然是日志，那么最常见的就是输出到文件了。loguru 对输出到文件的配置有非常强大的支持，比如支持输出到多个文件，分级别分别输出，过大创建新文件，过久自动删除等等。</p><p>下面我们分别看看这些怎样来实现，这里基本上就是 add 方法的使用介绍。因为这个 add 方法就相当于给 logger 添加了一个 Handler，它给我们暴露了许多参数来实现 Handler 的配置，下面我们来详细介绍下。<br>首先看看它的方法定义吧:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def add(</span><br><span class="line">        self,</span><br><span class="line">        sink,</span><br><span class="line">        *,</span><br><span class="line">        level&#x3D;_defaults.LOGURU_LEVEL,</span><br><span class="line">        format&#x3D;_defaults.LOGURU_FORMAT,</span><br><span class="line">        filter&#x3D;_defaults.LOGURU_FILTER,</span><br><span class="line">        colorize&#x3D;_defaults.LOGURU_COLORIZE,</span><br><span class="line">        serialize&#x3D;_defaults.LOGURU_SERIALIZE,</span><br><span class="line">        backtrace&#x3D;_defaults.LOGURU_BACKTRACE,</span><br><span class="line">        diagnose&#x3D;_defaults.LOGURU_DIAGNOSE,</span><br><span class="line">        enqueue&#x3D;_defaults.LOGURU_ENQUEUE,</span><br><span class="line">        catch&#x3D;_defaults.LOGURU_CATCH,</span><br><span class="line">        **kwargs</span><br><span class="line">    ):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure><p>看看它的源代码，它支持这么多的参数，如 level、format、filter、color 等等。</p><blockquote><p>sink<br>另外我们还注意到它有个非常重要的参数 sink，我们看看官方文档：<code>https://loguru.readthedocs.io/en/stable/api/logger.html#sink</code>，可以了解到通过 sink 我们可以传入多种不同的数据结构，汇总如下:</p></blockquote><ul><li>sink 可以传入一个 file 对象，例如 sys.stderr 或者 open(‘file.log’, ‘w’) 都可以。</li><li>sink 可以直接传入一个 str 字符串或者 pathlib.Path 对象，其实就是代表文件路径的，如果识别到是这种类型，它会自动创建对应路径的日志文件并将日志输出进去。</li><li>sink 可以是一个方法，可以自行定义输出实现。</li><li>sink 可以是一个 logging 模块的 Handler，比如 FileHandler、StreamHandler 等等，或者上文中我们提到的 CMRESHandler 照样也是可以的，这样就可以实现自定义 Handler 的配置。</li><li>sink 还可以是一个自定义的类，具体的实现规范可以参见官方文档.<br>所以说，刚才我们所演示的输出到文件，仅仅给它传了一个 str 字符串路径，他就给我们创建了一个日志文件，就是这个原理。</li></ul><blockquote><blockquote><p>format, filter, level<br>下面我们再了解下它的其他参数，例如 format、filter、level 等等。<br>其实它们的概念和格式和 logging 模块都是基本一样的了，例如这里使用 format、filter、level 来规定输出的格式:</p></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.add(&#39;runtime.log&#39;, format&#x3D;&quot;&#123;time&#125; &#123;level&#125; &#123;message&#125;&quot;, filter&#x3D;&quot;my_module&quot;, level&#x3D;&quot;INFO&quot;)</span><br></pre></td></tr></table></figure><blockquote><p>删除sink<br>另外添加 sink 之后我们也可以对其进行删除，相当于重新刷新并写入新的内容。<br>删除的时候根据刚刚 add 方法返回的 id 进行删除即可，看下面的例子:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from loguru import logger</span><br><span class="line"></span><br><span class="line">trace &#x3D; logger.add(&#39;runtime.log&#39;)</span><br><span class="line">logger.debug(&#39;this is a debug message&#39;)</span><br><span class="line">logger.remove(trace)</span><br><span class="line">logger.debug(&#39;this is another debug message&#39;)</span><br></pre></td></tr></table></figure><p>看这里，我们首先 add 了一个 sink，然后获取它的返回值，赋值为 trace。随后输出了一条日志，然后将 trace 变量传给 remove 方法，再次输出一条日志，看看结果是怎样的。<br>控制台输出如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">019-10-13 23:18:26.469 | DEBUG    | __main__:&lt;module&gt;:4 - this is a debug message</span><br><span class="line">2019-10-13 23:18:26.469 | DEBUG    | __main__:&lt;module&gt;:6 - this is another debug message</span><br></pre></td></tr></table></figure><p>日志文件 runtime.log 内容如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2019-10-13 23:18:26.469 | DEBUG    | __main__:&lt;module&gt;:4 - this is a debug message</span><br></pre></td></tr></table></figure><p>可以发现，在调用 remove 方法之后，确实将历史 log 删除了。<br>这样我们就可以实现日志的刷新重新写入操作。</p><blockquote><p>rotation 配置<br>用了 loguru 我们还可以非常方便地使用 rotation 配置，比如我们想一天输出一个日志文件，或者文件太大了自动分隔日志文件，我们可以直接使用 add 方法的 rotation 参数进行配置。<br>我们看看下面的例子：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.add(&#39;runtime_&#123;time&#125;.log&#39;, rotation&#x3D;&quot;500 MB&quot;)</span><br></pre></td></tr></table></figure><p>通过这样的配置我们就可以实现每 500MB 存储一个文件，每个 log 文件过大就会新创建一个 log 文件。我们在配置 log 名字时加上了一个 time 占位符，这样在生成时可以自动将时间替换进去，生成一个文件名包含时间的 log 文件。<br>另外我们也可以使用 rotation 参数实现定时创建 log 文件，例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.add(&#39;runtime_&#123;time&#125;.log&#39;, rotation&#x3D;&#39;00:00&#39;)</span><br></pre></td></tr></table></figure><p>这样就可以实现每天 0 点新创建一个 log 文件输出了。<br>另外我们也可以配置 log 文件的循环时间，比如每隔一周创建一个 log 文件，写法如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.add(&#39;runtime_&#123;time&#125;.log&#39;, rotation&#x3D;&#39;1 week&#39;)</span><br></pre></td></tr></table></figure><p>这样我们就可以实现一周创建一个 log 文件了。</p><blockquote><p>retention 配置<br>很多情况下，一些非常久远的 log 对我们来说并没有什么用处了，它白白占据了一些存储空间，不清除掉就会非常浪费。retention 这个参数可以配置日志的最长保留时间。<br>比如我们想要设置日志文件最长保留 10 天，可以这么来配置:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.add(&#39;runtime.log&#39;, retention&#x3D;&#39;10 days&#39;)</span><br></pre></td></tr></table></figure><p>这样 log 文件里面就会保留最新 10 天的 log，妈妈再也不用担心 log 沉积的问题啦。</p><blockquote><p>compression 配置<br>loguru 还可以配置文件的压缩格式，比如使用 zip 文件格式保存，示例如下:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.add(&#39;runtime.log&#39;, compression&#x3D;&#39;zip&#39;)</span><br></pre></td></tr></table></figure><p>这样可以更加节省存储空间。</p><blockquote><p>字符串格式化<br>loguru 在输出 log 的时候还提供了非常友好的字符串格式化功能，像这样:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.info(&#39;If you are using Python &#123;&#125;, prefer &#123;feature&#125; of course!&#39;, 3.6, feature&#x3D;&#39;f-strings&#39;)</span><br></pre></td></tr></table></figure><p>这样在添加参数就非常方便了。</p><blockquote><p>Traceback 记录<br>在很多情况下，如果遇到运行错误，而我们在打印输出 log 的时候万一不小心没有配置好 Traceback 的输出，很有可能我们就没法追踪错误所在了。<br>但用了 loguru 之后，我们用它提供的装饰器就可以直接进行 Traceback 的记录，类似这样的配置即可:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@logger.catch</span><br><span class="line">def my_function(x, y, z):</span><br><span class="line">    # An error? It&#39;s caught anyway!</span><br><span class="line">    return 1 &#x2F; (x + y + z)</span><br></pre></td></tr></table></figure><p>我们做个测试，我们在调用时三个参数都传入 0，直接引发除以 0 的错误，看看会出现什么情况:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_function(0, 0, 0)</span><br></pre></td></tr></table></figure><p>运行完毕之后，可以发现 log 里面就出现了 Traceback 信息，而且给我们输出了当时的变量值，真的是不能再赞了！结果如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; File &quot;run.py&quot;, line 15, in &lt;module&gt;</span><br><span class="line">    my_function(0, 0, 0)</span><br><span class="line">    └ &lt;function my_function at 0x1171dd510&gt;</span><br><span class="line"></span><br><span class="line">  File &quot;&#x2F;private&#x2F;var&#x2F;py&#x2F;logurutest&#x2F;demo5.py&quot;, line 13, in my_function</span><br><span class="line">    return 1 &#x2F; (x + y + z)</span><br><span class="line">                │   │   └ 0</span><br><span class="line">                │   └ 0</span><br><span class="line">                └ 0</span><br><span class="line"></span><br><span class="line">ZeroDivisionError: division by zero</span><br></pre></td></tr></table></figure><p>因此，用 loguru 可以非常方便地实现日志追踪，debug 效率可能要高上十倍了？<br>另外 loguru 还有很多很多强大的功能，这里就不再一一展开讲解了，更多的内容大家可以看看 loguru 的官方文档详细了解一下：<code>https://loguru.readthedocs.io/en/stable/index.html</code><br>看完之后，是时候把自己的 logging 模块替换成 loguru 啦！</p>]]></content>
    
    <summary type="html">
    
      Python 中更优雅的日志记录方案
    
    </summary>
    
    
      <category term="PYTHON" scheme="https://shuke163.github.io/categories/PYTHON/"/>
    
      <category term="DevOps" scheme="https://shuke163.github.io/categories/PYTHON/DevOps/"/>
    
    
      <category term="PYTHON" scheme="https://shuke163.github.io/tags/PYTHON/"/>
    
  </entry>
  
</feed>
