<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>shuke&#39;s Blog</title>
  
  <subtitle>技术 管理 生活 格局 人生</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://shuke163.github.io/"/>
  <updated>2020-05-03T03:09:10.952Z</updated>
  <id>https://shuke163.github.io/</id>
  
  <author>
    <name>shuke</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>EditorConfig使用介绍</title>
    <link href="https://shuke163.github.io/2020/05/03/EditorConfig%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/"/>
    <id>https://shuke163.github.io/2020/05/03/EditorConfig%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/</id>
    <published>2020-05-03T03:08:41.000Z</published>
    <updated>2020-05-03T03:09:10.952Z</updated>
    
    <content type="html"><![CDATA[<p>在github看到很多项目根目录都有 .editorconfig 文件，所以去了解一下。</p><p>这个文件是 EditorConfig 用来统一不同编辑器的代码风格的配置。</p><p>各种IDE的风格自然不一样，通过这样一个配置文件定义的标准统一风格，比如缩进用x个空格。再有就是多人一起协同开发一个项目，editorconfig 能起到很好的效果。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># EditorConfig: http:&#x2F;&#x2F;editorconfig.org&#x2F;</span><br><span class="line"></span><br><span class="line">root &#x3D; true</span><br><span class="line"></span><br><span class="line">[*]</span><br><span class="line">indent_style &#x3D; space</span><br><span class="line">indent_size &#x3D; 4</span><br><span class="line">end_of_line &#x3D; lf</span><br><span class="line">charset &#x3D; utf-8</span><br><span class="line">trim_trailing_whitespace &#x3D; true</span><br><span class="line">insert_final_newline &#x3D; true</span><br><span class="line"></span><br><span class="line">[*.md]</span><br><span class="line">trim_trailing_whitespace &#x3D; false</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      EditorConfig使用介绍
    
    </summary>
    
    
      <category term="IDE" scheme="https://shuke163.github.io/categories/IDE/"/>
    
    
      <category term="IDE" scheme="https://shuke163.github.io/tags/IDE/"/>
    
  </entry>
  
  <entry>
    <title>简易HTTPS 加密证书的工具</title>
    <link href="https://shuke163.github.io/2020/05/03/%E7%AE%80%E6%98%93HTTPS-%E5%8A%A0%E5%AF%86%E8%AF%81%E4%B9%A6%E7%9A%84%E5%B7%A5%E5%85%B7/"/>
    <id>https://shuke163.github.io/2020/05/03/%E7%AE%80%E6%98%93HTTPS-%E5%8A%A0%E5%AF%86%E8%AF%81%E4%B9%A6%E7%9A%84%E5%B7%A5%E5%85%B7/</id>
    <published>2020-05-03T03:06:07.000Z</published>
    <updated>2020-05-03T03:07:48.462Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/FiloSottile/mkcert" target="_blank" rel="noopener">mkcert</a> 是生成本地 HTTPS 加密证书的工具，一个命令就可以生成证书，不需要任何配置。</p><p>在 Linux 上，安装 certutil</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install libnss3-tools</span><br><span class="line">$ sudo yum install nss-tools</span><br></pre></td></tr></table></figure><p>使用示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ mkcert -install</span><br><span class="line">Created a new local CA at &quot;&#x2F;Users&#x2F;filippo&#x2F;Library&#x2F;Application Support&#x2F;mkcert&quot; 💥</span><br><span class="line">The local CA is now installed in the system trust store! ⚡️</span><br><span class="line">The local CA is now installed in the Firefox trust store (requires restart)! 🦊</span><br><span class="line"></span><br><span class="line">$ mkcert example.com &#39;*.example.org&#39; myapp.dev localhost 127.0.0.1 ::1</span><br><span class="line">Using the local CA at &quot;&#x2F;Users&#x2F;filippo&#x2F;Library&#x2F;Application Support&#x2F;mkcert&quot; ✨</span><br><span class="line"></span><br><span class="line">Created a new certificate valid for the following names 📜</span><br><span class="line"> - &quot;example.com&quot;</span><br><span class="line"> - &quot;*.example.org&quot;</span><br><span class="line"> - &quot;myapp.dev&quot;</span><br><span class="line"> - &quot;localhost&quot;</span><br><span class="line"> - &quot;127.0.0.1&quot;</span><br><span class="line"> - &quot;::1&quot;</span><br><span class="line"></span><br><span class="line">The certificate is at &quot;.&#x2F;example.com+5.pem&quot; and the key at &quot;.&#x2F;example.com+5-key.pem&quot; ✅</span><br></pre></td></tr></table></figure><p><a href="https://keer.me/Using-mkcert-to-generate-local-HTTPS-certificates.html" target="_blank" rel="noopener">使用方法参考</a></p>]]></content>
    
    <summary type="html">
    
      简易HTTPS 加密证书的工具
    
    </summary>
    
    
      <category term="Nginx" scheme="https://shuke163.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="https://shuke163.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>网站文档mkdocs</title>
    <link href="https://shuke163.github.io/2020/05/03/%E7%BD%91%E7%AB%99%E6%96%87%E6%A1%A3mkdocs/"/>
    <id>https://shuke163.github.io/2020/05/03/%E7%BD%91%E7%AB%99%E6%96%87%E6%A1%A3mkdocs/</id>
    <published>2020-05-03T03:02:31.000Z</published>
    <updated>2020-05-03T03:10:25.934Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mkdocs"><a href="#Mkdocs" class="headerlink" title="Mkdocs"></a>Mkdocs</h2><p><a href="https://www.mkdocs.org/#mkdocs" target="_blank" rel="noopener">mkdocs.org</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li>安装python2.7（安装时选中加入环境变量）</li><li>pip install mkdocs &amp; mkdocs –version</li><li>pip install click-man</li><li>mkdocs new my-project &amp; cd my-project</li><li>mkdocs serve</li><li>mkdocs build</li><li>mkdocs build –clean (清理已被删除的文档所生成的html文件)</li></ol><p>mkdocs-material主题配置<br><a href="https://squidfunk.github.io/mkdocs-material/getting-started/" target="_blank" rel="noopener">点击看效果 mkdocs-material</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. pip install mkdocs-material</span><br><span class="line">2. vim mkdocs.yml</span><br></pre></td></tr></table></figure><p>mkdocs.yml 配置示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">site_name: 文档中心</span><br><span class="line">theme:</span><br><span class="line">  name: &#39;material&#39;</span><br><span class="line">  palette:</span><br><span class="line">    primary: &#39;teal&#39;</span><br><span class="line">    accent: &#39;teal&#39;</span><br><span class="line">  font:</span><br><span class="line">    text: &#39;Roboto&#39;</span><br><span class="line">    code: &#39;Roboto Mono&#39;</span><br></pre></td></tr></table></figure><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdocs new [dir-name] - Create a new project.</span><br><span class="line">mkdocs serve - Start the live-reloading docs server.</span><br><span class="line">mkdocs build - Build the documentation site.</span><br><span class="line">mkdocs help - Print this help message.</span><br></pre></td></tr></table></figure><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdocs.yml    # The configuration file.</span><br><span class="line">docs&#x2F;</span><br><span class="line">    index.md  # The documentation homepage.</span><br><span class="line">    ...       # Other markdown pages, images and other files.</span><br></pre></td></tr></table></figure><h2 id="另外几种文档记录方式"><a href="#另外几种文档记录方式" class="headerlink" title="另外几种文档记录方式"></a>另外几种文档记录方式</h2><ul><li>gitbook</li><li>wiki</li><li>docusaurus</li><li>MM-wiki</li></ul>]]></content>
    
    <summary type="html">
    
      网站文档mkdocs
    
    </summary>
    
    
      <category term="docs" scheme="https://shuke163.github.io/categories/docs/"/>
    
    
      <category term="docs" scheme="https://shuke163.github.io/tags/docs/"/>
    
  </entry>
  
  <entry>
    <title>云存储平台Seafile</title>
    <link href="https://shuke163.github.io/2020/05/03/%E4%BA%91%E5%AD%98%E5%82%A8%E5%B9%B3%E5%8F%B0Seafile/"/>
    <id>https://shuke163.github.io/2020/05/03/%E4%BA%91%E5%AD%98%E5%82%A8%E5%B9%B3%E5%8F%B0Seafile/</id>
    <published>2020-05-03T02:58:45.000Z</published>
    <updated>2020-05-03T03:00:29.977Z</updated>
    
    <content type="html"><![CDATA[<h2 id="云存储平台seafile"><a href="#云存储平台seafile" class="headerlink" title="云存储平台seafile"></a>云存储平台seafile</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;haiwen&#x2F;seafile</span><br></pre></td></tr></table></figure><p>Seafile 的目标是给企业提供一个安全的云存储平台，满足企业文件的共享和协作的需求。</p><p>Seafile 采用开源的方式来进行产品开发。开源帮助 Seafile 成为了一个国际化的项目，并吸引了全球用户的参与和贡献。目前我们已经在 Github 开源代码托管平台上有了 3900 多个关注。全球用户的使用、反馈和审核使得 Seafile 更加的安全和稳定。</p><p>截至 2016 年初，Seafile 已经有超过 30 万用户使用，并拥有卡巴斯基，德国 Mainz 大学，德国 HU Berlin 大学和法国 Strasbourg 大学等大型组织机构客户。</p><p><a href="https://www.seafile.com/home/" target="_blank" rel="noopener">https://www.seafile.com/home/</a></p><h2 id="nextcloud"><a href="#nextcloud" class="headerlink" title="nextcloud"></a>nextcloud</h2><blockquote><p>另一个开放云盘服务</p></blockquote>]]></content>
    
    <summary type="html">
    
      云存储平台Seafile
    
    </summary>
    
    
      <category term="Seafile" scheme="https://shuke163.github.io/categories/Seafile/"/>
    
    
      <category term="Seafile" scheme="https://shuke163.github.io/tags/Seafile/"/>
    
  </entry>
  
  <entry>
    <title>推荐几个好用的DevOps小工具</title>
    <link href="https://shuke163.github.io/2020/04/30/%E6%8E%A8%E8%8D%90%E5%87%A0%E4%B8%AA%E5%A5%BD%E7%94%A8%E7%9A%84DevOps%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    <id>https://shuke163.github.io/2020/04/30/%E6%8E%A8%E8%8D%90%E5%87%A0%E4%B8%AA%E5%A5%BD%E7%94%A8%E7%9A%84DevOps%E5%B0%8F%E5%B7%A5%E5%85%B7/</id>
    <published>2020-04-30T15:26:36.000Z</published>
    <updated>2020-04-30T16:28:02.634Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工具推荐"><a href="#工具推荐" class="headerlink" title="工具推荐"></a>工具推荐</h2><ol><li>文档管理</li></ol><ul><li>wiki</li><li>MM-wiki</li><li>gitbook(推荐)</li><li>Docusaurus(推荐)</li><li>hexo</li></ul><ol start="2"><li>bug管理</li></ol><ul><li>git-bug</li><li>蝉道</li><li>Readme</li></ul><ol start="3"><li>code review</li></ol><ul><li>Phabricator(PHA)</li></ul>]]></content>
    
    <summary type="html">
    
      推荐几个好用的DevOps小工具
    
    </summary>
    
    
      <category term="DevOps" scheme="https://shuke163.github.io/categories/DevOps/"/>
    
    
      <category term="DevOps" scheme="https://shuke163.github.io/tags/DevOps/"/>
    
  </entry>
  
  <entry>
    <title>python小技巧</title>
    <link href="https://shuke163.github.io/2020/04/29/python%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>https://shuke163.github.io/2020/04/29/python%E5%B0%8F%E6%8A%80%E5%B7%A7/</id>
    <published>2020-04-29T00:46:02.000Z</published>
    <updated>2020-04-29T00:55:35.699Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>每天早晨洗一遍脑子特并清醒 </p></blockquote><ol><li><p>List: all_equal<br>功能实现: 检验一个列表中的所有元素是否都一样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def all_equal(lst):</span><br><span class="line">    return lst[1:] &#x3D;&#x3D; lst[:-1]</span><br><span class="line"></span><br><span class="line">ret &#x3D; all_equal([1, 2, 3, 4, 5, 6])</span><br><span class="line"></span><br><span class="line">ret2 &#x3D; all_equal([1, 1, 1, 1])</span><br><span class="line"></span><br><span class="line">print(ret, ret2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># True False</span><br></pre></td></tr></table></figure></li><li><p>List: all_unique<br>功能实现: 如果列表所有值都是唯一的，返回True, 否则返回False</p><blockquote><p>解读: 在给定列表上使用集合set()去重, 比较它和原列表的长度</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def all_unique(lst):</span><br><span class="line">    return len(lst) &#x3D;&#x3D; len(set(lst))</span><br><span class="line"></span><br><span class="line"># 举例:</span><br><span class="line">x &#x3D; [1, 2, 3, 4, 5, 6]</span><br><span class="line">y &#x3D; [1, 2, 2, 3, 4, 5]</span><br><span class="line">z &#x3D; all_unique(x)</span><br><span class="line">b &#x3D; all_unique(y)</span><br><span class="line">print(z, b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># True False</span><br></pre></td></tr></table></figure></li><li><p>List: bifucate<br>功能实现: 将列表值分组。如果filter的元素是True, 那么对应的元素属于第一个组,否则属于第二个组<br>解读: 使用列表推导式和enumerate()基于fiter元素到各组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def bifurcate(lst, filter):</span><br><span class="line">    return [</span><br><span class="line">        [x for i, x in enumerate(lst) if filter[i] &#x3D;&#x3D; True],</span><br><span class="line">        [x for i, x in enumerate(lst) if filter[i] &#x3D;&#x3D; False]</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">r &#x3D; bifurcate([&quot;beep&quot;, &quot;boop&quot;, &quot;foo&quot;, &quot;bar&quot;], [True, True, False, True])</span><br><span class="line"># [[&#39;beep&#39;, &#39;boop&#39;, &#39;bar&#39;], [&#39;foo&#39;]]</span><br></pre></td></tr></table></figure></li><li><p>List: difference<br>功能实现: 返回两个iterables间的差异<br>解读: 创建b的集合，使用a的列表推导式保留不在_b中的元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def difference(a, b):</span><br><span class="line">    _b &#x3D; set(b)</span><br><span class="line">    return [item for item in a if item not in _b]</span><br><span class="line"></span><br><span class="line">print(difference([1, 2, 3], [1, 2, 4]))</span><br><span class="line"></span><br><span class="line"># [3]</span><br></pre></td></tr></table></figure></li><li><p>Math: digitize<br>功能实现: 将一个数分解转换为个位数字<br>解读: 将n字符化后使用map()函数结合int完成转化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def digitize(n):</span><br><span class="line">    return list(map(int, str(n)))</span><br><span class="line"></span><br><span class="line">print(digitize(123))</span><br><span class="line"># [1,2,3]</span><br></pre></td></tr></table></figure></li><li><p>List: shuffle<br>功能实现: 将列表元素顺序随机打乱<br>解读: 使用Fisher-Yates算法重新排序列表元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from copy import deepcopy</span><br><span class="line">from random import randint</span><br><span class="line"></span><br><span class="line">def shuffle(lst):</span><br><span class="line">    temp_lst &#x3D; deepcopy(lst)</span><br><span class="line">    m &#x3D; len(temp_lst)</span><br><span class="line">    while (m):</span><br><span class="line">        m -&#x3D; 1</span><br><span class="line">        i &#x3D; randint(0, m)</span><br><span class="line">        temp_lst[m], temp_lst[i] &#x3D; temp_lst[i], temp_lst[m]</span><br><span class="line">    return temp_lst</span><br><span class="line"></span><br><span class="line">foo &#x3D; [1, 2, 3]</span><br><span class="line">print(shuffle(foo))</span><br><span class="line"></span><br><span class="line"># [2, 1, 3]</span><br></pre></td></tr></table></figure></li><li><p>Math: clamp_number<br>功能实现: 将数字num嵌在由a和b边界值规定的范围中<br>解读: 如果num落尽范围内,返回num 否则，返回范围内最接近的数字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def clamp_number(num, a, b):</span><br><span class="line">    return max(min(num, max(a, b)), min(a, b))</span><br><span class="line"></span><br><span class="line">a &#x3D; clamp_number(2, 3, 5)</span><br><span class="line">b &#x3D; clamp_number(1, -1, -5)</span><br><span class="line">print(a, b)</span><br><span class="line"></span><br><span class="line"># 3 -1</span><br></pre></td></tr></table></figure></li><li><p>String: byte_size<br>功能实现: 返回字符串的字节数<br>解读: 使用String.encode(‘utf-8’) 解码给定字符串, 返回长度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def byte_size(string):</span><br><span class="line">    return len(string.encode(&#39;utf-8&#39;))</span><br><span class="line"></span><br><span class="line"># print(byte_size(&#39;😀&#39;)) # 4</span><br><span class="line"># print(byte_size(&#39;Hello World&#39;)) # 11</span><br></pre></td></tr></table></figure></li><li><p>Math: gcd<br>功能实现: 计算几个数的最大公因数<br>解读: 使用reduce()和math.gcd在给定列表上实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from functools import reduce</span><br><span class="line">import math</span><br><span class="line"></span><br><span class="line">def gcd(numbers):</span><br><span class="line">    return reduce(math.gcd, numbers)</span><br><span class="line"></span><br><span class="line">print(gcd([8, 36, 28]))  # 4</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      python小技巧
    
    </summary>
    
    
      <category term="PYTHON" scheme="https://shuke163.github.io/categories/PYTHON/"/>
    
    
      <category term="PYTHON" scheme="https://shuke163.github.io/tags/PYTHON/"/>
    
  </entry>
  
  <entry>
    <title>一些python相关的知识点整理</title>
    <link href="https://shuke163.github.io/2020/04/23/%E4%B8%80%E4%BA%9Bpython%E7%9B%B8%E5%85%B3%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
    <id>https://shuke163.github.io/2020/04/23/%E4%B8%80%E4%BA%9Bpython%E7%9B%B8%E5%85%B3%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/</id>
    <published>2020-04-23T08:29:52.000Z</published>
    <updated>2020-04-23T08:31:17.283Z</updated>
    
    <content type="html"><![CDATA[<h3 id="django相关"><a href="#django相关" class="headerlink" title="django相关"></a>django相关</h3><ol><li><p>中间件<br>中间件一般做认证或批量请求处理，django中的中间件，其实是一个类，在请求和结束后，django会根据自己的规则在合适的时机执行中间件中相应的方法，<br>如请求过来 执行process_request, view，process_response方法</p></li><li><p>Django、Tornado、Flask各自的优势<br>Django：Django无socket，django的目的是简便，快速开发，并遵循MVC设计，多个组件可以很方便的以“插件”形式服务于整个框架，<br>django有许多功能强大的第三方插件。django具有很强的可扩展性。<br>Tornado：它是非阻塞式服务器，而且速度相当快，得力于其 非阻塞的方式和对epoll的运用，Future对象，缺点：没有session，需要自定制<br>Flask：是一个微型的web框架，配合SQLALchemy来使用，jinja2模板， werkzeug接口                  </p></li><li><p>django版本，Python版本，linux版本<br>django：1.11<br>Python：3.5<br>linux：6.8</p></li><li><p>django的template的注释是什么样子的<br>单行：<br>多行注释：&#123;%comment%&#123;&#123;</p></li><li><p>django怎么弄并发的<br>nginx+uwsig为django提供高并发，nginx的并发能力超过，单台并发能力过完，在纯静态的web服务中更是突出其优越的地方，由于底层使用epoll异步IO模型进行处理。</p></li><li><p>tornodo的ioloop知道是什么吗？<br>事件循环</p></li><li><p>select_related和prefetch_related，Q和F<br>select_related：一对多使用，查询主动做连表<br>prefetch_related：多对多或者一对多的时候使用，不做连表，做多次查询<br>Q：用于构造复杂查询条件<br>F：更新时用于获取原来的值，专门取对象中某一列进行操作</p></li><li><p>什么是ORM？<br>ORM，即Object-Relational Mapping（对象关系映射），它的作用是在关系型数据库和业务实体对象之间做一个映射<br>ORM优缺点：<br>优点：摆脱复杂的SQL操作，适应快速开发，让数据结果变得简单，数据库迁移成本更低<br>缺点：性能较差，不适用于大型应用，复杂的SQL操作还需要通过SQL语句实现</p></li><li><p>CORS跨域资源共享<br>首先会发送”预检”opption”，请求，如果”预检”成功，则发送真实数据。</p></li><li><p>Django的Form主要具有以下功能？<br>生成HTMl标签，验证用户数据 is_vaild，HTML Form提交保留上次提交数据，初始化页面显示内容</p></li><li><p>CBV和FBV<br>CBV在指定的类上面加上装饰器或在此方法上面添加装饰器 @method_decorator,并继承view</p></li><li><p>cookie及session<br>cookie：是保留在客户端上面的一组键值对，cookie不是很安全，别人可以分析存放在本地的cookie<br>session：是保存在服务器上面的一组键值对，依赖与cookie，安全指数比cookie高</p></li><li><p>django的请求生命周期<br>请求来了先到uwsgi，把请求做一部分分装给django框架，然后经过所有的中间件，路由，视图，视图处理再返回给中间件，中间件在返回给uwsgi，在返回给用户。</p></li><li><p>uwsgi和wsgi<br>wsgi：是web服务器网关接口，是pyhton应用程序或框架和web服务器之间的一种接口，其广泛使用的是django框架。<br>uwsgi：是一个web服务器，它实现了wsgi协议，Nginx中HttpUwsgiModule的作用是与Uwsgi服务器进行交换</p></li><li><p>解释下django - debug -toolbar的使用<br>使用django开发站点时，可以使用django-debug-toolbar来进行调试，在settings.py中添加 ‘debug—toolbar.midleware.Debug ToolbarMiddleware’到项目的MIDDLEWARE_CLASSES内。</p></li></ol><h3 id="Python部分"><a href="#Python部分" class="headerlink" title="Python部分"></a>Python部分</h3><ol><li><p><strong>new</strong>.<strong>init</strong>区别，如何实现单例模式，有什么优点<br><strong>new</strong>是一个静态方法，<strong>init</strong>是一个实例方法<br><strong>new</strong>返回一个创建的实例，<strong>init</strong>什么都不返回<br><strong>new</strong>返回一个cls的实例时后面的<strong>init</strong>才能被调用<br>当创建一个新实例时调用<strong>new</strong>，初始化一个实例时调用<strong>init</strong></p></li><li><p>深浅拷贝<br>浅拷贝只是增加了一个指针指向一个存在的地址，而深拷贝是增加一个指针并且开辟了新的内存，这个增加的指针指向这个新的内存，<br>采用浅拷贝的情况，释放内存，会释放同一内存，深拷贝就不会出现释放同一内存的错误</p></li><li><p>HTTP/IP相关协议，分别位于哪层<br>http协议是超文本传输协议，http协议是基于TCP/IP通信协议来传递数据<br>http协议工作与c/s架构上，浏览器作为http的客户端通过URL向http服务端即web服务器发送所用请求。web服务器收到所有请求后，向客户端发送响应信息，<br>http特点是短连接，无状态<br>地址栏键输入URL，按下回车之后经历了什么？</p></li><li><p>浏览器向DNS服务器请求解析该URL中的域名所对应的IP地址</p></li><li><p>解析出IP地址后，根据IP地址和默认端口80，和服务器建立TCP连接</p></li><li><p>浏览器发出读取文件的http请求，该请求报文作为TCP三次握手的第三个报文的数据发送给服务器</p></li><li><p>服务器对浏览器请求做出响应，并把对应的html文件发送给浏览器</p></li><li><p>释放TCP连接</p></li><li><p>浏览器将该HMTL渲染并显示内容</p></li><li><p>TCP/UDP区别<br>TCP协议是面向连接，保证高可靠性（数据无丢失，数据无失序，数据无错误，数据无重复达到）传输层协议<br>UDP：数据丢失，无秩序的传输层协议（qq基于udp协议）</p></li><li><p>webscoket<br>websocket是基于http协议的，可持续化连接<br>轮询：浏览器每隔几秒就发送一次请求，询问服务器是否有新消息<br>长轮询：客户端发起连接后，如果没有消息，就一直不返回response给客户端，直到有消息返回，返回完之后，客户端再次发起连接</p></li><li><p>RabbitMQ:<br>服务器端有Erlang语言来编写，支持多种客户端，只会ajax，用于分布式系统中存储转发消息，在易用性、扩展性、高可用性的方面不俗。<br>connection是RabbitMQ的socket连接，它封装了socket部分相关协议逻辑<br>connectionFactroy为connection的制造工厂<br>channel是我们与RabbitMQ打交道的最重要的一个接口，大部分的业务操作是在chaanel这个接口中完成，包括定义Queue、定义Exchange、<br>绑定Queue与Exchange,发布消息等</p></li><li><p>装饰器<br>调用装饰器其实是一个闭包函数，为其他函数添加附加功能，不修改被修改的源代码和不修改被修饰的方式，装饰器的返回值也是一个函数对象。<br>比如：插入日志、性能测试、事物处理、缓存、权限验证等，有了装饰器，就可以抽离出大量与函数功能本身无关的雷同代码并继续重用。</p></li><li><p>闭包</p></li><li><p>必须有一个内嵌函数</p></li><li><p>内嵌函数必须引用外部函数的变量（该函数包含对外作用域而不是全局作用域名字的引用）</p></li><li><p>外部函数的返回值必须是内嵌函数</p></li><li><p>迭代器与生成器<br>迭代可迭代对象对应_iter_（方法）和迭代器对应_next_（方法）的一个过程<br>生成器：包括含有yield这个关键字，生成器也是迭代器，调动next把函数变成迭代器。</p></li><li><p>classmethod，staticmethod，property<br>类方法：将类的函数转换成类方法，函数上装饰@classmethod会将函数的自动传值参数改成cls<br>静态方法：此方法相当于给类扩展一个功能，将类内的函数实例化，给类或对象使用，此时类内的函数就是普通函数，不管是类还是实例化的对象都可以使用<br>实例化：类的实例化就会产生一个实例（对象），可以理解为类（）把虚拟的东西实例化，得到具体存在的值</p></li><li><p>常用的状态码<br>200–服务器成功返回网页<br>204–请求收到,但返回信息为空<br>304–客户端已经执行了GET,但文件未变化<br>400–错误请求，如语法错误<br>403–无权限访问<br>404–请求的页面不存在<br>500–服务器产生内部错误<br>‍</p></li><li><p>多进程，多线程，协程，GIL<br>GIL:全局解释器锁，是锁在cpython解释器上，导致同一时刻，同一进程只能有一个线程被执行<br>多进程：多进程模块multiprocessing来实现，cpu密集型，IO计算型可以用多进程<br>多线程：多线程模块threading来实现，IO密集型，多线程可以提高效率<br>协程：依赖于geenlet，对于多线程应用。cpu通过切片的方式来切换线程间的执行，遇到IO操作自动切换，线程切换时需要耗时，<br>而协成好处没有切换的消耗，没有锁定概念。<br>进程：是资源管理单位，进行是相互独立的，实现并发和并发<br>线程：是最小的执行单位，线程的出现为了降低上下文切换的消耗，提供系统的并发性</p></li><li><p>IO多路复用/异步非阻塞<br>IO多路复用：通过一种机制，可以监听多个描述符 select/poll/epoll<br>select：连接数受限，查找配对速度慢，数据由内核拷贝到用户态<br>poll：改善了连接数，但是还是查找配对速度慢，数据由内核拷贝到用户态<br>epoll：epoll是linux下多路复用IO接口，是select/poll的增强版，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率<br>异步非阻塞：异步体现在回调上，回调就是有消息返回时告知一声儿进程进行处理。非阻塞就是不等待，不需要进程等待下去，<br>继续执行其他操作，不管其他进程的状态。</p></li><li><p>PEP8规范，规范的好处是什么？</p></li><li><p>缩进：4个空实现缩进，尽量不使用Tab</p></li><li><p>行：没行最大长度不超过79，换行可以使用反斜杠</p></li><li><p>命名规范：</p></li><li><p>注释规范：</p></li><li><p>range-and-xrange<br>都在循环时使用，xrange内存性能更好，xrange用法与range完全相同，range一个生成list对象，xrange是生成器</p></li><li><p>with上下文机制原理<br>_enter_和_exit_，上下文管理协议，即with语句，为了让一个对象兼容with语句，必须在这个对象类中声明_enter_和_exit_方法，<br>使用with语句的目的就是把代码块放入with中执行，with结束后，自动完成清理工作，无须收到干预</p></li><li><p>经典类、新式类<br>经典类遵循：深度优先，python2中<br>新式类遵循：广度优先，Python3中</p></li><li><p>有没有一个工具可以帮助查找Python的bug和进行静态的代码分析？<br>PyChecker是一个Python代码的静态分析工具，它可以帮助查找Python代码的bug，会对代码的复杂度和格式提出警告，<br>Pylint是另外一个工具可以进行codingstandard检查  </p></li><li><p>Python是如何进行内存管理的</p></li><li><p>对象引用计数：<br>  引用计数增加的情况：<br>  来保持追踪内存中的对象，所有对象都用引用计数，一个对象分配一个新名称<br>  将其放入一个容器中（列表，字典，元祖）<br>  引用计数减少的情况：<br>  使用del语句对对象别名显示的销毁<br>  引用超出作用域或被重新赋值<br>  sys.getrefcount()函数可以获得对象的当前引用计数</p></li><li><p>标记-清除机制</p></li><li><p>分代技术</p></li><li><p>什么是python？使用python有什么好处？<br>python是一种编程语言，它有对象、模块、线程、异常处理和自动内存管理。它简洁，简单、方便、容易扩展、有许多自带的数据结果，而且它开源</p></li><li><p>什么是pickling和unpickling？<br>Pickle模块读入任何python对象，将它们转换成字符串，然后使用dump函数将其转储到一个文件中——这个过程叫做pickling<br>反之从存储的字符串文件中提取原始python对象的过程，叫做unpickling</p></li><li><p>python是如何被解释的？<br>Python是一种解释性语言，它的源代码可以直接运行，Python解释器会将源代码转换成中间语言，之后再翻译成机器码再执行</p></li><li><p>数组和元祖之间的区别是什么？<br>数组和元祖之间的区别：数组内容可以被修改，而元祖内容是只读的，不可被修改的，另外元祖可以被哈希，比如作为字典的key</p></li><li><p>参数按值传递和引用传递是怎么实现的？<br>python中的一切都是类，所有的变量都是一个对象的引用。引用的值是由函数确定的，因此无法被改变，但是如果一个对象是可以被修改的，你可以改动对象</p></li><li><p>Python都有哪些自带的数据结构？<br>Python自带的数据结构分为可变和不可变的：可变的有：数组、集合、字典，不可变的是：字符串、元祖、整数</p></li><li><p>什么是python的命名空间？<br>在python中，所有的名字都存在于一个空间中，它们在改空间中存在和被操作——这就是命名空间，它就好像一个盒子，在每个变量名字都对应装着一个对象，<br>当查询变量的时候，会从该盒子里面寻找相应的对象</p></li><li><p>python中的unittest是什么？<br>在python中，unittest是python中的单元测试框架，它拥有支持共享搭建、自动测试、在测试中暂停代码、将不同测试迭代成一组</p></li><li><p><em>args与*</em>kwargs</p></li></ol><p><em>args代表位置参数，它会接收任意多个参数并把这些参数作为元祖传递给函数。*</em>kwargs代表的关键字参数，返回的是字典，位置参数一定要放在关键字前面</p><ol start="29"><li><p>在Python中什么是slicing？<br>slicing是一种在有序的对象类型中（数组、元祖、字符串）节选某一段的语法</p></li><li><p>中的docstring是什么？<br>Python中文档字符串被称为docstring，它在Python中的作用是为函数、模块和类注释生成文档</p></li><li><p>os与sys区别：<br>os是模块负责程序与操作系统的交互，提供了访问操作系统底层的接口<br>sys模块是负责程序与python解释器的交互，提供了一系列的函数和变量，用于操控Python时运行的环境</p></li><li><p>实现一个单例模式<br>_new_（）在 _init_（）之前被调用，用于生成实例对象。利用这个方法和类的属性的特点可以实现设计模式的单例模式。<br>单例模式是指创建唯一对象，单例模式设计的类只能实例，实例化1个对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Singleton(object):</span><br><span class="line">    __instance&#x3D;None</span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line">    def __new__(cls, *args, **kwargs):</span><br><span class="line">        if Singleton.__instance is None:</span><br><span class="line">            Singleton.__instance&#x3D;object.__new__(cls,*args,**kwargs)</span><br><span class="line">        return Singleton.__instance</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      一些python相关的知识点整理
    
    </summary>
    
    
      <category term="PYTHON" scheme="https://shuke163.github.io/categories/PYTHON/"/>
    
    
      <category term="PYTHON" scheme="https://shuke163.github.io/tags/PYTHON/"/>
    
  </entry>
  
  <entry>
    <title>面向对象-使用枚举类</title>
    <link href="https://shuke163.github.io/2020/04/23/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%BD%BF%E7%94%A8%E6%9E%9A%E4%B8%BE%E7%B1%BB/"/>
    <id>https://shuke163.github.io/2020/04/23/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%BD%BF%E7%94%A8%E6%9E%9A%E4%B8%BE%E7%B1%BB/</id>
    <published>2020-04-23T08:23:06.000Z</published>
    <updated>2020-04-23T08:23:22.596Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面向对象-使用枚举类"><a href="#面向对象-使用枚举类" class="headerlink" title="面向对象-使用枚举类"></a>面向对象-使用枚举类</h2><p>当我们需要定义常量时，一个办法是用大写变量通过整数来定义，例如月份：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JAN &#x3D; 1</span><br><span class="line">FEB &#x3D; 2</span><br><span class="line">MAR &#x3D; 3</span><br><span class="line">...</span><br><span class="line">NOV &#x3D; 11</span><br><span class="line">DEC &#x3D; 12</span><br></pre></td></tr></table></figure><p>好处是简单，缺点是类型是int，并且仍然是变量。</p><p>更好的方法是为这样的枚举类型定义一个class类型，然后，每个常量都是class的一个唯一实例。Python提供了Enum类来实现这个功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from enum import Enum</span><br><span class="line"></span><br><span class="line">Month &#x3D; Enum(&#39;Month&#39;, (&#39;Jan&#39;, &#39;Feb&#39;, &#39;Mar&#39;, &#39;Apr&#39;, &#39;May&#39;, &#39;Jun&#39;, &#39;Jul&#39;, &#39;Aug&#39;, &#39;Sep&#39;, &#39;Oct&#39;, &#39;Nov&#39;, &#39;Dec&#39;))</span><br></pre></td></tr></table></figure><p>这样我们就获得了Month类型的枚举类，可以直接使用Month.Jan来引用一个常量，或者枚举它的所有成员：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for name, member in Month.__members__.items():</span><br><span class="line">    print(name, &#39;&#x3D;&gt;&#39;, member, &#39;,&#39;, member.value)</span><br></pre></td></tr></table></figure><p>value属性则是自动赋给成员的int常量，默认从1开始计数。</p><p>如果需要更精确地控制枚举类型，可以从Enum派生出自定义类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from enum import Enum, unique</span><br><span class="line"></span><br><span class="line">@unique</span><br><span class="line">class Weekday(Enum):</span><br><span class="line">    Sun &#x3D; 0 # Sun的value被设定为0</span><br><span class="line">    Mon &#x3D; 1</span><br><span class="line">    Tue &#x3D; 2</span><br><span class="line">    Wed &#x3D; 3</span><br><span class="line">    Thu &#x3D; 4</span><br><span class="line">    Fri &#x3D; 5</span><br><span class="line">    Sat &#x3D; 6</span><br></pre></td></tr></table></figure><p>@unique装饰器可以帮助我们检查保证没有重复值。</p><p>访问这些枚举类型可以有若干种方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; day1 &#x3D; Weekday.Mon</span><br><span class="line">&gt;&gt;&gt; print(day1)</span><br><span class="line">Weekday.Mon</span><br><span class="line">&gt;&gt;&gt; print(Weekday.Tue)</span><br><span class="line">Weekday.Tue</span><br><span class="line">&gt;&gt;&gt; print(Weekday[&#39;Tue&#39;])</span><br><span class="line">Weekday.Tue</span><br><span class="line">&gt;&gt;&gt; print(Weekday.Tue.value)</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; print(day1 &#x3D;&#x3D; Weekday.Mon)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; print(day1 &#x3D;&#x3D; Weekday.Tue)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; print(Weekday(1))</span><br><span class="line">Weekday.Mon</span><br><span class="line">&gt;&gt;&gt; print(day1 &#x3D;&#x3D; Weekday(1))</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; Weekday(7)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">ValueError: 7 is not a valid Weekday</span><br><span class="line">&gt;&gt;&gt; for name, member in Weekday.__members__.items():</span><br><span class="line">...     print(name, &#39;&#x3D;&gt;&#39;, member)</span><br><span class="line">...</span><br><span class="line">Sun &#x3D;&gt; Weekday.Sun</span><br><span class="line">Mon &#x3D;&gt; Weekday.Mon</span><br><span class="line">Tue &#x3D;&gt; Weekday.Tue</span><br><span class="line">Wed &#x3D;&gt; Weekday.Wed</span><br><span class="line">Thu &#x3D;&gt; Weekday.Thu</span><br><span class="line">Fri &#x3D;&gt; Weekday.Fri</span><br><span class="line">Sat &#x3D;&gt; Weekday.Sat</span><br></pre></td></tr></table></figure><p>可见，既可以用成员名称引用枚举常量，又可以直接根据value的值获得枚举常量。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>把Student的gender属性改造为枚举类型，可以避免使用字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line">from enum import Enum, unique</span><br><span class="line"></span><br><span class="line">class Gender(Enum):</span><br><span class="line">    Male &#x3D; 0</span><br><span class="line">    Female &#x3D; 1</span><br><span class="line"></span><br><span class="line">class Student(object):</span><br><span class="line">    def __init__(self, name, gender):</span><br><span class="line">        self.name &#x3D; name</span><br><span class="line">        self.gender &#x3D; gender</span><br><span class="line"># 测试:</span><br><span class="line">bart &#x3D; Student(&#39;Bart&#39;, Gender.Male)</span><br><span class="line">if bart.gender &#x3D;&#x3D; Gender.Male:</span><br><span class="line">    print(bart.gender.value)</span><br><span class="line">    print(&#39;测试通过!&#39;)</span><br><span class="line">else:</span><br><span class="line">    print(&#39;测试失败!&#39;)</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>Enum</code>可以把一组相关常量定义在一个class中，且class不可变，而且成员可以直接比较。</p><p><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/00143191235886950998592cd3e426e91687cdae696e64b000" target="_blank" rel="noopener">原文地址</a></p>]]></content>
    
    <summary type="html">
    
      面向对象-使用枚举类
    
    </summary>
    
    
      <category term="PYTHON" scheme="https://shuke163.github.io/categories/PYTHON/"/>
    
    
      <category term="PYTHON" scheme="https://shuke163.github.io/tags/PYTHON/"/>
    
  </entry>
  
  <entry>
    <title>深入类与对象-上下文管理器</title>
    <link href="https://shuke163.github.io/2020/04/23/%E6%B7%B1%E5%85%A5%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1-%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8/"/>
    <id>https://shuke163.github.io/2020/04/23/%E6%B7%B1%E5%85%A5%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1-%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8/</id>
    <published>2020-04-23T08:19:17.000Z</published>
    <updated>2020-04-23T08:20:48.980Z</updated>
    
    <content type="html"><![CDATA[<h2 id="深入类与对象-上下文管理器"><a href="#深入类与对象-上下文管理器" class="headerlink" title="深入类与对象-上下文管理器"></a>深入类与对象-上下文管理器</h2><h3 id="mixin继承"><a href="#mixin继承" class="headerlink" title="mixin继承"></a>mixin继承</h3><p>多继承会造成关系混乱，导致MRO算法出现许多预料不到的问题，一般都是推荐MIXIN继承，最小继承，只继承一个类。</p><h3 id="上下文管理器"><a href="#上下文管理器" class="headerlink" title="上下文管理器"></a>上下文管理器</h3><p>with上下文管理器，这个用过很多次，比如在执行mysql语句的时候要先链接数据库，获取游标，执行sql语句，关闭连接。又或者是文本内容的读写，打开文本写入内容关闭文本。</p><p>如果每次执行一条语句都要做这么多操作，就会产生大量重复的代码，这个时候使用上下文管理器即可美观又轻松的解决这个问题。</p><p>with管理上下文的作用是对一些重复的代码简单化，并且能优化try/except/finally的写法。</p><p>上下文的实现是通过两个魔法函数enter和exit实现，后来更新再造后，使用contextlib提供的API可以更加方便的完成。</p><p>概念和功能都明白后，最重要的还是如何实现。</p><p>举个例子：shuke去给猫买饼干，每次买的时候都要做这些动作，掏出钱包，花出x元，收回钱包。每次都要重复掏钱包收钱包这个动作有些麻烦，并且万一忘了掏钱包就不能付钱，忘了收钱包的话，钱包就掉了。每次掏钱包收钱包都要写代码，有啥简介的方式嘛？</p><h3 id="使用enter和exit实现-1"><a href="#使用enter和exit实现-1" class="headerlink" title="使用enter和exit实现(1)"></a>使用enter和exit实现(1)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">@author: shuke</span><br><span class="line">@file: 0325.py </span><br><span class="line">@time: 2019&#x2F;03&#x2F;25 16:28</span><br><span class="line">@contact: zhaofengfeng@shuke.net</span><br><span class="line">@software:  learn</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class wallet(object):</span><br><span class="line">    def __init__(self, man):</span><br><span class="line">        self.man &#x3D; man</span><br><span class="line"></span><br><span class="line">    def __enter__(self):</span><br><span class="line">        print(self.man + &#39;放心大胆的掏出了钱包&#39;)</span><br><span class="line"></span><br><span class="line">    def __exit__(self, exc_type, exc_val, exc_tb):</span><br><span class="line">        print(self.man + &#39;小心翼翼的收起来钱包&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def use_money(man):</span><br><span class="line">    return wallet(man)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">with use_money(&#39;shuke&#39;) as a:</span><br><span class="line">    print(&#39;花了600块钱&#39;)</span><br></pre></td></tr></table></figure><p>返回结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shuke放心大胆的掏出了钱包</span><br><span class="line">花了600块钱</span><br><span class="line">shuke小心翼翼的收起来钱包</span><br></pre></td></tr></table></figure><h3 id="使用enter和exit实现-2"><a href="#使用enter和exit实现-2" class="headerlink" title="使用enter和exit实现(2)"></a>使用enter和exit实现(2)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class wallet(object):</span><br><span class="line">    def __init__(self, man):</span><br><span class="line">        self.man &#x3D; man</span><br><span class="line"></span><br><span class="line">    def __enter__(self):</span><br><span class="line">        print(self.man + &#39;放心大胆的掏出了钱包&#39;)</span><br><span class="line">        # return self 这一步非常重要，作用是返回实例</span><br><span class="line">        return self</span><br><span class="line"></span><br><span class="line">    def __exit__(self, exc_type, exc_val, exc_tb):</span><br><span class="line">        print(self.man + &#39;小心翼翼的收起来钱包&#39;)</span><br><span class="line"></span><br><span class="line">    def use_money(self, money):</span><br><span class="line">        print(self.man + &#39;花了&#39; + money + &#39;元&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">with wallet(&#39;shuke02&#39;)as a:</span><br><span class="line">    a.use_money(&#39;1000&#39;)</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shuke02放心大胆的掏出了钱包</span><br><span class="line">shuke02花了1000元</span><br><span class="line">shuke02小心翼翼的收起来钱包</span><br></pre></td></tr></table></figure><h3 id="使用contextlib实现"><a href="#使用contextlib实现" class="headerlink" title="使用contextlib实现"></a>使用contextlib实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import contextlib</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@contextlib.contextmanager</span><br><span class="line">def use_money(man):</span><br><span class="line">    try:</span><br><span class="line">        print(man + &#39;十分放心大胆的掏出钱包&#39;)</span><br><span class="line">        yield None</span><br><span class="line">        # yield生成器，运行到这里会返回一个值(你随便写一个就行)</span><br><span class="line">    finally:</span><br><span class="line">        print(man + &#39;万分谨慎的收起了钱包&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">with use_money(&#39;shuke03&#39;)as a:</span><br><span class="line">    print(&#39;花了100块钱&#39;)</span><br></pre></td></tr></table></figure><p>返回结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shuke03十分放心大胆的掏出钱包</span><br><span class="line">花了100块钱</span><br><span class="line">shuke03万分谨慎的收起了钱包</span><br></pre></td></tr></table></figure><p>这只是一个创建上下文管理器的方法，按照固定的格式书写就行.</p><h3 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h3><p><a href="http://www.langzi.fun/%E6%B7%B1%E5%85%A5%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1-%E4%B8%8B.html" target="_blank" rel="noopener">深入类与对象-下</a></p>]]></content>
    
    <summary type="html">
    
      深入类与对象-上下文管理器
    
    </summary>
    
    
      <category term="PYTHON" scheme="https://shuke163.github.io/categories/PYTHON/"/>
    
    
      <category term="PYTHON" scheme="https://shuke163.github.io/tags/PYTHON/"/>
    
  </entry>
  
  <entry>
    <title>给大家安利几个 Flask 学习资源</title>
    <link href="https://shuke163.github.io/2020/04/23/%E7%BB%99%E5%A4%A7%E5%AE%B6%E5%AE%89%E5%88%A9%E5%87%A0%E4%B8%AA-Flask-%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/"/>
    <id>https://shuke163.github.io/2020/04/23/%E7%BB%99%E5%A4%A7%E5%AE%B6%E5%AE%89%E5%88%A9%E5%87%A0%E4%B8%AA-Flask-%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/</id>
    <published>2020-04-23T08:17:58.000Z</published>
    <updated>2020-04-23T08:44:25.146Z</updated>
    
    <content type="html"><![CDATA[<h2 id="给大家安利几个-Flask-学习资源"><a href="#给大家安利几个-Flask-学习资源" class="headerlink" title="给大家安利几个 Flask 学习资源"></a>给大家安利几个 Flask 学习资源</h2><p>Flask 是 Python 中最流行的 Web 框架之一，以小巧、灵活、可扩展性强著称，相比 Django，它给了开发者最大限度的自由，如果你不喜欢关系型数据库，ok，没问题，切换成本非常低，而 Django 呢？你能遇到的问题它都帮你想好并且提供了对应解决方案，你自己就不要去重复造轮子了，比如模版引擎，ORM，不爽想替换？这个有点难。</p><h3 id="1-The-Flask-Mega-Tutorial-教程"><a href="#1-The-Flask-Mega-Tutorial-教程" class="headerlink" title="1. The Flask Mega-Tutorial 教程"></a>1. The Flask Mega-Tutorial 教程</h3><p>这个教程是《Flask Web开发：基于Python的Web应用开发实战》作者 Miguel Grinberg 写的 2017版 Flask 教程，也是我强烈推荐给大家的 Flask 教程，英语阅读水平过得去的话，建议直接读原文，英语渣也有福音，国内已有网友把它翻译成了中文。</p><p><a href="https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world" target="_blank" rel="noopener">英文地址</a><br><a href="https://github.com/luhuisicnu/The-Flask-Mega-Tutorial-zh" target="_blank" rel="noopener">中文地址</a></p><h3 id="2-Flask之旅"><a href="#2-Flask之旅" class="headerlink" title="2. Flask之旅"></a>2. Flask之旅</h3><p>如果你已经入门了Flask，肯定希望有一个 Flask 最佳实践指南，让你的 Flask 项目看起来更加 professional，而本书涉及的主题就是Flask的最佳编程实践和模式。尽量避免啰嗦官方文档中提到的内容，同时也会再次强调一些概念来加深印象。</p><p><a href="http://exploreflask.com/en/latest/" target="_blank" rel="noopener">英文地址</a><br><a href="https://spacewander.github.io/explore-flask-zh/index.html" target="_blank" rel="noopener">中文地址</a></p><h3 id="3-Flask-源码解析"><a href="#3-Flask-源码解析" class="headerlink" title="3. Flask 源码解析"></a>3. Flask 源码解析</h3><p>如果你已经熟练掌握了 Flask 框架，是不是惊叹于 Flask 框架背后的设计精髓，一个精悍的Web框架究竟是如何实现的？了解它最好的办法就是窥探它的源码，还好，这件事已经有人帮你做了。</p><p><a href="http://cizixs.com/2017/01/13/flask-insight-context" target="_blank" rel="noopener">地址</a></p><h3 id="4-Awesome-Flask"><a href="#4-Awesome-Flask" class="headerlink" title="4. Awesome Flask"></a>4. Awesome Flask</h3><p>最后强烈推荐的是这个 Awesome 系列的 Flask 资源大集合，涵盖了 Flask 的各方各面，包括第三方扩展插件以及教程、书籍和视频、PPT还有项目结构等等。</p><p><a href="https://github.com/humiaozuzu/awesome-flask" target="_blank" rel="noopener">地址</a></p><h3 id="5-Flask-for-Fun-and-Profit"><a href="#5-Flask-for-Fun-and-Profit" class="headerlink" title="5. Flask for Fun and Profit"></a>5. Flask for Fun and Profit</h3><p>Flask 作者 Armin Ronacher 在PyBay2016上的一个视频分享，手把手教你如何构建一个大型复杂的易于测试的API服务。同时还有在开发Flask的过程的一些设计思想。</p><p><a href="https://www.youtube.com/watch?v=1ByQhAM5c1I" target="_blank" rel="noopener">视频地址</a><br><a href="https://speakerdeck.com/player/94a53afb6a524ad88f301f62166a27e4?" target="_blank" rel="noopener">PPT</a></p><h3 id="再补充一些其它资源："><a href="#再补充一些其它资源：" class="headerlink" title="再补充一些其它资源："></a>再补充一些其它资源：</h3><p>Flask Web 开发入门<br><a href="https://funhacks.gitbooks.io/head-first-flask/content/chapter02/section2.03.html" target="_blank" rel="noopener">https://funhacks.gitbooks.io/head-first-flask/content/chapter02/section2.03.html</a></p><p><a href="http://www.bjhee.com/flask-1.html" target="_blank" rel="noopener">Flask入门系列教程</a></p><p><a href="http://www.bjhee.com/flask-ad1.html" target="_blank" rel="noopener">Flask进阶系列教程</a></p><p>Full Stack Web Development with Flask (视频教程，需要翻土啬)<br><a href="https://github.com/realpython/discover-flask" target="_blank" rel="noopener">https://github.com/realpython/discover-flask</a></p><p>Full Stack Python<br><a href="https://www.fullstackpython.com/flask.html" target="_blank" rel="noopener">https://www.fullstackpython.com/flask.html</a></p>]]></content>
    
    <summary type="html">
    
      给大家安利几个 Flask 学习资源
    
    </summary>
    
    
      <category term="Flask" scheme="https://shuke163.github.io/categories/Flask/"/>
    
    
      <category term="Flask" scheme="https://shuke163.github.io/tags/Flask/"/>
    
  </entry>
  
  <entry>
    <title>zabbix使用python获取阿里云SLB带宽</title>
    <link href="https://shuke163.github.io/2020/04/23/zabbix%E4%BD%BF%E7%94%A8python%E8%8E%B7%E5%8F%96%E9%98%BF%E9%87%8C%E4%BA%91SLB%E5%B8%A6%E5%AE%BD/"/>
    <id>https://shuke163.github.io/2020/04/23/zabbix%E4%BD%BF%E7%94%A8python%E8%8E%B7%E5%8F%96%E9%98%BF%E9%87%8C%E4%BA%91SLB%E5%B8%A6%E5%AE%BD/</id>
    <published>2020-04-23T08:16:12.000Z</published>
    <updated>2020-04-23T08:16:23.469Z</updated>
    
    <content type="html"><![CDATA[<h2 id="zabbix使用python获取阿里云SLB带宽"><a href="#zabbix使用python获取阿里云SLB带宽" class="headerlink" title="zabbix使用python获取阿里云SLB带宽"></a>zabbix使用python获取阿里云SLB带宽</h2><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/qgRAExPhngfpWON9icxJarejKzj940jmKeg9B7m6hgribxIaWtbYNsndFU2NVpxOIVr9oZAT7Phn93Zulicjnladw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="展示图"></p><h3 id="阿里云SDK"><a href="#阿里云SDK" class="headerlink" title="阿里云SDK"></a>阿里云SDK</h3><p>阿里云目前提供了很多的SDK，并且可以使用在线调试工具，虽然有些bug</p><p><a href="https://develop.aliyun.com/tools/sdk?#/python" target="_blank" rel="noopener">Python-sdk</a></p><p><a href="https://api.aliyun.com/?spm=5176.143622.743215.5.524c6168naUyOU" target="_blank" rel="noopener">在线调试工具</a></p><p>但是主页面的SDK列表里面并没有SLB，并且翻了下aliyun-python-sdk-slb (2.1.2)这个包里面好像也没有带宽相关的描述。别急，我们还有云监控的SDK。</p><p>这里我们使用了阿里云云监控的SDK（aliyun-python-sdk-cms (5.0.0)）</p><p>获取SLB带宽<br>Python2.7调试通过，需要使用pip安装<code>liyun-python-sdk-core，aliyun-python-sdk-cms</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line">#coding&#x3D;utf-8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">from aliyunsdkcore import client</span><br><span class="line"></span><br><span class="line">from aliyunsdkcms.request.v20170301 import QueryMetricListRequest</span><br><span class="line"></span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">clt &#x3D; client.AcsClient(&#39;&lt;ACCESSKEY&gt;&#39;,&#39;&lt;SECRETKEY&gt;&#39;,&#39;cn-beijing&#39;)</span><br><span class="line"></span><br><span class="line">request &#x3D; QueryMetricListRequest.QueryMetricListRequest()</span><br><span class="line"></span><br><span class="line">request.set_accept_format(&#39;json&#39;)</span><br><span class="line"></span><br><span class="line">#两个参数按照预设值设定，参见参考资料描述</span><br><span class="line"></span><br><span class="line">request.set_Project(&#39;acs_slb&#39;)</span><br><span class="line"></span><br><span class="line">request.set_Metric(&#39;TrafficTXNew&#39;)</span><br><span class="line"></span><br><span class="line">#只获取1小时内的数据</span><br><span class="line"></span><br><span class="line">start_time &#x3D; time.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;,time.localtime(time.time()-3600))</span><br><span class="line"></span><br><span class="line">timestamp_start &#x3D; int(time.mktime(time.strptime(start_time, &quot;%Y-%m-%d %H:%M:%S&quot;))) * 1000</span><br><span class="line"></span><br><span class="line">request.set_StartTime(timestamp_start)</span><br><span class="line"></span><br><span class="line">#从系统输入参数获取IP地址和SLB-ID</span><br><span class="line"></span><br><span class="line">slbip &#x3D; sys.argv[1]</span><br><span class="line"></span><br><span class="line">slbid &#x3D; sys.argv[2]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">request.set_Dimensions(&#123;&#39;instanceId&#39;:slbid,&#39;port&#39;:&#39;443&#39;,&#39;vip&#39;:slbip&#125;)</span><br><span class="line"></span><br><span class="line">request.set_Period(&#39;60&#39;)</span><br><span class="line"></span><br><span class="line">#result &#x3D; clt.do_action(request)</span><br><span class="line"></span><br><span class="line">result &#x3D; clt.do_action_with_exception(request)</span><br><span class="line"></span><br><span class="line">#print result</span><br><span class="line"></span><br><span class="line">#json结果处理</span><br><span class="line"></span><br><span class="line">datadict &#x3D; json.loads(result)</span><br><span class="line"></span><br><span class="line">#取倒数第二条数据，因为倒数第一条不太准</span><br><span class="line"></span><br><span class="line">res &#x3D; datadict[&#39;Datapoints&#39;][-2][&#39;Average&#39;]</span><br><span class="line"></span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure><p>使用方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python ali-slb.py  &lt;IP地址&gt;  &lt;SLB的ID&gt;</span><br></pre></td></tr></table></figure><p>然后接入zabbix，使用grafana就可以出图了。</p>]]></content>
    
    <summary type="html">
    
      zabbix使用python获取阿里云SLB带宽
    
    </summary>
    
    
      <category term="Zabbix" scheme="https://shuke163.github.io/categories/Zabbix/"/>
    
    
      <category term="Zabbix" scheme="https://shuke163.github.io/tags/Zabbix/"/>
    
  </entry>
  
  <entry>
    <title>Vim命令合集</title>
    <link href="https://shuke163.github.io/2020/04/23/Vim%E5%91%BD%E4%BB%A4%E5%90%88%E9%9B%86/"/>
    <id>https://shuke163.github.io/2020/04/23/Vim%E5%91%BD%E4%BB%A4%E5%90%88%E9%9B%86/</id>
    <published>2020-04-23T08:15:47.000Z</published>
    <updated>2020-04-23T08:15:57.548Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vim命令合集"><a href="#Vim命令合集" class="headerlink" title="Vim命令合集"></a>Vim命令合集</h2><h3 id="命令历史"><a href="#命令历史" class="headerlink" title="命令历史"></a>命令历史</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">以:和&#x2F;开头的命令都有历史纪录，可以首先键入:或&#x2F;然后按上下箭头来选择某个历史命令。</span><br></pre></td></tr></table></figure><h3 id="启动vim"><a href="#启动vim" class="headerlink" title="启动vim"></a>启动vim</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在命令行窗口中输入以下命令即可</span><br><span class="line"></span><br><span class="line">vim 直接启动vim</span><br><span class="line"></span><br><span class="line">vim filename 打开vim并创建名为filename的文件</span><br></pre></td></tr></table></figure><h3 id="文件命令"><a href="#文件命令" class="headerlink" title="文件命令"></a>文件命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">打开单个文件</span><br><span class="line">vim file</span><br><span class="line"></span><br><span class="line">同时打开多个文件</span><br><span class="line">vim file1 file2 file3 …</span><br><span class="line"></span><br><span class="line">在vim窗口中打开一个新文件</span><br><span class="line">:open file</span><br><span class="line"></span><br><span class="line">在新窗口中打开文件</span><br><span class="line">:split file</span><br><span class="line"></span><br><span class="line">切换到下一个文件</span><br><span class="line">:bn</span><br><span class="line"></span><br><span class="line">切换到上一个文件</span><br><span class="line">:bp</span><br><span class="line"></span><br><span class="line">查看当前打开的文件列表，当前正在编辑的文件会用[]括起来。</span><br><span class="line">:args</span><br><span class="line"></span><br><span class="line">### 打开远程文件，比如ftp或者share folder</span><br><span class="line">:e ftp:&#x2F;&#x2F;192.168.10.76&#x2F;abc.txt</span><br><span class="line">:e \\qadrive\test\1.txt</span><br></pre></td></tr></table></figure><h3 id="vim的模式"><a href="#vim的模式" class="headerlink" title="vim的模式"></a>vim的模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">正常模式（按Esc或Ctrl+[进入） 左下角显示文件名或为空</span><br><span class="line"></span><br><span class="line">插入模式（按i键进入） 左下角显示–INSERT–</span><br><span class="line"></span><br><span class="line">可视模式（不知道如何进入） 左下角显示–VISUAL–</span><br></pre></td></tr></table></figure><h3 id="导航命令"><a href="#导航命令" class="headerlink" title="导航命令"></a>导航命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">% 括号匹配</span><br></pre></td></tr></table></figure><h3 id="插入命令"><a href="#插入命令" class="headerlink" title="插入命令"></a>插入命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">i 在当前位置生前插入</span><br><span class="line"></span><br><span class="line">I 在当前行首插入</span><br><span class="line"></span><br><span class="line">a 在当前位置后插入</span><br><span class="line"></span><br><span class="line">A 在当前行尾插入</span><br><span class="line"></span><br><span class="line">o 在当前行之后插入一行</span><br><span class="line"></span><br><span class="line">O 在当前行之前插入一行</span><br></pre></td></tr></table></figure><h3 id="查找命令"><a href="#查找命令" class="headerlink" title="查找命令"></a>查找命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;text　　查找text，按n健查找下一个，按N健查找前一个</span><br><span class="line"></span><br><span class="line">?text　　查找text，反向查找，按n健查找下一个，按N健查找前一个。</span><br><span class="line"></span><br><span class="line">vim中有一些特殊字符在查找时需要转义　　.*[]^%&#x2F;?~$</span><br><span class="line"></span><br><span class="line">:set ignorecase　　忽略大小写的查找</span><br><span class="line"></span><br><span class="line">:set noignorecase　　不忽略大小写的查找</span><br><span class="line"></span><br><span class="line">查找很长的词，如果一个词很长，键入麻烦，可以将光标移动到该词上，按*或#键即可以该单词进行搜索，相当于&#x2F;搜索。而#命令相当于?搜索。</span><br><span class="line"></span><br><span class="line">:set hlsearch　　高亮搜索结果，所有结果都高亮显示，而不是只显示一个匹配。</span><br><span class="line">:set nohlsearch　　关闭高亮搜索显示</span><br><span class="line">:nohlsearch　　关闭当前的高亮显示，如果再次搜索或者按下n或N键，则会再次高亮。</span><br><span class="line">:set incsearch　　逐步搜索模式，对当前键入的字符进行搜索而不必等待键入完成。</span><br><span class="line">:set wrapscan　　重新搜索，在搜索到文件头或尾时，返回继续搜索，默认开启。</span><br></pre></td></tr></table></figure><h3 id="替换命令"><a href="#替换命令" class="headerlink" title="替换命令"></a>替换命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ra 将当前字符替换为a，当期字符即光标所在字符。</span><br><span class="line"></span><br><span class="line">s&#x2F;old&#x2F;new&#x2F; 用old替换new，替换当前行的第一个匹配</span><br><span class="line"></span><br><span class="line">s&#x2F;old&#x2F;new&#x2F;g 用old替换new，替换当前行的所有匹配</span><br><span class="line"></span><br><span class="line">%s&#x2F;old&#x2F;new&#x2F; 用old替换new，替换所有行的第一个匹配</span><br><span class="line"></span><br><span class="line">%s&#x2F;old&#x2F;new&#x2F;g 用old替换new，替换整个文件的所有匹配</span><br><span class="line"></span><br><span class="line">:10,20 s&#x2F;^&#x2F;    &#x2F;g 在第10行知第20行每行前面加四个空格，用于缩进。</span><br><span class="line"></span><br><span class="line">ddp 交换光标所在行和其下紧邻的一行。</span><br></pre></td></tr></table></figure><h3 id="移动命令"><a href="#移动命令" class="headerlink" title="移动命令"></a>移动命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">- h 左移一个字符</span><br><span class="line">- l 右移一个字符，这个命令很少用，一般用w代替。</span><br><span class="line">- k 上移一个字符</span><br><span class="line">- j 下移一个字符</span><br><span class="line"></span><br><span class="line">以上四个命令可以配合数字使用，比如20j就是向下移动20行，5h就是向左移动5个字符，在Vim中，很多命令都可以配合数字使用，比如删除10个字符10x，在当前位置后插入3个！，3a！&lt;Esc&gt;，这里的Esc是必须的，否则命令不生效。</span><br><span class="line"></span><br><span class="line">w 向前移动一个单词（光标停在单词首部），如果已到行尾，则转至下一行行首。此命令快，可以代替l命令。</span><br><span class="line"></span><br><span class="line">b 向后移动一个单词 2b 向后移动2个单词</span><br><span class="line"></span><br><span class="line">e，同w，只不过是光标停在单词尾部</span><br><span class="line"></span><br><span class="line">ge，同b，光标停在单词尾部。</span><br><span class="line"></span><br><span class="line">^ 移动到本行第一个非空白字符上。</span><br><span class="line"></span><br><span class="line">0（数字0）移动到本行第一个字符上，</span><br><span class="line"></span><br><span class="line">&lt;HOME&gt; 移动到本行第一个字符。同0健。</span><br><span class="line"></span><br><span class="line">$ 移动到行尾 3$ 移动到下面3行的行尾</span><br><span class="line"></span><br><span class="line">gg 移动到文件头。 &#x3D; [[</span><br><span class="line"></span><br><span class="line">G（shift + g） 移动到文件尾。 &#x3D; ]]</span><br><span class="line"></span><br><span class="line">f（find）命令也可以用于移动，fx将找到光标后第一个为x的字符，3fd将找到第三个为d的字符。</span><br><span class="line"></span><br><span class="line">F 同f，反向查找。</span><br><span class="line"></span><br><span class="line">跳到指定行，冒号+行号，回车，比如跳到240行就是 :240回车。另一个方法是行号+G，比如230G跳到230行。</span><br><span class="line"></span><br><span class="line">Ctrl + e 向下滚动一行</span><br><span class="line"></span><br><span class="line">Ctrl + y 向上滚动一行</span><br><span class="line"></span><br><span class="line">Ctrl + d 向下滚动半屏</span><br><span class="line"></span><br><span class="line">Ctrl + u 向上滚动半屏</span><br><span class="line"></span><br><span class="line">Ctrl + f 向下滚动一屏</span><br><span class="line"></span><br><span class="line">Ctrl + b 向上滚动一屏</span><br></pre></td></tr></table></figure><h3 id="撤销和重做"><a href="#撤销和重做" class="headerlink" title="撤销和重做"></a>撤销和重做</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">u 撤销（Undo）</span><br><span class="line"></span><br><span class="line">U 撤销对整行的操作</span><br><span class="line"></span><br><span class="line">Ctrl + r 重做（Redo），即撤销的撤销。</span><br></pre></td></tr></table></figure><h3 id="删除命令"><a href="#删除命令" class="headerlink" title="删除命令"></a>删除命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">x 删除当前字符</span><br><span class="line"></span><br><span class="line">3x 删除当前光标开始向后三个字符</span><br><span class="line"></span><br><span class="line">X 删除当前字符的前一个字符。X&#x3D;dh</span><br><span class="line"></span><br><span class="line">dl 删除当前字符， dl&#x3D;x</span><br><span class="line"></span><br><span class="line">dh 删除前一个字符</span><br><span class="line"></span><br><span class="line">dd 删除当前行</span><br><span class="line"></span><br><span class="line">dj 删除上一行</span><br><span class="line"></span><br><span class="line">dk 删除下一行</span><br><span class="line"></span><br><span class="line">10d 删除当前行开始的10行。</span><br><span class="line"></span><br><span class="line">D 删除当前字符至行尾。D&#x3D;d$</span><br><span class="line"></span><br><span class="line">d$ 删除当前字符之后的所有字符（本行）</span><br><span class="line"></span><br><span class="line">kdgg 删除当前行之前所有行（不包括当前行）</span><br><span class="line"></span><br><span class="line">jdG（jd shift + g）   删除当前行之后所有行（不包括当前行）</span><br><span class="line"></span><br><span class="line">:1,10d 删除1-10行</span><br><span class="line"></span><br><span class="line">:11,$d 删除11行及以后所有的行</span><br><span class="line"></span><br><span class="line">:1,$d 删除所有行</span><br><span class="line"></span><br><span class="line">J(shift + j)　　删除两行之间的空行，实际上是合并两行。</span><br></pre></td></tr></table></figure><h3 id="拷贝和粘贴"><a href="#拷贝和粘贴" class="headerlink" title="拷贝和粘贴"></a>拷贝和粘贴</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">yy 拷贝当前行</span><br><span class="line"></span><br><span class="line">nyy 拷贝当前后开始的n行，比如2yy拷贝当前行及其下一行。</span><br><span class="line"></span><br><span class="line">p  在当前光标后粘贴,如果之前使用了yy命令来复制一行，那么就在当前行的下一行粘贴。</span><br><span class="line"></span><br><span class="line">shift+p 在当前行前粘贴</span><br><span class="line"></span><br><span class="line">:1,10 co 20 将1-10行插入到第20行之后。</span><br><span class="line"></span><br><span class="line">:1,$ co $ 将整个文件复制一份并添加到文件尾部。</span><br><span class="line"></span><br><span class="line">正常模式下按v（逐字）或V（逐行）进入可视模式，然后用jklh命令移动即可选择某些行或字符，再按y即可复制</span><br><span class="line">ddp交换当前行和其下一行</span><br><span class="line"></span><br><span class="line">xp交换当前字符和其后一个字符</span><br></pre></td></tr></table></figure><h3 id="剪切命令"><a href="#剪切命令" class="headerlink" title="剪切命令"></a>剪切命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">正常模式下按v（逐字）或V（逐行）进入可视模式，然后用jklh命令移动即可选择某些行或字符，再按d即可剪切</span><br><span class="line"></span><br><span class="line">ndd 剪切当前行之后的n行。利用p命令可以对剪切的内容进行粘贴</span><br><span class="line"></span><br><span class="line">:1,10d 将1-10行剪切。利用p命令可将剪切后的内容进行粘贴。</span><br><span class="line"></span><br><span class="line">:1, 10 m 20 将第1-10行移动到第20行之后。</span><br></pre></td></tr></table></figure><h3 id="退出命令"><a href="#退出命令" class="headerlink" title="退出命令"></a>退出命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">:wq 保存并退出</span><br><span class="line"></span><br><span class="line">ZZ 保存并退出</span><br><span class="line"></span><br><span class="line">:q! 强制退出并忽略所有更改</span><br><span class="line"></span><br><span class="line">:e! 放弃所有修改，并打开原来文件。</span><br></pre></td></tr></table></figure><h3 id="窗口命令"><a href="#窗口命令" class="headerlink" title="窗口命令"></a>窗口命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">:split或new 打开一个新窗口，光标停在顶层的窗口上</span><br><span class="line"></span><br><span class="line">:split file或:new file 用新窗口打开文件</span><br><span class="line"></span><br><span class="line">split打开的窗口都是横向的，使用vsplit可以纵向打开窗口。</span><br><span class="line"></span><br><span class="line">Ctrl+ww 移动到下一个窗口</span><br><span class="line"></span><br><span class="line">Ctrl+wj 移动到下方的窗口</span><br><span class="line"></span><br><span class="line">Ctrl+wk 移动到上方的窗口</span><br></pre></td></tr></table></figure><h3 id="关闭窗口"><a href="#关闭窗口" class="headerlink" title="关闭窗口"></a>关闭窗口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">:close 最后一个窗口不能使用此命令，可以防止意外退出vim。</span><br><span class="line"></span><br><span class="line">:q 如果是最后一个被关闭的窗口，那么将退出vim。</span><br><span class="line"></span><br><span class="line">ZZ 保存并退出。</span><br><span class="line"></span><br><span class="line">关闭所有窗口，只保留当前窗口</span><br><span class="line"></span><br><span class="line">:only</span><br></pre></td></tr></table></figure><h3 id="录制宏"><a href="#录制宏" class="headerlink" title="录制宏"></a>录制宏</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">按q键加任意字母开始录制，再按q键结束录制（这意味着vim中的宏不可嵌套），使用的时候@加宏名，比如qa。。。q录制名为a的宏，@a使用这个宏。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">执行shell命令</span><br><span class="line"></span><br><span class="line">:!command</span><br><span class="line"></span><br><span class="line">:!ls 列出当前目录下文件</span><br><span class="line"></span><br><span class="line">:!perl -c script.pl 检查perl脚本语法，可以不用退出vim，非常方便。</span><br><span class="line"></span><br><span class="line">:!perl script.pl 执行perl脚本，可以不用退出vim，非常方便。</span><br><span class="line"></span><br><span class="line">:suspend或Ctrl – Z 挂起vim，回到shell，按fg可以返回vim。</span><br></pre></td></tr></table></figure><h3 id="注释命令"><a href="#注释命令" class="headerlink" title="注释命令"></a>注释命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">perl程序中#开始的行为注释，所以要注释某些行，只需在行首加入#</span><br><span class="line"></span><br><span class="line">3,5 s&#x2F;^&#x2F;#&#x2F;g 注释第3-5行</span><br><span class="line"></span><br><span class="line">3,5 s&#x2F;^#&#x2F;&#x2F;g 解除3-5行的注释</span><br><span class="line"></span><br><span class="line">1,$ s&#x2F;^&#x2F;#&#x2F;g 注释整个文档。</span><br><span class="line"></span><br><span class="line">:%s&#x2F;^&#x2F;#&#x2F;g 注释整个文档，此法更快。</span><br></pre></td></tr></table></figure><h3 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">:help or F1 显示整个帮助</span><br><span class="line"></span><br><span class="line">:help xxx 显示xxx的帮助，比如 :help i, :help CTRL-[（即Ctrl+[的帮助）。</span><br><span class="line"></span><br><span class="line">:help ‘number’ Vim选项的帮助用单引号括起</span><br><span class="line"></span><br><span class="line">:help &lt;Esc&gt;特殊键的帮助用&lt;&gt;扩起</span><br><span class="line"></span><br><span class="line">:help -t Vim启动参数的帮助用-</span><br><span class="line"></span><br><span class="line">:help i_&lt;Esc&gt; 插入模式下Esc的帮助，某个模式下的帮助用模式_主题的模式</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">帮助文件中位于||之间的内容是超链接，可以用Ctrl+]进入链接，Ctrl+o（Ctrl + t）返回</span><br></pre></td></tr></table></figure><h3 id="其他非编辑命令"><a href="#其他非编辑命令" class="headerlink" title="其他非编辑命令"></a>其他非编辑命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">. 重复前一次命令</span><br><span class="line"></span><br><span class="line">:set ruler?　　查看是否设置了ruler，在.vimrc中，使用set命令设制的选项都可以通过这个命令查看</span><br><span class="line"></span><br><span class="line">:scriptnames　　查看vim脚本文件的位置，比如.vimrc文件，语法文件及plugin等。</span><br><span class="line"></span><br><span class="line">:set list 显示非打印字符，如tab，空格，行尾等。如果tab无法显示，请确定用set lcs&#x3D;tab:&gt;-命令设置了.vimrc文件，并确保你的文件中的确有tab，如果开启了expendtab，那么tab将被扩展为空格。</span><br></pre></td></tr></table></figure><h3 id="Vim教程"><a href="#Vim教程" class="headerlink" title="Vim教程"></a>Vim教程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">在Unix系统上</span><br><span class="line"></span><br><span class="line">$ vimtutor</span><br><span class="line"></span><br><span class="line">在Windows系统上</span><br><span class="line">:help tutor</span><br><span class="line"></span><br><span class="line">:syntax 列出已经定义的语法项</span><br><span class="line"></span><br><span class="line">:syntax clear 清除已定义的语法规则</span><br><span class="line"></span><br><span class="line">:syntax case match 大小写敏感，int和Int将视为不同的语法元素</span><br><span class="line"></span><br><span class="line">:syntax case ignore 大小写无关，int和Int将视为相同的语法元素，并使用同样的配色方案</span><br></pre></td></tr></table></figure><h3 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h3><p>[<a href="http://www.cnblogs.com/softwaretesting/archive/2011/07/12/2104435.html" target="_blank" rel="noopener">Vim命令合集</a>]</p>]]></content>
    
    <summary type="html">
    
      Vim命令合集
    
    </summary>
    
    
      <category term="Vim" scheme="https://shuke163.github.io/categories/Vim/"/>
    
    
      <category term="Vim" scheme="https://shuke163.github.io/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>SFTP</title>
    <link href="https://shuke163.github.io/2020/04/23/SFTP/"/>
    <id>https://shuke163.github.io/2020/04/23/SFTP/</id>
    <published>2020-04-23T08:14:52.000Z</published>
    <updated>2020-04-23T08:15:18.680Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SFTP"><a href="#SFTP" class="headerlink" title="SFTP"></a>SFTP</h2><p>服务器地址：10.40.14.26(内网)  47.94.162.132(公网)   域名：ftp.wecash.net</p><p>SFTP配置过程<br>   1 连接用户根据用户需求添加系统用户配置密码，例：</p><pre><code>useradd sftp_testpasswd sftp_test</code></pre><p>   2  将用户加入sftp-group组（已预先添加）</p><pre><code>usermod -a -G  sftp-group sftp_test</code></pre><p>   3 创建chroot目录，该目录为sftp用户登录的目录，权限为root，限制用户在此目录操作权限，并且创建用户的操作目录</p><pre><code>mkdir /data/sftpmkdir /data/sftp/test 授权操作目录chown sftp_test:sftp-group /data/sftp/test</code></pre><p>4 配置ssh配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># cat &#x2F;etc&#x2F;ssh&#x2F;sshd_config</span><br><span class="line">Protocol 2</span><br><span class="line">Port 22</span><br><span class="line">AddressFamily any</span><br><span class="line">ListenAddress 0.0.0.0</span><br><span class="line">AllowGroups root</span><br><span class="line">AllowGroups yunwei deploy sftp-group</span><br><span class="line">AuthorizedKeysCommand &#x2F;usr&#x2F;bin&#x2F;sss_ssh_authorizedkeys</span><br><span class="line">AuthorizedKeysCommandUser root</span><br><span class="line">ChallengeResponseAuthentication yes</span><br><span class="line">LogLevel INFO</span><br><span class="line">PasswordAuthentication yes</span><br><span class="line">PermitEmptyPasswords no</span><br><span class="line">PermitRootLogin yes</span><br><span class="line">PubkeyAuthentication yes</span><br><span class="line">Subsystem sftp-user &#x2F;usr&#x2F;lib&#x2F;openssh&#x2F;sftp-server</span><br><span class="line">SyslogFacility AUTHPRIV</span><br><span class="line">UsePAM yes</span><br><span class="line">X11Forwarding yes</span><br><span class="line">Subsystem sftp &#x2F;usr&#x2F;lib&#x2F;openssh&#x2F;sftp-server</span><br><span class="line">Match Group sftp-group</span><br><span class="line">ChrootDirectory &#x2F;data&#x2F;sftp</span><br><span class="line">AllowTcpForwarding no</span><br><span class="line">PermitTunnel no</span><br><span class="line">ForceCommand internal-sftp</span><br></pre></td></tr></table></figure><p>新增配置：<br>         AllowGroups yunwei deploy sftp-group<br>         Subsystem sftp /usr/lib/openssh/sftp-servers<br>         Match Group sftp-group<br>         ChrootDirectory /data/sftp<br>         AllowTcpForwarding no<br>         PermitTunnel no<br>         ForceCommand internal-sftp<br>    重启sshd服务</p><pre><code>连接方式： sftp sftp_test@10.40.14.26使用ssh连接会提示仅用sftp连接：        This service allows sftp connections only.        Connection to 10.40.14.26 closed.</code></pre>]]></content>
    
    <summary type="html">
    
      SFTP
    
    </summary>
    
    
      <category term="SFTP" scheme="https://shuke163.github.io/categories/SFTP/"/>
    
    
      <category term="SFTP" scheme="https://shuke163.github.io/tags/SFTP/"/>
    
  </entry>
  
  <entry>
    <title>Redis集群部署</title>
    <link href="https://shuke163.github.io/2020/04/23/Redis%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/"/>
    <id>https://shuke163.github.io/2020/04/23/Redis%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/</id>
    <published>2020-04-23T08:14:25.000Z</published>
    <updated>2020-04-23T08:14:37.618Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis集群部署"><a href="#Redis集群部署" class="headerlink" title="Redis集群部署"></a>Redis集群部署</h2><h2 id="Redis集群部署-1"><a href="#Redis集群部署-1" class="headerlink" title="Redis集群部署"></a>Redis集群部署</h2><ol><li>编译安装<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># cd &#x2F;usr&#x2F;local&#x2F;src&#x2F;</span><br><span class="line"># wget http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-5.0.0.tar.gz</span><br><span class="line"># tar zxvf redis-5.0.0.tar.gz</span><br><span class="line"># apt-get update &amp;&amp; apt-get install -y gcc automake make</span><br><span class="line"># cd redis-5.0.0 &amp;&amp; make &amp;&amp; make install</span><br><span class="line"># cp .&#x2F;src&#x2F;redis-server &#x2F;usr&#x2F;bin&#x2F;</span><br><span class="line"># cp .&#x2F;src&#x2F;redis-cli &#x2F;usr&#x2F;bin&#x2F;</span><br></pre></td></tr></table></figure></li><li>创建服务启停脚本(如果需要)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># cp .&#x2F;utils&#x2F;redis_init_script &#x2F;etc&#x2F;init.d&#x2F;redisd</span><br><span class="line"># service redisd start</span><br></pre></td></tr></table></figure></li><li>创建目录及配置文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"># mkdir &#x2F;tmp&#x2F;redis-cluster&#x2F;&#123;7000,7001,7002,7003,7004,7005&#125;&#x2F;log -pv</span><br><span class="line"># cp &#x2F;usr&#x2F;local&#x2F;src&#x2F;redis-5.0.0&#x2F;redis.conf &#x2F;data&#x2F;redis-cluster&#x2F;7000&#x2F;redis.conf</span><br><span class="line"># cd &#x2F;data&#x2F;redis-cluster&#x2F; &amp;&amp; cat 7000&#x2F;redis.conf</span><br><span class="line">bind 0.0.0.0</span><br><span class="line">protected-mode yes</span><br><span class="line">port 7000</span><br><span class="line">tcp-backlog 511</span><br><span class="line">timeout 0</span><br><span class="line">tcp-keepalive 300</span><br><span class="line">daemonize yes</span><br><span class="line">supervised no</span><br><span class="line">pidfile &#x2F;var&#x2F;run&#x2F;redis_7000.pid</span><br><span class="line">loglevel notice</span><br><span class="line">logfile &quot;&#x2F;data&#x2F;redis-cluster&#x2F;7000&#x2F;log&#x2F;redis-7000.log&quot;</span><br><span class="line">databases 16</span><br><span class="line">always-show-logo yes</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line">rdbcompression yes</span><br><span class="line">rdbchecksum yes</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line">dir .&#x2F;</span><br><span class="line">replica-serve-stale-data yes</span><br><span class="line">replica-read-only yes</span><br><span class="line">repl-diskless-sync no</span><br><span class="line">repl-diskless-sync-delay 5</span><br><span class="line">repl-disable-tcp-nodelay no</span><br><span class="line">replica-priority 100</span><br><span class="line">lazyfree-lazy-eviction no</span><br><span class="line">lazyfree-lazy-expire no</span><br><span class="line">lazyfree-lazy-server-del no</span><br><span class="line">replica-lazy-flush no</span><br><span class="line">appendonly yes</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line">appendfsync everysec</span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line">aof-load-truncated yes</span><br><span class="line">aof-use-rdb-preamble yes</span><br><span class="line">lua-time-limit 5000</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes.conf</span><br><span class="line">cluster-node-timeout 15000</span><br><span class="line">slowlog-log-slower-than 10000</span><br><span class="line">slowlog-max-len 128</span><br><span class="line">latency-monitor-threshold 0</span><br><span class="line">notify-keyspace-events &quot;&quot;</span><br><span class="line">hash-max-ziplist-entries 512</span><br><span class="line">hash-max-ziplist-value 64</span><br><span class="line">list-max-ziplist-size -2</span><br><span class="line">list-compress-depth 0</span><br><span class="line">set-max-intset-entries 512</span><br><span class="line">zset-max-ziplist-entries 128</span><br><span class="line">zset-max-ziplist-value 64</span><br><span class="line">hll-sparse-max-bytes 3000</span><br><span class="line">stream-node-max-bytes 4096</span><br><span class="line">stream-node-max-entries 100</span><br><span class="line">activerehashing yes</span><br><span class="line">client-output-buffer-limit normal 0 0 0</span><br><span class="line">client-output-buffer-limit replica 256mb 64mb 60</span><br><span class="line">client-output-buffer-limit pubsub 32mb 8mb 60</span><br><span class="line">hz 10</span><br><span class="line">dynamic-hz yes</span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br><span class="line">rdb-save-incremental-fsync yes</span><br><span class="line">masterauth AuDdQdpuEZpXgNthP6CjYjPb</span><br><span class="line">requirepass AuDdQdpuEZpXgNthP6CjYjPb</span><br><span class="line">修改其他端口配置文件</span><br><span class="line"># cp 7000&#x2F;redis.conf 7001&#x2F;</span><br><span class="line"># cp 7000&#x2F;redis.conf 7002&#x2F;</span><br><span class="line"># cp 7000&#x2F;redis.conf 7003&#x2F;</span><br><span class="line"># cp 7000&#x2F;redis.conf 7004&#x2F;</span><br><span class="line"># cp 7000&#x2F;redis.conf 7005&#x2F;</span><br><span class="line"># sed -i &#39;s&#x2F;7000&#x2F;7001&#x2F;g&#39; 7001&#x2F;redis.conf</span><br><span class="line"># sed -i &#39;s&#x2F;7000&#x2F;7002&#x2F;g&#39; 7002&#x2F;redis.conf</span><br><span class="line"># sed -i &#39;s&#x2F;7000&#x2F;7003&#x2F;g&#39; 7003&#x2F;redis.conf</span><br><span class="line"># sed -i &#39;s&#x2F;7000&#x2F;7004&#x2F;g&#39; 7004&#x2F;redis.conf</span><br><span class="line"># sed -i &#39;s&#x2F;7000&#x2F;7005&#x2F;g&#39; 7005&#x2F;redis.conf</span><br></pre></td></tr></table></figure></li><li>调整下内存分配使用方式并使其生效<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#此参数可用的值为0,1,2 </span><br><span class="line">#0表示当用户空间请求更多的内存时，内核尝试估算出可用的内存 </span><br><span class="line">#1表示内核允许超量使用内存直到内存用完为止 </span><br><span class="line">#2表示整个内存地址空间不能超过swap+(vm.overcommit_ratio)%的RAM值 </span><br><span class="line">echo &quot;vm.overcommit_memory&#x3D;1&quot;&gt;&gt;&#x2F;etc&#x2F;sysctl.conf</span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure></li><li>制作启动脚本<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># cat start-redis-cluster.sh</span><br><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">cd &#x2F;data&#x2F;redis-cluster</span><br><span class="line"></span><br><span class="line">cd 7000 &amp;&amp; &#x2F;usr&#x2F;bin&#x2F;redis-server &#x2F;data&#x2F;redis-cluster&#x2F;7000&#x2F;redis.conf</span><br><span class="line">cd ..&#x2F;7001 &amp;&amp; &#x2F;usr&#x2F;bin&#x2F;redis-server &#x2F;data&#x2F;redis-cluster&#x2F;7001&#x2F;redis.conf</span><br><span class="line">cd ..&#x2F;7002 &amp;&amp; &#x2F;usr&#x2F;bin&#x2F;redis-server &#x2F;data&#x2F;redis-cluster&#x2F;7002&#x2F;redis.conf</span><br><span class="line">cd ..&#x2F;7003 &amp;&amp; &#x2F;usr&#x2F;bin&#x2F;redis-server &#x2F;data&#x2F;redis-cluster&#x2F;7003&#x2F;redis.conf</span><br><span class="line">cd ..&#x2F;7004 &amp;&amp; &#x2F;usr&#x2F;bin&#x2F;redis-server &#x2F;data&#x2F;redis-cluster&#x2F;7004&#x2F;redis.conf</span><br><span class="line">cd ..&#x2F;7005 &amp;&amp; &#x2F;usr&#x2F;bin&#x2F;redis-server &#x2F;data&#x2F;redis-cluster&#x2F;7005&#x2F;redis.conf</span><br></pre></td></tr></table></figure></li><li>启动服务<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># bash start-redis-cluster.sh</span><br><span class="line"># ps -ef|grep redis</span><br><span class="line">root     30192     1  0 06:54 ?        00:00:04 &#x2F;usr&#x2F;bin&#x2F;redis-server 0.0.0.0:7000 [cluster]</span><br><span class="line">root     30194     1  0 06:54 ?        00:00:05 &#x2F;usr&#x2F;bin&#x2F;redis-server 0.0.0.0:7001 [cluster]</span><br><span class="line">root     30196     1  0 06:54 ?        00:00:04 &#x2F;usr&#x2F;bin&#x2F;redis-server 0.0.0.0:7002 [cluster]</span><br><span class="line">root     30201     1  0 06:54 ?        00:00:04 &#x2F;usr&#x2F;bin&#x2F;redis-server 0.0.0.0:7003 [cluster]</span><br><span class="line">root     30206     1  0 06:54 ?        00:00:05 &#x2F;usr&#x2F;bin&#x2F;redis-server 0.0.0.0:7004 [cluster]</span><br><span class="line">root     30211     1  0 06:54 ?        00:00:04 &#x2F;usr&#x2F;bin&#x2F;redis-server 0.0.0.0:7005 [cluster]</span><br></pre></td></tr></table></figure></li><li>创建集群<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># redis-cli --cluster create 10.20.71.215:7000 10.20.73.204:7001 10.20.71.67:7002 10.20.71.215:7003 10.20.73.204:7004 10.20.71.67:7005 --cluster-replicas 1 -a AuDdQdpuEZpXgNthP6CjYjPb</span><br></pre></td></tr></table></figure></li><li>查看集群信息<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@mgo-db01cn-t001:&#x2F;usr&#x2F;local&#x2F;src&#x2F;redis-5.0.0# redis-cli -c -p 7000</span><br><span class="line">127.0.0.1:7000&gt; auth AuDdQdpuEZpXgNthP6CjYjPb</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:7000&gt; cluster nodes</span><br><span class="line">ab8eeb87cc65dd14d03b8ac1b1e8cf7956cec1f5 10.20.71.67:7005@17005 slave 113373eeb8450caf99f8bef80f7cf5e8be41f370 0 1556958626898 6 connected</span><br><span class="line">387497dd41e34c90f4ccfa5909e2c63987d2f0d6 10.20.71.67:7002@17002 master - 0 1556958624893 3 connected 10923-16383</span><br><span class="line">356ac5e0988889a793c055b99c1abff6579ba322 10.20.73.204:7004@17004 slave 387497dd41e34c90f4ccfa5909e2c63987d2f0d6 0 1556958625000 5 connected</span><br><span class="line">3c1d7c057ac1d325fcf63895ae52733242abc72b 10.20.73.204:7001@17001 master - 0 1556958625000 2 connected 5461-10922</span><br><span class="line">113373eeb8450caf99f8bef80f7cf5e8be41f370 10.20.71.215:7000@17000 myself,master - 0 1556958625000 1 connected 0-5460</span><br><span class="line">54c72a2901af3dd72cbbb816bd6c5283eec6eec9 10.20.71.215:7003@17003 slave 3c1d7c057ac1d325fcf63895ae52733242abc72b 0 1556958625894 4 connected</span><br></pre></td></tr></table></figure>控制台信息显示: 当前集群中存在3个主节点和3个从节点，说明我们的集群已经搭建成功<br>至此，Redis Cluster集群就搭建完成了!</li><li>测试数据<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@mgo-db01cn-t001:~# redis-cli -h 10.20.73.204 -p 7001</span><br><span class="line">10.20.73.204:7001&gt; auth AuDdQdpuEZpXgNthP6CjYjPb</span><br><span class="line">OK</span><br><span class="line">10.20.73.204:7001&gt;</span><br><span class="line">10.20.73.204:7001&gt;</span><br><span class="line">10.20.73.204:7001&gt;</span><br><span class="line">10.20.73.204:7001&gt; set name shuke</span><br><span class="line">OK</span><br><span class="line">10.20.73.204:7001&gt;</span><br><span class="line">10.20.73.204:7001&gt;</span><br><span class="line">10.20.73.204:7001&gt;</span><br><span class="line">10.20.73.204:7001&gt; get name</span><br><span class="line">&quot;shuke&quot;</span><br></pre></td></tr></table></figure></li><li>cluster saveconfig<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">将节点的配置文件保存到硬盘里面.</span><br><span class="line">试一下：</span><br><span class="line">127.0.0.1:7009&gt; cluster saveconfig</span><br><span class="line">OK</span><br><span class="line">ok说明成功了,它会覆盖配置文件夹里的nodes.conf文件.这样做是为了某种情况下nodes文件丢失,这样就会生成一个最新的节点配置文件。</span><br></pre></td></tr></table></figure></li></ol><p>Tips :</p><ol><li>如果想重新创建集群，需要登录到每个节点，执行flushdb，然后执行cluster reset，重启节点;</li></ol><h3 id="集群管理"><a href="#集群管理" class="headerlink" title="集群管理"></a>集群管理</h3><p><a href="http://www.redis.cn/topics/cluster-tutorial.html" target="_blank" rel="noopener">Redis 集群教程</a><br><a href="http://blog.huangz.me/2018/redis-cluster-manage-cheatsheet.html" target="_blank" rel="noopener">集群管理常见操作</a><br><a href="https://www.zybuluo.com/phper/note/205009" target="_blank" rel="noopener">常用命令</a></p><h3 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h3><p><a href="https://hoxis.github.io/redis-sentinel-ha.html" target="_blank" rel="noopener">Redis 高可用部署方案</a><br><a href="https://wizardforcel.gitbooks.io/redis-doc/content/doc/9.html" target="_blank" rel="noopener">Redis集群规范</a></p>]]></content>
    
    <summary type="html">
    
      Redis集群部署
    
    </summary>
    
    
      <category term="Redis" scheme="https://shuke163.github.io/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://shuke163.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Python中的一些高级技巧</title>
    <link href="https://shuke163.github.io/2020/04/23/Python%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7/"/>
    <id>https://shuke163.github.io/2020/04/23/Python%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7/</id>
    <published>2020-04-23T08:13:33.000Z</published>
    <updated>2020-04-23T08:13:53.725Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Python中的一些高级技巧"><a href="#Python中的一些高级技巧" class="headerlink" title="Python中的一些高级技巧"></a>Python中的一些高级技巧</h2><blockquote><p>Python 开发中有哪些高级技巧？这是知乎上一个问题，我总结了一些常见的技巧在这里，可能谈不上多高级，但掌握这些至少可以让你的代码看起来 Pythonic 一点。如果你还在按照类C语言的那套风格来写的话，在 code review 恐怕会要被吐槽了.</p></blockquote><h3 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; chars &#x3D; [ c for c in &#39;python&#39; ]</span><br><span class="line">&gt;&gt;&gt; chars</span><br><span class="line">[&#39;p&#39;, &#39;y&#39;, &#39;t&#39;, &#39;h&#39;, &#39;o&#39;, &#39;n&#39;]</span><br></pre></td></tr></table></figure><h3 id="字典推导式"><a href="#字典推导式" class="headerlink" title="字典推导式"></a>字典推导式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; dict1 &#x3D; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4, &#39;e&#39;: 5&#125;</span><br><span class="line">&gt;&gt;&gt; double_dict1 &#x3D; &#123;k:v*2 for (k,v) in dict1.items()&#125;</span><br><span class="line">&gt;&gt;&gt; double_dict1</span><br><span class="line">&#123;&#39;a&#39;: 2, &#39;b&#39;: 4, &#39;c&#39;: 6, &#39;d&#39;: 8, &#39;e&#39;: 10&#125;</span><br></pre></td></tr></table></figure><h3 id="集合推导式"><a href="#集合推导式" class="headerlink" title="集合推导式"></a>集合推导式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; set1 &#x3D; &#123;1,2,3,4&#125;</span><br><span class="line">&gt;&gt;&gt; double_set &#x3D; &#123;i*2 for i in set1&#125;</span><br><span class="line">&gt;&gt;&gt; double_set</span><br><span class="line">&#123;8, 2, 4, 6&#125;</span><br></pre></td></tr></table></figure><h3 id="合并字典"><a href="#合并字典" class="headerlink" title="合并字典"></a>合并字典</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x &#x3D; &#123;&#39;a&#39;:1,&#39;b&#39;:2&#125;</span><br><span class="line">&gt;&gt;&gt; y &#x3D; &#123;&#39;c&#39;:3, &#39;d&#39;:4&#125;</span><br><span class="line">&gt;&gt;&gt; z &#x3D; &#123;**x, **y&#125;</span><br><span class="line">&gt;&gt;&gt; z</span><br><span class="line">&#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4&#125;</span><br></pre></td></tr></table></figure><h3 id="复制列表"><a href="#复制列表" class="headerlink" title="复制列表"></a>复制列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; nums &#x3D; [1,2,3]</span><br><span class="line">&gt;&gt;&gt; nums[::]</span><br><span class="line">[1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; copy_nums &#x3D; nums[::]</span><br><span class="line">&gt;&gt;&gt; copy_nums</span><br><span class="line">[1, 2, 3]</span><br></pre></td></tr></table></figure><h3 id="反转列表"><a href="#反转列表" class="headerlink" title="反转列表"></a>反转列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; reverse_nums &#x3D; nums[::-1]</span><br><span class="line">&gt;&gt;&gt; reverse_nums</span><br><span class="line">[3, 2, 1]</span><br></pre></td></tr></table></figure><h3 id="变量交换"><a href="#变量交换" class="headerlink" title="变量交换"></a>变量交换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a,b &#x3D; 1, 2</span><br><span class="line">&gt;&gt;&gt; a ,b &#x3D; b,a</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="高级拆包"><a href="#高级拆包" class="headerlink" title="高级拆包"></a>高级拆包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a, *b &#x3D; 1,2,3</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">[2, 3]</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a, *b, c &#x3D; 1,2,3,4,5</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">[2, 3, 4]</span><br><span class="line">&gt;&gt;&gt; c</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h3 id="函数返回多个值-其实是自动packing成元组-然后unpacking赋值给4个变量"><a href="#函数返回多个值-其实是自动packing成元组-然后unpacking赋值给4个变量" class="headerlink" title="函数返回多个值(其实是自动packing成元组)然后unpacking赋值给4个变量"></a>函数返回多个值(其实是自动packing成元组)然后unpacking赋值给4个变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def f():</span><br><span class="line">...     return 1, 2, 3, 4</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; a, b, c, d &#x3D; f()</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="列表合并成字符串"><a href="#列表合并成字符串" class="headerlink" title="列表合并成字符串"></a>列表合并成字符串</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot; &quot;.join([&quot;I&quot;, &quot;Love&quot;, &quot;Python&quot;])</span><br><span class="line">&#39;I Love Python&#39;</span><br></pre></td></tr></table></figure><h3 id="链式比较"><a href="#链式比较" class="headerlink" title="链式比较"></a>链式比较</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; if a &gt; 2 and a &lt; 5:</span><br><span class="line">...     pass</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; if 2&lt;a&lt;5:</span><br><span class="line">...     pass</span><br></pre></td></tr></table></figure><h3 id="yield-from"><a href="#yield-from" class="headerlink" title="yield from"></a>yield from</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 没有使用 field from</span><br><span class="line">def dup(n):</span><br><span class="line">    for i in range(n):</span><br><span class="line">        yield i</span><br><span class="line">        yield i</span><br><span class="line"></span><br><span class="line"># 使用yield from</span><br><span class="line">def dup(n):</span><br><span class="line">    for i in range(n):</span><br><span class="line">    yield from [i, i]</span><br><span class="line"></span><br><span class="line">for i in dup(3):</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="in-代替-or"><a href="#in-代替-or" class="headerlink" title="in 代替 or"></a>in 代替 or</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; if x &#x3D;&#x3D; 1 or x &#x3D;&#x3D; 2 or x &#x3D;&#x3D; 3:</span><br><span class="line">...     pass</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; if x in (1,2,3):</span><br><span class="line">...     pass</span><br></pre></td></tr></table></figure><h3 id="字典代替多个if-else"><a href="#字典代替多个if-else" class="headerlink" title="字典代替多个if else"></a>字典代替多个if else</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def fun(x):</span><br><span class="line">    if x &#x3D;&#x3D; &#39;a&#39;:</span><br><span class="line">        return 1</span><br><span class="line">    elif x &#x3D;&#x3D; &#39;b&#39;:</span><br><span class="line">        return 2</span><br><span class="line">    else:</span><br><span class="line">        return None</span><br><span class="line"></span><br><span class="line">def fun(x):</span><br><span class="line">    return &#123;&quot;a&quot;: 1, &quot;b&quot;: 2&#125;.get(x)</span><br></pre></td></tr></table></figure><h3 id="有下标索引的枚举"><a href="#有下标索引的枚举" class="headerlink" title="有下标索引的枚举"></a>有下标索引的枚举</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for i, e in enumerate([&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]):</span><br><span class="line">...     print(i, e)</span><br><span class="line">...</span><br><span class="line">0 a</span><br><span class="line">1 b</span><br><span class="line">2 c</span><br></pre></td></tr></table></figure><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>注意区分列表推导式，生成器效率更高</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; g &#x3D; (i**2 for i in range(5))</span><br><span class="line">&gt;&gt;&gt; g</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at 0x10881e518&gt;</span><br><span class="line">&gt;&gt;&gt; for i in g:</span><br><span class="line">...     print(i)</span><br><span class="line">...</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">4</span><br><span class="line">9</span><br><span class="line">16</span><br></pre></td></tr></table></figure><h3 id="注意区分列表推导式，生成器效率更高"><a href="#注意区分列表推导式，生成器效率更高" class="headerlink" title="注意区分列表推导式，生成器效率更高"></a>注意区分列表推导式，生成器效率更高</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; g &#x3D; (i**2 for i in range(5))</span><br><span class="line">&gt;&gt;&gt; g</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at 0x10881e518&gt;</span><br><span class="line">&gt;&gt;&gt; for i in g:</span><br><span class="line">...     print(i)</span><br><span class="line">...</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">4</span><br><span class="line">9</span><br><span class="line">16</span><br></pre></td></tr></table></figure><h3 id="默认字典-defaultdict"><a href="#默认字典-defaultdict" class="headerlink" title="默认字典 defaultdict"></a>默认字典 defaultdict</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d &#x3D; dict()</span><br><span class="line">&gt;&gt;&gt; d[&#39;nums&#39;]</span><br><span class="line">KeyError: &#39;nums&#39;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; from collections import defaultdict</span><br><span class="line">&gt;&gt;&gt; d &#x3D; defaultdict(list)</span><br><span class="line">&gt;&gt;&gt; d[&quot;nums&quot;]</span><br><span class="line">[]</span><br></pre></td></tr></table></figure><h3 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; lang &#x3D; &#39;python&#39;</span><br><span class="line">&gt;&gt;&gt; f&#39;&#123;lang&#125; is most popular language in the world&#39;</span><br><span class="line">&#39;python is most popular language in the world&#39;</span><br></pre></td></tr></table></figure><h3 id="列表中出现次数最多的元素"><a href="#列表中出现次数最多的元素" class="headerlink" title="列表中出现次数最多的元素"></a>列表中出现次数最多的元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; nums &#x3D; [1,2,3,3]</span><br><span class="line">&gt;&gt;&gt; max(set(nums), key&#x3D;nums.count)</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line">from collections import Counter</span><br><span class="line">&gt;&gt;&gt; Counter(nums).most_common()[0][0]</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; with open(&quot;test.txt&quot;, &quot;w&quot;) as f:</span><br><span class="line">...     f.writelines(&quot;hello&quot;)</span><br></pre></td></tr></table></figure><h3 id="判断对象类型，可指定多个类型"><a href="#判断对象类型，可指定多个类型" class="headerlink" title="判断对象类型，可指定多个类型"></a>判断对象类型，可指定多个类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; isinstance(a, (int, str))</span><br><span class="line">True</span><br></pre></td></tr></table></figure><h3 id="类似的还有字符串的-startswith，endswith"><a href="#类似的还有字符串的-startswith，endswith" class="headerlink" title="类似的还有字符串的 startswith，endswith"></a>类似的还有字符串的 startswith，endswith</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;http:&#x2F;&#x2F;foofish.net&quot;.startswith((&#39;http&#39;,&#39;https&#39;))</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; &quot;https:&#x2F;&#x2F;foofish.net&quot;.startswith((&#39;http&#39;,&#39;https&#39;))</span><br><span class="line">True</span><br></pre></td></tr></table></figure><h3 id="str-与-repr-区别"><a href="#str-与-repr-区别" class="headerlink" title="str 与 repr 区别"></a><strong>str</strong> 与 <strong>repr</strong> 区别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; str(datetime.now())</span><br><span class="line">&#39;2018-11-20 00:31:54.839605&#39;</span><br><span class="line">&gt;&gt;&gt; repr(datetime.now())</span><br><span class="line">&#39;datetime.datetime(2018, 11, 20, 0, 32, 0, 579521)&#39;</span><br></pre></td></tr></table></figure><p>前者对人友好，可读性更强，后者对计算机友好，支持 obj == eval(repr(obj))</p><h3 id="使用装饰器"><a href="#使用装饰器" class="headerlink" title="使用装饰器"></a>使用装饰器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def makebold(f):</span><br><span class="line">return lambda: &quot;&lt;b&gt;&quot; + f() + &quot;&lt;&#x2F;b&gt;&quot;</span><br><span class="line"></span><br><span class="line">def makeitalic(f):</span><br><span class="line">return lambda: &quot;&lt;i&gt;&quot; + f() + &quot;&lt;&#x2F;i&gt;&quot;</span><br><span class="line"></span><br><span class="line">@makebold</span><br><span class="line">@makeitalic</span><br><span class="line">def say():</span><br><span class="line">return &quot;Hello&quot;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; say()</span><br><span class="line">&lt;b&gt;&lt;i&gt;Hello&lt;&#x2F;i&gt;&lt;&#x2F;b&gt;</span><br></pre></td></tr></table></figure><h3 id="不使用装饰器-可读性非常差"><a href="#不使用装饰器-可读性非常差" class="headerlink" title="不使用装饰器,可读性非常差"></a>不使用装饰器,可读性非常差</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def say():</span><br><span class="line">return &quot;Hello&quot;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; makebold(makeitalic(say))()</span><br><span class="line">&lt;b&gt;&lt;i&gt;Hello&lt;&#x2F;i&gt;&lt;&#x2F;b&gt;</span><br></pre></td></tr></table></figure><p><a href="https://mp.weixin.qq.com/s/cGHEJRUQ3CeuvL5rOqul8A" target="_blank" rel="noopener">原文地址</a></p>]]></content>
    
    <summary type="html">
    
      Python中的一些高级技巧
    
    </summary>
    
    
      <category term="PYTHON" scheme="https://shuke163.github.io/categories/PYTHON/"/>
    
    
      <category term="PYTHON" scheme="https://shuke163.github.io/tags/PYTHON/"/>
    
  </entry>
  
  <entry>
    <title>Python之禅</title>
    <link href="https://shuke163.github.io/2020/04/23/Python%E4%B9%8B%E7%A6%85/"/>
    <id>https://shuke163.github.io/2020/04/23/Python%E4%B9%8B%E7%A6%85/</id>
    <published>2020-04-23T08:12:23.000Z</published>
    <updated>2020-04-23T08:14:05.187Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Python之禅"><a href="#Python之禅" class="headerlink" title="Python之禅"></a>Python之禅</h2><blockquote><p>在Python交互式解释器中输 入import this就会显示Tim Peters的The Zen of python</p></blockquote><p><img src="https://pic4.zhimg.com/v2-3c27b47e4d5ef618a86252b39bb6db94_1200x500.jpg" alt="python"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import this</span><br><span class="line">The Zen of Python, by Tim Peters</span><br><span class="line"></span><br><span class="line">Beautiful is better than ugly.</span><br><span class="line">Explicit is better than implicit.</span><br><span class="line">Simple is better than complex.</span><br><span class="line">Complex is better than complicated.</span><br><span class="line">Flat is better than nested.</span><br><span class="line">Sparse is better than dense.</span><br><span class="line">Readability counts.</span><br><span class="line">Special cases aren&#39;t special enough to break the rules.</span><br><span class="line">Although practicality beats purity.</span><br><span class="line">Errors should never pass silently.</span><br><span class="line">Unless explicitly silenced.</span><br><span class="line">In the face of ambiguity, refuse the temptation to guess.</span><br><span class="line">There should be one-- and preferably only one --obvious way to do it.</span><br><span class="line">Although that way may not be obvious at first unless you&#39;re Dutch.</span><br><span class="line">Now is better than never.</span><br><span class="line">Although never is often better than *right* now.</span><br><span class="line">If the implementation is hard to explain, it&#39;s a bad idea.</span><br><span class="line">If the implementation is easy to explain, it may be a good idea.</span><br><span class="line">Namespaces are one honking great idea -- let&#39;s do more of those!</span><br></pre></td></tr></table></figure><p>翻译和解释:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Python之禅 by Tim Peters</span><br><span class="line"></span><br><span class="line">优美胜于丑陋（Python 以编写优美的代码为目标）</span><br><span class="line">明了胜于晦涩（优美的代码应当是明了的，命名规范，风格相似）</span><br><span class="line">简洁胜于复杂（优美的代码应当是简洁的，不要有复杂的内部实现）</span><br><span class="line">复杂胜于凌乱（如果复杂不可避免，那代码间也不能有难懂的关系，要保持接口简洁）</span><br><span class="line">扁平胜于嵌套（优美的代码应当是扁平的，不能有太多的嵌套）</span><br><span class="line">间隔胜于紧凑（优美的代码有适当的间隔，不要奢望一行代码解决问题）</span><br><span class="line">可读性很重要（优美的代码是可读的）</span><br><span class="line">即便假借特例的实用性之名，也不可违背这些规则（这些规则至高无上）</span><br><span class="line">不要包容所有错误，除非你确定需要这样做（精准地捕获异常，不写 except:pass 风格的代码）</span><br><span class="line">当存在多种可能，不要尝试去猜测</span><br><span class="line">而是尽量找一种，最好是唯一一种明显的解决方案（如果不确定，就用穷举法）</span><br><span class="line">虽然这并不容易，因为你不是 Python 之父（这里的 Dutch 是指 Guido ）</span><br><span class="line">做也许好过不做，但不假思索就动手还不如不做（动手之前要细思量）</span><br><span class="line">如果你无法向人描述你的方案，那肯定不是一个好方案；反之亦然（方案测评标准）</span><br><span class="line">命名空间是一种绝妙的理念，我们应当多加利用（倡导与号召）</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Python之禅
    
    </summary>
    
    
      <category term="PYTHON" scheme="https://shuke163.github.io/categories/PYTHON/"/>
    
    
      <category term="PYTHON" scheme="https://shuke163.github.io/tags/PYTHON/"/>
    
  </entry>
  
  <entry>
    <title>Python面向对象入门教程</title>
    <link href="https://shuke163.github.io/2020/04/23/Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
    <id>https://shuke163.github.io/2020/04/23/Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/</id>
    <published>2020-04-23T08:11:14.000Z</published>
    <updated>2020-04-23T08:11:33.826Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Python面向对象入门教程"><a href="#Python面向对象入门教程" class="headerlink" title="Python面向对象入门教程"></a>Python面向对象入门教程</h2><blockquote><p>面向对象编程和函数式编程（面向过程编程）都是程序设计的方法，不过稍有区别</p></blockquote><h3 id="面向过程与面向对象编程区别"><a href="#面向过程与面向对象编程区别" class="headerlink" title="面向过程与面向对象编程区别"></a>面向过程与面向对象编程区别</h3><ol><li>面向过程编程:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 导入各种外部库</span><br><span class="line">2. 设计各种全局变量</span><br><span class="line">3. 写一个函数完成某个功能</span><br><span class="line">4. 写一个函数完成某个功能</span><br><span class="line">5. 写一个函数完成某个功能</span><br><span class="line">6. 写一个函数完成某个功能</span><br><span class="line">7. 写一个函数完成某个功能</span><br><span class="line">8. ......</span><br><span class="line">9. 写一个main函数作为程序入口</span><br></pre></td></tr></table></figure>在多函数程序中，许多重要的数据被放置在全局数据区，这样它们可以被所有的函数访问。每个函数都可以具有它们自己的局部数据，将某些功能代码封装到函数中，日后便无需重复编写，仅调用函数即可。从代码的组织形式来看就是根据业务逻辑从上到下垒代码,程序从上到下顺序执行.</li><li>面向对象编程:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 导入各种外部库</span><br><span class="line">2. 设计各种全局变量</span><br><span class="line">3. 决定你要的类</span><br><span class="line">4. 给每个类提供完整的一组操作</span><br><span class="line">5. 明确地使用继承来表现不同类之间的共同点</span><br><span class="line">6. 根据需要，决定是否写一个main函数作为程序入口</span><br></pre></td></tr></table></figure>面向对象编程中，将函数和变量进一步封装成类，类才是程序的基本元素，它将数据和操作紧密地连结在一起，并保护数据不会被外界的函数意外地改变。类和和类的实例(也称对象)是面向对象的核心概念，是和面向过程编程、函数式编程的根本区别。</li></ol><p>⚠️ 并不是非要用面向对象编程，要看你的程序怎么设计方便，但是就目前来说，基本上都是在使用面向对象编程。</p><h3 id="类的基本用法"><a href="#类的基本用法" class="headerlink" title="类的基本用法"></a>类的基本用法</h3><p>面向对象是通过定义class类来定义，这么说面向对象编程就是只使用class类，在class类中有封装，继承的功能，并且还可以构造要传入的参数，方便控制。</p><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">import time</span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(&#39;utf-8&#39;)</span><br><span class="line"></span><br><span class="line">class studetn:</span><br><span class="line">    # 定义一个类名为studetn</span><br><span class="line">    def __init__(self,idx):</span><br><span class="line">    # 定义初始化构造，这里使用init，还有别的属性比如reversed，iter之类的</span><br><span class="line">        self.idx&#x3D;idx</span><br><span class="line">        self.age &#x3D; 18</span><br><span class="line">        # 初始化变量，方便继承</span><br><span class="line">        </span><br><span class="line">    def runx(self):</span><br><span class="line">    # 定义运行函数，从上面继承变量</span><br><span class="line">        print(self.idx)</span><br><span class="line">        time.sleep(1)</span><br><span class="line"></span><br><span class="line"># 这是类的调用，一定要记得类的使用方法，首先传入参数，类赋值给一个变量a</span><br><span class="line"># 然后调用这个类下面定义的函数        </span><br><span class="line">a&#x3D;studetn(&#39;a&#39;)</span><br><span class="line">a.runx()</span><br></pre></td></tr></table></figure><p>术语介绍:</p><ol><li>类(Class): 用来描述具有相同属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。其中的对象被称作类的实例。</li><li>实例：也称对象。通过类定义的初始化方法，赋予具体的值，成为一个”有血有肉的实体”。</li><li>实例化：创建类的实例的过程或操作。</li><li>实例变量：定义在实例中的变量，只作用于当前实例。</li><li>类变量：类变量是所有实例公有的变量。类变量定义在类中，但在方法体之外。</li><li>数据成员：类变量、实例变量、方法、类方法、静态方法和属性等的统称。</li><li>方法：类中定义的函数。</li><li>静态方法：不需要实例化就可以由类执行的方法</li><li>类方法：类方法是将类本身作为对象进行操作的方法。</li><li>方法重写：如果从父类继承的方法不能满足子类的需求，可以对父类的方法进行改写，这个过程也称override。</li><li>封装：将内部实现包裹起来，对外透明，提供api接口进行调用的机制</li><li>继承：即一个派生类(derived class)继承父类(base class)的变量和方法。</li><li>多态：根据对象类型的不同以不同的方式进行处理。</li></ol><h4 id="类与实例"><a href="#类与实例" class="headerlink" title="类与实例"></a>类与实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">@author: shuke</span><br><span class="line">@file: ec2.py </span><br><span class="line">@time: 2019&#x2F;03&#x2F;14 10:52</span><br><span class="line">@contact: zhaofengfeng@wecash.net</span><br><span class="line">@software:  learn</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line">import time</span><br><span class="line">import requests</span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(&#39;utf-8&#39;)</span><br><span class="line"></span><br><span class="line">class cc:</span><br><span class="line">    ccc &#x3D; &#39;ccc&#39;</span><br><span class="line">    # cc就是类名 如果想要继承别的类 就class cc(threading) 意思就是从threading继承</span><br><span class="line">    def __init__(self,a,b,c):</span><br><span class="line">        self.a&#x3D;a</span><br><span class="line">        self.b&#x3D;b</span><br><span class="line">        self.c&#x3D;c</span><br><span class="line">        # 定义构造的过程就是实例化</span><br><span class="line">    def runx(self):</span><br><span class="line">        print self.a*10</span><br><span class="line">        print self.b*5</span><br><span class="line">        print self.c*2</span><br><span class="line">    def runy(self):</span><br><span class="line">        print requests.get(&#39;http:&#x2F;&#x2F;www.langzi.fun&#39;).headers</span><br><span class="line">e &#x3D; cc(&#39;AAA&#39;,&#39;CCC&#39;,&#39;EEE&#39;)</span><br><span class="line">e.runx()</span><br><span class="line">e.runy()</span><br><span class="line"># 这两个就是调用类里面的方法</span><br><span class="line">print e.c</span><br><span class="line">#实例变量指的是实例本身拥有的变量。每个实例的变量在内存中都不一样。</span><br><span class="line">print e.ccc</span><br><span class="line">#类变量，在类里面找到定义的变量。</span><br></pre></td></tr></table></figure><h4 id="调用类的三种方法"><a href="#调用类的三种方法" class="headerlink" title="调用类的三种方法"></a>调用类的三种方法</h4><ol><li>实例方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">import time</span><br><span class="line">import requests</span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(&#39;utf-8&#39;)</span><br><span class="line"></span><br><span class="line">class dd:</span><br><span class="line">    def __init__(self,url):</span><br><span class="line">        self.url&#x3D;url</span><br><span class="line">    def runx(self):</span><br><span class="line">        print requests.get(self.url).status_code</span><br><span class="line"></span><br><span class="line">a &#x3D; dd(&#39;http:&#x2F;&#x2F;www.langzi.fun&#39;)</span><br><span class="line">a.runx()</span><br><span class="line"># 这种调用方法就是实例方法</span><br></pre></td></tr></table></figure></li><li>静态方法<blockquote><p>静态方法由类调用，无默认参数。将实例方法参数中的self去掉，然后在方法定义上方加上<code>@staticmethod</code>，就成为静态方法。它属于类，和实例无关。建议只使用类名.静态方法的调用方式。（虽然也可以使用实例名.静态方法的方式调用）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">import requests</span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(&#39;utf-8&#39;)</span><br><span class="line">class ff:</span><br><span class="line">    @staticmethod</span><br><span class="line">    def runx():</span><br><span class="line">        print requests.get(&#39;http:&#x2F;&#x2F;www.langzi.fun&#39;).status_code</span><br><span class="line">ff.runx()</span><br><span class="line">#这里就直接调用了类的变量，只在类中运行而不在实例中运行的方法</span><br></pre></td></tr></table></figure>经常有一些跟类有关系的功能但在运行时又不需要实例和类参与的情况下需要用到静态方法. 比如更改环境变量或者修改其他类的属性等能用到静态方法. 这种情况可以直接用函数解决, 但这样同样会扩散类内部的代码，造成维护困难。</li><li>类方法<blockquote><p>类方法由类调用，采用<code>@classmethod</code>装饰，至少传入一个cls（代指类本身，类似self）参数。执行类方法时，自动将调用该方法的类赋值给cls。建议只使用类名.类方法的调用方式。（虽然也可以使用实例名.类方法的方式调用）<br>如果要构造一个类，接受一个网站和这个网站的状态码，然后打印出来。就像这样：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">import requests</span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(&#39;utf-8&#39;)</span><br><span class="line">class gg:</span><br><span class="line">    def __init__(self,url,stat):</span><br><span class="line">        self.url&#x3D;url</span><br><span class="line">        self.stat&#x3D;stat</span><br><span class="line">    def outer(self):</span><br><span class="line">        print self.url</span><br><span class="line">        print self.stat</span><br><span class="line">a &#x3D; gg(&#39;langzi&#39;,200)</span><br><span class="line">a.outer()</span><br></pre></td></tr></table></figure>这样就是使用实例方法，虽然可以实现，但是有的时候传入的参数并不是(‘shuke’,200)这样的格式，而是(‘shuke-200’)这样的，那该怎么做？首先要把这个拆分，但是要使用实例方法实现起来很麻烦，这个时候就可以使用类方法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">import requests</span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(&#39;utf-8&#39;)</span><br><span class="line">class gg:</span><br><span class="line">    url &#x3D; 0</span><br><span class="line">    stat &#x3D; 0</span><br><span class="line">    # 因为使用classmethod后会传入新的变量，所以一开始是需要自己先定义类变量</span><br><span class="line">    def __init__(self,url&#x3D;0,stat&#x3D;0):</span><br><span class="line">    # 这里按照正常的定义构造函数</span><br><span class="line">        self.url&#x3D;url</span><br><span class="line">        self.stat&#x3D;stat</span><br><span class="line">    @classmethod</span><br><span class="line">    # 装饰器，立马执行下面的函数</span><br><span class="line">    def split(cls,info):</span><br><span class="line">        # 这个函数接受两个参数，默认的cls就是这个类的init函数，info就是外面传入进来的</span><br><span class="line">        url,stat&#x3D;map(str,info.split(&#39;-&#39;))</span><br><span class="line">        # 这里转换成了格式化的结构</span><br><span class="line">        data &#x3D; cls(url,stat)</span><br><span class="line">        # 然后执行这个类第一个方法，这个类构造函数需要传入两个参数，于是就传入了两个参数</span><br><span class="line">        return data</span><br><span class="line">        # 这里就直接返回了函数结果</span><br><span class="line">    def outer(self):</span><br><span class="line">        print self.url</span><br><span class="line">        print self.stat</span><br><span class="line"></span><br><span class="line">r &#x3D; gg.split((&#39;langzi-200&#39;))</span><br><span class="line">r.outer()</span><br><span class="line"># 这里是调用类方法，与调用实例方法一样</span><br></pre></td></tr></table></figure></li></ol><h3 id="类的特性"><a href="#类的特性" class="headerlink" title="类的特性"></a>类的特性</h3><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><blockquote><p>封装是指将数据与具体操作的实现代码放在某个对象内部，外部无法访问。必须要先调用类的方法才能启动。</p></blockquote><ol><li>Example<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class cc:</span><br><span class="line">    ccc &#x3D; &#39;ccc&#39;</span><br><span class="line">    # cc就是类名 如果想要继承别的类 就class cc(threading) 意思就是从threading继承</span><br><span class="line">    def __init__(self,a,b,c):</span><br><span class="line">        self.a&#x3D;a</span><br><span class="line">        self.b&#x3D;b</span><br><span class="line">        self.c&#x3D;c</span><br><span class="line">print e.ccc</span><br><span class="line">#类变量，在类里面找到定义的变量。</span><br><span class="line">print ccc</span><br><span class="line"># 这里会报错，这就是封装。类中的函数同理。</span><br></pre></td></tr></table></figure><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><blockquote><p>当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class）。<br>比如，我们已经编写了一个名为Animal的class，有一个run()方法可以直接打印：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Animal(object):</span><br><span class="line">    def run(self):</span><br><span class="line">        print &#39;Animal is running...&#39;</span><br></pre></td></tr></table></figure>当我们需要编写Dog和Cat类时，就可以直接从Animal类继承：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Dog(Animal):</span><br><span class="line">    pass</span><br><span class="line">class Cat(Animal):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>继承有什么好处？最大的好处是子类获得了父类的全部功能。由于Animial实现了run()方法，因此，Dog和Cat作为它的子类，什么事也没干，就自动拥有了run()方法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dog &#x3D; Dog()</span><br><span class="line">dog.run()</span><br><span class="line">cat &#x3D; Cat()</span><br><span class="line">cat.run()</span><br></pre></td></tr></table></figure>当子类和父类都存在相同的run()方法时，我们说，子类的run()覆盖了父类的run()，在代码运行的时候，总是会调用子类的run()。这样，我们就获得了继承的另一个好处: 多态。<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><blockquote><p>要理解多态的好处，我们还需要再编写一个函数，这个函数接受一个Animal类型的变量：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def run_twice(animal):</span><br><span class="line">    animal.run()</span><br><span class="line">    animal.run()</span><br></pre></td></tr></table></figure>当我们传入Animal的实例时，run_twice()就打印出：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">run_twice(Animal())</span><br><span class="line">运行结果：</span><br><span class="line">Animal is running...</span><br><span class="line">Animal is running...</span><br></pre></td></tr></table></figure>当我们传入Dog的实例时，run_twice()就打印出:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">run_twice(Dog())</span><br><span class="line">运行结果：</span><br><span class="line">Dog is running...</span><br><span class="line">Dog is running...</span><br></pre></td></tr></table></figure>当我们传入Cat的实例时，run_twice()就打印出：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">run_twice(Cat())</span><br><span class="line">运行结果：</span><br><span class="line">Cat is running...</span><br><span class="line">Cat is running...</span><br></pre></td></tr></table></figure>看上去没啥意思，但是仔细想想，现在，如果我们再定义一个Tortoise类型，也从Animal派生：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Tortoise(Animal):</span><br><span class="line">    def run(self):</span><br><span class="line">        print &#39;Tortoise is running slowly...&#39;</span><br></pre></td></tr></table></figure>当我们调用run_twice()时，传入Tortoise的实例:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">run_twice(Tortoise())</span><br><span class="line">运行结果：</span><br><span class="line">Tortoise is running slowly...</span><br><span class="line">Tortoise is running slowly...</span><br></pre></td></tr></table></figure></li><li>你会发现，新增一个Animal的子类，不必对run_twice()做任何修改，实际上，任何依赖Animal作为参数的函数或者方法都可以不加修改地正常运行，原因就在于多态。</li><li>多态的好处就是，当我们需要传入Dog、Cat、Tortoise……时，我们只需要接收Animal类型就可以了，因为Dog、Cat、Tortoise……都是Animal类型，然后，按照Animal类型进行操作即可。由于Animal类型有run()方法，因此，传入的任意类型，只要是Animal类或者子类，就会自动调用实际类型的run()方法，这就是多态的意思.</li><li>对于一个变量，我们只需要知道它是Animal类型，无需确切地知道它的子类型，就可以放心地调用run()方法，而具体调用的run()方法是作用在Animal、Dog、Cat还是Tortoise对象上，由运行时该对象的确切类型决定，这就是多态真正的威力：调用方只管调用，不管细节，而当我们新增一种Animal的子类时，只要确保run()方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则</li></ol><ul><li>对扩展开放：允许新增Animal子类</li><li>对修改封闭：不需要修改依赖Animal类型的run_twice()等函数<br>⚠️ 总结: </li></ul><ol><li>继承可以把父类的所有功能都直接拿过来，这样就不必重零做起，子类只需要新增自己特有的方法，也可以把父类不适合的方法覆盖重写；</li><li>有了继承，才能有多态。在调用类实例方法的时候，尽量把变量视作父类类型，这样，所有子类类型都可以正常被接收；</li><li>旧的方式定义Python类允许不从object类继承，但这种编程方式已经严重不推荐使用。任何时候，如果没有合适的类可以继承，就继承自object类。</li></ol><h3 id="魔法方法"><a href="#魔法方法" class="headerlink" title="魔法方法"></a>魔法方法</h3><p>在上面有提到除了<strong>init</strong>之外还有iter,reverse的方法，这里就详细说下除了init初始化还有哪些别的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">__init__ :      构造函数，在生成对象时调用</span><br><span class="line">__del__ :       析构函数，释放对象时使用</span><br><span class="line">__repr__ :      打印，转换</span><br><span class="line">__setitem__ :   按照索引赋值</span><br><span class="line">__getitem__:    按照索引获取值</span><br><span class="line">__len__:        获得长度</span><br><span class="line">__cmp__:        比较运算</span><br><span class="line">__call__:       调用</span><br><span class="line">__add__:        加运算</span><br><span class="line">__sub__:        减运算</span><br><span class="line">__mul__:        乘运算</span><br><span class="line">__div__:        除运算</span><br><span class="line">__mod__:        求余运算</span><br><span class="line">__pow__:        幂</span><br><span class="line">__doc__:        文档和信息</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h4><ol><li><strong>doc</strong><br>说明性文档和信息。Python自建，无需自定义。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Foo:</span><br><span class="line">    &quot;&quot;&quot; 描述类信息，可被自动收集 &quot;&quot;&quot;</span><br><span class="line">    def func(self):</span><br><span class="line">        pass</span><br><span class="line"># 打印类的说明文档 </span><br><span class="line">print(Foo.__doc__)</span><br></pre></td></tr></table></figure></li><li><strong>init</strong>()<br>实例化方法，通过类创建实例时，自动触发执行。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Foo:</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name &#x3D; name</span><br><span class="line">        self.age &#x3D; 18</span><br><span class="line">obj &#x3D; Foo(&#39;jack&#39;) # 自动执行类中的 __init__ 方法</span><br></pre></td></tr></table></figure></li><li><strong>module</strong> 和 <strong>class</strong><br>module 表示当前操作的对象在属于哪个模块。<br>class 表示当前操作的对象属于哪个类。<br>这两者也是Python内建，无需自定义。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Foo:</span><br><span class="line">    pass</span><br><span class="line">obj &#x3D; Foo()</span><br><span class="line">print(obj.__module__)</span><br><span class="line">print(obj.__class__)</span><br></pre></td></tr></table></figure></li><li><strong>del</strong>()<blockquote><p>析构方法，当对象在内存中被释放时，自动触发此方法。<br>注：此方法一般无须自定义，因为Python自带内存分配和释放机制，除非你需要在释放的时候指定做一些动作。析构函数的调用是由解释器在进行垃圾回收时自动触发执行的。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Foo:</span><br><span class="line">    def __del__(self):</span><br><span class="line">        print(&quot;我被回收了！&quot;)</span><br><span class="line"></span><br><span class="line">obj &#x3D; Foo()</span><br><span class="line">del obj</span><br></pre></td></tr></table></figure></li><li><strong>call</strong>()<blockquote><p>构造方法的执行是由类加括号执行的，即：对象 = 类名()，而对于call() 方法，是由对象后加括号触发的，即：对象() 或者 类()()<br>如果为一个类编写了该方法，那么在该类的实例后面加括号，可会调用这个方法。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Foo:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line">    def __call__(self, *args, **kwargs):</span><br><span class="line">        print(&#39;__call__&#39;)</span><br><span class="line">obj &#x3D; Foo()     # 执行 __init__</span><br><span class="line">obj()       # 执行 __call__</span><br></pre></td></tr></table></figure>可以用Python内建的callable()函数进行测试，判断一个对象是否可以被执行。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">callable(Student())</span><br><span class="line">运行结果：</span><br><span class="line">True</span><br></pre></td></tr></table></figure></li><li><strong>dict</strong><br>列出类或对象中的所有成员！非常重要和有用的一个属性，Python自建，无需用户自己定义。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Province:</span><br><span class="line">    country &#x3D; &#39;China&#39;</span><br><span class="line">    def __init__(self, name, count):</span><br><span class="line">        self.name &#x3D; name</span><br><span class="line">        self.count &#x3D; count</span><br><span class="line">    def func(self, *args, **kwargs):</span><br><span class="line">        print（&#39;func&#39;）</span><br><span class="line"># 获取类的成员</span><br><span class="line">print(Province.__dict__)</span><br><span class="line"># 获取 对象obj1 的成员 </span><br><span class="line">obj1 &#x3D; Province(&#39;HeBei&#39;,10000)</span><br><span class="line">print(obj1.__dict__)</span><br><span class="line"># 获取 对象obj2 的成员 </span><br><span class="line">obj2 &#x3D; Province(&#39;HeNan&#39;, 3888)</span><br><span class="line">print(obj2.__dict__)</span><br></pre></td></tr></table></figure></li><li><strong>str</strong>()</li></ol><p>如果一个类中定义了str()方法，那么在打印对象时，默认输出该方法的返回值。这也是一个非常重要的方法，需要用户自己定义。　<br>下面的类，没有定义str()方法，打印结果是：&lt;main.Foo object at 0x32io4u2389572394885&gt;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Foo:</span><br><span class="line">    pass</span><br><span class="line">obj &#x3D; Foo()</span><br><span class="line">print(obj)</span><br><span class="line">定义了__str__()方法后，打印结果是：&#39;jack&#39;。</span><br><span class="line">class Foo:</span><br><span class="line">    def __str__(self):</span><br><span class="line">        return &#39;jack&#39;</span><br><span class="line">obj &#x3D; Foo()</span><br><span class="line">print(obj)</span><br></pre></td></tr></table></figure><ol start="8"><li><strong>getitem</strong>()、<strong>setitem</strong>()、<strong>delitem</strong>()<br>取值、赋值、删除这”三剑客”的套路，在Python中，我们已经见过很多次了，比如前面的<code>@property</code>装饰器。<br>Python中，标识符后面加圆括号，通常代表执行或调用方法的意思。而在标识符后面加中括号[]，通常代表取值的意思。Python设计了<code>getitem()、setitem()、delitem()</code>这三个特殊成员，用于执行与中括号有关的动作。它们分别表示取值、赋值、删除数<br>也就是如下的操作：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; 标识符[]　： 　　执行__getitem__方法</span><br><span class="line">标识符[] &#x3D; a  ： 　　执行__setitem__方法</span><br><span class="line">del 标识符[]　： 　　执行__delitem__方法</span><br></pre></td></tr></table></figure>如果有一个类同时定义了这三个魔法方法，那么这个类的实例的行为看起来就像一个字典一样，如下例所示:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    def __getitem__(self, key):</span><br><span class="line">        print(&#39;__getitem__&#39;,key)</span><br><span class="line">    def __setitem__(self, key, value):</span><br><span class="line">        print(&#39;__setitem__&#39;,key,value)</span><br><span class="line">    def __delitem__(self, key):</span><br><span class="line">        print(&#39;__delitem__&#39;,key)</span><br><span class="line">obj &#x3D; Foo()</span><br><span class="line">result &#x3D; obj[&#39;k1&#39;]      # 自动触发执行 __getitem__</span><br><span class="line">obj[&#39;k2&#39;] &#x3D; &#39;jack&#39;      # 自动触发执行 __setitem__</span><br><span class="line">del obj[&#39;k1&#39;]</span><br></pre></td></tr></table></figure></li><li><strong>iter</strong>()<blockquote><p>这是迭代器方法！列表、字典、元组之所以可以进行for循环，是因为其内部定义了 iter()这个方法。如果用户想让自定义的类的对象可以被迭代，那么就需要在类中定义这个方法，并且让该方法的返回值是一个可迭代的对象。当在代码中利用for循环遍历对象时，就会调用类的这个iter()方法。<br>普通的类：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Foo:</span><br><span class="line">    pass</span><br><span class="line">obj &#x3D; Foo()</span><br><span class="line">for i in obj:</span><br><span class="line">    print(i)</span><br><span class="line"># 报错：TypeError: &#39;Foo&#39; object is not iterable&lt;br&gt;# 原因是Foo对象不可迭代</span><br><span class="line">添加一个__iter__()，但什么都不返回：</span><br><span class="line">class Foo:</span><br><span class="line">    def __iter__(self):</span><br><span class="line">        pass</span><br><span class="line">obj &#x3D; Foo()</span><br><span class="line">for i in obj:</span><br><span class="line">    print(i)</span><br><span class="line"># 报错：TypeError: iter() returned non-iterator of type &#39;NoneType&#39;</span><br><span class="line">#原因是 __iter__方法没有返回一个可迭代的对象</span><br></pre></td></tr></table></figure>返回一个可迭代对象：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Foo:</span><br><span class="line">    def __init__(self, sq):</span><br><span class="line">        self.sq &#x3D; sq</span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return iter(self.sq)</span><br><span class="line">obj &#x3D; Foo([11,22,33,44])</span><br><span class="line">for i in obj:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>最好的方法是使用生成器：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Foo:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line">    def __iter__(self):</span><br><span class="line">        yield 1</span><br><span class="line">        yield 2</span><br><span class="line">        yield 3</span><br><span class="line">obj &#x3D; Foo()</span><br><span class="line">for i in obj:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure></li><li><strong>len</strong>()<blockquote><p>在Python中，如果你调用内置的len()函数试图获取一个对象的长度，在后台，其实是去调用该对象的len()方法，所以，下面的代码是等价的：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">len(&#39;ABC&#39;)</span><br><span class="line">3</span><br><span class="line">&#39;ABC&#39;.__len__()</span><br><span class="line">3</span><br></pre></td></tr></table></figure>Python的list、dict、str等内置数据类型都实现了该方法，但是你自定义的类要实现len方法需要好好设计。</li><li><strong>repr</strong>()<blockquote><p>这个方法的作用和str()很像，两者的区别是str()返回用户看到的字符串，而repr()返回程序开发者看到的字符串，也就是说，repr()是为调试服务的。通常两者代码一样。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Foo:</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name &#x3D; name</span><br><span class="line">    def __str__(self):</span><br><span class="line">        return &quot;this is %s&quot; % self.name</span><br><span class="line">    __repr__ &#x3D; __str__</span><br></pre></td></tr></table></figure></li><li><strong>add</strong>: 加运算 <strong>sub</strong>: 减运算 <strong>mul</strong>: 乘运算 <strong>div</strong>: 除运算 <strong>mod</strong>: 求余运算 <strong>pow</strong>: 幂运算<blockquote><p>这些都是算术运算方法，需要你自己为类设计具体运算代码。有些Python内置数据类型，比如int就带有这些方法。Python支持运算符的重载，也就是重写。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Vector:</span><br><span class="line">   def __init__(self, a, b):</span><br><span class="line">      self.a &#x3D; a</span><br><span class="line">      self.b &#x3D; b</span><br><span class="line">   def __str__(self):</span><br><span class="line">      return &#39;Vector (%d, %d)&#39; % (self.a, self.b)</span><br><span class="line">   def __add__(self,other):</span><br><span class="line">      return Vector(self.a + other.a, self.b + other.b)</span><br><span class="line">v1 &#x3D; Vector(2,10)</span><br><span class="line">v2 &#x3D; Vector(5,-2)</span><br><span class="line">print (v1 + v2)</span><br></pre></td></tr></table></figure></li><li><strong>author</strong>作者信息<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__author__ &#x3D; &quot;shuke&quot;</span><br><span class="line">def show():</span><br><span class="line">    print(__author__)</span><br><span class="line">show()</span><br></pre></td></tr></table></figure></li><li><strong>slots</strong><blockquote><p>Python作为一种动态语言，可以在类定义完成和实例化后，给类或者对象继续添加随意个数或者任意类型的变量或方法，这是动态语言的特性。例如： </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def print_doc(self):</span><br><span class="line">    print(&quot;haha&quot;)</span><br><span class="line"></span><br><span class="line">class Foo:</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">obj1 &#x3D; Foo()</span><br><span class="line">obj2 &#x3D; Foo()</span><br><span class="line"># 动态添加实例变量</span><br><span class="line">obj1.name &#x3D; &quot;jack&quot;</span><br><span class="line">obj2.age &#x3D; 18</span><br><span class="line"># 动态的给类添加实例方法</span><br><span class="line">Foo.show &#x3D; print_doc</span><br><span class="line">obj1.show()</span><br><span class="line">obj2.show()</span><br></pre></td></tr></table></figure>但是！如果我想限制实例可以添加的变量怎么办？可以使slots限制实例的变量，比如，只允许Foo的实例添加name和age属性。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">def print_doc(self):</span><br><span class="line">    print(&quot;haha&quot;)</span><br><span class="line">class Foo:</span><br><span class="line">    __slots__ &#x3D; (&quot;name&quot;, &quot;age&quot;)</span><br><span class="line">    pass</span><br><span class="line">obj1 &#x3D; Foo()</span><br><span class="line">obj2 &#x3D; Foo()</span><br><span class="line"># 动态添加实例变量</span><br><span class="line">obj1.name &#x3D; &quot;jack&quot;</span><br><span class="line">obj2.age &#x3D; 18</span><br><span class="line">obj1.sex &#x3D; &quot;male&quot;       # 这一句会弹出错误</span><br><span class="line"># 但是无法限制给类添加方法</span><br><span class="line">Foo.show &#x3D; print_doc</span><br><span class="line">obj1.show()</span><br><span class="line">obj2.show()</span><br><span class="line">由于&#39;sex&#39;不在__slots__的列表中，所以不能绑定sex属性，试图绑定sex将得到AttributeError的错误。</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;F:&#x2F;Python&#x2F;pycharm&#x2F;201705&#x2F;1.py&quot;, line 14, in &lt;module&gt;</span><br><span class="line">    obj1.sex &#x3D; &quot;male&quot;</span><br><span class="line">AttributeError: &#39;Foo&#39; object has no attribute &#39;sex&#39;</span><br></pre></td></tr></table></figure>需要提醒的是，slots定义的属性仅对当前类的实例起作用，对继承了它的子类是不起作用的。想想也是这个道理，如果你继承一个父类，却莫名其妙发现有些变量无法定义，那不是大问题么？如果非要子类也被限制，除非在子类中也定义slots，这样，子类实例允许定义的属性就是自身的slots加上父类的slots。</li></ol><h3 id="成员保护与访问机制"><a href="#成员保护与访问机制" class="headerlink" title="成员保护与访问机制"></a>成员保护与访问机制</h3><p>有些对象你不想外部访问，即使是通过调用类对象也无法访问</p><h4 id="私有成员"><a href="#私有成员" class="headerlink" title="私有成员"></a>私有成员</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class obj:</span><br><span class="line">    def __init__(self,name):</span><br><span class="line">        self.name&#x3D;name</span><br><span class="line">    def pri(self):</span><br><span class="line">        print self.name</span><br><span class="line">    __age &#x3D; 18</span><br><span class="line">    # 加上双下划线的就是私有变量，只能在类的内部访问，外部无法访问</span><br><span class="line">a &#x3D; obj(&#39;zhao&#39;)</span><br><span class="line">a.pri()</span><br><span class="line"># output</span><br><span class="line">zhao</span><br></pre></td></tr></table></figure><p>如果要在类中调用这个私有成员，可以这么用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class obj:</span><br><span class="line">    def __init__(self,name):</span><br><span class="line">        self.name&#x3D;name</span><br><span class="line">    def prin(self):</span><br><span class="line">        print self.name</span><br><span class="line">    __age &#x3D; 18</span><br><span class="line">    # 加上双下划线的就是私有变量，只能在类的内部访问，外部无法访问</span><br><span class="line">    @classmethod</span><br><span class="line">    # 如果要在类中调用，首先调用类方法</span><br><span class="line">    def pri(cls):</span><br><span class="line">        print cls.__age</span><br><span class="line">        # 然后在使用</span><br><span class="line">a &#x3D; obj(&#39;zhao&#39;)</span><br><span class="line">a.prin()</span><br><span class="line">obj.pri()</span><br><span class="line"># 通过这样直接调用类中的私有变量</span><br><span class="line"># output</span><br><span class="line">zhao</span><br><span class="line">18</span><br></pre></td></tr></table></figure><h3 id="使用get-set-del方法操作私有成员"><a href="#使用get-set-del方法操作私有成员" class="headerlink" title="使用get-set-del方法操作私有成员"></a>使用get-set-del方法操作私有成员</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class obj:</span><br><span class="line">    def __init__(self,name):</span><br><span class="line">        self.name&#x3D;name</span><br><span class="line">    def prin(self):</span><br><span class="line">        print self.name</span><br><span class="line">    __age &#x3D; 18</span><br><span class="line">    # 加上双下划线的就是私有变量，只能在类的内部访问，外部无法访问</span><br><span class="line">    @classmethod</span><br><span class="line">    # 如果要在类中调用，首先调用类方法</span><br><span class="line">    def pri(cls):</span><br><span class="line">        print cls.__age</span><br><span class="line">        # 然后在使用</span><br><span class="line">    @classmethod</span><br><span class="line">    def set_age(cls,value):</span><br><span class="line">        cls.__age &#x3D; value</span><br><span class="line">        return cls.__age</span><br><span class="line">        # 这个用法就是改变__age的值</span><br><span class="line">    @classmethod</span><br><span class="line">    def get_age(cls):</span><br><span class="line">        return cls.__age</span><br><span class="line">        # 这个用法就是直接返回__age的值</span><br><span class="line">    @classmethod</span><br><span class="line">    def del_age(cls):</span><br><span class="line">        del cls.__age</span><br><span class="line">        # 这个用法就是直接删除__age的值</span><br><span class="line"></span><br><span class="line">print obj.get_age()</span><br><span class="line"># 这里是直接调用出__age的值  返回值18</span><br><span class="line">print obj.set_age(20)</span><br><span class="line"># 这里是直接改变__age的值  返回值20</span><br><span class="line">obj.del_age()</span><br><span class="line"># 这里是直接删除__age的值</span><br></pre></td></tr></table></figure><p>思考： 既然是私有变量，不让外部访问，为何有要在后面调用又改变呢？因为可以对私有变量进行额外的检测，处理，加工等等。比如判断value的值，使用isinstance然后做if-else判断。<br>使用私有变量可以对内部变量进行保护，外部无法改变，但是可以对它进行检测处理。<br>这里引申一下私有成员的保护机制，使用<code>_age</code>私有变量其实就是<code>obj._obj__age</code>样子进行保护，说白了你直接使用<code>bj._obj__age</code>可以直接调用内部私有变量age了。</p><h4 id="Propety装饰器"><a href="#Propety装饰器" class="headerlink" title="Propety装饰器"></a>Propety装饰器</h4><blockquote><p>把类的方法伪装成属性调用的方式，就是把类里面的一个函数，变成一个属性一样的东西~<br>一开始调用类的方法要使用圆括号，现在变成了属性进行读取设置存储。<br>举个例子来说明：</p></blockquote><ol><li>调用方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class obj:</span><br><span class="line">    def __init__(self,name,age):</span><br><span class="line">        self.__name&#x3D;name</span><br><span class="line">        self.__age&#x3D;age</span><br><span class="line">        # 讲这些设置成私有变量</span><br><span class="line">    def get_age(self):</span><br><span class="line">        return self.__age</span><br><span class="line">    def set_age(self,value):</span><br><span class="line">        if isinstance(value,int):</span><br><span class="line">            self.__age&#x3D;value</span><br><span class="line">        else:</span><br><span class="line">            raise ValueError(&#39;非整数类型&#39;)</span><br><span class="line">    def del_age(self):</span><br><span class="line">        print &#39;delete over&#39;</span><br><span class="line">a &#x3D; obj(&#39;langzi&#39;,18)</span><br><span class="line">print a.get_age()</span><br><span class="line">a.set_age(20)</span><br><span class="line">print a.get_age()</span><br></pre></td></tr></table></figure></li><li>使用装饰器<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class obj:</span><br><span class="line">    def __init__(self,name,age):</span><br><span class="line">        self.__name&#x3D;name</span><br><span class="line">        self.__age&#x3D;age</span><br><span class="line">        # 把这些设置成私有变量</span><br><span class="line">    @property</span><br><span class="line">    def age(self):</span><br><span class="line">        return self.__age</span><br><span class="line">    @age.setter</span><br><span class="line">    def age(self,value):</span><br><span class="line">        if isinstance(value,int):</span><br><span class="line">            self.__age&#x3D;value</span><br><span class="line">        else:</span><br><span class="line">            raise ValueError(&#39;非整数类型&#39;)</span><br><span class="line">    @age.deleter</span><br><span class="line">    def age(self):</span><br><span class="line">        print &#39;delete over&#39;</span><br><span class="line">a &#x3D; obj(&#39;langzi&#39;,18)</span><br><span class="line"># 使用这些装饰器，可以使用类与对象的方法直接调用</span><br><span class="line">print a.age</span><br><span class="line"># 这里就是直接调用返回age的值</span><br><span class="line">a.age&#x3D;20</span><br><span class="line"># 这里就是直接使用setter把值转换</span><br><span class="line">print a.age</span><br><span class="line">del a.age</span><br><span class="line"># 删除age</span><br></pre></td></tr></table></figure>当然这种调用方法有些麻烦，每次都是一个一个去实例类与对象，有个更加简单直观的方法。<h4 id="更加简便的使用property-函数"><a href="#更加简便的使用property-函数" class="headerlink" title="更加简便的使用property()函数"></a>更加简便的使用property()函数</h4><blockquote><p>装饰器的方式将一个方法伪装成属性外，Python内置的<code>uiltins</code>块中的<code>roperty()</code>数，为我们提供了第二种设置类属性的手段。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class People:</span><br><span class="line"></span><br><span class="line">    def __init__(self, name, age):</span><br><span class="line">        self.__name &#x3D; name</span><br><span class="line">        self.__age &#x3D; age</span><br><span class="line"></span><br><span class="line">    def get_age(self):</span><br><span class="line">        return self.__age</span><br><span class="line"></span><br><span class="line">    def set_age(self, age):</span><br><span class="line">        if isinstance(age, int):</span><br><span class="line">            self.__age &#x3D; age</span><br><span class="line">        else:</span><br><span class="line">            raise ValueError</span><br><span class="line"></span><br><span class="line">    def del_age(self):</span><br><span class="line">        print(&quot;删除年龄数据！&quot;)</span><br><span class="line"></span><br><span class="line">    # 核心在这句</span><br><span class="line">    age &#x3D; property(get_age, set_age, del_age, &quot;年龄&quot;)    </span><br><span class="line"></span><br><span class="line">obj &#x3D; People(&quot;jack&quot;, 18)</span><br><span class="line">print(obj.age)</span><br><span class="line">obj.age &#x3D; 19</span><br><span class="line">print(&quot;obj.age:  &quot;, obj.age)</span><br><span class="line">del obj.ag</span><br></pre></td></tr></table></figure>通过语句<code>ge = property(get_age, set_age, del_age, &quot;龄&quot;</code>一个方法伪装成为属性。其效果和装饰器的方法是一样的。<br>property()函数的参数：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一个参数是方法名，调用 实例.属性 时自动执行的方法</span><br><span class="line">第二个参数是方法名，调用 实例.属性 ＝ XXX时自动执行的方法</span><br><span class="line">第三个参数是方法名，调用 del实例.属性 时自动执行的方法</span><br><span class="line">第四个参数是字符串，调用 实例.属性.__doc__时的描述信息。</span><br></pre></td></tr></table></figure>在Django框架源码中有使用到此特性</li></ol>]]></content>
    
    <summary type="html">
    
      Python面向对象入门教程
    
    </summary>
    
    
      <category term="PYTHON" scheme="https://shuke163.github.io/categories/PYTHON/"/>
    
    
      <category term="PYTHON" scheme="https://shuke163.github.io/tags/PYTHON/"/>
    
  </entry>
  
  <entry>
    <title>Python技术进阶yield</title>
    <link href="https://shuke163.github.io/2020/04/23/Python%E6%8A%80%E6%9C%AF%E8%BF%9B%E9%98%B6yield/"/>
    <id>https://shuke163.github.io/2020/04/23/Python%E6%8A%80%E6%9C%AF%E8%BF%9B%E9%98%B6yield/</id>
    <published>2020-04-23T08:09:36.000Z</published>
    <updated>2020-04-23T08:09:48.579Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Python技术进阶yield"><a href="#Python技术进阶yield" class="headerlink" title="Python技术进阶yield"></a>Python技术进阶<code>yield</code></h2><blockquote><p><code>yield</code>关键字在Python中开发中使用较为频繁，它为我们某些开发场景提供了便利，这篇文章我们来深入讲解<code>yield</code>相关知识。</p></blockquote><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>在讲<code>yield</code>之前，我们先复习一下迭代器与生成器的区别，可以参考我之前写的文章：Python技术进阶——迭代器、可迭代对象、生成器。</p><p>简单总结如下：</p><ul><li>实现了迭代器协议<code>__iter__</code>和<code>next/__next__</code>方法的对象被称作迭代器</li><li>迭代器可以使用<code>for</code>执行输出每个元素</li><li>生成器是一种特殊的迭代器</li></ul><p>一个函数内，如果包含了<code>yield</code>关键字，这个函数就是一个生成器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 生成器函数</span><br><span class="line">def gen(n):</span><br><span class="line">    for i in range(n):</span><br><span class="line">        yield i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g &#x3D; gen(3)  # 创建一个生成器</span><br><span class="line">print(g)</span><br><span class="line"></span><br><span class="line">print(type(g))  # &lt;type &#39;generator&#39;&gt;</span><br><span class="line"></span><br><span class="line"># 生成器迭代</span><br><span class="line">for i in g:</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"># output</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">&lt;generator object gen at 0x10a1cbaf0&gt;</span><br><span class="line">&lt;class &#39;generator&#39;&gt;</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p>注意，在执行<code>g = gen(3)</code>时，函数中的代码并没有执行，此时我们只是创建了一个生成器对象，他的类型是<code>generator</code>。<br>当执行<code>for i in g</code>时，每执行一次循环，直到执行到<code>yield</code>时，返回<code>yield</code>后面的值。<br>换句话说，我们想输出5个元素，在创建生成器时，这个5个元素此时并没有产生，什么时候产生呢？在执行for循环遇到<code>yield</code>时，此时才会逐个生成每个元素。</p><p>生成器除了实现迭代器协议可以进行迭代之外，还包含一些方法：</p><ul><li><code>generator.next()</code>：每次执行到遇到<code>yield</code>后返回，直到没有<code>yield</code>，抛出<code>StopIterator</code>异常</li><li><code>generator.send(value)``：将</code>yield<code>的值设置为</code>value`</li><li><code>generator.throw(type[, value[, traceback]])</code>：向生成器当前状态抛出一个异常</li><li><code>generator.close()</code>：关闭生成器</li></ul><h3 id="next"><a href="#next" class="headerlink" title="next"></a>next</h3><p>为了更便于你理解只有在遇到<code>yield</code>时才产生值，我们可以改写程序如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">def gen(n):</span><br><span class="line">    for i in range(n):</span><br><span class="line">        print(&#39;yield before&#39;)</span><br><span class="line">        yield i</span><br><span class="line">        print(&#39;yield after&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g &#x3D; gen(3)  # 创建一个生成器</span><br><span class="line"># print(g.__next__)</span><br><span class="line">print(next(g))  # 0</span><br><span class="line">print(&#39;-&#39; * 5)</span><br><span class="line">print(next(g))  # 1</span><br><span class="line">print(&#39;-&#39; * 5)</span><br><span class="line">print(next(g))  # 2</span><br><span class="line">print(&#39;-&#39; * 5)</span><br><span class="line">print(next(g))  # StopIteration</span><br><span class="line"></span><br><span class="line"># output</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">yield before</span><br><span class="line">0</span><br><span class="line">-----</span><br><span class="line">yield after</span><br><span class="line">yield before</span><br><span class="line">1</span><br><span class="line">-----</span><br><span class="line">yield after</span><br><span class="line">yield before</span><br><span class="line">2</span><br><span class="line">-----</span><br><span class="line">yield after</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;learn.py&quot;, line 53, in &lt;module&gt;</span><br><span class="line">    print(next(g))  # StopIteration</span><br><span class="line">StopIteration</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p>只有在执行<code>next(g)</code>时，才会产生值，并且生成器会保留上下文信息，在再次执行<code>next(g)</code>时继续返回。</p><h3 id="send"><a href="#send" class="headerlink" title="send"></a>send</h3><p>上面的例子只展示了在<code>yield</code>后有值的情况，其实也可以使用<code>j = yield i</code>这种语法，我们看下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line">def gen():</span><br><span class="line">    i &#x3D; 1</span><br><span class="line">    while True:</span><br><span class="line">        j &#x3D; yield i</span><br><span class="line">        i *&#x3D; 2</span><br><span class="line">        time.sleep(2)</span><br><span class="line">        if j &#x3D;&#x3D; -1:</span><br><span class="line">            break</span><br><span class="line"></span><br><span class="line">for i in gen():</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"># output</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">8</span><br><span class="line">16</span><br><span class="line">32</span><br><span class="line">64</span><br><span class="line">128</span><br><span class="line">256</span><br><span class="line">^CTraceback (most recent call last):</span><br><span class="line">  File &quot;learn.py&quot;, line 86, in &lt;module&gt;</span><br><span class="line">    for i in gen():</span><br><span class="line">  File &quot;learn.py&quot;, line 81, in gen</span><br><span class="line">    time.sleep(2)</span><br><span class="line">KeyboardInterrupt</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p>这个生成器函数相当于无限生成每次翻倍的数字，一直循环下去，直到我们杀死进程才能停止。<br>在上面的代码你会发现，貌似永远执行不到<code>j == -1</code>这个分支里，如果想让代码执行到这，如何做？<br>这里就要用到生成的send方法，它可以在外部传入一个值，使得改变生成器当前的状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">g &#x3D; gen()            # 创建一个生成器</span><br><span class="line">print(next(g))       # 1</span><br><span class="line">print(next(g))       # 2</span><br><span class="line">print(next(g))       # 4</span><br><span class="line">print(g.send(-1))    # j &#x3D; -1 程序退出</span><br><span class="line"></span><br><span class="line"># output</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;learn.py&quot;, line 112, in &lt;module&gt;</span><br><span class="line">    print(g.send(-1))    # j &#x3D; -1 程序退出</span><br><span class="line">StopIteration</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p>执行<code>g.send(-1)</code>,相当于把-1传入生成器，赋值给了<code>yield</code>之前的j，从而改变了生成器内部的执行状态。</p><h3 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h3><p>除了可以向生成器内部传入指定值，还可以传入指定异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def gen():</span><br><span class="line">    try:</span><br><span class="line">        yield 1</span><br><span class="line">    except ValueError:</span><br><span class="line">        yield &#39;ValueError&#39;</span><br><span class="line">    finally:</span><br><span class="line">        print(&#39;finally&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g &#x3D; gen()  # 创建一个生成器</span><br><span class="line">print(next(g))  # 1</span><br><span class="line">print(g.throw(ValueError))  # 向内部传入异常，返回ValueError，并打印出finally</span><br><span class="line"></span><br><span class="line"># output</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">1</span><br><span class="line">ValueError</span><br><span class="line">finally</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p><code>throw</code>与<code>next</code>类似，但是以传入异常的方式使生成器执行,<code>throw</code>一般在开发中很少被用到。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>上面简单介绍了生成器和<code>yield</code>的使用方式，那么<code>yield</code>一般在哪些场景中被使用？</p><h4 id="大列表的生成"><a href="#大列表的生成" class="headerlink" title="大列表的生成"></a>大列表的生成</h4><blockquote><p>如果你想生成一个非常大的列表，使用list时只能一次性在内存中创建出这个列表，这可能导致内存资源申请非常大，甚至有可能被操作系统杀死进程。</p></blockquote><p>直接在内存中生成一个大列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def big_list():</span><br><span class="line">    result &#x3D; []</span><br><span class="line">    for i in range(1000000000000):</span><br><span class="line">        result.append(i)</span><br><span class="line">    return result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 一次性在内存中生成大列表 内存占用非常大</span><br><span class="line">for i in big_list():</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure><p>由于生成器只有在执行到<code>yield</code>时才会产生值，我们可以使用这个特性优雅地解决这类问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def big_list():</span><br><span class="line">    for i in range(1000000000000):</span><br><span class="line">        yield i</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"># 大列表只有在迭代时 才逐个生成元素 减少内存占用</span><br><span class="line">for i in big_list():</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure><h4 id="简化代码结构"><a href="#简化代码结构" class="headerlink" title="简化代码结构"></a>简化代码结构</h4><p>如果一个函数中要产生一个列表，但这个列表可能是多个逻辑块组合后才能产生的，这就会导致我们的代码结构变得复杂：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def gen_list():</span><br><span class="line">    # 多个逻辑块 组成生成一个列表</span><br><span class="line">    result &#x3D; []</span><br><span class="line">    for i in range(10):</span><br><span class="line">        result.append(i)</span><br><span class="line">    for j in range(5):</span><br><span class="line">        result.append(j * j)</span><br><span class="line">    for k in [100, 200, 300]:</span><br><span class="line">        result.append(k)</span><br><span class="line">    return result</span><br><span class="line">    </span><br><span class="line">for item in gen_list():</span><br><span class="line">    print item</span><br></pre></td></tr></table></figure><p>使用<code>yield</code>生成这个列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 多个逻辑块 使用yield 生成一个列表</span><br><span class="line">def gen_list():</span><br><span class="line">    for i in range(10):</span><br><span class="line">        yield i</span><br><span class="line">    for j in range(5):</span><br><span class="line">        yield j * j</span><br><span class="line">    for k in [100, 200, 300]:</span><br><span class="line">        yield k</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for item in gen_list():</span><br><span class="line">    print(item)</span><br></pre></td></tr></table></figure><p>我们看到，在第一个例子中，我们只能先声明一个<code>list</code>类型的变量，然后在每个逻辑块中产生元素，之后<code>append</code>到结果中，最终<code>return</code>返回这个结果。<br>而使用<code>yield</code>后，只需在每个逻辑块需要产生并返回元素时，使用<code>yield</code>即可，代码更加简洁，结构更清晰，同时还拥有减少内存占用的好处。</p><h3 id="协程与并发"><a href="#协程与并发" class="headerlink" title="协程与并发"></a>协程与并发</h3><p>我们都比较熟悉进程、线程，一般为了提高程序的运行效率，会使用多进程、多线程进行开发，最常用的编程模型就是生产者-消费者模型，即一个进程/线程生产数据，其他进程/线程消费数据。</p><p>在多进程、多线程开发时，为了防止资源被篡改，往往会进行加锁，这就导致了编程的复杂程度。</p><p>在Python开发中，也提供了多进程和多线程的开发方式，但由于解释器<code>GIL</code>的存在，多线程开发并不能提高执行效率。所以在Python中，更多提高执行效率的编程模型是：协程。</p><p>什么是协程？简单来说，由多个程序块组合协作执行的程序，称之为协程。可能这么说还是太过模糊，我们用<code>yield</code>实现一个生产者-消费者的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">def consumer():</span><br><span class="line">    i &#x3D; None</span><br><span class="line">    while True:</span><br><span class="line">        j &#x3D; yield i  # 拿到producer发来的数据</span><br><span class="line">        print(&#39;consume %s&#39; % j)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def producer(c):</span><br><span class="line">    next(c)</span><br><span class="line">    for i in range(5):</span><br><span class="line">        print(&#39;produce %s&#39; % i)</span><br><span class="line">        c.send(i)  # 发数据给consumer</span><br><span class="line">    c.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c &#x3D; consumer()</span><br><span class="line">producer(c)</span><br><span class="line"></span><br><span class="line"># output</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">produce 0</span><br><span class="line">consume 0</span><br><span class="line">produce 1</span><br><span class="line">consume 1</span><br><span class="line">produce 2</span><br><span class="line">consume 2</span><br><span class="line">produce 3</span><br><span class="line">consume 3</span><br><span class="line">produce 4</span><br><span class="line">consume 4</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><p>整个程序执行流程如下：</p><ul><li><code>c = consumer()</code>创建一个生成器对象</li><li><code>producer(c)</code>开始执行代码，<code>next(c)</code>会启动生成器<code>consumer</code>直到代码运行到<code>j = yield i</code>处，此时<code>consumer</code>第一次执行完毕，返回</li><li><code>producer</code>函数继续向下执行，直到<code>c.send(i)</code>，利用生成器的<code>send</code>方法，向<code>consumer</code>发送数据</li><li><code>consumer</code>函数被唤醒，从<code>j = yield i</code>处开始执行，并接收<code>producer</code>传来的数据赋值给j，然后打印输出，直到再次执行到<code>yield</code>处，返回</li><li><code>producer</code>继续执行循环，执行上面的过程，逐个发送数据给<code>cosnumer</code>，直到循环结束</li><li>最终<code>c.close()</code>关闭<code>consumer</code>生成器，程序退出<br>在上面的代码中我们发现，程序运行时，在<code>producer</code>和<code>consumer</code>这2个函数之间来回切换执行，完成了生产任务、消费任务的场景，而且整个程序运行在单进程单线程下。<br>这其中的原理就是利用了生成器的<code>yield</code>关键字以及生成器的<code>next</code>和<code>send</code>方法。<br>这么做的好处在于：</li><li>整个程序运行过程中无锁，编程复杂度降低</li><li>程序在函数之间来回切换，是在用户态下进行的，不像进程/线程切换陷入内核状态，没有内核态的上下文切换，损耗更小，执行效率更高</li></ul><p>Python的生成器实现了协程的编程方式，为程序的并发执行提供了编程基础。<br>Python的很多第三方包都是基于这一特性进行封装的，例如<code>gevent、tornado</code>，它们都大大提高了程序的运行效率。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这篇文章主要讲了Python中生成器与<code>yield</code>的相关知识，总结如下：</p><ul><li>生成器在生成很大的列表的场景，能够节省内存空间的占用</li><li>在复杂逻辑块生成列表元素时，使用<code>yield</code>能极大简化代码结构</li><li>生成器的特性为Python的并发编程模型——协程，提供了编程基础</li></ul><h3 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h3><p><a href="http://kaito-kidd.com/2018/05/21/python-advance-yield/" target="_blank" rel="noopener">原文参考</a></p>]]></content>
    
    <summary type="html">
    
      Python技术进阶yield
    
    </summary>
    
    
      <category term="PYTHON" scheme="https://shuke163.github.io/categories/PYTHON/"/>
    
    
      <category term="PYTHON" scheme="https://shuke163.github.io/tags/PYTHON/"/>
    
  </entry>
  
  <entry>
    <title>Python技术进阶</title>
    <link href="https://shuke163.github.io/2020/04/23/Python%E6%8A%80%E6%9C%AF%E8%BF%9B%E9%98%B6/"/>
    <id>https://shuke163.github.io/2020/04/23/Python%E6%8A%80%E6%9C%AF%E8%BF%9B%E9%98%B6/</id>
    <published>2020-04-23T08:09:30.000Z</published>
    <updated>2020-04-23T08:09:30.166Z</updated>
    
    <summary type="html">
    
      Python技术进阶
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Python合并两个字典成一个新字典的几种方法分析比较</title>
    <link href="https://shuke163.github.io/2020/04/23/Python%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E5%AD%97%E5%85%B8%E6%88%90%E4%B8%80%E4%B8%AA%E6%96%B0%E5%AD%97%E5%85%B8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90%E6%AF%94%E8%BE%83/"/>
    <id>https://shuke163.github.io/2020/04/23/Python%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E5%AD%97%E5%85%B8%E6%88%90%E4%B8%80%E4%B8%AA%E6%96%B0%E5%AD%97%E5%85%B8%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90%E6%AF%94%E8%BE%83/</id>
    <published>2020-04-23T08:08:35.000Z</published>
    <updated>2020-04-23T08:08:50.333Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Python合并两个字典成一个新字典的几种方法分析比较"><a href="#Python合并两个字典成一个新字典的几种方法分析比较" class="headerlink" title="Python合并两个字典成一个新字典的几种方法分析比较"></a>Python合并两个字典成一个新字典的几种方法分析比较</h2><p>两个字典如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d1 &#x3D; &#123;&#39;name&#39; : &#39;revotu&#39;, &#39;age&#39; : 99&#125;</span><br><span class="line">&gt;&gt;&gt; d2 &#x3D; &#123;&#39;age&#39; : 24, &#39;sex&#39; : &#39;male&#39;&#125;</span><br></pre></td></tr></table></figure><p>合并后的结果如下（即，key相同时后面字典值覆盖前面字典）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&#39;sex&#39;: &#39;male&#39;, &#39;name&#39;: &#39;revotu&#39;, &#39;age&#39;: 24&#125;</span><br></pre></td></tr></table></figure><p>首先，说明字典并不支持+加法运算：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d1 + d2</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: unsupported operand type(s) for +: &#39;dict&#39; and &#39;dict&#39;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>现总结如下几种方法以及简要分析比较。</p><ol><li><p>多次更新<br>下面是最简单的合并字典的方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d &#x3D; &#123;&#125;</span><br><span class="line">&gt;&gt;&gt; d.update(d1)</span><br><span class="line">&gt;&gt;&gt; d.update(d2)</span><br></pre></td></tr></table></figure><blockquote><p>首先创建一个空字典，并使用update方法向字典中添加元素。注意，先添加的是d1，以保证后面添加的d2重复键会覆盖d1。<br>此方法满足了我们的要求，而且清晰明确，可是三行代码总感觉不够Pythonic。</p></blockquote></li><li><p>先复制，后更新<br>先复制d1字典创建一个新字典，然后使用d2来更新前面创建的新字典。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d &#x3D; d1.copy()</span><br><span class="line">&gt;&gt;&gt; d.update(d2)</span><br></pre></td></tr></table></figure><blockquote><p>对比方法一，这种复制d1的方法，更明显的表现出d1作为默认值。</p></blockquote></li><li><p>字典构造器<br>还可以使用字典的构造器dict()复制字典，然后再更新：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d &#x3D; dict(d1)</span><br><span class="line">&gt;&gt;&gt; d.update(d2)</span><br></pre></td></tr></table></figure><blockquote><p>与方法二很相似，但是没有方法二直接明了。</p></blockquote></li><li><p>关键字参数hack<br>你可能见过下面这个巧妙的解决办法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d &#x3D; dict(d1 , **d2)</span><br></pre></td></tr></table></figure><p>只有一行代码，看上去很酷，但是有一个问题，这种hack技巧只有在字典的键是字符串时才有效。</p><blockquote><p>看上去很cool，但是不通用，字典的键必须是字符串才可以用这种关键字参数方法。</p></blockquote></li><li><p>字典推导式<br>可以用字典推导式解决此问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d &#x3D; &#123;k:v for d in [d1, d2] for k,v in d.items()&#125;</span><br></pre></td></tr></table></figure><blockquote><p>字典推导式方法满足要求，只是嵌套的字典推导式，不那么清晰，不易于理解。</p></blockquote></li><li><p>元素拼接<br>我们从每个字典中获取一个元素列表，将列表拼接起来，然后再用拼接的列表构造字典：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d &#x3D; dict(list(d1.items()) + list(d2.items()))</span><br></pre></td></tr></table></figure><blockquote><p>而且，d2的元素在列表后面，所以在键重复时可以覆盖d1。如果在Python2中，items()方法本身返回的就是列表，无需用list()转成列表。</p></blockquote></li></ol><p>元素拼接在构造字典可以满足要求，只是看上去代码有些重复。</p><ol start="7"><li><p>元素并集<br>在Python3中，字典返回的是视图对象，键的视图对象是一个类似集合的对象，如果字典中的值可以保证是唯一的可哈希的，此时items返回的视图对象也是一个类似集合的对象：</p><figure class="highlight plain"><figcaption><span>d </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; 这种方法挺有意思，可是并不准确，因为集合是无序的，键重复时不能保证谁覆盖谁，而且字典中的值通常也是不可哈希的，当然也就不能返回一个类似集合的对象。</span><br><span class="line"></span><br><span class="line">8. chain items</span><br><span class="line">目前为止，我们讨论的解决方案中，最符合Python语言习惯而且只有一行代码实现的，是创建两个items的列表，然后拼接成字典。</span><br><span class="line">我们可以用itertools.chain来简化items拼接过程：</span><br><span class="line">&#96;&#96;&#96;&gt;&gt;&gt; d &#x3D; dict(chain(d1.items(), d2.items()))</span><br></pre></td></tr></table></figure><blockquote><p>这种方案很不错，可能比另外创建两个不必要的列表更高效。</p></blockquote></li><li><p>ChainMap<br>collections.ChainMap可以将多个字典或映射，在逻辑上将它们合并为一个单独的映射结构：</p><figure class="highlight plain"><figcaption><span>from collections import ChainMap</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d &#x3D; dict(ChainMap(d1, d2))</span><br></pre></td></tr></table></figure><blockquote><p>这种方法也很pythonic，而且也是通用方法。</p></blockquote></li><li><p>字典拆分<br>在Python3.5+中，可以使用一种全新的字典合并方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d &#x3D; &#123;**d1, **d2&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这行代码很pythonic，如果是你的python版本是3.5+，用这种方法是很不错的选择。</p></blockquote></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上面说了十种可以合并两个字典成一个新字典的方式，具体用哪个取决于你。<br>如果使用的是Python3.5+的版本，那么字典拆分这种新语法应该很适合你：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d &#x3D; &#123;**d1, **d2&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.revotu.com/python-merge-two-dicts-into-one-dict.html#more" target="_blank" rel="noopener">原文博客</a></p>]]></content>
    
    <summary type="html">
    
      Python合并两个字典成一个新字典的几种方法分析比较
    
    </summary>
    
    
      <category term="PYTHON" scheme="https://shuke163.github.io/categories/PYTHON/"/>
    
    
      <category term="PYTHON" scheme="https://shuke163.github.io/tags/PYTHON/"/>
    
  </entry>
  
</feed>
