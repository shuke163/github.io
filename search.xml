<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Django 数据类型</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h2 id="Django-数据类型"><a href="#Django-数据类型" class="headerlink" title="Django 数据类型"></a>Django 数据类型</h2><table>
<thead>
<tr>
<th>表字段</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>models.Auto.Field</td>
<td>默认会生成一个名为ID的字段并为int类型</td>
</tr>
<tr>
<td>models.CharField</td>
<td>字符串类型</td>
</tr>
<tr>
<td>models.BooleanField</td>
<td>布尔类型</td>
</tr>
<tr>
<td>models.ComaSeparatedIntegerField</td>
<td>用逗号分隔的整数类型</td>
</tr>
<tr>
<td>models.DateField</td>
<td>日期(date)类型</td>
</tr>
<tr>
<td>models.DateTimeFile</td>
<td>日期(datetime)类型</td>
</tr>
<tr>
<td>models.Decimal</td>
<td>十进制小数类型</td>
</tr>
<tr>
<td>models.EmailField</td>
<td>字符串类型(正则表达式邮箱)</td>
</tr>
<tr>
<td>models.FloatField</td>
<td>浮点类型</td>
</tr>
<tr>
<td>models.IntegerField</td>
<td>整数类型</td>
</tr>
<tr>
<td>models.BigIntegerField</td>
<td>长整数类型</td>
</tr>
<tr>
<td>models.IPAddressField</td>
<td>字符串类型(正则表达式)</td>
</tr>
<tr>
<td>models.GenericIPAddressField</td>
<td>字符串类型，参数protocal可以是: both,IPv4和IPv6，验证IP地址</td>
</tr>
<tr>
<td>models.NullBooleanField</td>
<td>允许为空的布尔类型</td>
</tr>
<tr>
<td>models.PositiveIntegerField</td>
<td>正整数的整数类型</td>
</tr>
<tr>
<td>models.PositiveSmallIntegerField</td>
<td>小正整数类型</td>
</tr>
<tr>
<td>models.SlugField</td>
<td>包含字母/数字/下划线和连字符的字符串，常用语URL</td>
</tr>
<tr>
<td>models.SmallIntergerField</td>
<td>小整数类型，取值范围是(-32,768~+32,767)</td>
</tr>
<tr>
<td>models.TextField</td>
<td>长文本类型</td>
</tr>
<tr>
<td>models.Timefiled</td>
<td>时间类型，显示时分秒</td>
</tr>
<tr>
<td>models.URLField</td>
<td>字符串，地址为正则表达式</td>
</tr>
<tr>
<td>models.BinaryField</td>
<td>二进制数据类型</td>
</tr>
</tbody></table>
<h3 id="表字段参数设置"><a href="#表字段参数设置" class="headerlink" title="表字段参数设置"></a>表字段参数设置</h3><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Null</td>
<td>如为True,字段是否可以为空</td>
</tr>
<tr>
<td>Blank</td>
<td>如为True， 设置在Admin后台站点管理中添加数据时可以允许为空值</td>
</tr>
<tr>
<td>Default</td>
<td>设置为默认值</td>
</tr>
<tr>
<td>primary_key</td>
<td>如为True，将字段设置为主键</td>
</tr>
<tr>
<td>db_column</td>
<td>设置数据库中的字段名称</td>
</tr>
<tr>
<td>Unique</td>
<td>如为True,将自督办设置成唯一属性，默认为False</td>
</tr>
<tr>
<td>db_index</td>
<td>如为True，将字段添加数据库索引</td>
</tr>
<tr>
<td>verbose_name</td>
<td>在Admin站点管理设置字段的显示名称</td>
</tr>
<tr>
<td>related_name</td>
<td>关联对象反向饮用描述符，用于多表查询，可解决一个数据表有2个外键同时指向另一个数据表而出现重名的问题</td>
</tr>
</tbody></table>
<h3 id="django常用的内置函数"><a href="#django常用的内置函数" class="headerlink" title="django常用的内置函数"></a>django常用的内置函数</h3><table>
<thead>
<tr>
<th>内置函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>authenticate</td>
<td>验证用户是否存在，必选参数为<code>username</code>和<code>password</code>，只能用于模型User</td>
</tr>
<tr>
<td>create_user</td>
<td>创建新的用户信息，必选参数为<code>username</code>,只能用于模型User</td>
</tr>
<tr>
<td>set_password</td>
<td>修改用户密码，必选参数为<code>password</code>，只能用于模型User</td>
</tr>
<tr>
<td>login/logout</td>
<td>用户的的登陆和注销，只能用于模型User</td>
</tr>
<tr>
<td>make_password</td>
<td>密码加密处理，必选参数为<code>password</code>，可脱离模型User单独使用</td>
</tr>
<tr>
<td>check_password</td>
<td>校验加密前后的密码是否相同，可脱离模型User单独使用</td>
</tr>
<tr>
<td>email_user</td>
<td>发送邮件，只用用于模型User</td>
</tr>
<tr>
<td>send_mail</td>
<td>发送邮件</td>
</tr>
<tr>
<td>send_mass_mail</td>
<td>批量发送邮件</td>
</tr>
<tr>
<td>EmailMutilAlternatives</td>
<td>发送自定义内容格式的邮件</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django 找回密码</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h2 id="Django-找回密码"><a href="#Django-找回密码" class="headerlink" title="Django 找回密码"></a>Django 找回密码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import random</span><br><span class="line">from django.shortcuts import render</span><br><span class="line">from django.contrib.auth.models import User</span><br><span class="line">from django.contrib.auth.hashers import make_password</span><br><span class="line"></span><br><span class="line">def findpassword(request):</span><br><span class="line">    button &#x3D; &quot;获取验证码&quot;</span><br><span class="line">    new_password &#x3D; False</span><br><span class="line">    </span><br><span class="line">    if request.method &#x3D;&#x3D; &quot;POST&quot;:</span><br><span class="line">        username &#x3D; request.POST.get(&quot;username&quot;,&#39;root&#39;)</span><br><span class="line">        VerificationCode &#x3D; request.POST.get(&quot;VerificationCode&quot;,&quot;&quot;)</span><br><span class="line">        password&#x3D; request.POST.get(&quot;password&quot;,&quot;&quot;)</span><br><span class="line">        user &#x3D; User.objects.filter(username&#x3D;username)</span><br><span class="line">        if not user:</span><br><span class="line">            tips &#x3D; f&quot;用户&#123;username&#125;不存在&quot;</span><br><span class="line">        else:</span><br><span class="line">            if not request.session.get(&quot;VerificationCode&quot;,&quot;&quot;):</span><br><span class="line">                button &#x3D; &quot;重置密码&quot;</span><br><span class="line">                tips &#x3D; &quot;验证码已发送&quot;</span><br><span class="line">                new_password &#x3D; True</span><br><span class="line">                VerificationCode &#x3D; str(random.randint(1000,9999))</span><br><span class="line">                request.session[&quot;VerificationCode&quot;] &#x3D; VerificationCode</span><br><span class="line">                user[0].email_user(&quot;找回密码&quot;,VerificationCode)</span><br><span class="line">            elif verificationCode &#x3D;&#x3D; request.session.get(&quot;verificationCode&quot;):</span><br><span class="line">                dj_ps &#x3D; make_password(password,None,&quot;pbkdf2_sha256&quot;)</span><br><span class="line">                user[0].password &#x3D; dj_ps</span><br><span class="line">                user[0].save()</span><br><span class="line">                del request.session[&quot;VerificationCode&quot;]</span><br><span class="line">                tips &#x3D; &quot;密码已重置&quot;</span><br><span class="line">            else</span><br><span class="line">               tips &#x3D; &quot;验证码错误，请重新获取&quot;</span><br><span class="line">               new_password &#x3D; False</span><br><span class="line">               def request.session[&quot;VerificationCode&quot;]</span><br><span class="line">      return render(request,&quot;user.html&quot;,locals())</span><br></pre></td></tr></table></figure>

<h3 id="用户model的实现"><a href="#用户model的实现" class="headerlink" title="用户model的实现"></a>用户model的实现</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># models.py</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">from django.db import models</span><br><span class="line">from django.contrib.auth.models import AbstractUser</span><br><span class="line"></span><br><span class="line">class MyUser(AbstractUser):</span><br><span class="line">    qq &#x3D; models.ChardField(&quot;QQ 号码&quot;, max_length&#x3D;16)</span><br><span class="line">    weChat &#x3D; models.ChardField(&quot;微信&quot;, max_length&#x3D;100)</span><br><span class="line">    mobile &#x3D; models.ChardField(&quot;手机号码&quot;, max_length&#x3D;11)</span><br><span class="line">    </span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.username</span><br></pre></td></tr></table></figure>

<h2 id="扩展MyUser-Admin-信息"><a href="#扩展MyUser-Admin-信息" class="headerlink" title="扩展MyUser Admin 信息"></a>扩展MyUser Admin 信息</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from .models import MyUser</span><br><span class="line">from django.contrib.auth.admin import UserAdmin</span><br><span class="line">from django.utils.translation import gettext_lazy as _</span><br><span class="line"></span><br><span class="line">@admin.register(MyUser)</span><br><span class="line">class MyUserAdmin(UserAdmin):</span><br><span class="line">    list_display &#x3D; [&quot;uername&quot;,&quot;email&quot;,&quot;mobile&quot;,&quot;qq&quot;,&quot;weChat&quot;]</span><br><span class="line">    fieldsets &#x3D; list(&quot;UserAdmin.fielsets&quot;)</span><br><span class="line">    fieldsets[1] &#x3D; (_(&quot;Personal info&quot;),&#123;&quot;fields&quot;: (&quot;first_name&quot;,&quot;last_name&quot;,&quot;email&quot;,&quot;mobile&quot;,&quot;qq&quot;,&quot;weChat&quot;))&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="Admin后台app设置"><a href="#Admin后台app设置" class="headerlink" title="Admin后台app设置"></a>Admin后台app设置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># __init__.py</span><br><span class="line"></span><br><span class="line">from django.apps import AppConfig</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">## 修改app在admin后台显示名称</span><br><span class="line">## default_app_config的值来自apps.py类名</span><br><span class="line"></span><br><span class="line">default_app_config &#x3D; &quot;user.IndexConfig&quot;</span><br><span class="line"></span><br><span class="line"># 获取当前app的命名</span><br><span class="line">def get_current_app_name(_file):</span><br><span class="line">    return os.path.split(os.path.dirname(_file_)[-1])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 重写类 IndexConfig</span><br><span class="line">class IndexConfig(AppConfig):</span><br><span class="line">    name &#x3D; get_current_app_name(__file__)</span><br><span class="line">    verbose_name &#x3D; &quot;用户管理&quot;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django 聚合</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h1 id="Django-聚合"><a href="#Django-聚合" class="headerlink" title="Django 聚合"></a>Django 聚合</h1><hr>

<ol>
<li>在查询集上生成聚合(aggregate)<br>aggregate()是QuerySet 的一个终止子句，意思是说，它返回一个包含一些键值对的字典。键的名称是聚合值的标识符，值是计算出来的聚合值。键的名称是按照字段和聚合函数的名称自动生成出来的。如果你想要为聚合值指定一个名称，可以向聚合子句提供它。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; Book.objects.aggregate(average_price&#x3D;Avg(&#39;price&#39;))</span><br><span class="line">&#123;&#39;average_price&#39;: 34.35&#125;</span><br></pre></td></tr></table></figure></li>
<li>为查询集的每一项生成聚合(annotate)<br>逐个对象的汇总结果可以由annotate()子句生成。当annotate()子句被指定之后，QuerySet中的每个对象都会被注上特定的值。<br>这些注解的语法都和aggregate()子句所使用的相同。annotate()的每个参数都描述了将要被计算的聚合。比如，给图书添加作者数量的注解：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Build an annotated queryset</span><br><span class="line">&gt;&gt;&gt; from django.db.models import Count</span><br><span class="line">&gt;&gt;&gt; q &#x3D; Book.objects.annotate(Count(&#39;authors&#39;))</span><br><span class="line"># Interrogate the first object in the queryset</span><br><span class="line">&gt;&gt;&gt; q[0]</span><br><span class="line">&lt;Book: The Definitive Guide to Django&gt;</span><br><span class="line">&gt;&gt;&gt; q[0].authors__count</span><br><span class="line">2</span><br><span class="line"># Interrogate the second object in the queryset</span><br><span class="line">&gt;&gt;&gt; q[1]</span><br><span class="line">&lt;Book: Practical Django Projects&gt;</span><br><span class="line">&gt;&gt;&gt; q[1].authors__count</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
和使用 aggregate()一样，注解的名称也根据聚合函数的名称和聚合字段的名称得到的。你可以在指定注解时，为默认名称提供一个别名：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; q &#x3D; Book.objects.annotate(num_authors&#x3D;Count(&#39;authors&#39;))</span><br><span class="line">&gt;&gt;&gt; q[0].num_authors</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; q[1].num_authors</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>与 aggregate() 不同的是， annotate() 不是一个终止子句。annotate()子句的返回结果是一个查询集 (QuerySet)；这个 QuerySet可以用任何QuerySet方法进行修改，包括 filter(), order_by(), 甚至是再次应用annotate()。</p>
<p><a href="http://python.usyiyi.cn/documents/django_182/topics/db/aggregation.html" target="_blank" rel="noopener">Django 聚合</a></p>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Alembic</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h2 id="Alembic"><a href="#Alembic" class="headerlink" title="Alembic"></a>Alembic</h2><p>数据库的管理是一个项目中非常关键的部分。<br>整个开发过程中免不了要对数据库的结构进行一定的修改，比如字段的增加，字段类型的改变， 或者新添和删除一个表。<br>比如新建一个表格，朴素的思想（原始的冲动）是代码里补充一个 class，定义好各个字段（可能有50个甚至更多的字段），再一次 create_all()（这也意味着之前的数据会消失），或者在代码部分写好之后，通过数据库软件人肉修改数据库中的结构（想想，几十个字段，甚至上百个字段）。<br>上述的做法，费时费力，不要忘了，生产工具的使用促进人类社会发展，重复的机械劳动就是浪费生命，聪明的程序员是要学会偷懒的。<br>所以，今天我们来学习一下 alembic！这是 sqlalchemy 作者亲自开发的 数据库版本管理工具，亲儿子。（需要强调的是，仅仅针对结构化的数据，Mysql PostgreSQL 等）<br>数据库迁移的终极目的：数据不丢失。</p>
<h3 id="第一步："><a href="#第一步：" class="headerlink" title="第一步："></a>第一步：</h3><p>pip install alembic  # 请确保是你代码运行 python 版本中的 pip<br>显然，这是为了确保安装了 alembic。之后你就可以在命令行使用 alembic 命令了</p>
<h3 id="第二步："><a href="#第二步：" class="headerlink" title="第二步："></a>第二步：</h3><p>alembic init alembic_dir  # alembic_dir 是自定义的名字，不用加引号<br>在你的项目的根目录下运行这个指令，不出意外，会出现：（当然，你也可以在别的目录里面这么做，不过，仅仅是使用的话，知道这是个套路就好了，因为 alembic 命令会找当前命令录里的 env.py 文件）<br>yourproject/<br>alembic.ini  # 相关的初始化配置，主要为 env.py 中的 context 提供相应的参数，我们需要修改的是 sqlalchemy.url 这个<br>alembic_dir/<br>env.py # 环境文件，灵活性相当之大<br>README<br>   script.py.mako  # 这是用来生成迁移脚本 py 文件的 mako 语法脚本文件<br>   versions/  # 这个文件里保存着每次 revision 的相关信息</p>
<h3 id="第三步："><a href="#第三步：" class="headerlink" title="第三步："></a>第三步：</h3><p>编辑 alembic.ini 文件，绑定数据库<br>sqlalchemy.url = driver://user:pass@localhost/dbname  # 把 = 后面的修改成你数据库的配置就可以了，不要加引号<br>第四步：<br>在 env.py 中强势插入如下代码，防止在使用 自动迁移命令 时，找不到数据库的路径，参考：stackoverflow<br>import os<br>import sys<br>sys.path.insert(0. os.path.realpath(‘.’))<br>为了使用模型类实现 自动迁移，还需要设置元数据，这样 alembic 才能获取模型类中定义的信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from models import Base</span><br><span class="line">Target_metadata &#x3D; Base.metadata</span><br></pre></td></tr></table></figure>
<h3 id="第五步："><a href="#第五步：" class="headerlink" title="第五步："></a>第五步：</h3><p>比如你的代码里已经创建了一个表模型类，有如下两个操作。<br>alembic revision -m ‘input your description for this version’  # 这个属于你手动在 versions/fdfadsf.py 去更改，不需要模型类<br>alembic revision –autogenerate -m ‘input your description for this version’  # 这是自动的，建议用这个，省事，不过在 upgrade 之前一定要自己再 adjust 一下<br>这两个命令都会在 versions 文件夹里生成一个脚本文件，前者需要手动添加，后者自动生成。<br>迁移命令生成后之后不要忘记使用命令 alembic upgrade head 使数据库保持最新的状态。</p>
<p>顾名思义， 生成一个版本<br>此时在该数据库中会生成一个 alembic_version 的表，记录版本信息<br>注意，其中一旦某个版本缺失，那基本上就可以重来了，alembic 的操作将无法定位版本信息，不过！也可以自己 hack 一下，比如数据库的版本号不在versions里头，我们可以自己生成一个，把版本号给改了，这个大家有兴趣可以自己去玩，灵活性很大，总而言之，还是不希望版本的缺失。<br>最后介绍几个命令的意思：<br>alembic current  # 显示当前数据库的版本<br>alembic upgrade head/base/dfas(version num)  # head 指更新到最新版本，base 则是最初版本，也可以指定，类似于 git<br>alembic downgrade base/dfsa(version num)  # 降级，如果是 -1 的话，就是直接回退一级  +/- num 代表前进和后退多少个版本<br>alembic head  # 当前最新的版本号是哪个<br>alembic merge -m ‘fsdf’ asdf fdasf  # 合并两个 head<br>alembic -c test_alembic/alembic.ini dsfajf  # 指定目录<br>具体演示一些可参考的步骤：<br>pip install alembic，可以用 /anaconda/bin/pip install alembic<br>alembic init alembic_dir<br>alembic revision —autogenerate  # 自动脚本，初始化数据库，强调 使用 autogenerate 是无法在与最新版本号不一致的情况下使用的<br>alembic revision -m ‘fasdfads’  # 手动脚本<br>init data 插入数据，接下来的操作就是在存在数据的情况下进行操作，默认使用 autogenerate<br>增加字段，删除字段<br>重命名字段，自动脚本，手动脚本，引申到重命名表格<br>使用 compare_type=True，然后自动脚本 检测字段类型、长度改变，参考该链接<br>强调一下，autogenerate 的局限性，参考链接内容<br>统一再介绍一下几个相关的操作命令<br>团队使用方面，安利 flask-script 的功能，env.py 给予了充分自定义的可能，可以参考o2o_system的修改模式，可是要强调的是数据库操作是个敏感内容，不管是多大的团队，操作数据库的人总不会有太多，还有就是如何使用 flask-script 简化 命令 的输入。</p>
<p>op.rename_table(<br>    ‘old_name’,<br>    ‘new_name’<br>)<br>op.alter_column(<br>    ‘table_name’,<br>    ‘old_name’,<br>    ‘existing_type’,<br>    ‘new_name’<br>)<br>一些进阶的说明：<br>branches 的操作，涉及到了 merge heads 等命令，然后还可以指定 base。<br>offline mode<br>自定义配置文件，自定义 configuration<br>手动定义脚本中还有更多的内容可以学习，operation 有许多方法，比较有用的是批量处理的部分<br>multidb 模板</p>
]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>PYTHON</tag>
      </tags>
  </entry>
  <entry>
    <title>Django 自定义分页实现</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h2 id="Django-自定义分页实现"><a href="#Django-自定义分页实现" class="headerlink" title="Django 自定义分页实现"></a>Django 自定义分页实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># __author__ &#x3D; &quot;shuke&quot;</span><br><span class="line"># Date: 2017&#x2F;9&#x2F;9</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Page(object):</span><br><span class="line">    def __init__(self, current_page, all_count, base_url, per_page&#x3D;10, pager_page_count&#x3D;11):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :param current_page: 当前页</span><br><span class="line">        :param all_count: 数据总条数</span><br><span class="line">        :param base_url: 分页的url</span><br><span class="line">        :param per_page: 每页显示的数据条数</span><br><span class="line">        :param pager_page_count: 每页显示的页码数量</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.current_page &#x3D; current_page</span><br><span class="line">        self.per_page &#x3D; per_page</span><br><span class="line">        self.all_count &#x3D; all_count</span><br><span class="line">        self.base_url &#x3D; base_url</span><br><span class="line">        self.pager_page_count &#x3D; pager_page_count</span><br><span class="line">        pager_count, b &#x3D; divmod(all_count, per_page)</span><br><span class="line">        if b !&#x3D; 0:</span><br><span class="line">            pager_count +&#x3D; 1</span><br><span class="line">        self.pager_count &#x3D; pager_count</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def start(self):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        数据库获取值的起始索引位置</span><br><span class="line">        :return:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return (self.current_page - 1) * self.per_page</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def end(self):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        数据库获取值的结束索引位置</span><br><span class="line">        :return:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return self.current_page * self.per_page</span><br><span class="line"></span><br><span class="line">    def page_html(self):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        渲染的HTML页码</span><br><span class="line">        :return:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # 页码</span><br><span class="line">        pager_page_count &#x3D; self.pager_page_count</span><br><span class="line">        half_pager_page_count &#x3D; int(pager_page_count &#x2F; 2)</span><br><span class="line"></span><br><span class="line">        if self.pager_count &lt; self.pager_page_count:</span><br><span class="line">            pager_start &#x3D; 1</span><br><span class="line">            pager_end &#x3D; self.pager_count</span><br><span class="line">        else:</span><br><span class="line">            # 数据较多，页码超过11，最少110条</span><br><span class="line">            if self.current_page &lt;&#x3D; half_pager_page_count:</span><br><span class="line">                pager_start &#x3D; 1</span><br><span class="line">                pager_end &#x3D; pager_page_count</span><br><span class="line">            else:</span><br><span class="line">                if (self.current_page + half_pager_page_count) &gt; self.pager_count:</span><br><span class="line">                    pager_start &#x3D; self.pager_count - pager_page_count + 1</span><br><span class="line">                    pager_end &#x3D; self.pager_count</span><br><span class="line">                else:</span><br><span class="line">                    pager_start &#x3D; self.current_page - half_pager_page_count</span><br><span class="line">                    pager_end &#x3D; self.current_page + half_pager_page_count</span><br><span class="line">        page_list &#x3D; []</span><br><span class="line">        if self.current_page &lt;&#x3D; 1:</span><br><span class="line">            # prev &#x3D; &#39;&lt;a href&#x3D;&quot;#&quot;&gt;上一页&lt;&#x2F;a&gt;&#39;</span><br><span class="line">            prev &#x3D; &#39;&lt;li class&#x3D;&quot;disabled&quot;&gt;&lt;a href&#x3D;&quot;#&quot; aria-label&#x3D;&quot;Previous&quot;&gt;&lt;span aria-hidden&#x3D;&quot;true&quot;&gt;&amp;laquo;&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#39;</span><br><span class="line">        else:</span><br><span class="line">            # prev &#x3D; &#39;&lt;a href&#x3D;&quot;%s?page&#x3D;%s&quot;&gt;上一页&lt;&#x2F;a&gt;&#39; % (self.base_url, self.current_page - 1,)</span><br><span class="line">            prev &#x3D; &#39;&lt;li&gt;&lt;a href&#x3D;&quot;%s?page&#x3D;%s&quot; aria-label&#x3D;&quot;Previous&quot;&gt;&lt;span aria-hidden&#x3D;&quot;true&quot;&gt;&amp;laquo;&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#39; % \</span><br><span class="line">                   (self.base_url, self.current_page - 1)</span><br><span class="line">        page_list.append(prev)</span><br><span class="line">        for i in range(pager_start, pager_end + 1):</span><br><span class="line">            if self.current_page &#x3D;&#x3D; i:</span><br><span class="line">                # tpl &#x3D; &#39;&lt;a class&#x3D;&quot;active&quot; href&#x3D;&quot;%s?page&#x3D;%s&quot;&gt;%s&lt;&#x2F;a&gt;&#39; % (self.base_url, i, i)</span><br><span class="line">                tpl &#x3D; &#39;&lt;li class&#x3D;&quot;active&quot;&gt;&lt;a href&#x3D;&quot;%s?page&#x3D;%s&quot;&gt;%s&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#39; % (self.base_url, i, i)</span><br><span class="line">            else:</span><br><span class="line">                # tpl &#x3D; &#39;&lt;a href&#x3D;&quot;%s?page&#x3D;%s&quot;&gt;%s&lt;&#x2F;a&gt;&#39; % (self.base_url, i, i)</span><br><span class="line">                tpl &#x3D; &#39;&lt;li&gt;&lt;a href&#x3D;&quot;%s?page&#x3D;%s&quot;&gt;%s&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#39; % (self.base_url, i, i)</span><br><span class="line">            page_list.append(tpl)</span><br><span class="line"></span><br><span class="line">        if self.current_page &gt;&#x3D; self.pager_count:</span><br><span class="line">            # nex &#x3D; &#39;&lt;a href&#x3D;&quot;#&quot;&gt;下一页&lt;&#x2F;a&gt;&#39;</span><br><span class="line">            nex &#x3D; &#39;&lt;li class&#x3D;&quot;disabled&quot;&gt;&lt;a href&#x3D;&quot;#&quot; aria-label&#x3D;&quot;Next&quot;&gt;&lt;span aria-hidden&#x3D;&quot;true&quot;&gt;&amp;raquo;&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#39;</span><br><span class="line">        else:</span><br><span class="line">            # nex &#x3D; &#39;&lt;a href&#x3D;&quot;%s?page&#x3D;%s&quot;&gt;下一页&lt;&#x2F;a&gt;&#39; % (self.base_url, self.current_page + 1,)</span><br><span class="line">            nex &#x3D; &#39;&lt;li&gt;&lt;a href&#x3D;&quot;%s?page&#x3D;%s&quot; aria-label&#x3D;&quot;Next&quot;&gt;&lt;span aria-hidden&#x3D;&quot;true&quot;&gt;&amp;raquo;&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;&#39; % \</span><br><span class="line">                  (self.base_url, self.current_page + 1)</span><br><span class="line">        page_list.append(nex)</span><br><span class="line">        page_str &#x3D; &quot;&quot;.join(page_list)</span><br><span class="line">        return page_str</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django REST framework API认证(包含JWT认证) + 权限</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h2 id="Django-REST-framework-API认证-包含JWT认证-权限"><a href="#Django-REST-framework-API认证-包含JWT认证-权限" class="headerlink" title="Django REST framework API认证(包含JWT认证) + 权限"></a>Django REST framework API认证(包含JWT认证) + 权限</h2><h3 id="一-背景"><a href="#一-背景" class="headerlink" title="一. 背景"></a>一. 背景</h3><p>在我们学习Django Rest Framework（简称DRF）时，其非常友好地给我们提供了一个可浏览API的界面。很多测试工作都可以在可浏览API界面完成测试。要使用可浏览API界面很简单，只需要在urls.py文件中添加如下部分即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.conf.urls import include</span><br><span class="line">urlpatterns +&#x3D; [</span><br><span class="line">    url(r&#39;^api-auth&#x2F;&#39;, include(&#39;rest_framework.urls&#39;,</span><br><span class="line">                               namespace&#x3D;&#39;rest_framework&#39;)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>其中，r’^api-auth/‘部分实际上可以用任何你想使用URL替代。唯一的限制是所包含的URL必须使用’rest_framework’命名空间。在Django 1.9+中，REST framework将自动设置，所以你也无须关心。</p>
<p>配置完成后，如果再次打开浏览器API界面并刷新页面，你将在页面右上角看到一个“Log in”链接。这就是DRF提供的登录和登出入口，可以用来完成认证。</p>
<p>然后进入到’rest_framework.urls’源码，是可以看到提供了’login’和’logout’两个接口，分别用来登入和登录的。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if django.VERSION &lt; (1, 11):</span><br><span class="line">    login &#x3D; views.login</span><br><span class="line">    login_kwargs &#x3D; &#123;&#39;template_name&#39;: &#39;rest_framework&#x2F;login.html&#39;&#125;</span><br><span class="line">    logout &#x3D; views.logout</span><br><span class="line">else:</span><br><span class="line">    login &#x3D; views.LoginView.as_view(template_name&#x3D;&#39;rest_framework&#x2F;login.html&#39;)</span><br><span class="line">    login_kwargs &#x3D; &#123;&#125;</span><br><span class="line">    logout &#x3D; views.LogoutView.as_view()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">app_name &#x3D; &#39;rest_framework&#39;</span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    url(r&#39;^login&#x2F;$&#39;, login, login_kwargs, name&#x3D;&#39;login&#39;),</span><br><span class="line">    url(r&#39;^logout&#x2F;$&#39;, logout, name&#x3D;&#39;logout&#39;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>其中login接口调用LoginView视图，logout接口调用LogoutView视图。这两个视图都是django.contrib.auth应用提供的。在LogoutView视图中，有这么一个装饰器@method_decorator(csrf_protect)，是用来做CSRF code验证的，就是做表单安全验证的，防止跨站攻击。而这个CSRF code是在返回HTML页面的时候Django会自动注册这么一个CSRF code方法，而在template中会自动调用这个方法生成code值。在前端页面元素form部分，可以查看到name=”csrfmiddlewaretoken”标识，且在Django返回的 HTTP 响应的 cookie 里，Django 会为你添加一个csrftoken 字段，其值为一个自动生成的token。这就是用来做表单安全验证的，具体关于CSRF原理见Django章节。</p>
<p>这里要说明一个问题就是这个LoginView我们是无法直接拿来用的，因为它需要做CSRF验证，而在前后端分离系统中不需要做CSRF验证，这里不存在站内站外的问题，本身就是跨站访问的。那么在我们前后端分离项目中，如何做API接口的验证呢？其实framework也已经提供了多种验证方式。</p>
<h3 id="二-身份验证"><a href="#二-身份验证" class="headerlink" title="二. 身份验证"></a>二. 身份验证</h3><p>REST framework提供了许多开箱即用的身份验证方案，同时也允许你实施自定义方案。这里需要明确一下用户认证（Authentication）和用户授权（Authorization）是两个不同的概念，认证解决的是“有没有”的问题，而授权解决的是“能不能”的问题。</p>
<p>BasicAuthentication<br>该认证方案使用 HTTP Basic Authentication，并根据用户的用户名和密码进行签名。Basic Authentication 通常只适用于测试。</p>
<p>SessionAuthentication<br>此认证方案使用 Django 的默认 session 后端进行认证。Session 身份验证适用于与您的网站在同一会话环境中运行的 AJAX 客户端。</p>
<p>TokenAuthentication<br>此认证方案使用简单的基于令牌的 HTTP 认证方案。令牌身份验证适用于 client-server 架构，例如本机桌面和移动客户端。</p>
<p>RemoteUserAuthentication<br>这种身份验证方案允许您将身份验证委托给您的 Web 服务器，该服务器设置 REMOTE_USER 环境变量。</p>
<p>默认的认证方案可以使用DEFAULT_AUTHENTICATION_CLASSES全局设置，在settings.py文件配置。在默认情况下，DRF开启了 BasicAuthentication 与 SessionAuthentication 的认证。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK &#x3D; &#123;</span><br><span class="line">    &#39;DEFAULT_AUTHENTICATION_CLASSES&#39;: (</span><br><span class="line">        &#39;rest_framework.authentication.BasicAuthentication&#39;,</span><br><span class="line">        &#39;rest_framework.authentication.SessionAuthentication&#39;,</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于DRF，几乎所有的配置都定义在MREST_FRAMEWORK变量中。另外，关于认证方式DRF默认会检测配置在DEFAULT_AUTHENTICATION_CLASSES变量中的所有认证方式，只要有一个认证方式通过即可登录成功。这里的DEFAULT_AUTHENTICATION_CLASSES与Django中的MIDDLEWARE类似，在将request通过url映射到views之前，Django和DRF都会调用定义在MREST_FRAMEWORK变量中的类的一些方法。<br>另外，你还可以使用基于APIView类的视图，在每个视图或每个视图集的基础上设置身份验证方案。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from rest_framework.authentication import SessionAuthentication, BasicAuthentication</span><br><span class="line">from rest_framework.permissions import IsAuthenticated</span><br><span class="line">from rest_framework.response import Response</span><br><span class="line">from rest_framework.views import APIView</span><br><span class="line"> </span><br><span class="line">class ExampleView(APIView):</span><br><span class="line">    authentication_classes &#x3D; (SessionAuthentication, BasicAuthentication)</span><br><span class="line">    permission_classes &#x3D; (IsAuthenticated,)</span><br><span class="line"> </span><br><span class="line">    def get(self, request, format&#x3D;None):</span><br><span class="line">        content &#x3D; &#123;</span><br><span class="line">            &#39;user&#39;: unicode(request.user),  # &#96;django.contrib.auth.User&#96; instance.</span><br><span class="line">            &#39;auth&#39;: unicode(request.auth),  # None</span><br><span class="line">        &#125;</span><br><span class="line">        return Response(content)</span><br></pre></td></tr></table></figure>
<p>需要明白的一点是，DRF的认证是在定义有权限类（permission_classes）的视图下才有作用，且权限类（permission_classes）必须要求认证用户才能访问此视图。如果没有定义权限类（permission_classes），那么也就意味着允许匿名用户的访问，自然牵涉不到认证相关的限制了。所以，一般在项目中的使用方式是在全局配置DEFAULT_AUTHENTICATION_CLASSES认证，然后会定义多个base views，根据不同的访问需求来继承不同的base views即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from rest_framework.permissions import (</span><br><span class="line">    IsAuthenticated,</span><br><span class="line">    IsAdminUser,</span><br><span class="line">    IsAuthenticatedOrReadOnly</span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line">class BaseView(APIView):</span><br><span class="line">    &#39;&#39;&#39;普通用户&#39;&#39;&#39;</span><br><span class="line">    permission_classes &#x3D; (</span><br><span class="line">        IsOwnerOrReadOnly,</span><br><span class="line">        IsAuthenticated</span><br><span class="line">    )</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">class SuperUserpermissions(APIView):</span><br><span class="line">    &#39;&#39;&#39;超级用户&#39;&#39;&#39;</span><br><span class="line">    permission_classes &#x3D; (IsAdminUser,)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">class NotLogin(APIView):</span><br><span class="line">    &#39;&#39;&#39;匿名用户&#39;&#39;&#39;</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>
<p>另外，在前后端分离项目中一般不会使用 BasicAuthentication 与 SessionAuthentication 的认证方式。所以，我们只需要关心 TokenAuthentication 认证方式即可。</p>
<h3 id="三-TokenAuthentication"><a href="#三-TokenAuthentication" class="headerlink" title="三.TokenAuthentication"></a>三.TokenAuthentication</h3><p>要使用<code>TokenAuthentication</code>方案，你需要将认证类配置为包含<code>TokenAuthentication</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK &#x3D; &#123;</span><br><span class="line">    &#39;DEFAULT_AUTHENTICATION_CLASSES&#39;: (</span><br><span class="line">        &#39;rest_framework.authentication.BasicAuthentication&#39;,</span><br><span class="line">        &#39;rest_framework.authentication.SessionAuthentication&#39;,</span><br><span class="line">        &#39;rest_framework.authentication.TokenAuthentication&#39;,</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并在INSTALLED_APPS设置中另外包含 rest_framework.authtoken：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS &#x3D; (</span><br><span class="line">    ...</span><br><span class="line">    &#39;rest_framework.authtoken&#39;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意： rest_framework.authtoken应用一定要放到INSTALLED_APPS，并且确保在更改设置后运行<code>python manage.py migrate</code>。 rest_framework.authtoken应用需要创建一张表用来存储用户与Token的对应关系。<br>数据库迁移完成后，可以看到多了一个authtoken_token表，表结构如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show create table authtoken_token\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">       Table: authtoken_token</span><br><span class="line">Create Table: CREATE TABLE &#96;authtoken_token&#96; (</span><br><span class="line">  &#96;key&#96; varchar(40) NOT NULL,</span><br><span class="line">  &#96;created&#96; datetime(6) NOT NULL,</span><br><span class="line">  &#96;user_id&#96; int(11) NOT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;key&#96;),</span><br><span class="line">  UNIQUE KEY &#96;user_id&#96; (&#96;user_id&#96;),</span><br><span class="line">  CONSTRAINT &#96;authtoken_token_user_id_35299eff_fk_auth_user_id&#96; FOREIGN KEY (&#96;user_id&#96;) REFERENCES &#96;auth_user&#96; (&#96;id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure>
<p>其中“user_id”字段关联到了用户表。</p>
<ul>
<li>配置URLconf<br>使用<code>TokenAuthentication</code>时，你可能希望为客户提供一种机制，以获取给定用户名和密码的令牌。 REST framework 提供了一个内置的视图来支持这种行为。要使用它，请将<code>obtain_auth_token</code>视图添加到您的 URLconf 中：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from rest_framework.authtoken import views</span><br><span class="line">urlpatterns +&#x3D; [</span><br><span class="line">    url(r&#39;^api-token-auth&#x2F;&#39;, views.obtain_auth_token)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
其中，<code>r&#39;^api-token-auth/&#39;</code>部分实际上可以用任何你想使用URL替代。</li>
<li>创建Token<br>你还需要为用户创建令牌，用户令牌与用户是一一对应的。如果你已经创建了一些用户，则可以为所有现有用户生成令牌，例如<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.contrib.auth.models import User</span><br><span class="line">from rest_framework.authtoken.models import Token</span><br><span class="line"> </span><br><span class="line">for user in User.objects.all():</span><br><span class="line">    Token.objects.get_or_create(user&#x3D;user)</span><br></pre></td></tr></table></figure>
你也可以为某个已经存在的用户创建Token：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for user in User.objects.filter(username&#x3D;&#39;admin&#39;):</span><br><span class="line">    Token.objects.get_or_create(user&#x3D;user)</span><br></pre></td></tr></table></figure>
创建成功后，会在Token表中生成对应的Token信息。</li>
</ul>
<p>如果你希望每个用户都拥有一个自动生成的令牌，则只需捕捉用户的<code>post_save</code>信号即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.conf import settings</span><br><span class="line">from django.db.models.signals import post_save</span><br><span class="line">from django.dispatch import receiver</span><br><span class="line">from rest_framework.authtoken.models import Token</span><br><span class="line"></span><br><span class="line">@receiver(post_save, sender&#x3D;settings.AUTH_USER_MODEL)</span><br><span class="line">def create_auth_token(sender, instance&#x3D;None, created&#x3D;False, **kwargs):</span><br><span class="line">    if created:</span><br><span class="line">        Token.objects.create(user&#x3D;instance)</span><br></pre></td></tr></table></figure>
<p>请注意，你需要确保将此代码片段放置在已安装的models.py模块或 Django 启动时将导入的其他某个位置。</p>
<ul>
<li>获取Token<br>上面虽然介绍了多种创建Token的方式，其实我们最简单的就是只需要配置一下urls.py，然后就可以通过暴露的API来获取Token了。当使用表单数据或 JSON 将有效的username和password字段发布到视图时，obtain_auth_token视图将返回 JSON 响应：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl -d &quot;username&#x3D;admin&amp;password&#x3D;admin123456&quot; http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;api-token-auth&#x2F;</span><br><span class="line">&#123;&quot;token&quot;:&quot;684b41712e8e38549504776613bd5612ba997616&quot;&#125;</span><br></pre></td></tr></table></figure>
请注意，缺省的<code>obtain_auth_token</code>视图显式使用 JSON 请求和响应，而不是使用你设置的默认的渲染器和解析器类。</li>
</ul>
<p>当我们正常获取到Token后，<code>obtain_auth_token</code>视图会自动帮我们在Token表中创建对应的Token。源码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ObtainAuthToken(APIView):</span><br><span class="line">    throttle_classes &#x3D; ()</span><br><span class="line">    permission_classes &#x3D; ()</span><br><span class="line">    parser_classes &#x3D; (parsers.FormParser, parsers.MultiPartParser, parsers.JSONParser,)</span><br><span class="line">    renderer_classes &#x3D; (renderers.JSONRenderer,)</span><br><span class="line">    serializer_class &#x3D; AuthTokenSerializer</span><br><span class="line">    if coreapi is not None and coreschema is not None:</span><br><span class="line">        schema &#x3D; ManualSchema(</span><br><span class="line">            fields&#x3D;[</span><br><span class="line">                coreapi.Field(</span><br><span class="line">                    name&#x3D;&quot;username&quot;,</span><br><span class="line">                    required&#x3D;True,</span><br><span class="line">                    location&#x3D;&#39;form&#39;,</span><br><span class="line">                    schema&#x3D;coreschema.String(</span><br><span class="line">                        title&#x3D;&quot;Username&quot;,</span><br><span class="line">                        description&#x3D;&quot;Valid username for authentication&quot;,</span><br><span class="line">                    ),</span><br><span class="line">                ),</span><br><span class="line">                coreapi.Field(</span><br><span class="line">                    name&#x3D;&quot;password&quot;,</span><br><span class="line">                    required&#x3D;True,</span><br><span class="line">                    location&#x3D;&#39;form&#39;,</span><br><span class="line">                    schema&#x3D;coreschema.String(</span><br><span class="line">                        title&#x3D;&quot;Password&quot;,</span><br><span class="line">                        description&#x3D;&quot;Valid password for authentication&quot;,</span><br><span class="line">                    ),</span><br><span class="line">                ),</span><br><span class="line">            ],</span><br><span class="line">            encoding&#x3D;&quot;application&#x2F;json&quot;,</span><br><span class="line">        )</span><br><span class="line"> </span><br><span class="line">    def post(self, request, *args, **kwargs):</span><br><span class="line">        serializer &#x3D; self.serializer_class(data&#x3D;request.data,</span><br><span class="line">                                           context&#x3D;&#123;&#39;request&#39;: request&#125;)</span><br><span class="line">        serializer.is_valid(raise_exception&#x3D;True)</span><br><span class="line">        user &#x3D; serializer.validated_data[&#39;user&#39;]</span><br><span class="line">        token, created &#x3D; Token.objects.get_or_create(user&#x3D;user)</span><br><span class="line">        return Response(&#123;&#39;token&#39;: token.key&#125;)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">obtain_auth_token &#x3D; ObtainAuthToken.as_view()</span><br></pre></td></tr></table></figure>
<p>默认情况下，没有权限或限制应用于<code>obtain_auth_token</code>视图。 如果您希望应用<code>throttling</code>，则需要重写视图类，并使用<code>throttle_classes</code>属性包含它们。</p>
<p>如果你需要自定义<code>obtain_auth_token</code>视图，你可以通过继承<code>ObtainAuthToken</code>视图类来实现，并在你的urls.py中使用它。例如，你可能会返回超出token值的其他用户信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from rest_framework.authtoken.views import ObtainAuthToken</span><br><span class="line">from rest_framework.authtoken.models import Token</span><br><span class="line">from rest_framework.response import Response</span><br><span class="line"> </span><br><span class="line">class CustomAuthToken(ObtainAuthToken):</span><br><span class="line"> </span><br><span class="line">    def post(self, request, *args, **kwargs):</span><br><span class="line">        serializer &#x3D; self.serializer_class(data&#x3D;request.data,</span><br><span class="line">                                           context&#x3D;&#123;&#39;request&#39;: request&#125;)</span><br><span class="line">        serializer.is_valid(raise_exception&#x3D;True)</span><br><span class="line">        user &#x3D; serializer.validated_data[&#39;user&#39;]</span><br><span class="line">        token, created &#x3D; Token.objects.get_or_create(user&#x3D;user)</span><br><span class="line">        return Response(&#123;</span><br><span class="line">            &#39;token&#39;: token.key,</span><br><span class="line">            &#39;user_id&#39;: user.pk,</span><br><span class="line">            &#39;email&#39;: user.email</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>
<p>还有urls.py:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">urlpatterns +&#x3D; [</span><br><span class="line">    url(r&#39;^api-token-auth&#x2F;&#39;, CustomAuthToken.as_view())</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<ul>
<li>认证Token<br>当我们获取到Token后，就可以拿着这个Token来认证其他API了。对于客户端进行身份验证，令牌密钥应包含在 <code>Authorization</code> HTTP header 中。关键字应以字符串文字 “Token” 为前缀，用空格分隔两个字符串。例如：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Authorization: Token 9944b09199c62bcf9418ad846dd0e4bbdfc6ee4b</span><br></pre></td></tr></table></figure>
注意： 如果你想在 header 中使用不同的关键字（例如Bearer），只需子类化<code>TokenAuthentication</code>并设置keyword类变量。<br>如果成功通过身份验证，<code>TokenAuthentication</code>将提供以下凭据。</li>
</ul>
<p>request.user是一个User实例，包含了用户名及相关信息。<br>request.auth是一个rest_framework.authtoken.models.Token实例。<br>未经身份验证的响应被拒绝将导致HTTP 401 Unauthorized的响应和相应的 WWW-Authenticate header。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WWW-Authenticate: Token</span><br></pre></td></tr></table></figure>
<p>测试令牌认证的API，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl -X GET -H &#39;Authorization: Token 684b41712e8e38549504776613bd5612ba997616&#39; http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;virtual&#x2F;</span><br></pre></td></tr></table></figure>
<p>注意： 如果您在生产中使用<code>TokenAuthentication</code>，则必须确保您的 API 只能通过https访问。</p>
<h3 id="四-认证源码"><a href="#四-认证源码" class="headerlink" title="四. 认证源码"></a>四. 认证源码</h3><p>使用 TokenAuthentication 认证方式，当认证成功后，在 request 中将提供了 request.user 和 request.auth 实例。其中 request.user 实例中有用户信息，比如用户名及用户ID，而 request.auth 实例中有Token信息。那么DRF是如何把 Token 转换为用户信息呢？通过下面的源码部分就可以看到它们是如何转换的。</p>
<p>基于 DRF 的请求处理，与常规的 url 配置不同，通常一个 Django 的 url 请求对应一个视图函数，在使用 DRF 时，我们要基于视图对象，然后调用视图对象的 as_view 函数，as_view 函数中会调用 rest_framework/views.py 中的 dispatch 函数，这个函数会根据 request 请求方法，去调用我们在 view 对象中定义的对应的方法，就像这样:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from rest_framework.authtoken import views</span><br><span class="line">urlpatterns +&#x3D; [</span><br><span class="line">    url(r&#39;^api-token-auth&#x2F;&#39;, views.obtain_auth_token)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>这里虽然直接调用 views.obtain_auth_token 方法，但进入到 views.obtain_auth_token 方法后还是 DRF 模式，源码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">obtain_auth_token &#x3D; ObtainAuthToken.as_view()</span><br></pre></td></tr></table></figure>
<p>ObtainAuthToken 方法是继承 DRF 中的 APIView 的 View 类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ObtainAuthToken(APIView):</span><br><span class="line">    throttle_classes &#x3D; ()</span><br><span class="line">    permission_classes &#x3D; ()</span><br><span class="line">    parser_classes &#x3D; (parsers.FormParser, parsers.MultiPartParser, parsers.JSONParser,)</span><br><span class="line">    renderer_classes &#x3D; (renderers.JSONRenderer,)</span><br><span class="line">    serializer_class &#x3D; AuthTokenSerializer</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure>
<p>如果你是用 POST 方法请求 ObtainAuthToken，那么 as_view() 函数会调用 dispatch 函数，dispatch 根据 request.METHOD，这里是 POST，去调用 ObtainAuthToken 类的 POST 方法，这就跟通常的 url-&gt;view 的流程一样了。</p>
<p>这里需要注意的一点就是，DRF 中的 APIVIEW 是继承 Django View 的，重写了部分 as_view 方法，而调用 dispatch 函数是在 Django View 的 as_view 方法中做的事情，源码部分如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class APIView(View):</span><br><span class="line">    ....</span><br><span class="line">    @classmethod</span><br><span class="line">    def as_view(cls, **initkwargs):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Store the original class on the view function.</span><br><span class="line"> </span><br><span class="line">        This allows us to discover information about the view when we do URL</span><br><span class="line">        reverse lookups.  Used for breadcrumb generation.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if isinstance(getattr(cls, &#39;queryset&#39;, None), models.query.QuerySet):</span><br><span class="line">            def force_evaluation():</span><br><span class="line">                raise RuntimeError(</span><br><span class="line">                    &#39;Do not evaluate the &#96;.queryset&#96; attribute directly, &#39;</span><br><span class="line">                    &#39;as the result will be cached and reused between requests. &#39;</span><br><span class="line">                    &#39;Use &#96;.all()&#96; or call &#96;.get_queryset()&#96; instead.&#39;</span><br><span class="line">                )</span><br><span class="line">            cls.queryset._fetch_all &#x3D; force_evaluation</span><br><span class="line"> </span><br><span class="line">        view &#x3D; super(APIView, cls).as_view(**initkwargs)</span><br><span class="line">        view.cls &#x3D; cls</span><br><span class="line">        view.initkwargs &#x3D; initkwargs</span><br></pre></td></tr></table></figure>
<p>但是用户认证是在执行请求 View 之前做的，所以其实就是在 dispatch 函数之中做的，具体见源码 rest-framework/views.py 中 APIView 类中的 dispatch 函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class APIView(View):</span><br><span class="line">    &#x2F;&#x2F; 从settings文件中获取认证类、限流类、权限类</span><br><span class="line">    authentication_classes &#x3D; api_settings.DEFAULT_AUTHENTICATION_CLASSES</span><br><span class="line">    throttle_classes &#x3D; api_settings.DEFAULT_THROTTLE_CLASSES</span><br><span class="line">    permission_classes &#x3D; api_settings.DEFAULT_PERMISSION_CLASSES</span><br><span class="line">    ....</span><br><span class="line">    </span><br><span class="line">    def dispatch(self, request, *args, **kwargs):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        &#96;.dispatch()&#96; is pretty much the same as Django&#39;s regular dispatch,</span><br><span class="line">        but with extra hooks for startup, finalize, and exception handling.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.args &#x3D; args</span><br><span class="line">        self.kwargs &#x3D; kwargs</span><br><span class="line">       </span><br><span class="line">        &#x2F;&#x2F; 封装request，对原始request对象增加一些功能，比如认证类，都是在initialize_request方法中完成</span><br><span class="line">        request &#x3D; self.initialize_request(request, *args, **kwargs)</span><br><span class="line">        self.request &#x3D; request</span><br><span class="line">        self.headers &#x3D; self.default_response_headers  # deprecate?</span><br><span class="line"> </span><br><span class="line">        try:</span><br><span class="line">            &#x2F;&#x2F; 调用self.initial进行用户认证</span><br><span class="line">            self.initial(request, *args, **kwargs)</span><br><span class="line"> </span><br><span class="line">            # Get the appropriate handler method</span><br><span class="line">            if request.method.lower() in self.http_method_names:</span><br><span class="line">                handler &#x3D; getattr(self, request.method.lower(),</span><br><span class="line">                                  self.http_method_not_allowed)</span><br><span class="line">            else:</span><br><span class="line">                handler &#x3D; self.http_method_not_allowed</span><br><span class="line"> </span><br><span class="line">            response &#x3D; handler(request, *args, **kwargs)</span><br><span class="line"> </span><br><span class="line">        except Exception as exc:</span><br><span class="line">            response &#x3D; self.handle_exception(exc)</span><br><span class="line"> </span><br><span class="line">        self.response &#x3D; self.finalize_response(request, response, *args, **kwargs)</span><br><span class="line">        return self.response</span><br></pre></td></tr></table></figure>
<p>这里的 self.initialize_request 也可以关注一下，因为这里的 request 对象，后面也会有调用的地方。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class APIView(View):</span><br><span class="line">    ....</span><br><span class="line">    def initialize_request(self, request, *args, **kwargs):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Returns the initial request object.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        parser_context &#x3D; self.get_parser_context(request)</span><br><span class="line"> </span><br><span class="line">        return Request(</span><br><span class="line">            request,</span><br><span class="line">            parsers&#x3D;self.get_parsers(),</span><br><span class="line">            authenticators&#x3D;self.get_authenticators(),   &#x2F;&#x2F; 这里把认证类封装进行了request里面</span><br><span class="line">            negotiator&#x3D;self.get_content_negotiator(),</span><br><span class="line">            parser_context&#x3D;parser_context</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>
<p>其中 self.get_authenticators() 方法就是用来取 self.authentication_classes 变量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class APIView(View):</span><br><span class="line">    ....</span><br><span class="line">    def get_authenticators(self):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Instantiates and returns the list of authenticators that this view can use.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return [auth() for auth in self.authentication_classes]</span><br></pre></td></tr></table></figure>
<p>关于 authentication_classes 变量，上面已经给出了，就在 APIView 里面 authentication_classes 字段。</p>
<p>然后就到了认证，重点在于 self.initial(request, *args, **kwargs) 函数，对于这个函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class APIView(View):</span><br><span class="line">    ....</span><br><span class="line">    def initial(self, request, *args, **kwargs):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Runs anything that needs to occur prior to calling the method handler.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.format_kwarg &#x3D; self.get_format_suffix(**kwargs)</span><br><span class="line"> </span><br><span class="line">        # Perform content negotiation and store the accepted info on the request</span><br><span class="line">        neg &#x3D; self.perform_content_negotiation(request)</span><br><span class="line">        request.accepted_renderer, request.accepted_media_type &#x3D; neg</span><br><span class="line"> </span><br><span class="line">        # Determine the API version, if versioning is in use.</span><br><span class="line">        version, scheme &#x3D; self.determine_version(request, *args, **kwargs)</span><br><span class="line">        request.version, request.versioning_scheme &#x3D; version, scheme</span><br><span class="line"> </span><br><span class="line">        # Ensure that the incoming request is permitted</span><br><span class="line">        self.perform_authentication(request)   &#x2F;&#x2F; 用户认证</span><br><span class="line">        self.check_permissions(request)        &#x2F;&#x2F; 权限检查</span><br><span class="line">        self.check_throttles(request)          &#x2F;&#x2F; 限流检查</span><br></pre></td></tr></table></figure>
<p>这里关注 self.perform_authentication(request) 验证某个用户，其实可以看到权限检查及限流也是在这里做的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class APIView(View):</span><br><span class="line">    ....</span><br><span class="line">    def perform_authentication(self, request):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Perform authentication on the incoming request.</span><br><span class="line"> </span><br><span class="line">        Note that if you override this and simply &#39;pass&#39;, then authentication</span><br><span class="line">        will instead be performed lazily, the first time either</span><br><span class="line">        &#96;request.user&#96; or &#96;request.auth&#96; is accessed.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        request.user</span><br></pre></td></tr></table></figure>
<p>这里 request.user 其实是一个 @property 的函数，加 @property 表示调用 user 方法的时候不需要加括号“user()”，可以直接调用 request.user 。而这里的 request 对象就是上面 initialize_request 方法返回的，其中还返回了 DRF 定义的 request 对象，在 request 对象中有被 @property 装饰的 user 方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Request(object):</span><br><span class="line">    ....</span><br><span class="line">    @property</span><br><span class="line">    def user(self):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Returns the user associated with the current request, as authenticated</span><br><span class="line">        by the authentication classes provided to the request.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if not hasattr(self, &#39;_user&#39;):</span><br><span class="line">            with wrap_attributeerrors():</span><br><span class="line">                self._authenticate()</span><br><span class="line">        return self._user</span><br></pre></td></tr></table></figure>
<p>重点来了，到了真正认证的方法了，关注 <code>self._authenticate()</code>函数即可。此方法会循环尝试每个 DRF 认证方式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Request(object):</span><br><span class="line">    ....</span><br><span class="line">    def _authenticate(self):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        尝试使用每个身份验证实例验证请求</span><br><span class="line">        self.authenticators &#x3D; [BasicAuthentication, SessionAuthentication, TokenAuthentication]</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        for authenticator in self.authenticators:</span><br><span class="line">            try:</span><br><span class="line">                user_auth_tuple &#x3D; authenticator.authenticate(self)</span><br><span class="line">            except exceptions.APIException:</span><br><span class="line">                &#x2F;&#x2F; 如果authenticate方法抛出异常，则执行self._not_authenticated方法，相当于匿名用户，没有通过认证</span><br><span class="line">                self._not_authenticated()</span><br><span class="line">                raise</span><br><span class="line"> </span><br><span class="line">            if user_auth_tuple is not None:</span><br><span class="line">                self._authenticator &#x3D; authenticator</span><br><span class="line">                self.user, self.auth &#x3D; user_auth_tuple</span><br><span class="line">                return</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; 如果没有设置认证类的话，也相当于匿名用户，没有通过认证</span><br><span class="line">        self._not_authenticated()</span><br></pre></td></tr></table></figure>
<p>那么 self.authenticators 从哪儿来的呢？就是上面展示的，在 APIVIEW 类中的 authentication_classes = api_settings.DEFAULT_AUTHENTICATION_CLASSES 得到的。我们上面在介绍 DRF 身份验证时也说了，可以把认证类定义在全局 settings 文件中，你还可以使用基于 APIView 类的视图，在每个视图或每个视图集的基础上设置身份验证方案。如下方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ExampleView(APIView):</span><br><span class="line">    authentication_classes &#x3D; (SessionAuthentication, BasicAuthentication)</span><br><span class="line">    permission_classes &#x3D; (IsAuthenticated,)</span><br></pre></td></tr></table></figure>
<p>当基于 APIView 类的视图定义验证或权限类时，相当于覆盖了原生 APIVIEW 中的相关变量，自然就使用覆盖后的变量了。authentication_classes 里面放的就是可以用来验证一个用户的类，他是一个元组，验证用户时，按照这个元组顺序，直到验证通过或者遍历整个元组还没有通过。同理 self.check_permissions(request) 是验证该用户是否具有API的使用权限。关于对view控制的其他类都在rest-framework/views.py的APIView类中定义了。</p>
<p>由于我们这里只是拿 TokenAuthentication 认证说明，所以忽略 BasicAuthentication 和 SessionAuthentication 这两种认证，其原理与TokenAuthentication 一样。这样，就进入到了 TokenAuthentication 认证，其源码部分如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取header部分 Authorization 标识的信息</span><br><span class="line">def get_authorization_header(request):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Return request&#39;s &#39;Authorization:&#39; header, as a bytestring.</span><br><span class="line"> </span><br><span class="line">    Hide some test client ickyness where the header can be unicode.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    auth &#x3D; request.META.get(&#39;HTTP_AUTHORIZATION&#39;, b&#39;&#39;)</span><br><span class="line">    if isinstance(auth, text_type):</span><br><span class="line">        # Work around django test client oddness</span><br><span class="line">        auth &#x3D; auth.encode(HTTP_HEADER_ENCODING)</span><br><span class="line">    return auth</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 解析并认证 Token</span><br><span class="line">class TokenAuthentication(BaseAuthentication):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Simple token based authentication.</span><br><span class="line"> </span><br><span class="line">    Clients should authenticate by passing the token key in the &quot;Authorization&quot;</span><br><span class="line">    HTTP header, prepended with the string &quot;Token &quot;.  For example:</span><br><span class="line"> </span><br><span class="line">        Authorization: Token 401f7ac837da42b97f613d789819ff93537bee6a</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"> </span><br><span class="line">    keyword &#x3D; &#39;Token&#39;</span><br><span class="line">    model &#x3D; None</span><br><span class="line"> </span><br><span class="line">    def get_model(self):</span><br><span class="line">        if self.model is not None:</span><br><span class="line">            return self.model</span><br><span class="line">        from rest_framework.authtoken.models import Token</span><br><span class="line">        return Token</span><br><span class="line"> </span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    A custom token model may be used, but must have the following properties.</span><br><span class="line"> </span><br><span class="line">    * key -- The string identifying the token</span><br><span class="line">    * user -- The user to which the token belongs</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"> </span><br><span class="line">    def authenticate(self, request):</span><br><span class="line">        &#x2F;&#x2F; 通过上面的get_authorization_header方法得到Token信息</span><br><span class="line">        &#x2F;&#x2F; auth &#x3D; [b&#39;Token&#39;, b&#39;684b41712e8e38549504776613bd5612ba997616&#39;]</span><br><span class="line">        auth &#x3D; get_authorization_header(request).split()</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 通过获取Token关键字，并与keyword变量比对，来判断是否是Token方式认证</span><br><span class="line">        if not auth or auth[0].lower() !&#x3D; self.keyword.lower().encode():</span><br><span class="line">            return None</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; auth长度等于2时才是合法值，继续往下进行</span><br><span class="line">        if len(auth) &#x3D;&#x3D; 1:</span><br><span class="line">            msg &#x3D; _(&#39;Invalid token header. No credentials provided.&#39;)</span><br><span class="line">            raise exceptions.AuthenticationFailed(msg)</span><br><span class="line">        elif len(auth) &gt; 2:</span><br><span class="line">            msg &#x3D; _(&#39;Invalid token header. Token string should not contain spaces.&#39;)</span><br><span class="line">            raise exceptions.AuthenticationFailed(msg)</span><br><span class="line">     </span><br><span class="line">        &#x2F;&#x2F; 进行token解码，从bytes编码格式转为字符串</span><br><span class="line">        try:</span><br><span class="line">            token &#x3D; auth[1].decode()</span><br><span class="line">        except UnicodeError:</span><br><span class="line">            msg &#x3D; _(&#39;Invalid token header. Token string should not contain invalid characters.&#39;)</span><br><span class="line">            raise exceptions.AuthenticationFailed(msg)</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; 把转换过的token传给认证凭证方法进行验证</span><br><span class="line">        return self.authenticate_credentials(token)</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 验证凭证方法进行接收token并进行验证</span><br><span class="line">    def authenticate_credentials(self, key):</span><br><span class="line">        &#x2F;&#x2F; 获取Token模型实例</span><br><span class="line">        model &#x3D; self.get_model()</span><br><span class="line">        try:</span><br><span class="line">            &#x2F;&#x2F; 使用select_related方法获取相应外键对应的对象（就是两表Join），然后进行Token过滤查询</span><br><span class="line">            token &#x3D; model.objects.select_related(&#39;user&#39;).get(key&#x3D;key)</span><br><span class="line">        except model.DoesNotExist:</span><br><span class="line">            raise exceptions.AuthenticationFailed(_(&#39;Invalid token.&#39;))</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; 判断用户是否是登录成功</span><br><span class="line">        if not token.user.is_active:</span><br><span class="line">            raise exceptions.AuthenticationFailed(_(&#39;User inactive or deleted.&#39;))</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; 返回user实例，及token实例</span><br><span class="line">        return (token.user, token)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>PS：DRF自带的TokenAuthentication认证方式也非常简单，同时弊端也很大，真正项目中用的较少。由于需要存储在数据库表中，它在分布式系统中用起来较为麻烦，并且每次都需要查询数据库，增加数据库压力；同时它不支持Token的过期设置，这是一个很大的问题。在实际前后端分离项目中使用JWT（Json Web Token）标准的认证方式较多，每个语言都有各自实现JWT的方式，Python也不例外。</p>
</blockquote>
<h3 id="五-JWT认证"><a href="#五-JWT认证" class="headerlink" title="五. JWT认证"></a>五. JWT认证</h3><p>了解完DRF自带的TokenAuthentication认证方式的弊端之后，再来看JWT（Json Web Token）认证方式。它们两个的原理是一样的，就是认证用户Token，然后取出对应的用户。但JWT解决了两个较大的问题。</p>
<p>第一，是不需要把Token存储到数据库表中了，而是根据一定的算法来算出用户Token，然后每次用户来验证时再以同样的方式生成对应的Token进行校验。当然，实际JWT生成Token的方式还是较为复杂的，具体可以看JWT协议相关文章。</p>
<p>第二，JWT对于生成的Token可以设置过期时间，从而在一定程度提高了Token的安全性。</p>
<p>JWT的原理还是稍稍有点麻烦的，里面涉及了一些对称加密和非对称加密的算法。但是JWT使用起来确是非常简单，Python中有PyJWT库，而在DRF中也有对应的开源项目<a href="https://github.com/GetBlimp/django-rest-framework-jwt" target="_blank" rel="noopener">django-rest-framework-jwt</a></p>
<ul>
<li>安装<br>直接使用pip安装即可，目前支持Python、Django、DRF主流版本：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pip install djangorestframework-jwt</span><br></pre></td></tr></table></figure></li>
<li>使用<br>在settings.py文件中，将JSONWebTokenAuthentication 添加到REST framework框架的DEFAULT_AUTHENTICATION_CLASSES<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK &#x3D; &#123;</span><br><span class="line">    &#39;DEFAULT_PERMISSION_CLASSES&#39;: (</span><br><span class="line">        &#39;rest_framework.permissions.IsAuthenticated&#39;,</span><br><span class="line">    ),</span><br><span class="line">    &#39;DEFAULT_AUTHENTICATION_CLASSES&#39;: (</span><br><span class="line">        &#39;rest_framework_jwt.authentication.JSONWebTokenAuthentication&#39;,</span><br><span class="line">        &#39;rest_framework.authentication.SessionAuthentication&#39;,</span><br><span class="line">        &#39;rest_framework.authentication.BasicAuthentication&#39;,</span><br><span class="line">    ),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
同样，你还可以使用基于APIView类的视图，在每个视图或每个视图集的基础上设置身份验证方案。与上面演示的 Token 认证一样，这里就不贴代码了，尽可能使用基于APIView类的视图认证方式。<br>但使用基于APIView类的视图认证方式时，不要忘记导入类。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from rest_framework_jwt.authentication import JSONWebTokenAuthentication</span><br></pre></td></tr></table></figure>
在你的urls.py文件中添加以下URL路由，以便通过POST包含用户名和密码的令牌获取。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from rest_framework_jwt.views import obtain_jwt_token</span><br><span class="line">urlpatterns +&#x3D; [</span><br><span class="line">    url(r&#39;^api-token-auth&#x2F;&#39;, obtain_jwt_token)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
如果你使用用户名admin和密码admin123456创建了用户，则可以通过在终端中执行以下操作来测试JWT是否正常工作。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl -X POST -d &quot;username&#x3D;admin&amp;password&#x3D;admin123456&quot; http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;api-token-auth&#x2F;</span><br></pre></td></tr></table></figure>
或者，你可以使用Django REST framework支持的所有内容类型来获取身份验证令牌。例如：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl -X POST -H &quot;Content-Type: application&#x2F;json&quot; -d &#39;&#123;&quot;username&quot;:&quot;admin&quot;,&quot;password&quot;:&quot;admin123456&quot;&#125;&#39; http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;api-token-auth&#x2F;</span><br></pre></td></tr></table></figure>
现在访问需要认证的API时，就必须要包含<code>Authorization: JWT &lt;your_token&gt;</code>头信息了：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl -H &quot;Authorization: JWT &lt;your_token&gt;&quot; http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;virtual&#x2F;</span><br></pre></td></tr></table></figure></li>
<li>刷新Token<br>如果JWT_ALLOW_REFRESH为True，可以“刷新”未过期的令牌以获得具有更新到期时间的全新令牌。像如下这样添加一个URL模式：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from rest_framework_jwt.views import refresh_jwt_token</span><br><span class="line">urlpatterns +&#x3D; [</span><br><span class="line">    url(r&#39;^api-token-refresh&#x2F;&#39;, refresh_jwt_token)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
使用方式就是将现有令牌传递到刷新API，如下所示: <code>{&quot;token&quot;: EXISTING_TOKEN}</code>。请注意，只有非过期的令牌才有效。另外，响应JSON看起来与正常获取令牌端点<code>{&quot;token&quot;: NEW_TOKEN}</code>相同。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl -X POST -H &quot;Content-Type: application&#x2F;json&quot; -d &#39;&#123;&quot;token&quot;:&quot;&lt;EXISTING_TOKEN&gt;&quot;&#125;&#39; http:&#x2F;&#x2F;localhost:8000&#x2F;api-token-refresh&#x2F;</span><br></pre></td></tr></table></figure>
可以重复使用令牌刷新（token1 -&gt; token2 -&gt; token3），但此令牌链存储原始令牌（使用用户名/密码凭据获取）的时间。作为orig_iat，你只能将刷新令牌保留至JWT_REFRESH_EXPIRATION_DELTA。<br>刷新token以获得新的token的作用在于，持续保持活跃用户登录状态。比如通过用户密码获得的token有效时间为1小时，那么也就意味着1小时后此token失效，用户必须得重新登录，这对于活跃用户来说其实是多余的。如果这个用户在这1小时内都在浏览网站，我们不应该让用户重新登录，就是在token没有失效之前调用刷新接口为用户获得新的token。</li>
<li>认证Token<br>在一些微服务架构中，身份验证由单个服务处理。此服务负责其他服务委派确认用户已登录此身份验证服务的责任。这通常意味着其他服务将从用户接收JWT传递给身份验证服务，并在将受保护资源返回给用户之前等待JWT有效的确认。添加以下URL模式：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from rest_framework_jwt.views import verify_jwt_token</span><br><span class="line">urlpatterns +&#x3D; [</span><br><span class="line">    url(r&#39;^api-token-verify&#x2F;&#39;, verify_jwt_token)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
将Token传递给验证API，如果令牌有效，则返回令牌，返回状态码为200。否则，它将返回400 Bad Request以及识别令牌无效的错误。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl -X POST -H &quot;Content-Type: application&#x2F;json&quot; -d &#39;&#123;&quot;token&quot;:&quot;&lt;EXISTING_TOKEN&gt;&quot;&#125;&#39; http:&#x2F;&#x2F;localhost:8000&#x2F;api-token-verify&#x2F;</span><br></pre></td></tr></table></figure></li>
<li>手动创建Token<br>有时候你可能希望手动生成令牌，例如在创建帐户后立即将令牌返回给用户。或者，你需要返回的信息不止是Token，可能还有用户权限相关值。你可以这样做：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from rest_framework_jwt.settings import api_settings</span><br><span class="line"> </span><br><span class="line">jwt_payload_handler &#x3D; api_settings.JWT_PAYLOAD_HANDLER</span><br><span class="line">jwt_encode_handler &#x3D; api_settings.JWT_ENCODE_HANDLER</span><br><span class="line"> </span><br><span class="line">payload &#x3D; jwt_payload_handler(user)</span><br><span class="line">token &#x3D; jwt_encode_handler(payload)</span><br></pre></td></tr></table></figure></li>
<li>其他设置<br>你可以覆盖一些其他设置，比如变更Token过期时间，以下是所有可用设置的默认值。在settings.py文件中设置。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JWT_AUTH &#x3D; &#123;</span><br><span class="line">    &#39;JWT_ENCODE_HANDLER&#39;:</span><br><span class="line">    &#39;rest_framework_jwt.utils.jwt_encode_handler&#39;,</span><br><span class="line"> </span><br><span class="line">    &#39;JWT_DECODE_HANDLER&#39;:</span><br><span class="line">    &#39;rest_framework_jwt.utils.jwt_decode_handler&#39;,</span><br><span class="line"> </span><br><span class="line">    &#39;JWT_PAYLOAD_HANDLER&#39;:</span><br><span class="line">    &#39;rest_framework_jwt.utils.jwt_payload_handler&#39;,</span><br><span class="line"> </span><br><span class="line">    &#39;JWT_PAYLOAD_GET_USER_ID_HANDLER&#39;:</span><br><span class="line">    &#39;rest_framework_jwt.utils.jwt_get_user_id_from_payload_handler&#39;,</span><br><span class="line"> </span><br><span class="line">    &#39;JWT_RESPONSE_PAYLOAD_HANDLER&#39;:</span><br><span class="line">    &#39;rest_framework_jwt.utils.jwt_response_payload_handler&#39;,</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 这是用于签署JWT的密钥，确保这是安全的，不共享不公开的</span><br><span class="line">    &#39;JWT_SECRET_KEY&#39;: settings.SECRET_KEY,</span><br><span class="line">    &#39;JWT_GET_USER_SECRET_KEY&#39;: None,</span><br><span class="line">    &#39;JWT_PUBLIC_KEY&#39;: None,</span><br><span class="line">    &#39;JWT_PRIVATE_KEY&#39;: None,</span><br><span class="line">    &#39;JWT_ALGORITHM&#39;: &#39;HS256&#39;,</span><br><span class="line">    &#x2F;&#x2F; 如果秘钥是错误的，它会引发一个jwt.DecodeError</span><br><span class="line">    &#39;JWT_VERIFY&#39;: True,</span><br><span class="line">    &#39;JWT_VERIFY_EXPIRATION&#39;: True,</span><br><span class="line">    &#39;JWT_LEEWAY&#39;: 0,</span><br><span class="line">    &#x2F;&#x2F; Token过期时间设置</span><br><span class="line">    &#39;JWT_EXPIRATION_DELTA&#39;: datetime.timedelta(seconds&#x3D;300),</span><br><span class="line">    &#39;JWT_AUDIENCE&#39;: None,</span><br><span class="line">    &#39;JWT_ISSUER&#39;: None,</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 是否开启允许Token刷新服务，及限制Token刷新间隔时间，从原始Token获取开始计算</span><br><span class="line">    &#39;JWT_ALLOW_REFRESH&#39;: False,</span><br><span class="line">    &#39;JWT_REFRESH_EXPIRATION_DELTA&#39;: datetime.timedelta(days&#x3D;7),</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 定义与令牌一起发送的Authorization标头值前缀</span><br><span class="line">    &#39;JWT_AUTH_HEADER_PREFIX&#39;: &#39;JWT&#39;,</span><br><span class="line">    &#39;JWT_AUTH_COOKIE&#39;: None,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
一般除了过期时间外，其他配置参数很少改变。具体参数意义当用到时可以查询官网。</li>
</ul>
<p>JWT唯一的一个不算缺点的缺点就是Token太长了，180位。</p>
<p><a href="https://segmentfault.com/a/1190000013010835" target="_blank" rel="noopener">Token 认证的来龙去脉</a></p>
<p><a href="http://www.hi-roy.com/2017/01/11/%E5%9F%BA%E4%BA%8Ecookie%E7%9A%84django-rest-jwt%E8%AE%A4%E8%AF%81/" target="_blank" rel="noopener">基于cookie的django-rest-jwt认证</a></p>
<p><a href="https://q1mi.github.io/Django-REST-framework-documentation/api-guide/authentication_zh/" target="_blank" rel="noopener">TokenAuthentication</a></p>
<h3 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h3><p><a href="http://www.ywnds.com/?p=14967" target="_blank" rel="noopener">原文地址</a></p>
<h3 id="权限相关参考"><a href="#权限相关参考" class="headerlink" title="权限相关参考"></a>权限相关参考</h3><p><a href="https://segmentfault.com/a/1190000004401112" target="_blank" rel="noopener">Django REST framework的各种技巧【目录索引】 - 后端开发那点事儿 - SegmentFault 思否</a><br><a href="https://segmentfault.com/a/1190000004400312" target="_blank" rel="noopener">Django REST framework的各种技巧——3.权限 - 后端开发那点事儿 - SegmentFault 思否</a><br><a href="https://cloud.tencent.com/developer/article/1155184" target="_blank" rel="noopener">django权限管理(Permission)-内置权限实现</a><br><a href="https://juejin.im/post/5a991807518825558a060a77" target="_blank" rel="noopener">django viewset</a></p>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django基于Admin原理实现的CURD组件</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h1 id="Django基于Admin原理实现的CURD组件"><a href="#Django基于Admin原理实现的CURD组件" class="headerlink" title="Django基于Admin原理实现的CURD组件"></a>Django基于Admin原理实现的CURD组件</h1><hr>
</br>

<h2 id="Django管理后台admin"><a href="#Django管理后台admin" class="headerlink" title="Django管理后台admin"></a>Django管理后台admin</h2><p>常用共29个功能: <a href="http://www.cnblogs.com/wupeiqi/articles/7444717.html" target="_blank" rel="noopener">参考</a></p>
<ol>
<li>在项目的app中的admin.py文件中注册models类，示例如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cat app_name&#x2F;admin.py</span><br><span class="line"></span><br><span class="line">from django.contrib import admin</span><br><span class="line">from django.contrib.admin import ModelAdmin</span><br><span class="line">from . import models</span><br><span class="line">from django.shortcuts import HttpResponse</span><br><span class="line">from django.forms import ModelForm</span><br><span class="line">from django.forms import fields</span><br><span class="line">from django.forms import widgets</span><br><span class="line"></span><br><span class="line"># 用户表,自定义admin后台错误信息提示</span><br><span class="line">class UserModelForm(ModelForm):</span><br><span class="line">    others &#x3D; fields.CharField()</span><br><span class="line">    class Meta:</span><br><span class="line">        model &#x3D; models.UserInfo</span><br><span class="line">        fields &#x3D; &quot;__all__&quot;</span><br><span class="line">        error_messages &#x3D; &#123;</span><br><span class="line">            &#39;name&#39;:&#123;&#39;required&#39;:&#39;用户名不能问空&#39;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">class UserInfoModelAdmin(ModelAdmin):</span><br><span class="line">    # 使用自定义的form表单验证功能</span><br><span class="line">    form &#x3D; UserModelForm</span><br><span class="line"></span><br><span class="line">    # 1.定义列表页面，显示列数据</span><br><span class="line">    list_display &#x3D; [&#39;name&#39;,&#39;pwd&#39;,&#39;email&#39;]</span><br><span class="line"></span><br><span class="line">    def email(self, obj):</span><br><span class="line">        return obj.name + obj.pwd</span><br><span class="line"></span><br><span class="line">    email.empty_value_display &#x3D; &quot;默认为空时显示的值&quot;</span><br><span class="line"></span><br><span class="line">    # 2.定义列表页面，列可以进行点击进入编辑页面</span><br><span class="line">    list_display_links &#x3D; [&#39;pwd&#39;]</span><br><span class="line">    </span><br><span class="line">    # 3.定义列表页面，快速搜索</span><br><span class="line">    list_filter &#x3D; [&#39;ut&#39;]</span><br><span class="line">    </span><br><span class="line">    # 4.定义列表页面，分页功能</span><br><span class="line">    list_per_page &#x3D; 10</span><br><span class="line">    </span><br><span class="line">    # 5. 列是否可编辑</span><br><span class="line">    list_editable &#x3D; [&#39;name&#39;]</span><br><span class="line"></span><br><span class="line">    # 6. 查询列</span><br><span class="line">    search_fields &#x3D; [&#39;name&#39;,&#39;pwd&#39;]</span><br><span class="line"></span><br><span class="line">    # 7. 是否在页面顶端显示保存按钮</span><br><span class="line">    # save_on_top &#x3D; True</span><br><span class="line"></span><br><span class="line">    # 8. 下拉选项的批量操作，类似于批量删除功能</span><br><span class="line">    def func(self, request, queryset):</span><br><span class="line">        print(self, request, queryset)</span><br><span class="line">        id_list &#x3D; request.POST.getlist(&#39;_selected_action&#39;)</span><br><span class="line">        # models.UserInfo.objects.filter(id__in&#x3D;id_list).delete()</span><br><span class="line"></span><br><span class="line">    func.short_description &#x3D; &quot;批量初始化&quot;</span><br><span class="line"></span><br><span class="line">    actions &#x3D; [func, ]</span><br><span class="line"></span><br><span class="line">    # 9. 列表页面使用模板文件</span><br><span class="line">    change_list_template &#x3D; [&#39;xxx.html&#39;]</span><br><span class="line">    </span><br><span class="line">    # raw_id_fields &#x3D; [&#39;ut&#39;,]</span><br><span class="line">    # fields &#x3D; [&#39;name&#39;]</span><br><span class="line">    # exclude &#x3D; [&#39;name&#39;,]</span><br><span class="line">    </span><br><span class="line">    # 10. 分类展示</span><br><span class="line">    # fieldsets &#x3D; (</span><br><span class="line">    #     (&#39;基本数据&#39;, &#123;</span><br><span class="line">    #         &#39;fields&#39;: (&#39;name&#39;,)</span><br><span class="line">    #     &#125;),</span><br><span class="line">    #     (&#39;其他&#39;, &#123;</span><br><span class="line">    #         &#39;classes&#39;: (&#39;collapse&#39;, &#39;wide&#39;, &#39;extrapretty&#39;),  # &#39;collapse&#39;,&#39;wide&#39;, &#39;extrapretty&#39;</span><br><span class="line">    #         &#39;fields&#39;: (&#39;pwd&#39;, &#39;ut&#39;),</span><br><span class="line">    #     &#125;),</span><br><span class="line">    # )</span><br><span class="line"></span><br><span class="line">    # 11.快速过滤</span><br><span class="line">    # filter_vertical &#x3D; (&quot;roles&quot;,)</span><br><span class="line">    filter_horizontal &#x3D; (&quot;roles&quot;,)</span><br><span class="line">    </span><br><span class="line">    # 12. 排序</span><br><span class="line">    ordering &#x3D; [&#39;-id&#39;]</span><br><span class="line"></span><br><span class="line"># 注册使用自定义的UserInfoModelAdmin类的页面展示规则</span><br><span class="line">admin.site.register(models.UserInfo,UserInfoModelAdmin)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 2. 用户类型表(基于ModelAdmin类)</span><br><span class="line">class UserTypeModelAdmin(ModelAdmin):</span><br><span class="line">    list_display &#x3D; [&#39;title&#39;]</span><br><span class="line">    </span><br><span class="line">admin.site.register(models.UserType,UserTypeModelAdmin)</span><br></pre></td></tr></table></figure></li>
</ol>
<p><em>注: 默认使用ModelAdmin类进行后台操作，可以定义自己的calss，通过继承ModelAdmin类实现定制页面展示功能</em><br>2. Django自带Admin原理<br>2.1 每注册一个model类，Django内部会生成4个对应的增删改查URL，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">URL:</span><br><span class="line">    &#x2F;admin&#x2F;app_name&#x2F;model_name&#x2F;</span><br><span class="line">    &#x2F;admin&#x2F;app_name&#x2F;model_name&#x2F;add&#x2F;</span><br><span class="line">    &#x2F;admin&#x2F;app_name&#x2F;model_name&#x2F;1&#x2F;change&#x2F;</span><br><span class="line">    &#x2F;admin&#x2F;app_name&#x2F;model_name&#x2F;1&#x2F;delete&#x2F;</span><br><span class="line">    例：&#x2F;admin&#x2F;app01&#x2F;userinfo&#x2F;</span><br></pre></td></tr></table></figure>
<p>2.2 内部实现机制</p>
<ul>
<li>在app下面的admin.py文件中注册models类;</li>
<li>Django程序在启动时会循环所有app下面的admin文件中注册的models类，为每个models类生成对应的增删改查4个URL;</li>
<li>每个注册的model类会封装一个用于处理当前类所对应的URL的view对象,用于处理CURD操作，默认为ModelAdmin类对象;<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. self.model&#x3D;models.UserInfo</span><br><span class="line">&#x2F;admin&#x2F;app01&#x2F;userinfo&#x2F;                obj1.changelist_view</span><br><span class="line">&#x2F;admin&#x2F;app01&#x2F;userinfo&#x2F;add&#x2F;            obj1.add_view</span><br><span class="line">&#x2F;admin&#x2F;app01&#x2F;userinfo&#x2F;(\d+)&#x2F;delete&#x2F;   obj1.delete_view</span><br><span class="line">&#x2F;admin&#x2F;app01&#x2F;userinfo&#x2F;(\d+)&#x2F;change&#x2F;   obj1.change_view</span><br><span class="line"></span><br><span class="line">2. self.model&#x3D;models.UserType</span><br><span class="line">&#x2F;admin&#x2F;app01&#x2F;usertype&#x2F;                obj2.changelist_view</span><br><span class="line">&#x2F;admin&#x2F;app01&#x2F;usertype&#x2F;add&#x2F;            obj2.add_view</span><br><span class="line">&#x2F;admin&#x2F;app01&#x2F;usertype&#x2F;(\d+)&#x2F;delete&#x2F;   obj2.delete_view</span><br><span class="line">&#x2F;admin&#x2F;app01&#x2F;usertype&#x2F;(\d+)&#x2F;change&#x2F;   obj2.change_view</span><br></pre></td></tr></table></figure>
</br>

</li>
</ul>
<h2 id="自定义实现CURD类似Admin功能"><a href="#自定义实现CURD类似Admin功能" class="headerlink" title="自定义实现CURD类似Admin功能"></a>自定义实现CURD类似Admin功能</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ul>
<li>了解django启动时执行的启动文件顺序</li>
<li>制作启动文件</li>
<li>settings.py配置文件中注册启动文件使全局生效</li>
<li>实现组件CURD业务逻辑</li>
<li>主要参考Django Admin的实现，利用单利模式和include原理实现路由分发</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><em>假设组件app名称为: arya</em></p>
<ol>
<li>Django程序启动顺序<br>在程序启动时，django会根据配置项INSTALLED_APPS中注册的启动文件，遍历每个App下面对应的注册启动文件,在arya组件下面的app.py文件中实现ready方法激活启动文件,如下:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># arya&#x2F;app.py</span><br><span class="line"></span><br><span class="line">from django.apps import AppConfig</span><br><span class="line"></span><br><span class="line">class AryaConfig(AppConfig):</span><br><span class="line">    name &#x3D; &#39;arya&#39;</span><br><span class="line"></span><br><span class="line">    # Django启动时自动扫描所有app下面的arya模块</span><br><span class="line">    def ready(self):</span><br><span class="line">        from django.utils.module_loading import autodiscover_modules</span><br><span class="line">        autodiscover_modules(&#39;arya&#39;)</span><br></pre></td></tr></table></figure></li>
<li>在项目的setting.py文件中配置，激活组件，使全局生效，此时Django启动时，在完全启动前，便会扫描所有app下面的arya.py文件并加载生效<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS &#x3D; [</span><br><span class="line">    ...</span><br><span class="line">    &#39;arya.apps.AryaConfig&#39;,</span><br><span class="line">    ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
<li>核心代码逻辑实现<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cat arya&#x2F;seevice&#x2F;v1.py</span><br><span class="line"></span><br><span class="line">from django.conf.urls import url</span><br><span class="line">from django.shortcuts import render, HttpResponse, redirect</span><br><span class="line"></span><br><span class="line">class AryaConfig(object):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    每个models类的URL对应处理的View实现</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def __init__(self, model_class, site):</span><br><span class="line">        self.model_class &#x3D; model_class</span><br><span class="line">        # View对象</span><br><span class="line">        self.site &#x3D; site</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def urls(self):</span><br><span class="line">        partterns &#x3D; [</span><br><span class="line">            url(r&#39;^$&#39;, self.changelist_view),</span><br><span class="line">            url(r&#39;^add&#x2F;&#39;, self.add_view),</span><br><span class="line">            url(r&#39;^(\d+)&#x2F;change&#x2F;$&#39;, self.change_view),</span><br><span class="line">            url(r&#39;^(\d+)&#x2F;delete&#x2F;$&#39;, self.delete_view)</span><br><span class="line">        ]</span><br><span class="line">        return partterns</span><br><span class="line"></span><br><span class="line">    def changelist_view(self, request):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        列表试图</span><br><span class="line">        :param request:</span><br><span class="line">        :return:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # return HttpResponse(&quot;列表页面&quot;)</span><br><span class="line">        return render(request, &#39;arya&#x2F;changelist.html&#39;)</span><br><span class="line"></span><br><span class="line">    def add_view(self, request):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        添加试图</span><br><span class="line">        :param request:</span><br><span class="line">        :return:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return HttpResponse(&quot;添加试图&quot;)</span><br><span class="line"></span><br><span class="line">    def change_view(self, request):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        修改试图</span><br><span class="line">        :param request:</span><br><span class="line">        :return:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return HttpResponse(&quot;修改试图&quot;)</span><br><span class="line"></span><br><span class="line">    def delete_view(self, request):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        删除试图</span><br><span class="line">        :param request:</span><br><span class="line">        :return:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return HttpResponse(&quot;删除试图&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class AryaSite(object):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    实现类似于admin.site.register()功能</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    # 存放所有的models类及对应处理UTRL的的view对象</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self._registry &#x3D; &#123;&#125;</span><br><span class="line"></span><br><span class="line">    def register(self, class_name, config_class):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        注册方法,封装对象</span><br><span class="line">        self._registry &#x3D; &#123;</span><br><span class="line">            module.UserInfo: obj1,  # obj1 &#x3D; AryaConfig(models.UserInfo,site),</span><br><span class="line">            module.UserType: obj2,  # obj2 &#x3D; AryaConfig(models.UserType,site),</span><br><span class="line">        &#125;</span><br><span class="line">        :param class_name: models类</span><br><span class="line">        :param config_class: 对应的View类(AryaConfig)</span><br><span class="line">        :return:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self._registry[class_name] &#x3D; config_class(class_name, self)</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def urls(self):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        处理子路由</span><br><span class="line">        :return:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        partterns &#x3D; [</span><br><span class="line">            url(r&#39;^login&#x2F;$&#39;, self.login),</span><br><span class="line">            url(r&#39;^logout&#x2F;$&#39;, self.logout),</span><br><span class="line">        ]</span><br><span class="line">        # 循环self._registry属性里面的每一个元素，key为models类，value为URLS对应处理的类obj对象</span><br><span class="line">        for model_class, arya_config_obj in self._registry.items():</span><br><span class="line">            # 分别为app名称和models的类名称</span><br><span class="line">            print(&quot;*&quot; * 50)</span><br><span class="line">            print(model_class._meta.app_label, model_class._meta.model_name)</span><br><span class="line">            app_model_name_urls &#x3D; r&#39;^&#123;0&#125;&#x2F;&#123;1&#125;&#x2F;&#39;.format(model_class._meta.app_label, model_class._meta.model_name)</span><br><span class="line">            # arya_config_obj.urls self._registry字典中存放的values对象obj下面的urls方法</span><br><span class="line">            pt &#x3D; url(app_model_name_urls, (arya_config_obj.urls, None, None))</span><br><span class="line">            partterns.append(pt)</span><br><span class="line">        # 3元组</span><br><span class="line">        return partterns, None, None</span><br><span class="line"></span><br><span class="line">    def login(self):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        登陆</span><br><span class="line">        :return:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return redirect(&#39;login&#39;)</span><br><span class="line"></span><br><span class="line">    def logout(self):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        退出</span><br><span class="line">        :return:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return redirect(&#39;login&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 实例化，利用单例模式</span><br><span class="line">site &#x3D; AryaSite()</span><br></pre></td></tr></table></figure>
</br>

</li>
</ol>
<h3 id="引入arya组件并使用"><a href="#引入arya组件并使用" class="headerlink" title="引入arya组件并使用"></a>引入arya组件并使用</h3><ol>
<li><p>创建app，引入arya组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">创建多个app，并在每个app下面创建arya.py文件，用于实现CURD操作</span><br><span class="line">django startapp app01</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
<li><p>在app01下面创建models模型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cat app01&#x2F;models.py</span><br><span class="line"></span><br><span class="line">from django.db import models</span><br><span class="line"></span><br><span class="line">class UserType(models.Model):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    用户类型表</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    title &#x3D; models.CharField(max_length&#x3D;32, verbose_name&#x3D;&quot;用户类型&quot;)</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        verbose_name_plural &#x3D; &quot;用户类型表&quot;</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.title</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Role(models.Model):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    角色表</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    caption &#x3D; models.CharField(max_length&#x3D;32, verbose_name&#x3D;&quot;角色名&quot;)</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        verbose_name_plural &#x3D; &quot;角色表&quot;</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.caption</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class UserInfo(models.Model):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    用户表</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    username &#x3D; models.CharField(max_length&#x3D;32, verbose_name&#x3D;&quot;用户名&quot;)</span><br><span class="line">    password &#x3D; models.CharField(max_length&#x3D;64, verbose_name&#x3D;&quot;密码&quot;)</span><br><span class="line">    email &#x3D; models.CharField(max_length&#x3D;32, verbose_name&#x3D;&quot;邮箱&quot;)</span><br><span class="line">    ut &#x3D; models.ForeignKey(to&#x3D;&quot;UserType&quot;, blank&#x3D;True, verbose_name&#x3D;&quot;用户类型&quot;)</span><br><span class="line">    roles &#x3D; models.ManyToManyField(to&#x3D;&quot;Role&quot;, blank&#x3D;True, verbose_name&#x3D;&quot;所属角色&quot;)</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        verbose_name_plural &#x3D; &quot;用户表&quot;</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.username</span><br></pre></td></tr></table></figure></li>
<li><p>生成表结构并制作部分展示数据，可以直接在表中添加，也可以通过admin后台进行添加</p>
</li>
<li><p>在app01中的arya.py文件中注册models类并自定义实现展示UI</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cat app01&#x2F;arya.py</span><br><span class="line"></span><br><span class="line">from arya.service import v1</span><br><span class="line">from . import models</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"># 自定义属性控制UI展示</span><br><span class="line">class UserInfoConfig(v1.AryaConfig):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    自定义用户信息UI</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    list_display &#x3D; [&#39;username&#39;, &#39;ut&#39;, &#39;roles&#39;, &#39;email&#39;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class UserTypeConfig(v1.AryaConfig):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    自定义用户类型UI</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    list_display &#x3D; [&#39;title&#39;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class RoleConfig(v1.AryaConfig):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    自定义角色UI</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    list_display &#x3D; [&#39;caption&#39;]</span><br><span class="line"></span><br><span class="line"># 注册models</span><br><span class="line">v1.site.register(models.UserInfo, UserInfoConfig)</span><br><span class="line">v1.site.register(models.UserType, UserTypeConfig)</span><br><span class="line">v1.site.register(models.Role, RoleConfig)</span><br></pre></td></tr></table></figure></li>
<li><p>在项目中应用arya组件，使URL生效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#cat project_name&#x2F;urls.py</span><br><span class="line"></span><br><span class="line">from django.contrib import admin</span><br><span class="line">from django.conf.urls import url</span><br><span class="line">from arya.service import v1</span><br><span class="line">from . import views</span><br><span class="line"></span><br><span class="line"># url的第二个参数返回类型为([],None,None)的元组,源码见include方法</span><br><span class="line"># 此处的login和logut也可以使用arya&#x2F;service&#x2F;v1.py文件中定义的路由，示例为自己实现</span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    url(r&#39;^admin&#x2F;&#39;, admin.site.urls),</span><br><span class="line">    # 此处会生成对应的多个URL子路由</span><br><span class="line">    url(r&#39;^arya&#x2F;&#39;, v1.site.urls),</span><br><span class="line">    url(r&#39;^index&#x2F;$&#39;, views.index, name&#x3D;&quot;index&quot;),</span><br><span class="line">    url(r&#39;^login&#x2F;$&#39;, views.login, name&#x3D;&quot;login&quot;),</span><br><span class="line">    url(r&#39;^logout&#x2F;$&#39;, views.logout, name&#x3D;&quot;logout&quot;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
<li><p>路由试图处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cat project_name&#x2F;views.py</span><br><span class="line"></span><br><span class="line">from django.shortcuts import render, redirect</span><br><span class="line">from app01 import models</span><br><span class="line"></span><br><span class="line">def login(request):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    登陆</span><br><span class="line">    :param request:</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if request.method &#x3D;&#x3D; &quot;GET&quot;:</span><br><span class="line">        return render(request, &#39;login.html&#39;)</span><br><span class="line">    else:</span><br><span class="line">        username &#x3D; request.POST.get(&#39;username&#39;)</span><br><span class="line">        password &#x3D; request.POST.get(&#39;password&#39;)</span><br><span class="line">        obj &#x3D; models.UserInfo.objects.filter(username&#x3D;username, password&#x3D;password).first()</span><br><span class="line">        if obj:</span><br><span class="line">            request.session[&#39;userinfo&#39;] &#x3D; &#123;&#39;username&#39;: obj.username, &#39;is_login&#39;: True&#125;</span><br><span class="line">            return redirect(&#39;index&#39;)</span><br><span class="line">        return render(request, &#39;login.html&#39;, &#123;&#39;msg&#39;: &#39;用户名或密码错误&#39;&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def logout(request):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    退出</span><br><span class="line">    :param request:</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if request.method &#x3D;&#x3D; &quot;GET&quot;:</span><br><span class="line">        return redirect(&#39;login&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def index(request):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    首页</span><br><span class="line">    :param request:</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if request.method &#x3D;&#x3D; &quot;GET&quot;:</span><br><span class="line">        return render(request, &#39;index.html&#39;)</span><br></pre></td></tr></table></figure></li>
<li><p>项目URL<br>此时在项目的路由中已经存在对应增删改查的4个URL，如下所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># app_nmae 应用名</span><br><span class="line"># models_name models类名小写</span><br><span class="line">arya&#x2F;app_name&#x2F;models_name&#x2F;</span><br><span class="line">arya&#x2F;app_name&#x2F;models_name&#x2F;add&#x2F;</span><br><span class="line">arya&#x2F;app_name&#x2F;models_name&#x2F;(\d+)&#x2F;change&#x2F;</span><br><span class="line">arya&#x2F;app_name&#x2F;models_name&#x2F;(\d+)&#x2F;delete&#x2F;</span><br><span class="line"># 在该示例中为: </span><br><span class="line">http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;arya&#x2F;app01&#x2F;userinfo&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;arya&#x2F;app01&#x2F;userinfo&#x2F;add&#x2F;</span><br><span class="line">http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;arya&#x2F;app01&#x2F;userinfo&#x2F;()</span><br><span class="line">....</span><br></pre></td></tr></table></figure></li>
<li><p>扩展<br>在每个app下面的arya.py文件中继承arya组件中的service.v1.AryaConfig类，自己内部实现处理URL的view以及定制化操作</p>
</br>  

</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>  至此，自定义实现的类似Django admin组件基本开发完成，能够满足models模型数据的CURD操作。在Django中作为app引入CustAdmin组件，然后在settings文件中注册后就<br>可以生效使用了,engoy it!</p>
<p><a href="https://github.com/shuke163/CustAdmin" target="_blank" rel="noopener">github</a></p>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django序列化</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h2 id="Django序列化"><a href="#Django序列化" class="headerlink" title="Django序列化"></a>Django序列化</h2><h3 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h3><p>序列化的model中含choice字段信息存在的问题，status会显示数字而非状态相关的文本，通过在<code>serializers.py</code>文件中添加另一个<code>status_display</code>字段类显示状态文本，便可以解决该问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from rest——framework import serializers</span><br><span class="line">from .models import Sprint,Task</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">class TaskSerializer(serializers.ModelSerializer):</span><br><span class="line">   status_display &#x3D; serializers.SerializerMethodField()</span><br><span class="line">   </span><br><span class="line">   class Meta:</span><br><span class="line">       model &#x3D; Task</span><br><span class="line">       fields &#x3D; (&quot;id&quot;,&quot;name&quot;,&quot;description&quot;,&quot;sprint&quot;,&quot;status&quot;,&quot;status_display&quot;,&quot;order&quot;,&quot;assignred&quot;,&quot;started&quot;,&quot;due&quot;,&quot;completed&quot;,)</span><br><span class="line">       </span><br><span class="line">   def get_status_display(self,obj):</span><br><span class="line">       return obj.get_status_display()</span><br></pre></td></tr></table></figure>
<ul>
<li>status_display 是一个只读字段，返回序列化器中<code>get_status_display</code>中方法的值,该方法的语法格式为<code>get</code> + 下划线 + 字段名称组成，如上所示，<code>get_status_display</code></li>
</ul>
<h3 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h3><blockquote>
<p>序列化遇到的第二个问题是: <code>assigned</code>是一个指向<code>User</code>模型中的外键,这里显示的是用户的主键，然而我们的URL结构期望通过用户名来引用用户，我们在<code>serializers</code>中使用<code>SlugRelatedField</code>来解决这个问题       </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class TaskSerializer(serializers.ModelSerializer):</span><br><span class="line">    assigned &#x3D; serializers.SlugRelatedField(</span><br><span class="line">        slug_field&#x3D;User.USERNAME_FIELD, required&#x3D;False, allow_null&#x3D;true,</span><br><span class="line">        queryset&#x3D;user.objects.all()</span><br><span class="line">    )</span><br><span class="line">    status_display &#x3D; serializers.SerializerMethodField()</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        model &#x3D; Task</span><br><span class="line">        fields &#x3D; (</span><br><span class="line">            &quot;id&quot;, &quot;name&quot;, &quot;description&quot;, &quot;sprint&quot;, &quot;status&quot;, &quot;status_display&quot;, &quot;order&quot;, &quot;assigned&quot;, &quot;started&quot;, &quot;due&quot;,</span><br><span class="line">            &quot;completed&quot;)</span><br><span class="line"></span><br><span class="line">    def get_status_display(self, obj):</span><br><span class="line">        return obj.get_status_display()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django中间件</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h2 id="Django中间件"><a href="#Django中间件" class="headerlink" title="Django中间件"></a>Django中间件</h2><p>Django1.9版本以后，我们从浏览器发出一个请求 Request，得到一个响应后的内容 HttpResponse ，这个请求传递到 Django的过程如下：<br><img src="https://note.youdao.com/yws/api/personal/file/WEB04655a9c01957e832ef5e4d978b4e24c?method=download&shareKey=8d63de97ad045d5d59f417afb25f7f5a" alt="请求到Django中的处理流程图">  </p>
<p>也就是说，每一个请求都是先通过中间件中的 process_request 函数，这个函数返回 None 或者 HttpResponse 对象，如果返回前者，继续处理其它中间件，如果返回一个 HttpResponse，就处理中止，返回到网页上。</p>
<p>中间件（类）的几种方法<br>中间件可以定义的几种方法，分别是：</p>
<p>process_request(self,request) ： 在处理url请求之前执行</p>
<p>process_view(self, request, callback, callback_args,<br>callback_kwargs) ： 调用视图之前执行</p>
<p>process_template_response(self,request,response) ： 只有当views函数中返回的对象中具有render方法，才会直接调用</p>
<p>process_response(self, request, response) ： 在响应返回浏览器之前调用</p>
<p>自定义中间件<br>在Django中我们可以自己写一个继承了MiddlewareMixin的类，来实现自定义中间件。通过from django.urls.deprecation import MiddlewareMixin导入MiddlewareMixin。</p>
<p>为中间件创建一个目录Middle，并在Middle目录下创建middle1.py:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.utils.deprecation import MiddlewareMixin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class middle11(MiddlewareMixin):</span><br><span class="line">    def process_request(self, request):</span><br><span class="line">        print(&quot;中间件1请求&quot;)</span><br><span class="line"></span><br><span class="line">    def process_response(self, request, response):</span><br><span class="line">        print(&quot;中间件1返回&quot;)</span><br><span class="line">        return response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class middle2(MiddlewareMixin):</span><br><span class="line">    def process_request(self, request):</span><br><span class="line">        print(&quot;中间件2请求&quot;)</span><br><span class="line"></span><br><span class="line">    def process_response(self, request, response):</span><br><span class="line">        print(&quot;中间件2返回&quot;)</span><br><span class="line">        return response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class middle3(MiddlewareMixin):</span><br><span class="line">    def process_request(self, request):</span><br><span class="line">        print(&quot;中间件3请求&quot;)</span><br><span class="line"></span><br><span class="line">    def process_response(self, request, response):</span><br><span class="line">        print(&quot;中间件3返回&quot;)</span><br><span class="line">        return response</span><br></pre></td></tr></table></figure>
<p>在项目目录下的settings.py文件的MIDDLEWARE中添加如下三行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;Middle.middle1.middle11&#39;,</span><br><span class="line">&#39;Middle.middle1.middle2&#39;,</span><br><span class="line">&#39;Middle.middle1.middle3&#39;,</span><br></pre></td></tr></table></figure>
<p>当我们在浏览器中访问一个页面的时候在控制台就会看到如下的结果：<br><img src="https://note.youdao.com/yws/api/personal/file/WEB7f08c20201bab55e63606763d5718b3f?method=download&shareKey=a861abec06c2fef7e33e026196e5f453" alt="middleware自定义演示结果">  </p>
<p>从这里也向我们证实了当一个请求进来的时候，会通过所有的中间件处理，并且当请求获得相应时也会通过中间件去处理。</p>
<h3 id="中间件应用场景"><a href="#中间件应用场景" class="headerlink" title="中间件应用场景"></a>中间件应用场景</h3><p>由于中间件工作在 视图函数执行前、执行后适合所有的请求/一部分请求做批量处理。</p>
<p>1、做IP限制<br>放在 中间件类的列表中，阻止某些IP访问了；</p>
<p>2.URL访问过滤<br>如果用户访问的是login视图（放过）</p>
<p>如果访问其他视图（需要检测是不是有session已经有了放行，没有返回login），这样就省得在 多个视图函数上写装饰器了！</p>
<p>3、缓存(CDN)<br>客户端请求来了，中间件去缓存看看有没有数据，有直接返回给用户，没有再去逻辑层 执行视图函数</p>
<blockquote>
<p>注意：项目目录下MIDDLEWARE中’django.middleware.csrf.CsrfViewMiddleware’,为用户实现防止跨站请求伪造的功能，在之前我们都是将它注释掉的，因为我们如果不注释掉在表单提交的时候就会报forbidden的错误，但是如果我们又要用到防止跨域请求，又不要报错我们只需要在表单<from>标签中加入<code>{ csrf_token }</code>即可解决这个问题。</p>
</blockquote>
<h3 id="练习："><a href="#练习：" class="headerlink" title="练习："></a>练习：</h3><p>1.利用用中间件，实现让所有页面都必须在进行用户登录后才能访问qin<br>2.中间件统计，某个网页的访问次数。</p>
<p><a href="https://www.jianshu.com/p/2889eaff70fa" target="_blank" rel="noopener">原文链接</a>  </p>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker部署Django+Vue前后端分离的项目</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h2 id="Docker部署Django-Vue前后端分离的项目"><a href="#Docker部署Django-Vue前后端分离的项目" class="headerlink" title="Docker部署Django+Vue前后端分离的项目"></a>Docker部署Django+Vue前后端分离的项目</h2><blockquote>
<p>本文主要介绍使用Docker环境部署一个Django Rest和Vue结合的前后端分离项目.</p>
</blockquote>
<h3 id="前端Vue"><a href="#前端Vue" class="headerlink" title="前端Vue"></a>前端Vue</h3><h4 id="使用Makefile编译打包"><a href="#使用Makefile编译打包" class="headerlink" title="使用Makefile编译打包"></a>使用Makefile编译打包</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line"># cmdb-frontend makefile</span><br><span class="line">#</span><br><span class="line">SHELL :&#x3D; &#x2F;bin&#x2F;bash</span><br><span class="line">PATH  :&#x3D; node_modules&#x2F;.bin:$(PATH)</span><br><span class="line"></span><br><span class="line">NOW :&#x3D; $(shell date +&quot;%Y-%m-%d %H:%M:%S&quot;)</span><br><span class="line">PROJECT :&#x3D; cmdb-frontend</span><br><span class="line">PKG_NAME :&#x3D; $(PROJECT).tar.gz</span><br><span class="line"></span><br><span class="line"># Docker</span><br><span class="line">REGISTRY :&#x3D; wcr.shuke.net</span><br><span class="line">NAME :&#x3D; devops&#x2F;$(PROJECT)</span><br><span class="line">TAG :&#x3D; v$(shell date +&quot;%Y%m%d&quot;)</span><br><span class="line">IMG :&#x3D; $(REGISTRY)&#x2F;$(NAME):$(TAG)</span><br><span class="line"></span><br><span class="line"># update helm values.yaml</span><br><span class="line">CONTENT :&#x3D; $(subst TAG,$(TAG),&#39;9 s&#x2F;.*&#x2F;  tag\: TAG&#x2F;g&#39;)</span><br><span class="line"></span><br><span class="line">all : install pkg build-img</span><br><span class="line">.PHONY: all</span><br><span class="line"></span><br><span class="line">install:</span><br><span class="line">	@echo -e &quot;\033[32m$(NOW): Build $&#123;PROJECT&#125; project\033[0m&quot;</span><br><span class="line">	npm run build</span><br><span class="line"></span><br><span class="line">pkg:</span><br><span class="line">	@echo -e &quot;\033[32m$(NOW): start packing\033[0m&quot;</span><br><span class="line">	tar zcf $(PKG_NAME) dist&#x2F;*</span><br><span class="line"></span><br><span class="line">build-img:</span><br><span class="line">	@echo -e &quot;\033[32m$(NOW): Start build image...\033[0m&quot;</span><br><span class="line">	cp -Ra dist nginx&#x2F;</span><br><span class="line">	docker build -t $(IMG) nginx</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">	@echo -e &quot;\033[32m$(NOW): clean...\033[0m&quot;</span><br><span class="line">	-rm -rf $(PKG_NAME) dist nginx&#x2F;dist</span><br><span class="line">	-docker rmi $(IMG)</span><br></pre></td></tr></table></figure>
<p>⚠️ 注: 在项目的根目录下执行<code>make all</code>命令进行编译打包操作以及生成docker镜像.</p>
<h4 id="Nginx配置文件"><a href="#Nginx配置文件" class="headerlink" title="Nginx配置文件"></a>Nginx配置文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cat cmdb.shuke.net.conf</span><br><span class="line">upstream cmdb-backend &#123;</span><br><span class="line">    server web:8000;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">	listen 80;</span><br><span class="line">	server_name cmdb.shuke.net;</span><br><span class="line"></span><br><span class="line">	location &#x2F; &#123;</span><br><span class="line">    	    root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">            try_files $uri $uri&#x2F; &#x2F;index.html @fallback;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">        location @fallback &#123;</span><br><span class="line">            proxy_set_header Host $host;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">	        proxy_pass    http:&#x2F;&#x2F;cmdb-backend;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">        error_page   500 502 503 504  &#x2F;50x.html;</span><br><span class="line">        location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">            root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>⚠️ 注: 需将nginx配置文件复制到Dokcer镜像中覆盖默认的配置文件</p>
<h4 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line"># CMDB Frontend Nginx Dockerfile</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">FROM wcr.shuke.net&#x2F;base&#x2F;nginx:1.14.2</span><br><span class="line"></span><br><span class="line">LABEL maintainer&#x3D;&quot;shu_ke163@163.com&quot;</span><br><span class="line"></span><br><span class="line">COPY dist &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html</span><br><span class="line"></span><br><span class="line">COPY cmdb.shuke.net.conf &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;default.conf</span><br><span class="line"></span><br><span class="line">WORKDIR &#x2F;etc&#x2F;nginx</span><br><span class="line"></span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line">CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]</span><br></pre></td></tr></table></figure>
<p>⚠️ 注: 此处的nginx镜像可以使用Docker Hub官方的镜像也可以自定义.</p>
<h3 id="后端Django"><a href="#后端Django" class="headerlink" title="后端Django"></a>后端Django</h3><h4 id="Dockerfile-1"><a href="#Dockerfile-1" class="headerlink" title="Dockerfile"></a>Dockerfile</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line"># Django CMDB</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">FROM python:3</span><br><span class="line">ENV PYTHONUNBUFFERED 1</span><br><span class="line">RUN mkdir &#x2F;code</span><br><span class="line">WORKDIR &#x2F;code</span><br><span class="line">ADD requirements.txt &#x2F;code&#x2F;</span><br><span class="line">RUN pip install  --no-cache-dir -r requirements.txt</span><br><span class="line">ADD . &#x2F;code&#x2F;</span><br><span class="line">EXPOSE 8000</span><br><span class="line">CMD [&quot;python&quot;, &quot;.&#x2F;manage.py runserver 0.0.0.0:8000&quot;]</span><br></pre></td></tr></table></figure>
<p>⚠️ 注: 将Dockerfile放入Django的项目根节点目录下,用于构建后端容器</p>
<h4 id="docker-compose-yml-文件"><a href="#docker-compose-yml-文件" class="headerlink" title="docker-compose.yml 文件"></a>docker-compose.yml 文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line">  redis:</span><br><span class="line">    image: redis:4</span><br><span class="line">    container_name: cmdb-redis</span><br><span class="line">  db:</span><br><span class="line">    image: mysql:5.6</span><br><span class="line">    container_name: cmdb-mysql</span><br><span class="line">    volumes:</span><br><span class="line">      - ~&#x2F;data&#x2F;mysql&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql</span><br><span class="line">    environment:</span><br><span class="line">      MYSQL_ROOT_PASSWORD: admin123</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;3307:3306&quot;</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    image: cmdb-backend:v1.0.0</span><br><span class="line">    container_name: cmdb-backend</span><br><span class="line">    command: python3 manage.py runserver 0.0.0.0:8000</span><br><span class="line">    volumes:</span><br><span class="line">      - .:&#x2F;code</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8000:8000&quot;</span><br><span class="line">    depends_on:</span><br><span class="line">      - redis</span><br><span class="line">      - db</span><br><span class="line">    links:</span><br><span class="line">      - redis</span><br><span class="line">      - db</span><br><span class="line">  nginx:</span><br><span class="line">   # 前端Vue项目Dockerfile所在目录 </span><br><span class="line">    build: ..&#x2F;cmdb-frontend&#x2F;nginx&#x2F;</span><br><span class="line">    image: cmdb-frontend:v1.0.0</span><br><span class="line">    container_name: cmdb-nginx</span><br><span class="line">    ports:</span><br><span class="line">      - 9000:80</span><br><span class="line">    depends_on:</span><br><span class="line">      - web</span><br><span class="line">    links:</span><br><span class="line">      - web</span><br><span class="line">    restart: always</span><br></pre></td></tr></table></figure>
<p>⚠️ 注: 使用docker-compose 进行管理项目的所有依赖,包括redis/mysql/django/nginx容器,控制整个项目所依赖的所有容器的生命周期,使用<code>docker-compose up -d</code>命令拉取或生成镜像并启动项目依赖的所有容器</p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. docker-compose build web   构建后端Django项目容器</span><br><span class="line">2. docker-compose build nginx 构建前端Vue项目容器</span><br><span class="line">3. docker-compose up 前台启动项目</span><br><span class="line">4. docker-compose up 后台启动项目</span><br><span class="line">5. docker-compose images 查看项目所有镜像</span><br><span class="line">6. docker-compose ps 查看项目所有容器</span><br><span class="line">7. docker-compose logs -f [service name] 如:web&#x2F;nginx  查看容器log信息</span><br><span class="line">8. docker-compose config 查看docker-compose.yml文件内容并校验</span><br><span class="line">9. $ docker-compose port nginx 80   # 查看服务的端口映射</span><br><span class="line">0.0.0.0:9000</span><br><span class="line">10. docker-compose stop db 停止单个容器</span><br><span class="line">11. docker-compose start db 启动单个容器</span><br><span class="line">12. docker-compose restart db 重启单个容器</span><br><span class="line">13. docker-compose start   启动所有容器</span><br><span class="line">14. docker-compose stop  停止所有容器</span><br><span class="line">15. docker-compose restart  重启所有容器</span><br><span class="line">16. docker-compose rm  删除所有已停止的容器</span><br><span class="line"></span><br><span class="line"># 以下是所有的docker-compose一些命令参数</span><br><span class="line">Commands:</span><br><span class="line">  build              Build or rebuild services</span><br><span class="line">  bundle             Generate a Docker bundle from the Compose file</span><br><span class="line">  config             Validate and view the Compose file</span><br><span class="line">  create             Create services</span><br><span class="line">  down               Stop and remove containers, networks, images, and volumes</span><br><span class="line">  events             Receive real time events from containers</span><br><span class="line">  exec               Execute a command in a running container</span><br><span class="line">  help               Get help on a command</span><br><span class="line">  images             List images</span><br><span class="line">  kill               Kill containers</span><br><span class="line">  logs               View output from containers</span><br><span class="line">  pause              Pause services</span><br><span class="line">  port               Print the public port for a port binding</span><br><span class="line">  ps                 List containers</span><br><span class="line">  pull               Pull service images</span><br><span class="line">  push               Push service images</span><br><span class="line">  restart            Restart services</span><br><span class="line">  rm                 Remove stopped containers</span><br><span class="line">  run                Run a one-off command</span><br><span class="line">  scale              Set number of containers for a service</span><br><span class="line">  start              Start services</span><br><span class="line">  stop               Stop services</span><br><span class="line">  top                Display the running processes</span><br><span class="line">  unpause            Unpause services</span><br><span class="line">  up                 Create and start containers</span><br><span class="line">  version            Show the Docker-Compose version information</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask之路(一)</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h2 id="Flask之路-一"><a href="#Flask之路-一" class="headerlink" title="Flask之路(一)"></a>Flask之路(一)</h2><h3 id="一-简介"><a href="#一-简介" class="headerlink" title="一. 简介"></a>一. 简介</h3><p>Flask是一个基于Python开发并且依赖jinja2模板和Werkzeug WSGI服务的一个微型框架，对于Werkzeug本质是Socket服务端，其用于接收http请求并对请求进行预处理，然后触发Flask框架，开发人员基于Flask框架提供的功能对请求进行相应的处理，并返回给用户，如果要返回给用户复杂的内容时，需要借助jinja2模板来实现对模板的处理，即：将模板和数据进行渲染，将渲染后的字符串返回给用户浏览器。</p>
<p>“微”(micro) 并不表示你需要把整个 Web 应用塞进单个 Python 文件（虽然确实可以 ），也不意味着 Flask 在功能上有所欠缺。微框架中的“微”意味着 Flask 旨在保持核心简单而易于扩展。Flask 不会替你做出太多决策——比如使用何种数据库。而那些 Flask 所选择的——比如使用何种模板引擎——则很容易替换。除此之外的一切都由可由你掌握。如此，Flask 可以与您珠联璧合。</p>
<p>默认情况下，Flask 不包含数据库抽象层、表单验证，或是其它任何已有多种库可以胜任的功能。然而，Flask 支持用扩展来给应用添加这些功能，如同是 Flask 本身实现的一样。众多的扩展提供了数据库集成、表单验证、上传处理、各种各样的开放认证技术等功能。Flask 也许是“微小”的，但它已准备好在需求繁杂的生产环境中投入使用。</p>
<h4 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install flask</span><br></pre></td></tr></table></figure>
<h4 id="2-WSGI实现原理"><a href="#2-WSGI实现原理" class="headerlink" title="2. WSGI实现原理"></a>2. WSGI实现原理</h4><p>Flask依赖werkzeug模块实现了WSGi协议,监听socket的请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from werkzeug.wrappers import Request, Response</span><br><span class="line"></span><br><span class="line">@Request.application</span><br><span class="line">def hello(request):</span><br><span class="line">    return Response(&#39;Hello World!&#39;)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    from werkzeug.serving import run_simple</span><br><span class="line">    run_simple(&#39;localhost&#39;, 4000, hello)</span><br><span class="line"></span><br><span class="line">werkzeug</span><br></pre></td></tr></table></figure>

<h4 id="3-基本使用"><a href="#3-基本使用" class="headerlink" title="3. 基本使用"></a>3. 基本使用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line"></span><br><span class="line">app &#x3D; Flask(__name__)</span><br><span class="line">@app.route(&#39;&#x2F;&#39;)</span><br><span class="line">def hello_world():</span><br><span class="line">    return &#39;Hello World!&#39;</span><br><span class="line">    </span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    app.run()</span><br><span class="line"></span><br><span class="line">$ curl http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure>



<h3 id="二-路由系统源码分析"><a href="#二-路由系统源码分析" class="headerlink" title="二. 路由系统源码分析"></a>二. 路由系统源码分析</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line"></span><br><span class="line">app &#x3D; Flask(__name__)</span><br><span class="line"></span><br><span class="line">def index():</span><br><span class="line">    return &#39;Hello World!!&#39;</span><br><span class="line"></span><br><span class="line"># app对象的run方法中,self.add_url_rule(rule, endpoint, f, **options)</span><br><span class="line"># 此处的rule是请求的uri路径，endpoint类似于Django中路由系统的name参数，用于反向生成URL,参数f为触发执行的函数fun,此处也可以是class对象，会触发对象的__call__方法</span><br><span class="line">app.add_url_rule(&#39;&#x2F;index&#39;, &#39;index&#39;, index)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    # 1. 请求进来首先会触发run_simple函数运行,同时执行app.__call__方法</span><br><span class="line">    # 封装请求</span><br><span class="line">    # 路由匹配</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>

<h3 id="三-Flask的装饰器"><a href="#三-Flask的装饰器" class="headerlink" title="三. Flask的装饰器"></a>三. Flask的装饰器</h3><h4 id="3-1-装饰器"><a href="#3-1-装饰器" class="headerlink" title="3.1 装饰器"></a>3.1 装饰器</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># __author__ &#x3D; &quot;shuke&quot;</span><br><span class="line"># Date: 2018&#x2F;4&#x2F;15</span><br><span class="line"></span><br><span class="line"># 1. 无参装饰器</span><br><span class="line">def wapper(f):</span><br><span class="line">    def inner(*args, **kwargs):</span><br><span class="line">        return f(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    return inner</span><br><span class="line"></span><br><span class="line"># 1. 立即执行wapper函数,并且将被装饰的函数当作参数传递</span><br><span class="line"># 2. 此时的func&#x3D;inner</span><br><span class="line">@wapper</span><br><span class="line">def func(arg):</span><br><span class="line">    print(arg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func(123)</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">&gt;&gt;&gt; 123</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 2. 带参数的装饰器,此处为3层的函数嵌套</span><br><span class="line">def outer(num):</span><br><span class="line">    def wapper(f):</span><br><span class="line">        def inner(*args, **kwargs):</span><br><span class="line">            return f(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">        return inner</span><br><span class="line"></span><br><span class="line">    print(num)</span><br><span class="line">    return wapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 首先执行wapper(666)，获得返回值;@wapper;此时@wapper,再执行wapper(func)函数,获得返回值inner，此时:func&#x3D;inner函数</span><br><span class="line">@outer(666)</span><br><span class="line">def func(arg):</span><br><span class="line">    print(arg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func(&#39;Hello&#39;)</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">666</span><br><span class="line">Hello</span><br><span class="line">&#39;&#39;&#39;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-Flask中的路由装饰器"><a href="#3-2-Flask中的路由装饰器" class="headerlink" title="3.2 Flask中的路由装饰器"></a>3.2 Flask中的路由装饰器</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line"></span><br><span class="line">app &#x3D; Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.route(&#39;&#x2F;&#39;)   #app.router函数装返回decorator对象:形入@decorator</span><br><span class="line">def hello_world():</span><br><span class="line">    return &#39;Hello World!&#39;</span><br></pre></td></tr></table></figure>
<p>⚠️  Flask中路由系统使用的就是带参数的装饰器形式,本质是封装成rule对象,添加到app.url_map属性中</p>
<h4 id="3-3-Flask中认证的装饰器用法"><a href="#3-3-Flask中认证的装饰器用法" class="headerlink" title="3.3 Flask中认证的装饰器用法"></a>3.3 Flask中认证的装饰器用法</h4><p>a. functools 模块使用示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import functools</span><br><span class="line">def wapper(func):</span><br><span class="line">    @functools.wraps(func)</span><br><span class="line">    def inner(*args,**kwargs):</span><br><span class="line">        return func(*args,**kwargs)</span><br><span class="line">    return inner</span><br><span class="line"></span><br><span class="line">@wapper</span><br><span class="line">def index():</span><br><span class="line">    print(&#39;函数内容&#39;)</span><br><span class="line"></span><br><span class="line">@wapper</span><br><span class="line">def order():</span><br><span class="line">    print(&#39;函数内容&#39;)</span><br><span class="line"></span><br><span class="line">print(index.__name__)</span><br><span class="line">print(order.__name__)</span><br></pre></td></tr></table></figure>
<p>b. Flask中应用示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import functools</span><br><span class="line">from flask import Flask,render_template,request,redirect,session</span><br><span class="line"></span><br><span class="line">app &#x3D; Flask(__name__,template_folder&#x3D;&quot;templates&quot;)</span><br><span class="line">app.secret_key &#x3D; &#39;as923lrjks9d8fwlkxlduf&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def auth(func):</span><br><span class="line">    @functools.wraps(func)</span><br><span class="line">    def inner(*args,**kwargs):</span><br><span class="line">        user_info &#x3D; session.get(&#39;user_info&#39;)</span><br><span class="line">        if not user_info:</span><br><span class="line">            return redirect(&#39;&#x2F;login&#39;)</span><br><span class="line">        return func(*args,**kwargs)</span><br><span class="line">    return inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;order: inner函数, name: order</span><br><span class="line">    &#x2F;index: inner函数, name: index</span><br><span class="line">&#125;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">@app.route(&#39;&#x2F;order&#39;,methods&#x3D;[&#39;GET&#39;])</span><br><span class="line">@auth</span><br><span class="line">def order():</span><br><span class="line">    user_info &#x3D; session.get(&#39;user_info&#39;)</span><br><span class="line">    if not user_info:</span><br><span class="line">        return redirect(&#39;&#x2F;login&#39;)</span><br><span class="line"></span><br><span class="line">    return render_template(&#39;index.html&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.route(&#39;&#x2F;index&#39;,methods&#x3D;[&#39;GET&#39;])</span><br><span class="line">@auth</span><br><span class="line">def index():</span><br><span class="line">    return render_template(&#39;index.html&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.route(&#39;&#x2F;login&#39;,methods&#x3D;[&#39;GET&#39;,&#39;POST&#39;])</span><br><span class="line">def login():</span><br><span class="line">    if request.method &#x3D;&#x3D; &quot;GET&quot;:</span><br><span class="line">        return render_template(&#39;login.html&#39;)</span><br><span class="line">    else:</span><br><span class="line">        user &#x3D; request.form.get(&#39;user&#39;)</span><br><span class="line">        pwd &#x3D; request.form.get(&#39;pwd&#39;)</span><br><span class="line">        if user &#x3D;&#x3D; &#39;shuke&#39; and pwd &#x3D;&#x3D; &#39;123&#39;:</span><br><span class="line">            session[&#39;user_info&#39;] &#x3D; user</span><br><span class="line">            return redirect(&#39;&#x2F;index&#39;)</span><br><span class="line">        # return render_template(&#39;login.html&#39;,msg &#x3D; &quot;用户名或密码错误&quot;,error &#x3D; &quot;请注册&quot;)</span><br><span class="line">        return render_template(&#39;login.html&#39;,**&#123;&#39;msg&#39;:&#39;用户名或密码错误&#39;&#125;)</span><br><span class="line"></span><br><span class="line">@app.route(&#39;&#x2F;logout&#39;,methods&#x3D;[&#39;GET&#39;])</span><br><span class="line">def logout():</span><br><span class="line">    del session[&#39;user_info&#39;]</span><br><span class="line">    return redirect(&#39;&#x2F;login&#39;)</span><br><span class="line">    </span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>
<p>⚠️  此处,使用auth装饰器的时候多个函数会对应到同一个同一个装饰器函数inner对象,Flask启动会报错;<br>此时可以使用endpoint参数解决此问题,Flask内部默认使用函数的<strong>name</strong>获取的函数名作为endpoint参数;<br>或者利用functools模块保留被装饰函数的元信息;<br>在实际应用中建议使用类似于Django的中间件方式更优雅的方式解决;</p>
<h3 id="四-配置文件"><a href="#四-配置文件" class="headerlink" title="四. 配置文件"></a>四. 配置文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flask中的配置文件是一个flask.config.Config对象（继承字典）,默认配置为：</span><br><span class="line">    &#123;</span><br><span class="line">        &#39;DEBUG&#39;:                                get_debug_flag(default&#x3D;False),  是否开启Debug模式</span><br><span class="line">        &#39;TESTING&#39;:                              False,                          是否开启测试模式</span><br><span class="line">        &#39;PROPAGATE_EXCEPTIONS&#39;:                 None,                          </span><br><span class="line">        &#39;PRESERVE_CONTEXT_ON_EXCEPTION&#39;:        None,</span><br><span class="line">        &#39;SECRET_KEY&#39;:                           None,</span><br><span class="line">        &#39;PERMANENT_SESSION_LIFETIME&#39;:           timedelta(days&#x3D;31),</span><br><span class="line">        &#39;USE_X_SENDFILE&#39;:                       False,</span><br><span class="line">        &#39;LOGGER_NAME&#39;:                          None,</span><br><span class="line">        &#39;LOGGER_HANDLER_POLICY&#39;:               &#39;always&#39;,</span><br><span class="line">        &#39;SERVER_NAME&#39;:                          None,</span><br><span class="line">        &#39;APPLICATION_ROOT&#39;:                     None,</span><br><span class="line">        &#39;SESSION_COOKIE_NAME&#39;:                  &#39;session&#39;,</span><br><span class="line">        &#39;SESSION_COOKIE_DOMAIN&#39;:                None,</span><br><span class="line">        &#39;SESSION_COOKIE_PATH&#39;:                  None,</span><br><span class="line">        &#39;SESSION_COOKIE_HTTPONLY&#39;:              True,</span><br><span class="line">        &#39;SESSION_COOKIE_SECURE&#39;:                False,</span><br><span class="line">        &#39;SESSION_REFRESH_EACH_REQUEST&#39;:         True,</span><br><span class="line">        &#39;MAX_CONTENT_LENGTH&#39;:                   None,</span><br><span class="line">        &#39;SEND_FILE_MAX_AGE_DEFAULT&#39;:            timedelta(hours&#x3D;12),</span><br><span class="line">        &#39;TRAP_BAD_REQUEST_ERRORS&#39;:              False,</span><br><span class="line">        &#39;TRAP_HTTP_EXCEPTIONS&#39;:                 False,</span><br><span class="line">        &#39;EXPLAIN_TEMPLATE_LOADING&#39;:             False,</span><br><span class="line">        &#39;PREFERRED_URL_SCHEME&#39;:                 &#39;http&#39;,</span><br><span class="line">        &#39;JSON_AS_ASCII&#39;:                        True,</span><br><span class="line">        &#39;JSON_SORT_KEYS&#39;:                       True,</span><br><span class="line">        &#39;JSONIFY_PRETTYPRINT_REGULAR&#39;:          True,</span><br><span class="line">        &#39;JSONIFY_MIMETYPE&#39;:                     &#39;application&#x2F;json&#39;,</span><br><span class="line">        &#39;TEMPLATES_AUTO_RELOAD&#39;:                None,</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>方式一：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    app.config[&#39;DEBUG&#39;] &#x3D; True</span><br><span class="line"> </span><br><span class="line">    PS： 由于Config对象本质上是字典，所以还可以使用app.config.update(...)</span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line">方式二：</span><br></pre></td></tr></table></figure>
<pre><code>app.config.from_pyfile(&quot;python文件名称&quot;)
    如：
        settings.py
            DEBUG = True
        app.config.from_pyfile(&quot;settings.py&quot;)

app.config.from_envvar(&quot;环境变量名称&quot;)
    环境变量的值为python文件名称名称，内部调用from_pyfile方法

app.config.from_json(&quot;json文件名称&quot;)
    JSON文件名称，必须是json格式，因为内部会执行json.loads

app.config.from_mapping({&apos;DEBUG&apos;:True})
    字典格式

app.config.from_object(&quot;python类或类的路径&quot;)

    app.config.from_object(&apos;pro_flask.settings.TestingConfig&apos;)

    settings.py 内容

        class Config(object):
            DEBUG = False
            TESTING = False
            DATABASE_URI = &apos;sqlite://:memory:&apos;

        class ProductionConfig(Config):
            DATABASE_URI = &apos;mysql://user@localhost/foo&apos;

        class DevelopmentConfig(Config):
            DEBUG = True

        class TestingConfig(Config):
            TESTING = True</code></pre><p>PS: 从sys.path中已经存在的路径下开始查找</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PS: settings.py文件默认路径要放在程序root_path目录，如果instance_relative_config为True，则就是instance_path目录</span><br><span class="line"></span><br><span class="line">### 五. 路由系统</span><br><span class="line">#### 5.1 路由基本使用</span><br><span class="line">- @app.route(&#39;&#x2F;user&#x2F;&lt;username&gt;&#39;)</span><br><span class="line">- @app.route(&#39;&#x2F;post&#x2F;&lt;int:post_id&gt;&#39;)</span><br><span class="line">- @app.route(&#39;&#x2F;post&#x2F;&lt;float:post_id&gt;&#39;)</span><br><span class="line">- @app.route(&#39;&#x2F;post&#x2F;&lt;path:path&gt;&#39;)</span><br><span class="line">- @app.route(&#39;&#x2F;login&#39;, methods&#x3D;[&#39;GET&#39;, &#39;POST&#39;])</span><br><span class="line"></span><br><span class="line">常用路由系统有以上五种，所有的路由系统都是基于以下对应关系来处理:</span><br></pre></td></tr></table></figure>
<p>DEFAULT_CONVERTERS = {<br>    ‘default’:          UnicodeConverter,<br>    ‘string’:           UnicodeConverter,<br>    ‘any’:              AnyConverter,<br>    ‘path’:             PathConverter,<br>    ‘int’:              IntegerConverter,<br>    ‘float’:            FloatConverter,<br>    ‘uuid’:             UUIDConverter,<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#### 5.2 注册路由原理</span><br></pre></td></tr></table></figure>
<p>def auth(func):<br>            def inner(<em>args, *</em>kwargs):<br>                print(‘before’)<br>                result = func(<em>args, *</em>kwargs)<br>                print(‘after’)<br>                return result</p>
<pre><code>return inner

@app.route(&apos;/index.html&apos;,methods=[&apos;GET&apos;,&apos;POST&apos;],endpoint=&apos;index&apos;)
@auth
def index():
    return &apos;Index&apos;
或
def index():
    return &quot;Index&quot;

self.add_url_rule(rule=&apos;/index.html&apos;, endpoint=&quot;index&quot;, view_func=index, methods=[&quot;GET&quot;,&quot;POST&quot;])
or
app.add_url_rule(rule=&apos;/index.html&apos;, endpoint=&quot;index&quot;, view_func=index, methods=[&quot;GET&quot;,&quot;POST&quot;])
app.view_functions[&apos;index&apos;] = index
或
def auth(func):
    def inner(*args, **kwargs):
        print(&apos;before&apos;)
        result = func(*args, **kwargs)
        print(&apos;after&apos;)
        return result

return inner

class IndexView(views.View):
    methods = [&apos;GET&apos;]
    decorators = [auth, ]

    def dispatch_request(self):
        print(&apos;Index&apos;)
        return &apos;Index!&apos;

app.add_url_rule(&apos;/index&apos;, view_func=IndexView.as_view(name=&apos;index&apos;))  # name=endpoint
或
class IndexView(views.MethodView):
    methods = [&apos;GET&apos;]
    decorators = [auth, ]

    def get(self):
        return &apos;Index.GET&apos;

    def post(self):
        return &apos;Index.POST&apos;

app.add_url_rule(&apos;/index&apos;, view_func=IndexView.as_view(name=&apos;index&apos;))  # name=endpoint

@app.route和app.add_url_rule参数：
    rule,                       URL规则
    view_func,                  视图函数名称
    defaults=None,              默认值,当URL中无参数，函数需要参数时，使用defaults={&apos;k&apos;:&apos;v&apos;}为函数提供参数
    endpoint=None,              名称，用于反向生成URL，即： url_for(&apos;名称&apos;)
    methods=None,               允许的请求方式，如：[&quot;GET&quot;,&quot;POST&quot;]


    strict_slashes=None,        对URL最后的 / 符号是否严格要求，
                                如：
                                    @app.route(&apos;/index&apos;,strict_slashes=False)，
                                        访问 http://www.xx.com/index/ 或 http://www.xx.com/index均可
                                    @app.route(&apos;/index&apos;,strict_slashes=True)
                                        仅访问 http://www.xx.com/index 
    redirect_to=None,           重定向到指定地址
                                如：
                                    @app.route(&apos;/index/&lt;int:nid&gt;&apos;, redirect_to=&apos;/home/&lt;nid&gt;&apos;)
                                    或
                                    def func(adapter, nid):
                                        return &quot;/home/888&quot;
                                    @app.route(&apos;/index/&lt;int:nid&gt;&apos;, redirect_to=func)
    subdomain=None,             子域名访问
                                        from flask import Flask, views, url_for

                                        app = Flask(import_name=__name__)
                                        app.config[&apos;SERVER_NAME&apos;] = &apos;wupeiqi.com:5000&apos;


                                        @app.route(&quot;/&quot;, subdomain=&quot;admin&quot;)
                                        def static_index():
                                            &quot;&quot;&quot;Flask supports static subdomains
                                            This is available at static.your-domain.tld&quot;&quot;&quot;
                                            return &quot;static.your-domain.tld&quot;

                                        @app.route(&quot;/dynamic&quot;, subdomain=&quot;&lt;username&gt;&quot;)
                                        def username_index(username):
                                            &quot;&quot;&quot;Dynamic subdomains are also supported
                                            Try going to user1.your-domain.tld/dynamic&quot;&quot;&quot;
                                            return username + &quot;.your-domain.tld&quot;

                                        if __name__ == &apos;__main__&apos;:
                                            app.run()</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#### 5.3 自定义正则路由匹配</span><br></pre></td></tr></table></figure>
<p>from flask import Flask, views, url_for<br>            from werkzeug.routing import BaseConverter</p>
<pre><code>app = Flask(import_name=__name__)


class RegexConverter(BaseConverter):
    &quot;&quot;&quot;
    自定义URL匹配正则表达式
    &quot;&quot;&quot;
    def __init__(self, map, regex):
        super(RegexConverter, self).__init__(map)
        self.regex = regex

    def to_python(self, value):
        &quot;&quot;&quot;
        路由匹配时，匹配成功后传递给视图函数中参数的值
        :param value: 
        :return: 
        &quot;&quot;&quot;
        return int(value)

    def to_url(self, value):
        &quot;&quot;&quot;
        使用url_for反向生成URL时，传递的参数经过该方法处理，返回的值用于生成URL中的参数
        :param value: 
        :return: 
        &quot;&quot;&quot;
        val = super(RegexConverter, self).to_url(value)
        return val

# 添加到flask中
app.url_map.converters[&apos;regex&apos;] = RegexConverter


@app.route(&apos;/index/&lt;regex(&quot;\d+&quot;):nid&gt;&apos;)
def index(nid):
    print(url_for(&apos;index&apos;, nid=&apos;888&apos;))
    return &apos;Index&apos;

if __name__ == &apos;__main__&apos;:
    app.run()</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 五. </span><br><span class="line">1. 模板的使用</span><br><span class="line">Flask使用的是Jinja2模板，所以其语法和Django无差别</span><br><span class="line">2. 自定义模板方法</span><br><span class="line">Flask中自定义模板方法的方式和Bottle相似，创建一个函数并通过参数的形式传入render_template，如：</span><br></pre></td></tr></table></figure>
<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
    <h1>自定义函数</h1>
    

</body>
</html>

<p>html</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;&#96;&#96;</span><br><span class="line"># cat run.py</span><br><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">from flask import Flask,render_template</span><br><span class="line">app &#x3D; Flask(__name__)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def wupeiqi():</span><br><span class="line">    return &#39;&lt;h1&gt;Wupeiqi&lt;&#x2F;h1&gt;&#39;</span><br><span class="line"> </span><br><span class="line">@app.route(&#39;&#x2F;login&#39;, methods&#x3D;[&#39;GET&#39;, &#39;POST&#39;])</span><br><span class="line">def login():</span><br><span class="line">    return render_template(&#39;login.html&#39;, ww&#x3D;wupeiqi)</span><br><span class="line"> </span><br><span class="line">app.run()</span><br></pre></td></tr></table></figure>
<p>example.html</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#123;% macro input(name, type&#x3D;&#39;text&#39;, value&#x3D;&#39;&#39;) %&#125;</span><br><span class="line">        &lt;input type&#x3D;&quot;&#123;&#123; type &#125;&#125;&quot; name&#x3D;&quot;&#123;&#123; name &#125;&#125;&quot; value&#x3D;&quot;&#123;&#123; value &#125;&#125;&quot;&gt;</span><br><span class="line">    &#123;% endmacro %&#125;</span><br><span class="line"></span><br><span class="line">    &#123;&#123; input(&#39;n1&#39;) &#125;&#125;</span><br><span class="line"></span><br><span class="line">    &#123;% include &#39;tp.html&#39; %&#125;</span><br><span class="line"></span><br><span class="line">    &lt;h1&gt;asdf&#123;&#123; v.k1&#125;&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<p>注⚠️：Markup等价django的mark_safe</p>
<h3 id="六-请求和响应"><a href="#六-请求和响应" class="headerlink" title="六. 请求和响应"></a>六. 请求和响应</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line">    from flask import request</span><br><span class="line">    from flask import render_template</span><br><span class="line">    from flask import redirect</span><br><span class="line">    from flask import make_response</span><br><span class="line"></span><br><span class="line">    app &#x3D; Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @app.route(&#39;&#x2F;login.html&#39;, methods&#x3D;[&#39;GET&#39;, &quot;POST&quot;])</span><br><span class="line">    def login():</span><br><span class="line"></span><br><span class="line">        # 请求相关信息</span><br><span class="line">        # request.method</span><br><span class="line">        # request.args</span><br><span class="line">        # request.form</span><br><span class="line">        # request.values</span><br><span class="line">        # request.cookies</span><br><span class="line">        # request.headers</span><br><span class="line">        # request.path</span><br><span class="line">        # request.full_path</span><br><span class="line">        # request.script_root</span><br><span class="line">        # request.url</span><br><span class="line">        # request.base_url</span><br><span class="line">        # request.url_root</span><br><span class="line">        # request.host_url</span><br><span class="line">        # request.host</span><br><span class="line">        # request.files</span><br><span class="line">        # obj &#x3D; request.files[&#39;the_file_name&#39;]</span><br><span class="line">        # obj.save(&#39;&#x2F;var&#x2F;www&#x2F;uploads&#x2F;&#39; + secure_filename(f.filename))</span><br><span class="line"></span><br><span class="line">        # 响应相关信息</span><br><span class="line">        # return &quot;字符串&quot;</span><br><span class="line">        # return render_template(&#39;html模板路径&#39;,**&#123;&#125;)</span><br><span class="line">        # return redirect(&#39;&#x2F;index.html&#39;)</span><br><span class="line"></span><br><span class="line">        # response &#x3D; make_response(render_template(&#39;index.html&#39;))</span><br><span class="line">        # response是flask.wrappers.Response类型</span><br><span class="line">        # response.delete_cookie(&#39;key&#39;)</span><br><span class="line">        # response.set_cookie(&#39;key&#39;, &#39;value&#39;)</span><br><span class="line">        # response.headers[&#39;X-Something&#39;] &#x3D; &#39;A value&#39;</span><br><span class="line">        # return response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        return &quot;内容&quot;</span><br><span class="line"></span><br><span class="line">    if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">        app.run()</span><br></pre></td></tr></table></figure>
<h3 id="七-Session"><a href="#七-Session" class="headerlink" title="七. Session"></a>七. Session</h3><p>除请求对象之外，还有一个 session 对象。它允许你在不同请求间存储特定用户的信息。它是在 Cookies 的基础上实现的，并且对 Cookies 进行密钥签名要使用会话，你需要设置一个密钥。<br>设置：session[‘username’] ＝ ‘xxx’<br>删除：session.pop(‘username’, None)</p>
<ol>
<li>基本使用<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from flask import Flask, session, redirect, url_for, escape, request</span><br><span class="line"> </span><br><span class="line">app &#x3D; Flask(__name__)</span><br><span class="line"> </span><br><span class="line">@app.route(&#39;&#x2F;&#39;)</span><br><span class="line">def index():</span><br><span class="line">    if &#39;username&#39; in session:</span><br><span class="line">        return &#39;Logged in as %s&#39; % escape(session[&#39;username&#39;])</span><br><span class="line">    return &#39;You are not logged in&#39;</span><br><span class="line"> </span><br><span class="line">@app.route(&#39;&#x2F;login&#39;, methods&#x3D;[&#39;GET&#39;, &#39;POST&#39;])</span><br><span class="line">def login():</span><br><span class="line">    if request.method &#x3D;&#x3D; &#39;POST&#39;:</span><br><span class="line">        session[&#39;username&#39;] &#x3D; request.form[&#39;username&#39;]</span><br><span class="line">        return redirect(url_for(&#39;index&#39;))</span><br><span class="line">    return &#39;&#39;&#39;</span><br><span class="line">        &lt;form action&#x3D;&quot;&quot; method&#x3D;&quot;post&quot;&gt;</span><br><span class="line">            &lt;p&gt;&lt;input type&#x3D;text name&#x3D;username&gt;</span><br><span class="line">            &lt;p&gt;&lt;input type&#x3D;submit value&#x3D;Login&gt;</span><br><span class="line">        &lt;&#x2F;form&gt;</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line"> </span><br><span class="line">@app.route(&#39;&#x2F;logout&#39;)</span><br><span class="line">def logout():</span><br><span class="line">    # remove the username from the session if it&#39;s there</span><br><span class="line">    session.pop(&#39;username&#39;, None)</span><br><span class="line">    return redirect(url_for(&#39;index&#39;))</span><br><span class="line"> </span><br><span class="line"># set the secret key.  keep this really secret:</span><br><span class="line">app.secret_key &#x3D; &#39;A0Zr98j&#x2F;3yX R~XHH!jmN]LWX&#x2F;,?RT&#39;</span><br></pre></td></tr></table></figure></li>
<li>自定义Session<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install Flask-Session</span><br><span class="line">        </span><br><span class="line">        run.py</span><br><span class="line">            from flask import Flask</span><br><span class="line">            from flask import session</span><br><span class="line">            from pro_flask.utils.session import MySessionInterface</span><br><span class="line">            app &#x3D; Flask(__name__)</span><br><span class="line"></span><br><span class="line">            app.secret_key &#x3D; &#39;A0Zr98j&#x2F;3yX R~XHH!jmN]LWX&#x2F;,?RT&#39;</span><br><span class="line">            app.session_interface &#x3D; MySessionInterface()</span><br><span class="line"></span><br><span class="line">            @app.route(&#39;&#x2F;login.html&#39;, methods&#x3D;[&#39;GET&#39;, &quot;POST&quot;])</span><br><span class="line">            def login():</span><br><span class="line">                print(session)</span><br><span class="line">                session[&#39;user1&#39;] &#x3D; &#39;alex&#39;</span><br><span class="line">                session[&#39;user2&#39;] &#x3D; &#39;alex&#39;</span><br><span class="line">                del session[&#39;user2&#39;]</span><br><span class="line"></span><br><span class="line">                return &quot;内容&quot;</span><br><span class="line"></span><br><span class="line">            if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">                app.run()</span><br><span class="line"></span><br><span class="line">        session.py</span><br><span class="line">            #!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line">            # -*- coding:utf-8 -*-</span><br><span class="line">            import uuid</span><br><span class="line">            import json</span><br><span class="line">            from flask.sessions import SessionInterface</span><br><span class="line">            from flask.sessions import SessionMixin</span><br><span class="line">            from itsdangerous import Signer, BadSignature, want_bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            class MySession(dict, SessionMixin):</span><br><span class="line">                def __init__(self, initial&#x3D;None, sid&#x3D;None):</span><br><span class="line">                    self.sid &#x3D; sid</span><br><span class="line">                    self.initial &#x3D; initial</span><br><span class="line">                    super(MySession, self).__init__(initial or ())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                def __setitem__(self, key, value):</span><br><span class="line">                    super(MySession, self).__setitem__(key, value)</span><br><span class="line"></span><br><span class="line">                def __getitem__(self, item):</span><br><span class="line">                    return super(MySession, self).__getitem__(item)</span><br><span class="line"></span><br><span class="line">                def __delitem__(self, key):</span><br><span class="line">                    super(MySession, self).__delitem__(key)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            class MySessionInterface(SessionInterface):</span><br><span class="line">                session_class &#x3D; MySession</span><br><span class="line">                container &#x3D; &#123;&#125;</span><br><span class="line"></span><br><span class="line">                def __init__(self):</span><br><span class="line">                    import redis</span><br><span class="line">                    self.redis &#x3D; redis.Redis()</span><br><span class="line"></span><br><span class="line">                def _generate_sid(self):</span><br><span class="line">                    return str(uuid.uuid4())</span><br><span class="line"></span><br><span class="line">                def _get_signer(self, app):</span><br><span class="line">                    if not app.secret_key:</span><br><span class="line">                        return None</span><br><span class="line">                    return Signer(app.secret_key, salt&#x3D;&#39;flask-session&#39;,</span><br><span class="line">                                  key_derivation&#x3D;&#39;hmac&#39;)</span><br><span class="line"></span><br><span class="line">                def open_session(self, app, request):</span><br><span class="line">                    &quot;&quot;&quot;</span><br><span class="line">                    程序刚启动时执行，需要返回一个session对象</span><br><span class="line">                    &quot;&quot;&quot;</span><br><span class="line">                    sid &#x3D; request.cookies.get(app.session_cookie_name)</span><br><span class="line">                    if not sid:</span><br><span class="line">                        sid &#x3D; self._generate_sid()</span><br><span class="line">                        return self.session_class(sid&#x3D;sid)</span><br><span class="line"></span><br><span class="line">                    signer &#x3D; self._get_signer(app)</span><br><span class="line">                    try:</span><br><span class="line">                        sid_as_bytes &#x3D; signer.unsign(sid)</span><br><span class="line">                        sid &#x3D; sid_as_bytes.decode()</span><br><span class="line">                    except BadSignature:</span><br><span class="line">                        sid &#x3D; self._generate_sid()</span><br><span class="line">                        return self.session_class(sid&#x3D;sid)</span><br><span class="line"></span><br><span class="line">                    # session保存在redis中</span><br><span class="line">                    # val &#x3D; self.redis.get(sid)</span><br><span class="line">                    # session保存在内存中</span><br><span class="line">                    val &#x3D; self.container.get(sid)</span><br><span class="line"></span><br><span class="line">                    if val is not None:</span><br><span class="line">                        try:</span><br><span class="line">                            data &#x3D; json.loads(val)</span><br><span class="line">                            return self.session_class(data, sid&#x3D;sid)</span><br><span class="line">                        except:</span><br><span class="line">                            return self.session_class(sid&#x3D;sid)</span><br><span class="line">                    return self.session_class(sid&#x3D;sid)</span><br><span class="line"></span><br><span class="line">                def save_session(self, app, session, response):</span><br><span class="line">                    &quot;&quot;&quot;</span><br><span class="line">                    程序结束前执行，可以保存session中所有的值</span><br><span class="line">                    如：</span><br><span class="line">                        保存到resit</span><br><span class="line">                        写入到用户cookie</span><br><span class="line">                    &quot;&quot;&quot;</span><br><span class="line">                    domain &#x3D; self.get_cookie_domain(app)</span><br><span class="line">                    path &#x3D; self.get_cookie_path(app)</span><br><span class="line">                    httponly &#x3D; self.get_cookie_httponly(app)</span><br><span class="line">                    secure &#x3D; self.get_cookie_secure(app)</span><br><span class="line">                    expires &#x3D; self.get_expiration_time(app, session)</span><br><span class="line"></span><br><span class="line">                    val &#x3D; json.dumps(dict(session))</span><br><span class="line"></span><br><span class="line">                    # session保存在redis中</span><br><span class="line">                    # self.redis.setex(name&#x3D;session.sid, value&#x3D;val, time&#x3D;app.permanent_session_lifetime)</span><br><span class="line">                    # session保存在内存中</span><br><span class="line">                    self.container.setdefault(session.sid, val)</span><br><span class="line"></span><br><span class="line">                    session_id &#x3D; self._get_signer(app).sign(want_bytes(session.sid))</span><br><span class="line"></span><br><span class="line">                    response.set_cookie(app.session_cookie_name, session_id,</span><br><span class="line">                                        expires&#x3D;expires, httponly&#x3D;httponly,</span><br><span class="line">                                        domain&#x3D;domain, path&#x3D;path, secure&#x3D;secure)</span><br></pre></td></tr></table></figure></li>
<li>第三方Session<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">pip3 install redis</span><br><span class="line">pip3 install flask-session</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">from flask import Flask, session, redirect</span><br><span class="line">from flask.ext.session import Session</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app &#x3D; Flask(__name__)</span><br><span class="line">app.debug &#x3D; True</span><br><span class="line">app.secret_key &#x3D; &#39;asdfasdfasd&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.config[&#39;SESSION_TYPE&#39;] &#x3D; &#39;redis&#39;</span><br><span class="line">from redis import Redis</span><br><span class="line">app.config[&#39;SESSION_REDIS&#39;] &#x3D; Redis(host&#x3D;&#39;192.168.0.94&#39;,port&#x3D;&#39;6379&#39;)</span><br><span class="line">Session(app)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.route(&#39;&#x2F;login&#39;)</span><br><span class="line">def login():</span><br><span class="line">    session[&#39;username&#39;] &#x3D; &#39;alex&#39;</span><br><span class="line">    return redirect(&#39;&#x2F;index&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.route(&#39;&#x2F;index&#39;)</span><br><span class="line">def index():</span><br><span class="line">    name &#x3D; session[&#39;username&#39;]</span><br><span class="line">    return name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>
<h3 id="八-蓝图-Blueprint"><a href="#八-蓝图-Blueprint" class="headerlink" title="八. 蓝图(Blueprint)"></a>八. 蓝图(Blueprint)</h3>蓝图用于为应用提供目录划分：</li>
</ol>
<ul>
<li>小型应用程序：示例</li>
<li>大型应用程序：示例</li>
<li>其他：<ul>
<li>蓝图URL前缀：xxx = Blueprint(‘account’, <strong>name</strong>,url_prefix=’/xxx’)</li>
<li>蓝图子域名：xxx = Blueprint(‘account’, <strong>name</strong>,subdomain=’admin’)</li>
<li>前提需要给配置SERVER_NAME： app.config[‘SERVER_NAME’] = ‘<a href="http://www.shuke.com:5000&#39;">www.shuke.com:5000&#39;</a><br>访问时：<a href="http://www.shuke.com:5000/login.html" target="_blank" rel="noopener">www.shuke.com:5000/login.html</a></li>
</ul>
</li>
</ul>
<h3 id="九-闪现-message"><a href="#九-闪现-message" class="headerlink" title="九. 闪现(message)"></a>九. 闪现(message)</h3><p>message是一个基于Session实现的用于保存数据的集合，其特点是：使用一次就删除</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from flask import Flask, flash, redirect, render_template, request, get_flashed_messages</span><br><span class="line"></span><br><span class="line">        app &#x3D; Flask(__name__)</span><br><span class="line">        app.secret_key &#x3D; &#39;some_secret&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        @app.route(&#39;&#x2F;&#39;)</span><br><span class="line">        def index1():</span><br><span class="line">            messages &#x3D; get_flashed_messages()</span><br><span class="line">            print(messages)</span><br><span class="line">            return &quot;Index1&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        @app.route(&#39;&#x2F;set&#39;)</span><br><span class="line">        def index2():</span><br><span class="line">            v &#x3D; request.args.get(&#39;p&#39;)</span><br><span class="line">            flash(v)</span><br><span class="line">            return &#39;ok&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">            app.run()</span><br></pre></td></tr></table></figure>

<h3 id="十-中间件"><a href="#十-中间件" class="headerlink" title="十. 中间件"></a>十. 中间件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from flask import Flask, flash, redirect, render_template, request</span><br><span class="line"> </span><br><span class="line">app &#x3D; Flask(__name__)</span><br><span class="line">app.secret_key &#x3D; &#39;some_secret&#39;</span><br><span class="line"> </span><br><span class="line">@app.route(&#39;&#x2F;&#39;)</span><br><span class="line">def index1():</span><br><span class="line">    return render_template(&#39;index.html&#39;)</span><br><span class="line"> </span><br><span class="line">@app.route(&#39;&#x2F;set&#39;)</span><br><span class="line">def index2():</span><br><span class="line">    v &#x3D; request.args.get(&#39;p&#39;)</span><br><span class="line">    flash(v)</span><br><span class="line">    return &#39;ok&#39;</span><br><span class="line"> </span><br><span class="line">class MiddleWare:</span><br><span class="line">    def __init__(self,wsgi_app):</span><br><span class="line">        self.wsgi_app &#x3D; wsgi_app</span><br><span class="line"> </span><br><span class="line">    def __call__(self, *args, **kwargs):</span><br><span class="line"> </span><br><span class="line">        return self.wsgi_app(*args, **kwargs)</span><br><span class="line"> </span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    app.wsgi_app &#x3D; MiddleWare(app.wsgi_app)</span><br><span class="line">    app.run(port&#x3D;9999)</span><br></pre></td></tr></table></figure>

<h3 id="十一-请求扩展"><a href="#十一-请求扩展" class="headerlink" title="十一. 请求扩展"></a>十一. 请求扩展</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">from flask import Flask, Request, render_template</span><br><span class="line"></span><br><span class="line">app &#x3D; Flask(__name__, template_folder&#x3D;&#39;templates&#39;)</span><br><span class="line">app.debug &#x3D; True</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.before_first_request</span><br><span class="line">def before_first_request1():</span><br><span class="line">    print(&#39;before_first_request1&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.before_first_request</span><br><span class="line">def before_first_request2():</span><br><span class="line">    print(&#39;before_first_request2&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.before_request</span><br><span class="line">def before_request1():</span><br><span class="line">    Request.nnn &#x3D; 123</span><br><span class="line">    print(&#39;before_request1&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.before_request</span><br><span class="line">def before_request2():</span><br><span class="line">    print(&#39;before_request2&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.after_request</span><br><span class="line">def after_request1(response):</span><br><span class="line">    print(&#39;before_request1&#39;, response)</span><br><span class="line">    return response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.after_request</span><br><span class="line">def after_request2(response):</span><br><span class="line">    print(&#39;before_request2&#39;, response)</span><br><span class="line">    return response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.errorhandler(404)</span><br><span class="line">def page_not_found(error):</span><br><span class="line">    return &#39;This page does not exist&#39;, 404</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.template_global()</span><br><span class="line">def sb(a1, a2):</span><br><span class="line">    return a1 + a2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.template_filter()</span><br><span class="line">def db(a1, a2, a3):</span><br><span class="line">    return a1 + a2 + a3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.route(&#39;&#x2F;&#39;)</span><br><span class="line">def hello_world():</span><br><span class="line">    return render_template(&#39;hello.html&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>

<h3 id="十二-Flask插件"><a href="#十二-Flask插件" class="headerlink" title="十二. Flask插件"></a>十二. Flask插件</h3><ul>
<li>WTForms    </li>
<li>SQLAchemy</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://www.cnblogs.com/wupeiqi/articles/7552008.html" target="_blank" rel="noopener">Flask-武沛齐-博客园</a><br><a href="http://docs.jinkan.org/docs/flask/" target="_blank" rel="noopener">欢迎使用 Flask — Flask 0.10.1 文档</a><br><a href="http://flask.pocoo.org/docs/0.12/" target="_blank" rel="noopener">Welcome to Flask — Flask Documentation  (0.12)</a><br><a href="https://wizardforcel.gitbooks.io/explore-flask/content/index.html" target="_blank" rel="noopener">Flask 之旅</a> </p>
]]></content>
      <categories>
        <category>Flask</category>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>PYTHON</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>Django基于RBAC的权限组件</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h1 id="Django基于RBAC的权限组件"><a href="#Django基于RBAC的权限组件" class="headerlink" title="Django基于RBAC的权限组件"></a>Django基于RBAC的权限组件</h1><hr>

<h3 id="RBAC前奏"><a href="#RBAC前奏" class="headerlink" title="RBAC前奏"></a>RBAC前奏</h3><ol>
<li><p>RBAC概念<br>RBAC（Role-Based Access Control，基于角色的访问控制），就是用户通过角色与权限进行关联。简单地说，一个用户拥有若干角色，每一个角色拥有若干权限。这样，就构造成“用户-角色-权限”的授权模型。在这种模型中，用户与角色之间，角色与权限之间，一般者是多对多的关系。</p>
</li>
<li><p>扩展</p>
<ul>
<li>角色是什么？可以理解为一定数量的权限的集合，权限的载体。例如：一个论坛系统，“超级管理员”、“版主”都是角色。版主可管理版内的帖子、可管理版内的用户等，这些是权限。要给某个用户授予这些权限，不需要直接将权限授予用户，可将“版主”这个角色赋予该用户。 </li>
<li>当用户的数量非常大时，要给系统每个用户逐一授权（授角色），是件非常烦琐的事情。这时，就需要给用户分组，每个用户组内有多个用户。除了可给用户授权外，还可以给用户组授权。这样一来，用户拥有的所有权限，就是用户个人拥有的权限与该用户所在用户组拥有的权限之和。</li>
<li>在应用系统中，权限表现成什么？对功能模块的操作，对上传文件的删改，菜单的访问，甚至页面上某个按钮、某个图片的可见性控制，都可属于权限的范畴。有些权限设计，会把功能操作作为一类，而把文件、菜单、页面元素等作为另一类，这样构成“用户-角色-权限-资源”的授权模型。而在做数据表建模时，可把功能操作和资源统一管理，也就是都直接与权限表进行关联，这样可能更具便捷性和易扩展性。</li>
<li>请留意权限表中有一列“权限类型”，我们根据它的取值来区分是哪一类权限，如“MENU”表示菜单的访问权限、“OPERATION”表示功能模块的操作权限、“FILE”表示文件的修改权限、“ELEMENT”表示页面元素的可见性控制等。</li>
<li>这样设计的好处有二。其一，不需要区分哪些是权限操作，哪些是资源，（实际上，有时候也不好区分，如菜单，把它理解为资源呢还是功能模块权限呢？）。其二，方便扩展，当系统要对新的东西进行权限控制时，我只需要建立一个新的关联表“权限XX关联表”，并确定这类权限的权限类型字符串。</li>
<li>这里要注意的是，权限表与权限菜单关联表、权限菜单关联表与菜单表都是一对一的关系。（文件、页面权限点、功能操作等同理）。也就是每添加一个菜单，就得同时往这三个表中各插入一条记录。这样，可以不需要权限菜单关联表，让权限表与菜单表直接关联，此时，须在权限表中新增一列用来保存菜单的ID，权限表通过“权限类型”和这个ID来区分是种类型下的哪条记录。</li>
<li>随着系统的日益庞大，为了方便管理，可引入角色组对角色进行分类管理，跟用户组不同，角色组不参与授权。例如：某电网系统的权限管理模块中，角色就是挂在区局下，而区局在这里可当作角色组，它不参于权限分配。另外，为方便上面各主表自身的管理与查找，可采用树型结构，如菜单树、功能树等，当然这些可不需要参于权限分配。</li>
</ul>
</li>
<li><p>基于rbac的实现<br><a href="https://github.com/shonenada/flask-rbac" target="_blank" rel="noopener">flask-rbac</a><br><a href="https://pypi.python.org/pypi/simple-rbac/0.1.1" target="_blank" rel="noopener">simple-rbac</a></p>
</br>

</li>
</ol>
<h3 id="知识点储备"><a href="#知识点储备" class="headerlink" title="知识点储备"></a>知识点储备</h3><ol>
<li>Django ORM<br>常用的orm方法，all,values,values_list等<br>from models import User</li>
</ol>
<ul>
<li>all<br>models.User.objects.all(),返回值为queryset类型，形如：[obj,obj,obj]</li>
<li>values<br>models.User.objects.values(‘id’,’username’,’password’),返回值为queryset类型，形如：[{‘id’:1,’username’:’shuke’,’password’:’123456’}]</li>
<li>values_list<br>models.User.objects.values_list(‘id’,’username’,’password’),返回值为queryset类型，形如: [(1,’shuke’,’123456’),(2,’mary’,’123456’)]</li>
</ul>
<ol start="2">
<li>一对多及多对多</li>
</ol>
<ul>
<li>一对多（FK常用操作）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.db import models</span><br><span class="line">class A(models.Model):</span><br><span class="line">    name &#x3D; models.CharField(max_length&#x3D;32)</span><br><span class="line"></span><br><span class="line">class B(models.Model):</span><br><span class="line">    title &#x3D; models.CharField(max_length&#x3D;32)</span><br><span class="line">    fk &#x3D; models.ForeignKey(to&#x3D;&quot;A&quot;)</span><br><span class="line"># 跨表操作</span><br><span class="line">a. all()</span><br><span class="line">b_list &#x3D; models.B.objects.all()</span><br><span class="line">for item in b_list:</span><br><span class="line">    item.id</span><br><span class="line">    item.name</span><br><span class="line">    item.fk_id</span><br><span class="line">    item.fk</span><br><span class="line">    item.fk.name</span><br><span class="line">    item.fk.id</span><br><span class="line">b. values()</span><br><span class="line">b_list &#x3D; models.B.objects.values(&#39;id&#39;,&#39;name&#39;,&#39;fk_id&#39;,&#39;fk__name&#39;)</span><br><span class="line">for item in b_list:</span><br><span class="line">    item[&#39;id&#39;]</span><br><span class="line">    item[&#39;name&#39;]</span><br><span class="line">    item[&#39;fk_id&#39;]</span><br><span class="line">    item[&#39;fk__name&#39;]</span><br><span class="line">c. values_list()</span><br><span class="line">b_list &#x3D; models.B.objects.values_list(&#39;id&#39;,&#39;name&#39;,&#39;fk_id&#39;,&#39;fk__name&#39;)</span><br><span class="line">for item in b_list:</span><br><span class="line">    item[0]  # id</span><br><span class="line">    item[1]  # name</span><br><span class="line">    item[2]  # fk_id</span><br><span class="line">    item[3]  # fk__name</span><br><span class="line">d. 查找名称是&quot;Jack&quot;的用户所有B表中的数据</span><br><span class="line">models.B.objects.filter(fk__name&#x3D;&quot;Jack&quot;).all()</span><br></pre></td></tr></table></figure></li>
<li>多对多(ManyToMany)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.db import models</span><br><span class="line">class A(models.Model):</span><br><span class="line">    name &#x3D; models.CharField(max_length&#x3D;32)</span><br><span class="line"></span><br><span class="line">class B(models.Model):</span><br><span class="line">    title &#x3D; models.CharField(max_length&#x3D;32)</span><br><span class="line">    m2m &#x3D; models.ManyToMany(to&#x3D;&quot;A&quot;)</span><br><span class="line">PS: 自动会生成第3张表</span><br><span class="line">a. 在A和B表中各插入2条数据</span><br><span class="line">models.A.objects.create(name&#x3D;&quot;Jack&quot;)</span><br><span class="line">models.A.objects.create(name&#x3D;&quot;Mary&quot;)</span><br><span class="line"></span><br><span class="line">models.A.objects.create(title&#x3D;&quot;IT&quot;)</span><br><span class="line">models.A.objects.create(title&#x3D;&quot;CTO&quot;)</span><br><span class="line"></span><br><span class="line">b. CTO和[&#39;Jack&#39;,&#39;Mary&#39;]创建关系</span><br><span class="line">obj &#x3D; models.B.objects.get(title&#x3D;&quot;CTO&quot;)</span><br><span class="line">obj.m2m.add(1)   # 此处可以写id也可以写关联的A表中的obj</span><br><span class="line">obj.m2m.add(2)</span><br><span class="line"></span><br><span class="line">c. 查找CTO的关联的人</span><br><span class="line">obj &#x3D; models.B.objects.get(title&#x3D;&quot;CTO&quot;)</span><br><span class="line">obj.m2m.all()    # 得到一个QuerySet列表，内容为A表中的对象</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="3">
<li>中间件<br>中间件其实就是一个类，包含2个方法,形如:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MiddleWare:</span><br><span class="line">    # 所有的resquest请求都需要经过该方法,且该方法返回值为None时，继续请求下一个中间件</span><br><span class="line">    def process_request(self,request):</span><br><span class="line">        pass</span><br><span class="line">    def process_response(self,request,response):</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure></li>
</ol>
<p><em>注: 中间件编写完成后需要在settings文件中进行注册使用，注册时注意中间件顺序</em></p>
<ol start="4">
<li>Session与Cookie的区别</li>
</ol>
<ul>
<li>由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session.典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的，使用一些缓存服务比如Memcached之类的来放 Session。</li>
<li>思考一下服务端如何识别特定的客户？这个时候Cookie就登场了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。有人问，如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。</li>
<li>Cookie其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到Cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是Cookie名称的由来，给用户的一点甜头。</li>
<li>总结：Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。</li>
</ul>
<ol start="5">
<li>正则模块re<br>re.match()方法<br>决定RE是否在字符串刚开始的位置匹配,返回_sre.SRE_Match对象，如果不能匹配返回None。<br>注：这个方法并不是完全匹配。当pattern结束时若string还有剩余字符，仍然视为成功。想要完全匹配，可以在表达式末尾加上边界匹配符’$’<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">re.match(pattern, string, flags&#x3D;0)</span><br><span class="line"></span><br><span class="line">print(re.match(&#39;com&#39;,&#39;comwww.runcomoob&#39;).group())</span><br><span class="line">print(re.match(&#39;com&#39;,&#39;Comwww.runcomoob&#39;,re.I).group())</span><br><span class="line">执行结果如下：</span><br><span class="line">com</span><br><span class="line">com</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
</br>

<h3 id="RBAC实现"><a href="#RBAC实现" class="headerlink" title="RBAC实现"></a>RBAC实现</h3><h4 id="开发RBAC流程"><a href="#开发RBAC流程" class="headerlink" title="开发RBAC流程"></a>开发RBAC流程</h4><ol>
<li>表结构设计</li>
<li>Django Admin录入数据</li>
<li>用户登陆<ul>
<li>获取角色</li>
<li>获取权限</li>
<li>对权限URL进行去重</li>
</ul>
</li>
<li>生成权限结构信息，写入session中<br>{<br> 1: {<pre><code>&apos;urls&apos;: [&apos;/userinfo/&apos;, &apos;/userinfo/add/&apos;, &apos;/userinfo/(\\d+)/delete/&apos;, &apos;/userinfo/(\\d+)/change/&apos;],
&apos;codes&apos;: [&apos;list&apos;, &apos;add&apos;, &apos;del&apos;, &apos;edit&apos;]</code></pre> },<br> 2: {<pre><code>&apos;urls&apos;: [&apos;/order/&apos;, &apos;/order/add/&apos;, &apos;/order/(\\d+)/delete/&apos;, &apos;/order/(\\d+)/change/&apos;],
&apos;codes&apos;: [&apos;list&apos;, &apos;add&apos;, &apos;del&apos;, &apos;edit&apos;]</code></pre> }<br>}</li>
<li>注册中间件<ul>
<li>白名单</li>
<li>获取当前访问url: request.path_info</li>
<li>session中获取权限，进行权限访问验证</li>
</ul>
</li>
<li>自动生成菜单功能<ul>
<li>采用自定义tag方式实现(inclusion_tag)</li>
<li>作为模板使用{ menu_html request }方式导入html文件中使用</li>
</ul>
</li>
<li>通过Django Admin后台进行管理及维护工作 </br>

</li>
</ol>
<h4 id="Django-ORM表结构设计"><a href="#Django-ORM表结构设计" class="headerlink" title="Django ORM表结构设计"></a>Django ORM表结构设计</h4><p><strong>5个类6张表</strong></p>
<ol>
<li>菜单表<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Menu(models.Models):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    菜单表</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    title &#x3D; models.CharField(max_length&#x3D;32,verbose_name&#x3D;&#39;菜单标题&#39;)</span><br><span class="line">    </span><br><span class="line">     # django admin后台显示用</span><br><span class="line">    class Meta:</span><br><span class="line">        verbose_name_plural &#x3D; &quot;菜单表&quot;</span><br><span class="line">    # 重写__str__方法，实例化后的对象将以字符串的形式展示，但实际是一个obj,所以，请不要相信你的眼睛，必要时使用type(arg)进行验证</span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.title</span><br></pre></td></tr></table></figure></li>
<li>权限组表<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Group(models.Model):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    权限组</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    caption &#x3D; models.CharField(max_length&#x3D;32, verbose_name&#x3D;&quot;组名称&quot;)</span><br><span class="line">    menu &#x3D; models.ForeignKey(to&#x3D;&quot;Menu&quot;, default&#x3D;1, blank&#x3D;True, verbose_name&#x3D;&quot;关联的菜单&quot;)</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        verbose_name_plural &#x3D; &quot;权限组&quot;</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.caption</span><br></pre></td></tr></table></figure></li>
<li>权限表<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Permission(models.Model):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    权限表</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    title &#x3D; models.CharField(max_length&#x3D;32, verbose_name&#x3D;&quot;标题&quot;)</span><br><span class="line">    url &#x3D; models.CharField(max_length&#x3D;128, verbose_name&#x3D;&quot;含正则的URL&quot;)</span><br><span class="line">    # menu_gp为null说明是title为菜单项</span><br><span class="line">    menu_gp &#x3D; models.ForeignKey(to&#x3D;&quot;Permission&quot;, null&#x3D;True, blank&#x3D;True, verbose_name&#x3D;&quot;默认选中的组内权限ID&quot;, related_name&#x3D;&quot;pm&quot;)</span><br><span class="line">    code &#x3D; models.CharField(max_length&#x3D;16, verbose_name&#x3D;&quot;权限码&quot;)</span><br><span class="line">    group &#x3D; models.ForeignKey(to&#x3D;&quot;Group&quot;, blank&#x3D;True, verbose_name&#x3D;&quot;所属组&quot;)</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        verbose_name_plural &#x3D; &quot;权限表&quot;</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.title</span><br></pre></td></tr></table></figure></li>
<li>用户表<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class User(models.Model):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    用户表</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    username &#x3D; models.CharField(max_length&#x3D;32, verbose_name&#x3D;&quot;用户名&quot;)</span><br><span class="line">    password &#x3D; models.CharField(max_length&#x3D;64, verbose_name&#x3D;&quot;密码&quot;)</span><br><span class="line">    email &#x3D; models.CharField(max_length&#x3D;32, verbose_name&#x3D;&quot;邮箱&quot;)</span><br><span class="line">    roles &#x3D; models.ManyToManyField(to&#x3D;&quot;Role&quot;, blank&#x3D;True, verbose_name&#x3D;&quot;用户关联的角色&quot;)</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        verbose_name_plural &#x3D; &quot;用户表&quot;</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.username</span><br></pre></td></tr></table></figure></li>
<li>角色表<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Role(models.Model):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    角色表</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    title &#x3D; models.CharField(max_length&#x3D;32, verbose_name&#x3D;&quot;角色名称&quot;)</span><br><span class="line">    permissions &#x3D; models.ManyToManyField(to&#x3D;&quot;Permission&quot;, blank&#x3D;True, verbose_name&#x3D;&quot;角色关联的权限&quot;)</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        verbose_name_plural &#x3D; &quot;角色表&quot;</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.title</span><br></pre></td></tr></table></figure></li>
<li>附加</li>
</ol>
<ul>
<li>创建数据库表结构信息</li>
<li>创建超级用户</li>
<li>在admin.py中注册models类</li>
<li>登陆admin管理后台添加数据，进行管理</li>
</ul>
</br>

<h3 id="settings中添加配置项"><a href="#settings中添加配置项" class="headerlink" title="settings中添加配置项"></a>settings中添加配置项</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在文件末尾添加配置信息</span><br><span class="line"></span><br><span class="line">vim projectname&#x2F;settings.py</span><br><span class="line"># ########################### 权限管理相关 ###########################3</span><br><span class="line">PERMISSION_MENU_KEY &#x3D; &quot;asdkjalsdf9uajsdf&quot;</span><br><span class="line">PERMISSION_URL_DICT_KEY &#x3D; &quot;iujmsufnsdflsdkf&quot;</span><br><span class="line"></span><br><span class="line">VALID_URL&#x3D; [</span><br><span class="line">    &#39;^&#x2F;login&#x2F;&#39;,</span><br><span class="line">    &quot;^&#x2F;admin*&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>


<h4 id="初始化权限信息"><a href="#初始化权限信息" class="headerlink" title="初始化权限信息"></a>初始化权限信息</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#cat rbac&#x2F;service&#x2F;init_permission.py</span><br><span class="line"></span><br><span class="line">from django.conf import settings</span><br><span class="line"></span><br><span class="line">def init_permission(request,user):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    用户权限信息初始化，获取当前用户所有权限信息，并保存到Session中</span><br><span class="line">    此处的request以及user参数均为对象，user为登陆成功时在数据库中查询到的user对象</span><br><span class="line">    :param request:</span><br><span class="line">    :param user:</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    # 去空去重</span><br><span class="line">    permission_list &#x3D; user.roles.filter(permissions__id__isnull&#x3D;False).values(</span><br><span class="line">        &#39;permissions__id&#39;,</span><br><span class="line">        &#39;permissions__title&#39;,                # 用户列表</span><br><span class="line">        &#39;permissions__url&#39;,</span><br><span class="line">        &#39;permissions__code&#39;,</span><br><span class="line">        &#39;permissions__menu_gp_id&#39;,           # 组内菜单ID，Null表示是菜单</span><br><span class="line">        &#39;permissions__group_id&#39;,             # 权限的组ID</span><br><span class="line">        &#39;permissions__group__menu_id&#39;,       # 当前权限所在组的菜单ID</span><br><span class="line">        &#39;permissions__group__menu__title&#39;,   # 当前权限所在组的菜单名称</span><br><span class="line">    ).distinct()</span><br><span class="line">    </span><br><span class="line">    # 菜单相关配置，在inclusion_tag中使用</span><br><span class="line">    menu_permission_list&#x3D; []</span><br><span class="line">    for item in permission_list:</span><br><span class="line">        tpl &#x3D; &#123;</span><br><span class="line">            &#39;id&#39;: item[&#39;permissions__id&#39;],</span><br><span class="line">            &#39;title&#39;: item[&#39;permissions__title&#39;],</span><br><span class="line">            &#39;url&#39;: item[&#39;permissions__url&#39;],</span><br><span class="line">            &#39;menu_gp_id&#39;: item[&#39;permissions_menu_gp_id&#39;],</span><br><span class="line">            &#39;menu_id&#39;: item[&#39;permissions__group__menu_id&#39;],</span><br><span class="line">            &#39;menu_title&#39;: item[&#39;permissions__group__menu__title&#39;] </span><br><span class="line">        &#125;</span><br><span class="line">        menu_permission_list.append(tpl)</span><br><span class="line">        request.session[settings.PERMISSION_MENU_KEY] &#x3D; menu_permission_list</span><br><span class="line">        # 形如</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        &#123;&quot;url&quot;: &quot;&#x2F;host&#x2F;&quot;,&quot;menu_title&quot;: &quot;主机管理&quot;,&quot;title&quot;: &quot;主机列表&quot;,&quot;id&quot;: 1,&quot;menu_gp_id&quot;: null,&quot;menu_id&quot;: 1&#125;,</span><br><span class="line">        &#123;&quot;url&quot;: &quot;&#x2F;host&#x2F;add&#x2F;&quot;,&quot;menu_title&quot;: &quot;主机管理&quot;,&quot;title&quot;: &quot;添加主机&quot;,&quot;id&quot;: 2,&quot;menu_gp_id&quot;: 1,&quot;menu_id&quot;: 1&#125;,</span><br><span class="line">        &#123;&quot;url&quot;: &quot;&#x2F;host&#x2F;(\\d+)&#x2F;delete&#x2F;&quot;,&quot;menu_title&quot;: &quot;主机管理&quot;,&quot;title&quot;: &quot;删除主机&quot;,&quot;id&quot;: 3,&quot;menu_gp_id&quot;: 1,&quot;menu_id&quot;: 1&#125;,</span><br><span class="line">        &#123;&quot;url&quot;: &quot;&#x2F;host&#x2F;(\\d+)&#x2F;change&#x2F;&quot;,&quot;menu_title&quot;: &quot;主机管理&quot;,&quot;title&quot;: &quot;修改主机&quot;,&quot;id&quot;: 4,&quot;menu_gp_id&quot;: 1,&quot;menu_id&quot;: 1&#125;</span><br><span class="line">        &#123;&quot;url&quot;: &quot;&#x2F;userinfo&#x2F;&quot;,&quot;menu_title&quot;: &quot;用户管理&quot;,&quot;title&quot;: &quot;用户列表&quot;,&quot;id&quot;: 5,&quot;menu_gp_id&quot;: null,&quot;menu_id&quot;: 2&#125;,</span><br><span class="line">        &#123;&quot;url&quot;: &quot;&#x2F;userinfo&#x2F;add&#x2F;&quot;,&quot;menu_title&quot;: &quot;用户管理&quot;,&quot;title&quot;: &quot;添加用户&quot;,&quot;id&quot;: 6,&quot;menu_gp_id&quot;: 5,&quot;menu_id&quot;: 2&#125;,</span><br><span class="line">        ......</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    # 权限相关，中间件使用</span><br><span class="line">    permission_dict &#x3D; &#123;&#125;</span><br><span class="line">    for item in permission_list:</span><br><span class="line">        group_id &#x3D; item[&#39;permissions__group_id&#39;]</span><br><span class="line">        code &#x3D; item[&#39;permissions__code&#39;]</span><br><span class="line">        url &#x3D; item[&#39;permissions__url&#39;]</span><br><span class="line">        if group_id in permission_dict:</span><br><span class="line">            permission_dict[group_id][&#39;codes&#39;].append(code)</span><br><span class="line">            permission_dict[group_id][&#39;urls&#39;].append(url)</span><br><span class="line">        else:</span><br><span class="line">            permission_dict[group_id] &#x3D; &#123;&quot;codes&quot;: [code, ], &quot;urls&quot;: [url, ]&#125;</span><br><span class="line">    request.session[settings.PERMISSION_URL_DICT_KEY] &#x3D; permission_dict</span><br><span class="line">    # 形如</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;1&quot;: &#123;</span><br><span class="line">            &quot;codes&quot;: [&quot;list&quot;,&quot;add&quot;,&quot;delete&quot;,&quot;edit&quot;],</span><br><span class="line">            &quot;urls&quot;: [&quot;&#x2F;host&#x2F;&quot;,&quot;&#x2F;host&#x2F;add&#x2F;&quot;,&quot;&#x2F;host&#x2F;(\\d+)&#x2F;delete&#x2F;&quot;,&quot;&#x2F;host&#x2F;(\\d+)&#x2F;change&#x2F;&quot;]</span><br><span class="line">         &#125;,</span><br><span class="line">        &quot;2&quot;: &#123;</span><br><span class="line">            &quot;codes&quot;: [&quot;list&quot;,&quot;add&quot;,&quot;delete&quot;,&quot;change&quot;],</span><br><span class="line">            &quot;urls&quot;: [&quot;&#x2F;userinfo&#x2F;&quot;,&quot;&#x2F;userinfo&#x2F;add&#x2F;&quot;,&quot;&#x2F;userinfo&#x2F;(\\d+)&#x2F;delete&#x2F;&quot;,&quot;&#x2F;userinfo&#x2F;(\\d+)&#x2F;change&#x2F;&quot;]</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &quot;&quot;&quot;</span><br></pre></td></tr></table></figure>
<p><em>注: 用户登陆成功后进行初始化权限信息,在处理用户权限时需要进行数据去重</em></p>
<h3 id="菜单List及权限Dict格式如下所示："><a href="#菜单List及权限Dict格式如下所示：" class="headerlink" title="菜单List及权限Dict格式如下所示："></a>菜单List及权限Dict格式如下所示：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 菜单List request.session[settings.PERMISSION_MENU_KEY]</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;url&quot;: &quot;&#x2F;host&#x2F;&quot;,</span><br><span class="line">        &quot;menu_title&quot;: &quot;主机管理&quot;,</span><br><span class="line">        &quot;title&quot;: &quot;主机列表&quot;,</span><br><span class="line">        &quot;id&quot;: 1,</span><br><span class="line">        &quot;menu_gp_id&quot;: null,</span><br><span class="line">        &quot;menu_id&quot;: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;url&quot;: &quot;&#x2F;host&#x2F;add&#x2F;&quot;,</span><br><span class="line">        &quot;menu_title&quot;: &quot;主机管理&quot;,</span><br><span class="line">        &quot;title&quot;: &quot;添加主机&quot;,</span><br><span class="line">        &quot;id&quot;: 2,</span><br><span class="line">        &quot;menu_gp_id&quot;: 1,</span><br><span class="line">        &quot;menu_id&quot;: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;url&quot;: &quot;&#x2F;host&#x2F;(\\d+)&#x2F;delete&#x2F;&quot;,</span><br><span class="line">        &quot;menu_title&quot;: &quot;主机管理&quot;,</span><br><span class="line">        &quot;title&quot;: &quot;删除主机&quot;,</span><br><span class="line">        &quot;id&quot;: 3,</span><br><span class="line">        &quot;menu_gp_id&quot;: 1,</span><br><span class="line">        &quot;menu_id&quot;: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;url&quot;: &quot;&#x2F;host&#x2F;(\\d+)&#x2F;change&#x2F;&quot;,</span><br><span class="line">        &quot;menu_title&quot;: &quot;主机管理&quot;,</span><br><span class="line">        &quot;title&quot;: &quot;修改主机&quot;,</span><br><span class="line">        &quot;id&quot;: 4,</span><br><span class="line">        &quot;menu_gp_id&quot;: 1,</span><br><span class="line">        &quot;menu_id&quot;: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;url&quot;: &quot;&#x2F;userinfo&#x2F;&quot;,</span><br><span class="line">        &quot;menu_title&quot;: &quot;用户管理&quot;,</span><br><span class="line">        &quot;title&quot;: &quot;用户列表&quot;,</span><br><span class="line">        &quot;id&quot;: 5,</span><br><span class="line">        &quot;menu_gp_id&quot;: null,</span><br><span class="line">        &quot;menu_id&quot;: 2</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;url&quot;: &quot;&#x2F;userinfo&#x2F;add&#x2F;&quot;,</span><br><span class="line">        &quot;menu_title&quot;: &quot;用户管理&quot;,</span><br><span class="line">        &quot;title&quot;: &quot;添加用户&quot;,</span><br><span class="line">        &quot;id&quot;: 6,</span><br><span class="line">        &quot;menu_gp_id&quot;: 5,</span><br><span class="line">        &quot;menu_id&quot;: 2</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;url&quot;: &quot;&#x2F;userinfo&#x2F;(\\d+)&#x2F;delete&#x2F;&quot;,</span><br><span class="line">        &quot;menu_title&quot;: &quot;用户管理&quot;,</span><br><span class="line">        &quot;title&quot;: &quot;删除用户&quot;,</span><br><span class="line">        &quot;id&quot;: 7,</span><br><span class="line">        &quot;menu_gp_id&quot;: 5,</span><br><span class="line">        &quot;menu_id&quot;: 2</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;url&quot;: &quot;&#x2F;userinfo&#x2F;(\\d+)&#x2F;change&#x2F;&quot;,</span><br><span class="line">        &quot;menu_title&quot;: &quot;用户管理&quot;,</span><br><span class="line">        &quot;title&quot;: &quot;修改用户&quot;,</span><br><span class="line">        &quot;id&quot;: 8,</span><br><span class="line">        &quot;menu_gp_id&quot;: 5,</span><br><span class="line">        &quot;menu_id&quot;: 2</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"># 权限Dict request.session[settings.PERMISSION_URL_DICT_KEY]</span><br><span class="line">&#123;</span><br><span class="line">    &quot;1&quot;: &#123;</span><br><span class="line">        &quot;codes&quot;: [</span><br><span class="line">            &quot;list&quot;,</span><br><span class="line">            &quot;add&quot;,</span><br><span class="line">            &quot;delete&quot;,</span><br><span class="line">            &quot;edit&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;urls&quot;: [</span><br><span class="line">            &quot;&#x2F;host&#x2F;&quot;,</span><br><span class="line">            &quot;&#x2F;host&#x2F;add&#x2F;&quot;,</span><br><span class="line">            &quot;&#x2F;host&#x2F;(\\d+)&#x2F;delete&#x2F;&quot;,</span><br><span class="line">            &quot;&#x2F;host&#x2F;(\\d+)&#x2F;change&#x2F;&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;2&quot;: &#123;</span><br><span class="line">        &quot;codes&quot;: [</span><br><span class="line">            &quot;list&quot;,</span><br><span class="line">            &quot;add&quot;,</span><br><span class="line">            &quot;delete&quot;,</span><br><span class="line">            &quot;change&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;urls&quot;: [</span><br><span class="line">            &quot;&#x2F;userinfo&#x2F;&quot;,</span><br><span class="line">            &quot;&#x2F;userinfo&#x2F;add&#x2F;&quot;,</span><br><span class="line">            &quot;&#x2F;userinfo&#x2F;(\\d+)&#x2F;delete&#x2F;&quot;,</span><br><span class="line">            &quot;&#x2F;userinfo&#x2F;(\\d+)&#x2F;change&#x2F;&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</br>

<h4 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat rbac&#x2F;middleware&#x2F;rbac.py</span><br><span class="line"></span><br><span class="line">from django.shortcuts import redirect,HttpResponse</span><br><span class="line">from django.conf import settings</span><br><span class="line"></span><br><span class="line"># 在后续版本中可能会被废弃，故在此直接引入</span><br><span class="line">#from django.utils.deprecation import MiddlewareMixin</span><br><span class="line">class MiddlewareMixin(object):</span><br><span class="line">    def __init__(self, get_response&#x3D;None):</span><br><span class="line">        self.get_response &#x3D; get_response</span><br><span class="line">        super(MiddlewareMixin, self).__init__()</span><br><span class="line"></span><br><span class="line">    def __call__(self, request):</span><br><span class="line">        response &#x3D; None</span><br><span class="line">        if hasattr(self, &#39;process_request&#39;):</span><br><span class="line">            response &#x3D; self.process_request(request)</span><br><span class="line">        if not response:</span><br><span class="line">            response &#x3D; self.get_response(request)</span><br><span class="line">        if hasattr(self, &#39;process_response&#39;):</span><br><span class="line">            response &#x3D; self.process_response(request, response)</span><br><span class="line">        return response</span><br><span class="line"></span><br><span class="line">class RbacMiddleware(MiddlewareMixin):</span><br><span class="line">    def process_request(self,request):</span><br><span class="line">        # 1. 当前请求URL</span><br><span class="line">        current_request_url &#x3D; request.path_info</span><br><span class="line"></span><br><span class="line">        # 2. 处理白名单,如login及admin页面需开放访问权限，根据实际情况而定</span><br><span class="line">        for url in settings.VALID_URL_LIST:</span><br><span class="line">            if re.match(url,current_request_url):</span><br><span class="line">                return None</span><br><span class="line"></span><br><span class="line">        # 3. 获取session中保存的权限信息</span><br><span class="line">        permission_dict &#x3D; request.session.get(settings.PERMISSION_MENU_LIST)</span><br><span class="line">        if not permission_dict:</span><br><span class="line">            # 登陆页面</span><br><span class="line">            return redirect(settings.RBAC_LOGIN_URL)</span><br><span class="line"></span><br><span class="line">        flag &#x3D; False</span><br><span class="line">        for group_id, values in permission_dict.items():</span><br><span class="line">            for url in values[&#39;urls&#39;]:</span><br><span class="line">                regex &#x3D; settings.URL_FORMAT.format(url)</span><br><span class="line">                if re.match(regex, current_request_url):</span><br><span class="line">                    flag &#x3D; True</span><br><span class="line">                    break</span><br><span class="line">            if flag:</span><br><span class="line">                break</span><br><span class="line">        if not flag:</span><br><span class="line">            # 无权访问页面，可以直接redirect</span><br><span class="line">            return HttpResponse(&#39;无权访问&#39;)</span><br></pre></td></tr></table></figure>
</br>

<h4 id="自动生成菜单template-tags"><a href="#自动生成菜单template-tags" class="headerlink" title="自动生成菜单template tags"></a>自动生成菜单template tags</h4><ol>
<li>template tags部分<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># __author__ &#x3D; &quot;shuke&quot;</span><br><span class="line"># Date: 2017&#x2F;11&#x2F;20</span><br><span class="line"></span><br><span class="line">from django.conf import settings</span><br><span class="line">from django.template import Library</span><br><span class="line">import re</span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line">register &#x3D; Library()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@register.inclusion_tag(&#39;menu.html&#39;)</span><br><span class="line">def menu_html(request):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    获取session中的菜单信息，匹配当前URL，生成菜单</span><br><span class="line">    :param request: 请求的requst对象</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    menu_list &#x3D; request.session.get(settings.PERMISSION_MENU_KEY)</span><br><span class="line">    # 当前请求URL</span><br><span class="line">    current_url &#x3D; request.path_info</span><br><span class="line"></span><br><span class="line">    menu_dict &#x3D; &#123;&#125;</span><br><span class="line">    # menu_gp_id为空则是菜单</span><br><span class="line">    for item in menu_list:</span><br><span class="line">        if not item[&#39;menu_gp_id&#39;]:</span><br><span class="line">            menu_dict[item[&#39;id&#39;]] &#x3D; item</span><br><span class="line"></span><br><span class="line">    for item in menu_list:</span><br><span class="line">        regax &#x3D; &quot;^&#123;0&#125;$&quot;.format(item[&#39;url&#39;])</span><br><span class="line">        if re.match(regax, current_url):</span><br><span class="line">            menu_gp_id &#x3D; item[&#39;menu_gp_id&#39;]</span><br><span class="line">            if menu_gp_id:</span><br><span class="line">                menu_dict[menu_gp_id][&#39;active&#39;] &#x3D; True</span><br><span class="line">            else:</span><br><span class="line">                menu_dict[item[&#39;id&#39;]][&#39;active&#39;] &#x3D; True</span><br><span class="line"></span><br><span class="line">    result &#x3D; &#123;&#125;</span><br><span class="line">    for item in menu_dict.values():</span><br><span class="line">        active &#x3D; item.get(&#39;active&#39;)</span><br><span class="line">        menu_id &#x3D; item[&#39;menu_id&#39;]</span><br><span class="line">        if menu_id in result:</span><br><span class="line">            result[menu_id][&#39;children&#39;].append(&#123;&#39;title&#39;: item[&#39;title&#39;], &#39;url&#39;: item[&#39;url&#39;], &#39;active&#39;: active&#125;)</span><br><span class="line">            if active:</span><br><span class="line">                result[menu_id][&#39;active&#39;] &#x3D; True</span><br><span class="line">        else:</span><br><span class="line">            result[menu_id] &#x3D; &#123;</span><br><span class="line">                &#39;menu_id&#39;: item[&#39;menu_id&#39;],</span><br><span class="line">                &#39;menu_title&#39;: item[&#39;menu_title&#39;],</span><br><span class="line">                &#39;active&#39;: active,</span><br><span class="line">                &#39;children&#39;: [</span><br><span class="line">                    &#123;&#39;title&#39;: item[&#39;title&#39;], &#39;url&#39;: item[&#39;url&#39;], &#39;active&#39;: active&#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">    print(json.dumps(result, indent&#x3D;4, ensure_ascii&#x3D;False))</span><br><span class="line">    return &#123;&#39;menu_dict&#39;: result&#125;</span><br></pre></td></tr></table></figure></li>
<li>生成的菜单树格式如下<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;1&quot;: &#123;</span><br><span class="line">        &quot;children&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;url&quot;: &quot;&#x2F;host&#x2F;&quot;,</span><br><span class="line">                &quot;active&quot;: null,</span><br><span class="line">                &quot;title&quot;: &quot;主机列表&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        &quot;menu_id&quot;: 1,</span><br><span class="line">        &quot;menu_title&quot;: &quot;主机管理&quot;,</span><br><span class="line">        &quot;active&quot;: null</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;2&quot;: &#123;</span><br><span class="line">        &quot;children&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;url&quot;: &quot;&#x2F;userinfo&#x2F;&quot;,</span><br><span class="line">                &quot;active&quot;: null,</span><br><span class="line">                &quot;title&quot;: &quot;用户列表&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        &quot;menu_id&quot;: 2,</span><br><span class="line">        &quot;menu_title&quot;: &quot;用户管理&quot;,</span><br><span class="line">        &quot;active&quot;: null</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>menu_tpl.html部分<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% for k,item in menu_dict.items %&#125;</span><br><span class="line">    &lt;div class&#x3D;&quot;item&quot;&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;item-title&quot;&gt; &#123;&#123; item.menu_title &#125;&#125; &lt;&#x2F;div&gt;</span><br><span class="line">        &#123;% if item.active %&#125;</span><br><span class="line">            &lt;div class&#x3D;&quot;item-permission&quot;&gt;</span><br><span class="line">        &#123;% else %&#125;</span><br><span class="line">            &lt;div class&#x3D;&quot;item-permission hide&quot;&gt;</span><br><span class="line">        &#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">            &#123;% for v in item.children %&#125;</span><br><span class="line">                &#123;% if v.active %&#125;</span><br><span class="line">                    &lt;a href&#x3D;&quot;&#123;&#123; v.url &#125;&#125;&quot; class&#x3D;&quot;active&quot;&gt;&#123;&#123; v.title &#125;&#125;&lt;&#x2F;a&gt;</span><br><span class="line">                &#123;% else %&#125;</span><br><span class="line">                    &lt;a href&#x3D;&quot;&#123;&#123; v.url &#125;&#125;&quot;&gt;&#123;&#123; v.title &#125;&#125;&lt;&#x2F;a&gt;</span><br><span class="line">                &#123;% endif %&#125;</span><br><span class="line">            &#123;% endfor %&#125;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure></li>
<li>HTML部分使用tags<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 上文中的menu_html函数依赖request参数，此处需要传入</span><br><span class="line">&#123; load rbac &#125;</span><br><span class="line">&#123; menu_html request &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><em>注: 自定义tags只支持传入1个参数</em><br></br></p>
<h4 id="注册中间件使用"><a href="#注册中间件使用" class="headerlink" title="注册中间件使用"></a>注册中间件使用</h4><p>project/settings.py</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MIDDLEWARE &#x3D; [</span><br><span class="line">    &#39;django.middleware.security.SecurityMiddleware&#39;,</span><br><span class="line">    &#39;django.contrib.sessions.middleware.SessionMiddleware&#39;,</span><br><span class="line">    &#39;django.middleware.common.CommonMiddleware&#39;,</span><br><span class="line">    &#39;django.middleware.csrf.CsrfViewMiddleware&#39;,</span><br><span class="line">    &#39;django.contrib.auth.middleware.AuthenticationMiddleware&#39;,</span><br><span class="line">    &#39;django.contrib.messages.middleware.MessageMiddleware&#39;,</span><br><span class="line">    &#39;django.middleware.clickjacking.XFrameOptionsMiddleware&#39;,</span><br><span class="line">    &#39;rbac.middleware.rbac.RbacMiddleware&#39;,</span><br><span class="line"></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h4 id="维护"><a href="#维护" class="headerlink" title="维护"></a>维护</h4><p>在Django Admin中维护rbac的权限系统并使用<br></br></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，基于role实现的rbac组件基本开发完成，在Django中作为app引入在settings文件中注册后就可以生效使用了,engoy it!</p>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask知识点总结</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<blockquote class="blockquote-center">优秀的人，不是不合群，而是他们合群的人里面没有你</blockquote>


<h2 id="Python-中更优雅的日志记录方案"><a href="#Python-中更优雅的日志记录方案" class="headerlink" title="Python 中更优雅的日志记录方案"></a>Python 中更优雅的日志记录方案</h2><p>在 Python 中，一般情况下我们可能直接用自带的 logging 模块来记录日志，包括我之前的时候也是一样。在使用时我们需要配置一些 Handler、Formatter 来进行一些处理，比如把日志输出到不同的位置，或者设置一个不同的输出格式，或者设置日志分块和备份。但其实个人感觉 logging 用起来其实并不是那么好用，其实主要还是配置较为繁琐.</p>
<h2 id="常见使用"><a href="#常见使用" class="headerlink" title="常见使用"></a>常见使用</h2><p>首先看看 logging 常见的解决方案吧，我一般会配置输出到文件、控制台和 Elasticsearch。输出到控制台就仅仅是方便直接查看的；输出到文件是方便直接存储，保留所有历史记录的备份；输出到 Elasticsearch，直接将 Elasticsearch 作为存储和分析的中心，使用 Kibana 可以非常方便地分析和查看运行情况。<br>所以在这里我基本会对 logging 做如下的封装写法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mport logging</span><br><span class="line">import sys</span><br><span class="line">from os import makedirs</span><br><span class="line">from os.path import dirname, exists</span><br><span class="line"></span><br><span class="line">from cmreslogging.handlers import CMRESHandler</span><br><span class="line"></span><br><span class="line">loggers &#x3D; &#123;&#125;</span><br><span class="line"></span><br><span class="line">LOG_ENABLED &#x3D; True  # 是否开启日志</span><br><span class="line">LOG_TO_CONSOLE &#x3D; True  # 是否输出到控制台</span><br><span class="line">LOG_TO_FILE &#x3D; True  # 是否输出到文件</span><br><span class="line">LOG_TO_ES &#x3D; True  # 是否输出到 Elasticsearch</span><br><span class="line"></span><br><span class="line">LOG_PATH &#x3D; &#39;.&#x2F;runtime.log&#39;  # 日志文件路径</span><br><span class="line">LOG_LEVEL &#x3D; &#39;DEBUG&#39;  # 日志级别</span><br><span class="line">LOG_FORMAT &#x3D; &#39;%(levelname)s - %(asctime)s - process: %(process)d - %(filename)s - %(name)s - %(lineno)d - %(module)s - %(message)s&#39;  # 每条日志输出格式</span><br><span class="line">ELASTIC_SEARCH_HOST &#x3D; &#39;eshost&#39;  # Elasticsearch Host</span><br><span class="line">ELASTIC_SEARCH_PORT &#x3D; 9200  # Elasticsearch Port</span><br><span class="line">ELASTIC_SEARCH_INDEX &#x3D; &#39;runtime&#39;  # Elasticsearch Index Name</span><br><span class="line">APP_ENVIRONMENT &#x3D; &#39;dev&#39;  # 运行环境，如测试环境还是生产环境</span><br><span class="line"></span><br><span class="line">def get_logger(name&#x3D;None):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    get logger by name</span><br><span class="line">    :param name: name of logger</span><br><span class="line">    :return: logger</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    global loggers</span><br><span class="line"></span><br><span class="line">    if not name: name &#x3D; __name__</span><br><span class="line"></span><br><span class="line">    if loggers.get(name):</span><br><span class="line">        return loggers.get(name)</span><br><span class="line"></span><br><span class="line">    logger &#x3D; logging.getLogger(name)</span><br><span class="line">    logger.setLevel(LOG_LEVEL)</span><br><span class="line"></span><br><span class="line">    # 输出到控制台</span><br><span class="line">    if LOG_ENABLED and LOG_TO_CONSOLE:</span><br><span class="line">        stream_handler &#x3D; logging.StreamHandler(sys.stdout)</span><br><span class="line">        stream_handler.setLevel(level&#x3D;LOG_LEVEL)</span><br><span class="line">        formatter &#x3D; logging.Formatter(LOG_FORMAT)</span><br><span class="line">        stream_handler.setFormatter(formatter)</span><br><span class="line">        logger.addHandler(stream_handler)</span><br><span class="line"></span><br><span class="line">    # 输出到文件</span><br><span class="line">    if LOG_ENABLED and LOG_TO_FILE:</span><br><span class="line">        # 如果路径不存在，创建日志文件文件夹</span><br><span class="line">        log_dir &#x3D; dirname(log_path)</span><br><span class="line">        if not exists(log_dir): makedirs(log_dir)</span><br><span class="line">        # 添加 FileHandler</span><br><span class="line">        file_handler &#x3D; logging.FileHandler(log_path, encoding&#x3D;&#39;utf-8&#39;)</span><br><span class="line">        file_handler.setLevel(level&#x3D;LOG_LEVEL)</span><br><span class="line">        formatter &#x3D; logging.Formatter(LOG_FORMAT)</span><br><span class="line">        file_handler.setFormatter(formatter)</span><br><span class="line">        logger.addHandler(file_handler)</span><br><span class="line"></span><br><span class="line">    # 输出到 Elasticsearch</span><br><span class="line">    if LOG_ENABLED and LOG_TO_ES:</span><br><span class="line">        # 添加 CMRESHandler</span><br><span class="line">        es_handler &#x3D; CMRESHandler(hosts&#x3D;[&#123;&#39;host&#39;: ELASTIC_SEARCH_HOST, &#39;port&#39;: ELASTIC_SEARCH_PORT&#125;],</span><br><span class="line">                                  # 可以配置对应的认证权限</span><br><span class="line">                                  auth_type&#x3D;CMRESHandler.AuthType.NO_AUTH,  </span><br><span class="line">                                  es_index_name&#x3D;ELASTIC_SEARCH_INDEX,</span><br><span class="line">                                  # 一个月分一个 Index</span><br><span class="line">                                  index_name_frequency&#x3D;CMRESHandler.IndexNameFrequency.MONTHLY,</span><br><span class="line">                                  # 额外增加环境标识</span><br><span class="line">                                  es_additional_fields&#x3D;&#123;&#39;environment&#39;: APP_ENVIRONMENT&#125;  </span><br><span class="line">                                  )</span><br><span class="line">        es_handler.setLevel(level&#x3D;LOG_LEVEL)</span><br><span class="line">        formatter &#x3D; logging.Formatter(LOG_FORMAT)</span><br><span class="line">        es_handler.setFormatter(formatter)</span><br><span class="line">        logger.addHandler(es_handler)</span><br><span class="line"></span><br><span class="line">    # 保存到全局 loggers</span><br><span class="line">    loggers[name] &#x3D; logger</span><br><span class="line">    return logger</span><br></pre></td></tr></table></figure>
<p>定义完了怎么使用呢？只需要使用定义的方法获取一个 logger，然后 log 对应的内容即可:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logger &#x3D; get_logger()</span><br><span class="line">logger.debug(&#39;this is a message&#39;)</span><br></pre></td></tr></table></figure>
<p>运行结果如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DEBUG - 2019-10-11 22:27:35,923 - process: 99490 - logger.py - __main__ - 81 - logger - this is a message</span><br></pre></td></tr></table></figure>
<p>我们看看这个定义的基本实现吧。首先这里一些常量是用来定义 <code>logging</code> 模块的一些基本属性的，比如 LOG_ENABLED 代表是否开启日志功能，<code>LOG_TO_E</code>S 代表是否将日志输出到 Elasticsearch，另外还有很多其他的日志基本配置，如 <code>LOG_FORMAT</code> 配置了日志每个条目输出的基本格式，另外还有一些连接的必要信息。这些变量可以和运行时的命令行或环境变量对接起来，可以方便地实现一些开关和配置的更换。</p>
<p>然后定义了这么一个 <code>get_logger</code> 方法，接收一个参数 name。首先该方法拿到 name 之后，会到全局的 loggers 变量里面查找，loggers 变量是一个全局字典，如果有已经声明过的 logger，直接将其获取返回即可，不用再将其二次初始化。如果 loggers 里面没有找到 name 对应的 logger，那就进行创建即可。创建 logger 之后，可以为其添加各种对应的 Handler，如输出到控制台就用 StreamHandler，输出到文件就用 FileHandler 或 RotatingFileHandler，输出到 Elasticsearch 就用 CMRESHandler，分别配置好对应的信息即可。</p>
<p>最后呢，将新建的 logger 保存到全局的 loggers 里面并返回即可，这样如果有同名的 logger 便可以直接查找 loggers 直接返回了。<br>在这里依赖了额外的输出到 Elasticsearch 的包，叫做 CMRESHandler，它可以支持将日志输出到 Elasticsearch 里面，如果要使用的话可以安装一下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install CMRESHandler</span><br></pre></td></tr></table></figure>
<p>其 GitHub 地址是：<code>https://github.com/cmanaha/python-elasticsearch-logger</code>，具体的使用方式可以看看它的官方说明，如配置认证信息，配置 Index 分隔信息等等。<br>好，上面就是我之前常用的 logging 配置，通过如上的配置，我就可以实现将 logging 输出到三个位置，并可以实现对应的效果。比如输出到 Elasticsearch 之后，我就可以非常方便地使用 Kibana 来查看当前运行情况，ERROR Log 的比例等等.<br>也可以在它的基础上做更进一步的统计分析.</p>
<h2 id="loguru"><a href="#loguru" class="headerlink" title="loguru"></a>loguru</h2><p>上面的实现方式已经是一个较为可行的配置方案了。然而，我还是会感觉到有些 Handler 配起来麻烦，尤其是新建一个项目的很多时候懒得去写一些配置。即使是不用上文的配置，用最基本的几行 logging 配置，像如下的通用配置:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import logging</span><br><span class="line">logging.basicConfig(level &#x3D; logging.INFO,format &#x3D; &#39;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#39;)</span><br><span class="line">logger &#x3D; logging.getLogger(__name__)</span><br></pre></td></tr></table></figure>
<p>我也懒得去写，感觉并不是一个优雅的实现方式。<br>有需求就有动力啊，这不，就有人实现了这么一个库，叫做 loguru，可以将 log 的配置和使用更加简单和方便。<br>下面我们来看看它到底是怎么用的吧.</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先，这个库的安装方式很简单，就用基本的 pip 安装即可，Python 3 版本的安装如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install loguru</span><br></pre></td></tr></table></figure>
<p>安装完毕之后，我们就可以在项目里使用这个 loguru 库了.</p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>那么这个库怎么来用呢？我们先用一个实例感受下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from loguru import logger</span><br><span class="line"></span><br><span class="line">logger.debug(&#39;this is a debug message&#39;)</span><br></pre></td></tr></table></figure>
<p>看到了吧，不需要配置什么东西，直接引入一个 logger，然后调用其 debug 方法即可。</p>
<p>在 loguru 里面有且仅有一个主要对象，那就是 logger，loguru 里面有且仅有一个 logger，而且它已经被提前配置了一些基础信息，比如比较友好的格式化、文本颜色信息等等。</p>
<p>上面的代码运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2019-10-13 22:46:12.367 | DEBUG    | __main__:&lt;module&gt;:4 - this is a debug message</span><br></pre></td></tr></table></figure>
<p>可以看到其默认的输出格式是上面的内容，有时间、级别、模块名、行号以及日志信息，不需要手动创建 logger，直接使用即可，另外其输出还是彩色的，看起来会更加友好。</p>
<p>以上的日志信息是直接输出到控制台的，并没有输出到其他的地方，如果想要输出到其他的位置，比如存为文件，我们只需要使用一行代码声明即可。</p>
<p>例如将结果同时输出到一个 runtime.log 文件里面，可以这么写:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from loguru import logger</span><br><span class="line"></span><br><span class="line">logger.add(&#39;runtime.log&#39;)</span><br><span class="line">logger.debug(&#39;this is a debug&#39;)</span><br></pre></td></tr></table></figure>
<p>很简单吧，我们也不需要再声明一个 FileHandler 了，就一行 add 语句搞定，运行之后会发现目录下 runtime.log 里面同样出现了刚刚控制台输出的 DEBUG 信息。</p>
<p>上面就是一些基本的使用，但这还远远不够，下面我们来详细了解下它的一些功能模块.</p>
<h2 id="详细使用"><a href="#详细使用" class="headerlink" title="详细使用"></a>详细使用</h2><p>既然是日志，那么最常见的就是输出到文件了。loguru 对输出到文件的配置有非常强大的支持，比如支持输出到多个文件，分级别分别输出，过大创建新文件，过久自动删除等等。</p>
<p>下面我们分别看看这些怎样来实现，这里基本上就是 add 方法的使用介绍。因为这个 add 方法就相当于给 logger 添加了一个 Handler，它给我们暴露了许多参数来实现 Handler 的配置，下面我们来详细介绍下。<br>首先看看它的方法定义吧:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def add(</span><br><span class="line">        self,</span><br><span class="line">        sink,</span><br><span class="line">        *,</span><br><span class="line">        level&#x3D;_defaults.LOGURU_LEVEL,</span><br><span class="line">        format&#x3D;_defaults.LOGURU_FORMAT,</span><br><span class="line">        filter&#x3D;_defaults.LOGURU_FILTER,</span><br><span class="line">        colorize&#x3D;_defaults.LOGURU_COLORIZE,</span><br><span class="line">        serialize&#x3D;_defaults.LOGURU_SERIALIZE,</span><br><span class="line">        backtrace&#x3D;_defaults.LOGURU_BACKTRACE,</span><br><span class="line">        diagnose&#x3D;_defaults.LOGURU_DIAGNOSE,</span><br><span class="line">        enqueue&#x3D;_defaults.LOGURU_ENQUEUE,</span><br><span class="line">        catch&#x3D;_defaults.LOGURU_CATCH,</span><br><span class="line">        **kwargs</span><br><span class="line">    ):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>
<p>看看它的源代码，它支持这么多的参数，如 level、format、filter、color 等等。</p>
<blockquote>
<p>sink<br>另外我们还注意到它有个非常重要的参数 sink，我们看看官方文档：<code>https://loguru.readthedocs.io/en/stable/api/logger.html#sink</code>，可以了解到通过 sink 我们可以传入多种不同的数据结构，汇总如下:</p>
</blockquote>
<ul>
<li>sink 可以传入一个 file 对象，例如 sys.stderr 或者 open(‘file.log’, ‘w’) 都可以。</li>
<li>sink 可以直接传入一个 str 字符串或者 pathlib.Path 对象，其实就是代表文件路径的，如果识别到是这种类型，它会自动创建对应路径的日志文件并将日志输出进去。</li>
<li>sink 可以是一个方法，可以自行定义输出实现。</li>
<li>sink 可以是一个 logging 模块的 Handler，比如 FileHandler、StreamHandler 等等，或者上文中我们提到的 CMRESHandler 照样也是可以的，这样就可以实现自定义 Handler 的配置。</li>
<li>sink 还可以是一个自定义的类，具体的实现规范可以参见官方文档.<br>所以说，刚才我们所演示的输出到文件，仅仅给它传了一个 str 字符串路径，他就给我们创建了一个日志文件，就是这个原理。</li>
</ul>
<blockquote>
<blockquote>
<p>format, filter, level<br>下面我们再了解下它的其他参数，例如 format、filter、level 等等。<br>其实它们的概念和格式和 logging 模块都是基本一样的了，例如这里使用 format、filter、level 来规定输出的格式:</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logger.add(&#39;runtime.log&#39;, format&#x3D;&quot;&#123;time&#125; &#123;level&#125; &#123;message&#125;&quot;, filter&#x3D;&quot;my_module&quot;, level&#x3D;&quot;INFO&quot;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>删除sink<br>另外添加 sink 之后我们也可以对其进行删除，相当于重新刷新并写入新的内容。<br>删除的时候根据刚刚 add 方法返回的 id 进行删除即可，看下面的例子:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from loguru import logger</span><br><span class="line"></span><br><span class="line">trace &#x3D; logger.add(&#39;runtime.log&#39;)</span><br><span class="line">logger.debug(&#39;this is a debug message&#39;)</span><br><span class="line">logger.remove(trace)</span><br><span class="line">logger.debug(&#39;this is another debug message&#39;)</span><br></pre></td></tr></table></figure>
<p>看这里，我们首先 add 了一个 sink，然后获取它的返回值，赋值为 trace。随后输出了一条日志，然后将 trace 变量传给 remove 方法，再次输出一条日志，看看结果是怎样的。<br>控制台输出如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">019-10-13 23:18:26.469 | DEBUG    | __main__:&lt;module&gt;:4 - this is a debug message</span><br><span class="line">2019-10-13 23:18:26.469 | DEBUG    | __main__:&lt;module&gt;:6 - this is another debug message</span><br></pre></td></tr></table></figure>
<p>日志文件 runtime.log 内容如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2019-10-13 23:18:26.469 | DEBUG    | __main__:&lt;module&gt;:4 - this is a debug message</span><br></pre></td></tr></table></figure>
<p>可以发现，在调用 remove 方法之后，确实将历史 log 删除了。<br>这样我们就可以实现日志的刷新重新写入操作。</p>
<blockquote>
<p>rotation 配置<br>用了 loguru 我们还可以非常方便地使用 rotation 配置，比如我们想一天输出一个日志文件，或者文件太大了自动分隔日志文件，我们可以直接使用 add 方法的 rotation 参数进行配置。<br>我们看看下面的例子：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logger.add(&#39;runtime_&#123;time&#125;.log&#39;, rotation&#x3D;&quot;500 MB&quot;)</span><br></pre></td></tr></table></figure>
<p>通过这样的配置我们就可以实现每 500MB 存储一个文件，每个 log 文件过大就会新创建一个 log 文件。我们在配置 log 名字时加上了一个 time 占位符，这样在生成时可以自动将时间替换进去，生成一个文件名包含时间的 log 文件。<br>另外我们也可以使用 rotation 参数实现定时创建 log 文件，例如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logger.add(&#39;runtime_&#123;time&#125;.log&#39;, rotation&#x3D;&#39;00:00&#39;)</span><br></pre></td></tr></table></figure>
<p>这样就可以实现每天 0 点新创建一个 log 文件输出了。<br>另外我们也可以配置 log 文件的循环时间，比如每隔一周创建一个 log 文件，写法如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logger.add(&#39;runtime_&#123;time&#125;.log&#39;, rotation&#x3D;&#39;1 week&#39;)</span><br></pre></td></tr></table></figure>
<p>这样我们就可以实现一周创建一个 log 文件了。</p>
<blockquote>
<p>retention 配置<br>很多情况下，一些非常久远的 log 对我们来说并没有什么用处了，它白白占据了一些存储空间，不清除掉就会非常浪费。retention 这个参数可以配置日志的最长保留时间。<br>比如我们想要设置日志文件最长保留 10 天，可以这么来配置:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logger.add(&#39;runtime.log&#39;, retention&#x3D;&#39;10 days&#39;)</span><br></pre></td></tr></table></figure>
<p>这样 log 文件里面就会保留最新 10 天的 log，妈妈再也不用担心 log 沉积的问题啦。</p>
<blockquote>
<p>compression 配置<br>loguru 还可以配置文件的压缩格式，比如使用 zip 文件格式保存，示例如下:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logger.add(&#39;runtime.log&#39;, compression&#x3D;&#39;zip&#39;)</span><br></pre></td></tr></table></figure>
<p>这样可以更加节省存储空间。</p>
<blockquote>
<p>字符串格式化<br>loguru 在输出 log 的时候还提供了非常友好的字符串格式化功能，像这样:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logger.info(&#39;If you are using Python &#123;&#125;, prefer &#123;feature&#125; of course!&#39;, 3.6, feature&#x3D;&#39;f-strings&#39;)</span><br></pre></td></tr></table></figure>
<p>这样在添加参数就非常方便了。</p>
<blockquote>
<p>Traceback 记录<br>在很多情况下，如果遇到运行错误，而我们在打印输出 log 的时候万一不小心没有配置好 Traceback 的输出，很有可能我们就没法追踪错误所在了。<br>但用了 loguru 之后，我们用它提供的装饰器就可以直接进行 Traceback 的记录，类似这样的配置即可:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@logger.catch</span><br><span class="line">def my_function(x, y, z):</span><br><span class="line">    # An error? It&#39;s caught anyway!</span><br><span class="line">    return 1 &#x2F; (x + y + z)</span><br></pre></td></tr></table></figure>
<p>我们做个测试，我们在调用时三个参数都传入 0，直接引发除以 0 的错误，看看会出现什么情况:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">my_function(0, 0, 0)</span><br></pre></td></tr></table></figure>
<p>运行完毕之后，可以发现 log 里面就出现了 Traceback 信息，而且给我们输出了当时的变量值，真的是不能再赞了！结果如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; File &quot;run.py&quot;, line 15, in &lt;module&gt;</span><br><span class="line">    my_function(0, 0, 0)</span><br><span class="line">    └ &lt;function my_function at 0x1171dd510&gt;</span><br><span class="line"></span><br><span class="line">  File &quot;&#x2F;private&#x2F;var&#x2F;py&#x2F;logurutest&#x2F;demo5.py&quot;, line 13, in my_function</span><br><span class="line">    return 1 &#x2F; (x + y + z)</span><br><span class="line">                │   │   └ 0</span><br><span class="line">                │   └ 0</span><br><span class="line">                └ 0</span><br><span class="line"></span><br><span class="line">ZeroDivisionError: division by zero</span><br></pre></td></tr></table></figure>
<p>因此，用 loguru 可以非常方便地实现日志追踪，debug 效率可能要高上十倍了？<br>另外 loguru 还有很多很多强大的功能，这里就不再一一展开讲解了，更多的内容大家可以看看 loguru 的官方文档详细了解一下：<code>https://loguru.readthedocs.io/en/stable/index.html</code><br>看完之后，是时候把自己的 logging 模块替换成 loguru 啦！</p>
]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>PYTHON</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask之路-前戏</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h2 id="Flask之路-前戏"><a href="#Flask之路-前戏" class="headerlink" title="Flask之路-前戏"></a>Flask之路-前戏</h2><p>以下内容都是学习Flask框架之前需要了解的知识点,敲黑板…</p>
<h3 id="一-Flask前戏之装饰器"><a href="#一-Flask前戏之装饰器" class="headerlink" title="一. Flask前戏之装饰器"></a>一. Flask前戏之装饰器</h3><h4 id="1-1-无参装饰器"><a href="#1-1-无参装饰器" class="headerlink" title="1.1 无参装饰器"></a>1.1 无参装饰器</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># __author__ &#x3D; &quot;shuke&quot;</span><br><span class="line"># Date: 2018&#x2F;4&#x2F;15</span><br><span class="line"></span><br><span class="line">def wapper(f):</span><br><span class="line">    def inner(*args, **kwargs):</span><br><span class="line">        return f(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    return inner</span><br><span class="line"></span><br><span class="line"># 1. 立即执行wapper函数,并且将被装饰的函数当作参数传递</span><br><span class="line"># 2. 此时的func&#x3D;inner</span><br><span class="line">@wapper</span><br><span class="line">def func(arg):</span><br><span class="line">    print(arg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func(123)</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">&gt;&gt;&gt; 123</span><br><span class="line">&#39;&#39;&#39;</span><br></pre></td></tr></table></figure>

<h4 id="2-带参数的装饰器"><a href="#2-带参数的装饰器" class="headerlink" title="2. 带参数的装饰器"></a>2. 带参数的装饰器</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def outer(num):</span><br><span class="line">    def wapper(f):</span><br><span class="line">        def inner(*args, **kwargs):</span><br><span class="line">            return f(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">        return inner</span><br><span class="line"></span><br><span class="line">    print(num)</span><br><span class="line">    return wapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 首先执行wapper(666)，获得返回值;@wapper;此时@wapper,再执行wapper(func)函数,获得返回值inner，此时:func&#x3D;inner函数</span><br><span class="line">@outer(666)</span><br><span class="line">def func(arg):</span><br><span class="line">    print(arg)</span><br><span class="line"></span><br><span class="line">func(&#39;Hello&#39;)</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">666</span><br><span class="line">Hello</span><br><span class="line">&#39;&#39;&#39;</span><br></pre></td></tr></table></figure>
<h4 id="4-扩展"><a href="#4-扩展" class="headerlink" title="4. 扩展"></a>4. 扩展</h4><p>这里我们引入一个functools模块，这个模块是它能将装饰过的函数的特殊属性保留,对于这个functools.wraps装饰器，相当于wrapper = functools.wraps(func)(wrapper)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import  functools</span><br><span class="line">def wapper(func):</span><br><span class="line">    @functools.wraps(func)</span><br><span class="line">    def inner(*args,**kwargs):</span><br><span class="line">        return func(*args,**kwargs)</span><br><span class="line">    return inner</span><br><span class="line">@wapper</span><br><span class="line">def index():</span><br><span class="line">    print(&quot;hello world ,from index&quot;)</span><br><span class="line">@wapper</span><br><span class="line">def order():</span><br><span class="line">    print(&quot;hell world ,from order&quot;)</span><br><span class="line"></span><br><span class="line">print(index.__name__) </span><br><span class="line">print(order.__name__) </span><br><span class="line">##########  使用functools.wraps(函数) #############</span><br><span class="line">index</span><br><span class="line">order</span><br><span class="line">########## 不使用functools.wraps(函数)#####################</span><br><span class="line">inner</span><br><span class="line">inner</span><br></pre></td></tr></table></figure>
<h3 id="二-Flask前戏之面向对象"><a href="#二-Flask前戏之面向对象" class="headerlink" title="二. Flask前戏之面向对象"></a>二. Flask前戏之面向对象</h3><p>面向对象3大特性: 继承 封装 多态</p>
<ul>
<li>继承<br>子类继承父类<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Parent(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def talk(self):</span><br><span class="line">        print(&quot;Say Hello!&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Child(Parent):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c1 &#x3D; Child()</span><br><span class="line">c1.talk()</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">&gt;&gt;&gt; Say Hello!</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">PS: 在python3.x中类的继承遵循广度优先原则,在python2.x中遵循深度优先原则</span><br></pre></td></tr></table></figure></li>
<li>封装<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 示例</span><br><span class="line">class Foo(object):</span><br><span class="line">    def __init__(self, age, name):</span><br><span class="line">        self.age &#x3D; age</span><br><span class="line">        self.name &#x3D; name</span><br><span class="line"></span><br><span class="line"># 此处的18和&#39;shuke&#39;被封装到Foo类中</span><br><span class="line">f1 &#x3D; Foo(18, &#39;shuke&#39;)</span><br><span class="line"></span><br><span class="line">2. 示例</span><br><span class="line">class Bar(object):</span><br><span class="line">    def __init__(self, counter, obj):</span><br><span class="line">        self.age &#x3D; counter</span><br><span class="line">        self.obj &#x3D; obj</span><br><span class="line"></span><br><span class="line"># 此处的self.obj即为Foo类的对象f1</span><br><span class="line">b1 &#x3D; Bar(1, f1)</span><br><span class="line"></span><br><span class="line">3. 示例</span><br><span class="line">class Bar(object):</span><br><span class="line">    def __init__(self, counter):</span><br><span class="line">        self.age &#x3D; counter</span><br><span class="line">        self.obj &#x3D; Foo(18, &#39;shuke&#39;)</span><br><span class="line">        </span><br><span class="line"># 此处的self.obj即为Foo类的对象</span><br><span class="line">b1 &#x3D; Bar(1)</span><br></pre></td></tr></table></figure></li>
<li>多态<br>鸭子模型</li>
</ul>
<p>PS: 一个py文件中的函数可以被当作模块导入,在其他文件中调用即为封装思想</p>
<h3 id="三-python中什么后面可以加括号"><a href="#三-python中什么后面可以加括号" class="headerlink" title="三. python中什么后面可以加括号"></a>三. python中什么后面可以加括号</h3><h4 id="3-1-基本形式如下"><a href="#3-1-基本形式如下" class="headerlink" title="3.1 基本形式如下"></a>3.1 基本形式如下</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def func(arg):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    由于arg在函数中加括号，所以基本上只有4中表现形式</span><br><span class="line">    :param arg: </span><br><span class="line">    :return: </span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    arg()</span><br></pre></td></tr></table></figure>
<p>a. 函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def f1():</span><br><span class="line">    print(&quot;f1&quot;)</span><br><span class="line">    </span><br><span class="line">func(f1)</span><br></pre></td></tr></table></figure>
<p>b. 类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Foo(object):</span><br><span class="line">    pass</span><br><span class="line"># 执行类.__init__构造方法</span><br><span class="line">func(Foo)</span><br></pre></td></tr></table></figure>
<p>c. 方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class F3(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def example(self):</span><br><span class="line">        print(&quot;F3&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj &#x3D; F3()</span><br><span class="line">func(obj.example)</span><br></pre></td></tr></table></figure>
<p>d. 对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class F4(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def __call__(self, *args, **kwargs):</span><br><span class="line">        print(&quot;call方法&quot;)</span><br><span class="line"></span><br><span class="line">obj &#x3D; F4()</span><br><span class="line">obj()</span><br><span class="line">&#39;&#39;&#39;&#39;</span><br><span class="line">&gt;&gt;&gt; call方法</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">func(obj)</span><br></pre></td></tr></table></figure>

<h4 id="延伸-函数与方法的区别"><a href="#延伸-函数与方法的区别" class="headerlink" title="延伸(函数与方法的区别)"></a>延伸(函数与方法的区别)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class F3(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def example(self):</span><br><span class="line">        print(&quot;F3&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj &#x3D; F3()</span><br><span class="line"># 方法</span><br><span class="line">obj.example()</span><br><span class="line"># 函数</span><br><span class="line">F3.example</span><br></pre></td></tr></table></figure>
<h4 id="科学依据"><a href="#科学依据" class="headerlink" title="科学依据"></a>科学依据</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from types import MethodType, FunctionType</span><br><span class="line"></span><br><span class="line">class F3(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def example(self):</span><br><span class="line">        print(&quot;F3&quot;)</span><br><span class="line"></span><br><span class="line">ret1 &#x3D; isinstance(F3.example, MethodType)</span><br><span class="line">ret2 &#x3D; isinstance(F3.example, FunctionType)</span><br><span class="line">print(ret1, ret2)</span><br><span class="line"></span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">&gt;&gt;&gt; False True</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line"></span><br><span class="line">obj &#x3D; F3()</span><br><span class="line">ret3 &#x3D; isinstance(obj.example, MethodType)</span><br><span class="line">ret4 &#x3D; isinstance(obj.example, FunctionType)</span><br><span class="line">print(ret3, ret4)</span><br><span class="line"></span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">&gt;&gt;&gt; True False</span><br><span class="line">&#39;&#39;&#39;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Flask</category>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>PYTHON</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>Kong-api-gateway</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h1 id="Kong-api-gateway"><a href="#Kong-api-gateway" class="headerlink" title="Kong-api-gateway"></a>Kong-api-gateway</h1><hr>

<p><a href="https://getkong.org" target="_blank" rel="noopener">Kong官方网站</a></p>
<h2 id="1-Install"><a href="#1-Install" class="headerlink" title="1. Install"></a>1. Install</h2><p><a href="https://konghq.com/install/" target="_blank" rel="noopener">install-kong</a></p>
<h2 id="2-postgresql"><a href="#2-postgresql" class="headerlink" title="2. postgresql"></a>2. postgresql</h2><ol>
<li>安装<br>sudo apt-get install postgresql-9.6<br>安装完成后，默认会：</li>
</ol>
<p>（1）创建名为”postgres”的Linux用户</p>
<p>（2）创建名为”postgres”、不带密码的默认数据库账号作为数据库管理员</p>
<p>（3）创建名为”postgres”的表</p>
<p>安装完成后的一些默认信息如下：</p>
<p>config /etc/postgresql/9.5/main<br>data /var/lib/postgresql/9.5/main<br>locale en_US.UTF-8<br>socket /var/run/postgresql<br>port 5432</p>
<p>安装完后会有PostgreSQL的客户端psql，通过 sudo -u postgres psql 进入，提示符变成： postgres=#<br>在这里可用执行SQL语句和psql的基本命令。可用的基本命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\password：设置密码</span><br><span class="line">\q：退出</span><br><span class="line">\h：查看SQL命令的解释，比如\h select。</span><br><span class="line">\?：查看psql命令列表。</span><br><span class="line">\l：列出所有数据库。</span><br><span class="line">\c [database_name]：连接其他数据库。</span><br><span class="line">\d：列出当前数据库的所有表格。</span><br><span class="line">\d [table_name]：列出某一张表格的结构。</span><br><span class="line">\du：列出所有用户。</span><br><span class="line">\e：打开文本编辑器。</span><br><span class="line">\conninfo：列出当前数据库和连接的信息。</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>修改默认管理员密码<br>以Linux用户”postgres”的身份（此时只有该用户有psql命令）执行psql客户端，进入该客户端的提示符界面（这里系统用户名、数据库用户名、数据库名都为postgres，故可采用简写形式）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo -u postgres psql</span><br><span class="line">postgres&#x3D;# alter user postgres with password &#39;123456&#39;;</span><br></pre></td></tr></table></figure>
<p>若要删除该管理员的密码，则可用命令：sudo -u postgres psql -d postgres</p>
</li>
<li><p>配置远程连接<br>安装完成后，默认只能本地才能连接数据库，其他机子访问不了，需要进行配置。（以下示例开放了最大连接权限，实际配置根据你的需要而定）</p>
</li>
<li><p>1 修改监听地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo gedit &#x2F;etc&#x2F;postgresql&#x2F;9.5&#x2F;main&#x2F;postgresql.conf </span><br><span class="line">将 #listen_addresses &#x3D; &#39;localhost&#39; 的注释去掉并改为 listen_addresses &#x3D; &#39;*&#39;</span><br></pre></td></tr></table></figure></li>
<li><p>修改可访问用户的IP段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo gedit &#x2F;etc&#x2F;postgresql&#x2F;9.5&#x2F;main&#x2F;pg_hba.conf </span><br><span class="line">在文件末尾添加： host all all 0.0.0.0 0.0.0.0 md5 ，表示允许任何IP连接</span><br></pre></td></tr></table></figure></li>
<li><p>启动数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;etc&#x2F;init.d&#x2F;postgresql start</span><br></pre></td></tr></table></figure></li>
<li><p>添加用户及授权</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">运行系统用户&quot;postgres&quot;的psql命令，进入客户端：</span><br><span class="line">sudo -u postgres psql</span><br><span class="line">创建用户&quot;kong&quot;并设置密码：</span><br><span class="line">postgres&#x3D;# create user kong with password &#39;123456&#39;;</span><br><span class="line">创建数据库kong，所有者为kong：</span><br><span class="line">postgres&#x3D;# create database kong owner kong;</span><br><span class="line">将konhg数据库的所有权限赋予kong用户，否则kong只能登录psql，没有任何数据库操作权限：</span><br><span class="line">grant all privileges on database kong to kong;. 添加用户及授权</span><br></pre></td></tr></table></figure></li>
<li><p>查看<br>postgres=# \du 得到用户列表<br>postgres=# \l  得到数据库列表<br>删除<br>postgres=# drop database kong<br>postgres=# drop user kong</p>
</li>
<li><p>常用操作命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建新表 </span><br><span class="line">CREATE TABLE user_tbl(name VARCHAR(20), signup_date DATE);</span><br><span class="line"># 插入数据 </span><br><span class="line">INSERT INTO user_tbl(name, signup_date) VALUES(&#39;张三&#39;, &#39;2013-12-22&#39;);</span><br><span class="line"># 选择记录 </span><br><span class="line">SELECT * FROM user_tbl;</span><br><span class="line"># 更新数据 </span><br><span class="line">UPDATE user_tbl set name &#x3D; &#39;李四&#39; WHERE name &#x3D; &#39;张三&#39;;</span><br><span class="line"># 删除记录 </span><br><span class="line">DELETE FROM user_tbl WHERE name &#x3D; &#39;李四&#39; ;</span><br><span class="line"># 添加栏位 </span><br><span class="line">ALTER TABLE user_tbl ADD email VARCHAR(40);</span><br><span class="line"># 更新结构 </span><br><span class="line">ALTER TABLE user_tbl ALTER COLUMN signup_date SET NOT NULL;</span><br><span class="line"># 更名栏位 </span><br><span class="line">ALTER TABLE user_tbl RENAME COLUMN signup_date TO signup;</span><br><span class="line"># 删除栏位 </span><br><span class="line">ALTER TABLE user_tbl DROP COLUMN email;</span><br><span class="line"># 表格更名 </span><br><span class="line">ALTER TABLE user_tbl RENAME TO backup_tbl;</span><br><span class="line"># 删除表格 </span><br><span class="line">DROP TABLE IF EXISTS backup_tbl;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="3-Kong-Dashboard"><a href="#3-Kong-Dashboard" class="headerlink" title="3. Kong-Dashboard"></a>3. Kong-Dashboard</h2><ul>
<li><a href="https://github.com/pantsel/konga" target="_blank" rel="noopener">Konga</a></li>
<li><a href="https://www.npmjs.com/package/kong-dashboard" target="_blank" rel="noopener">Kong-dashboard-node</a></li>
<li><a href="https://github.com/PGBI/kong-dashboard" target="_blank" rel="noopener">Kong-dashboard-github</a></li>
</ul>
]]></content>
      <categories>
        <category>Kong</category>
      </categories>
      <tags>
        <tag>Kong</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM调优命令</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h2 id="JVM调优命令"><a href="#JVM调优命令" class="headerlink" title="JVM调优命令"></a>JVM调优命令</h2><blockquote>
<p>运用jvm自带的命令可以方便的在生产监控和打印堆栈的日志信息帮忙我们来定位问题！虽然jvm调优成熟的工具已经有很多：jconsole、大名鼎鼎的VisualVM，IBM的Memory Analyzer等等，但是在生产环境出现问题的时候，一方面工具的使用会有所限制，另一方面喜欢装X的我们，总喜欢在出现问题的时候在终端输入一些命令来解决。所有的工具几乎都是依赖于jdk的接口和底层的这些命令，研究这些命令的使用也让我们更能了解jvm构成和特性。<br>Sun JDK监控和故障处理命令有jps jstat jmap jhat jstack jinfo下面做一一介绍</p>
</blockquote>
<h3 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h3><blockquote>
<p>JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。</p>
</blockquote>
<p>命令格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jps [options] [hostid]</span><br></pre></td></tr></table></figure>
<p>option参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-l : 输出主类全名或jar路径</span><br><span class="line">-q : 只输出LVMID</span><br><span class="line">-m : 输出JVM启动时传递给main()的参数</span><br><span class="line">-v : 输出JVM启动时显示指定的JVM参数</span><br></pre></td></tr></table></figure>
<p>其中<code>[option]、[hostid]</code>参数也可以不写</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@jav-collection01br-p001:~# jps -mlv</span><br><span class="line">1808 &#x2F;data&#x2F;services&#x2F;brazil_DivisionCaseTools&#x2F;DivisionCaseTools_br-1.0.jar --spring.profiles.active&#x3D;br-prod -Xmx1024M -Duser.timezone&#x3D;America&#x2F;Sao_Paulo</span><br><span class="line">8196 &#x2F;data&#x2F;services&#x2F;brazil_phonebook&#x2F;phonebook_br-0.0.1-SNAPSHOT.jar --spring.profiles.active&#x3D;br-prod -Xmx1024M -Duser.timezone&#x3D;America&#x2F;Sao_Paulo</span><br><span class="line">4756 org.apache.catalina.startup.Bootstrap start -Djava.util.logging.config.file&#x3D;&#x2F;data&#x2F;services&#x2F;brazil_AuthCenter&#x2F;conf&#x2F;logging.properties -Djava.util.logging.manager&#x3D;org.apache.juli.ClassLoaderLogManager -Xmx1G -Xms1G -XX:MetaspaceSize&#x3D;128M -XX:MaxMetaspaceSize&#x3D;128M -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath&#x3D;&#x2F;data&#x2F;services&#x2F;brazil_AuthCenter&#x2F;logs&#x2F;dump -XX:+PrintClassHistogram -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintHeapAtGC -Xloggc:&#x2F;data&#x2F;services&#x2F;brazil_AuthCenter&#x2F;logs&#x2F;gc.log -Djdk.tls.ephemeralDHKeySize&#x3D;2048 -Djava.protocol.handler.pkgs&#x3D;org.apache.catalina.webresources -Djava.endorsed.dirs&#x3D;&#x2F;data&#x2F;services&#x2F;brazil_AuthCenter&#x2F;endorsed -Dcatalina.base&#x3D;&#x2F;data&#x2F;services&#x2F;brazil_AuthCenter -Dcatalina.home&#x3D;&#x2F;data&#x2F;services&#x2F;brazil_AuthCenter -Djava.io.tmpdir&#x3D;&#x2F;data&#x2F;services&#x2F;brazil_AuthCenter&#x2F;temp</span><br><span class="line">3928 &#x2F;data&#x2F;soft&#x2F;lts&#x2F;lts-task-tracker&#x2F;prod&#x2F;lts-tasktracker-springboot-1.6.9.jar -Duser.timezone&#x3D;America&#x2F;Sao_Paulo -Xmx256M</span><br></pre></td></tr></table></figure>

<h3 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3><blockquote>
<p>jstat(JVM statistics Monitoring)是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。</p>
</blockquote>
<h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jstat [option] LVMID [interval] [count]</span><br></pre></td></tr></table></figure>
<p>补充:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">堆内存 &#x3D; 年轻代 + 年老代 + 永久代 + 元数据区</span><br><span class="line">年轻代 &#x3D; Eden区 + 两个Survivor区（From和To）</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; jstat -options</span><br><span class="line"></span><br><span class="line">-class 显示ClassLoad的相关信息；</span><br><span class="line">-compiler 显示JIT编译的相关信息；</span><br><span class="line">-gc 显示和gc相关的堆信息；</span><br><span class="line">-gccapacity 　　 显示各个代的容量以及使用情况；</span><br><span class="line">-gcmetacapacity 显示metaspace的大小</span><br><span class="line">-gcnew 显示新生代信息；</span><br><span class="line">-gcnewcapacity 显示新生代大小和使用情况；</span><br><span class="line">-gcold 显示老年代和永久代的信息；</span><br><span class="line">-gcoldcapacity 显示老年代的大小；</span><br><span class="line">-gcutil　　 显示垃圾收集信息；</span><br><span class="line">-gccause 显示垃圾回收的相关信息（通-gcutil）,同时显示最后一次或当前正在发生的垃圾回收的诱因；</span><br><span class="line">-printcompilation 输出JIT编译的方法信息</span><br></pre></td></tr></table></figure>
<p>参数名称 | 参数说明<br>—|—|—<br>class | 用于查看类加载情况的统计，显示加载class的数量，及所占空间等信息。<br>compiler | 查看HotSpot中即时编译器编译情况的统计<br>gc | 查看JVM中堆的垃圾收集情况的统计，可以显示gc的信息，查看gc的次数，及时间。其中最后五项，分别是young gc的次数，young gc的时间，full gc的次数，full gc的时间，gc的总时间。<br>gccapacity | 查看新生代、老生代及持久代的存储容量情况，可以显示，VM内存中三代（young,old,perm）对象的使用和占用大小<br>gccause | 查看垃圾收集的统计情况（这个和-gcutil选项一样），如果有发生垃圾收集，它还会显示最后一次及当前正在发生垃圾收集的原因<br>gcmetacapacity | 显示关于metaspace大小的统计信息。<br>gcnew | 查看新生代垃圾收集的情况，new对象的信息<br>gcnewcapacity | 用于查看新生代的存储容量情况，new对象的信息及其占用量<br>gcold | 用于查看老生代及持久代发生GC的情况，old对象的信息<br>gcoldcapacity | 用于查看老生代的容量，old对象的信息及其占用量<br>gcpermcapacity | 用于查看持久代的容量，perm对象的信息及其占用量<br>gcutil | 查看新生代、老生代及持代垃圾收集的情况<br>printcompilation | 当前VM执行的信息</p>
<h3 id="参数使用示例"><a href="#参数使用示例" class="headerlink" title="参数使用示例"></a>参数使用示例</h3><ol>
<li>jstat -gc  pid  垃圾回收统计<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@jav-collection01br-p001:~# jstat -gc 1808</span><br><span class="line"> S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line">1536.0 1536.0 288.0   0.0   346112.0 136222.0  233472.0   151382.5  60416.0 58963.1 6912.0 6587.0  32144   93.009   5      0.469   93.478</span><br><span class="line">- S0C：第一个幸存区的大小</span><br><span class="line"></span><br><span class="line">- S1C：第二个幸存区的大小</span><br><span class="line"></span><br><span class="line">- S0U：第一个幸存区的使用大小</span><br><span class="line"></span><br><span class="line">- S1U：第二个幸存区的使用大小</span><br><span class="line"></span><br><span class="line">- EC：伊甸园区的大小</span><br><span class="line"></span><br><span class="line">- EU：伊甸园区的使用大小</span><br><span class="line"></span><br><span class="line">- OC：老年代大小</span><br><span class="line"></span><br><span class="line">- OU：老年代使用大小</span><br><span class="line"></span><br><span class="line">- MC：方法区大小</span><br><span class="line"></span><br><span class="line">- MU：方法区使用大小</span><br><span class="line"></span><br><span class="line">- CCSC:压缩类空间大小</span><br><span class="line"></span><br><span class="line">- CCSU:压缩类空间使用大小</span><br><span class="line"></span><br><span class="line">- YGC：年轻代垃圾回收次数</span><br><span class="line"></span><br><span class="line">- YGCT：年轻代垃圾回收消耗时间</span><br><span class="line"></span><br><span class="line">- FGC：老年代垃圾回收次数</span><br><span class="line"></span><br><span class="line">- FGCT：老年代垃圾回收消耗时间</span><br><span class="line"></span><br><span class="line">- GCT：垃圾回收消耗总时间</span><br></pre></td></tr></table></figure></li>
<li>jstat -gcutil pid  总垃圾回收统计<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@jav-collection01br-p001:~# jstat -gcutil 1808</span><br><span class="line">  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line"> 18.75   0.00  39.38  64.84  97.60  95.30  32144   93.009     5    0.469   93.478</span><br><span class="line"> S0：幸存1区当前使用比例</span><br><span class="line"></span><br><span class="line">S1：幸存2区当前使用比例</span><br><span class="line"></span><br><span class="line">E：伊甸园区使用比例</span><br><span class="line"></span><br><span class="line">O：老年代使用比例</span><br><span class="line"></span><br><span class="line">M：元数据区使用比例</span><br><span class="line"></span><br><span class="line">CCS：压缩使用比例</span><br><span class="line"></span><br><span class="line">YGC：年轻代垃圾回收次数</span><br><span class="line"></span><br><span class="line">FGC：老年代垃圾回收次数</span><br><span class="line"></span><br><span class="line">FGCT：老年代垃圾回收消耗时间</span><br><span class="line"></span><br><span class="line">GCT：垃圾回收消耗总时间</span><br></pre></td></tr></table></figure></li>
<li>jstat -gcnew  pid 新生代垃圾回收统计<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@jav-collection01br-p001:~# jstat -gcnew 1808</span><br><span class="line"> S0C    S1C    S0U    S1U   TT MTT  DSS      EC       EU     YGC     YGCT</span><br><span class="line">1536.0 1536.0  288.0    0.0 15  15 1536.0 346112.0 136299.9  32144   93.009</span><br><span class="line">- S0C：第一个幸存区大小</span><br><span class="line"></span><br><span class="line">- S1C：第二个幸存区的大小</span><br><span class="line"></span><br><span class="line">- S0U：第一个幸存区的使用大小</span><br><span class="line"></span><br><span class="line">- S1U：第二个幸存区的使用大小</span><br><span class="line"></span><br><span class="line">- TT:对象在新生代存活的次数</span><br><span class="line"></span><br><span class="line">- MTT:对象在新生代存活的最大次数</span><br><span class="line"></span><br><span class="line">- DSS:期望的幸存区大小</span><br><span class="line"></span><br><span class="line">- EC：伊甸园区的大小</span><br><span class="line"></span><br><span class="line">- EU：伊甸园区的使用大小</span><br><span class="line"></span><br><span class="line">- YGC：年轻代垃圾回收次数</span><br><span class="line"></span><br><span class="line">- YGCT：年轻代垃圾回收消耗时间</span><br></pre></td></tr></table></figure></li>
<li>jstat -gccapacity pid 堆内存统计<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 记忆这个命令可以根据单词组合记忆</span><br><span class="line"> -gc &#x3D;&gt; 名称</span><br><span class="line"> capacity &#x3D;&gt; 容量</span><br><span class="line">root@jav-collection01br-p001:~# jstat -gccapacity 1808</span><br><span class="line"> NGCMN    NGCMX     NGC     S0C   S1C       EC      OGCMN      OGCMX       OGC         OC       MCMN     MCMX      MC     CCSMN    CCSMX     CCSC    YGC    FGC</span><br><span class="line"> 40960.0 349184.0 349184.0 1536.0 1536.0 346112.0    81920.0   699392.0   233472.0   233472.0      0.0 1103872.0  60416.0      0.0 1048576.0   6912.0  32144     5</span><br><span class="line">NGCMN：新生代最小容量</span><br><span class="line"></span><br><span class="line">NGCMX：新生代最大容量</span><br><span class="line"></span><br><span class="line">NGC：当前新生代容量</span><br><span class="line"></span><br><span class="line">S0C：第一个幸存区大小</span><br><span class="line"></span><br><span class="line">S1C：第二个幸存区的大小</span><br><span class="line"></span><br><span class="line">EC：伊甸园区的大小</span><br><span class="line"></span><br><span class="line">OGCMN：老年代最小容量</span><br><span class="line"></span><br><span class="line">OGCMX：老年代最大容量</span><br><span class="line"></span><br><span class="line">OGC：当前老年代大小</span><br><span class="line"></span><br><span class="line">OC:当前老年代大小</span><br><span class="line"></span><br><span class="line">MCMN:最小元数据容量</span><br><span class="line"></span><br><span class="line">MCMX：最大元数据容量</span><br><span class="line"></span><br><span class="line">MC：当前元数据空间大小</span><br><span class="line"></span><br><span class="line">CCSMN：最小压缩类空间大小</span><br><span class="line"></span><br><span class="line">CCSMX：最大压缩类空间大小</span><br><span class="line"></span><br><span class="line">CCSC：当前压缩类空间大小</span><br><span class="line"></span><br><span class="line">YGC：年轻代gc次数</span><br><span class="line"></span><br><span class="line">FGC：老年代GC次数</span><br></pre></td></tr></table></figure></li>
<li>jstat -gcmetacapacity pid   元数据空间统计<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@jav-collection01br-p001:~# jstat -gcmetacapacity 1808</span><br><span class="line">   MCMN       MCMX        MC       CCSMN      CCSMX       CCSC     YGC   FGC    FGCT     GCT</span><br><span class="line">       0.0  1103872.0    60416.0        0.0  1048576.0     6912.0 32144     5    0.469   93.478</span><br><span class="line">MCMN:最小元数据容量</span><br><span class="line"></span><br><span class="line">MCMX：最大元数据容量</span><br><span class="line"></span><br><span class="line">MC：当前元数据空间大小</span><br><span class="line"></span><br><span class="line">CCSMN：最小压缩类空间大小</span><br><span class="line"></span><br><span class="line">CCSMX：最大压缩类空间大小</span><br><span class="line"></span><br><span class="line">CCSC：当前压缩类空间大小</span><br><span class="line"></span><br><span class="line">YGC：年轻代垃圾回收次数</span><br><span class="line"></span><br><span class="line">FGC：老年代垃圾回收次数</span><br><span class="line"></span><br><span class="line">FGCT：老年代垃圾回收消耗时间</span><br><span class="line"></span><br><span class="line">GCT：垃圾回收消耗总时间</span><br></pre></td></tr></table></figure></li>
<li>jstat -gcnewcapacity pid 新生代内存空间统计<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@jav-collection01br-p001:~# jstat -gcnewcapacity 1808</span><br><span class="line">  NGCMN      NGCMX       NGC      S0CMX     S0C     S1CMX     S1C       ECMX        EC      YGC   FGC</span><br><span class="line">   40960.0   349184.0   349184.0 116224.0   1536.0 116224.0   1536.0   348160.0   346112.0 32144     5</span><br><span class="line">NGCMN：新生代最小容量</span><br><span class="line"></span><br><span class="line">NGCMX：新生代最大容量</span><br><span class="line"></span><br><span class="line">NGC：当前新生代容量</span><br><span class="line"></span><br><span class="line">S0CMX：最大幸存1区大小</span><br><span class="line"></span><br><span class="line">S0C：当前幸存1区大小</span><br><span class="line"></span><br><span class="line">S1CMX：最大幸存2区大小</span><br><span class="line"></span><br><span class="line">S1C：当前幸存2区大小</span><br><span class="line"></span><br><span class="line">ECMX：最大伊甸园区大小</span><br><span class="line"></span><br><span class="line">EC：当前伊甸园区大小</span><br><span class="line"></span><br><span class="line">YGC：年轻代垃圾回收次数</span><br><span class="line"></span><br><span class="line">FGC：老年代回收次数</span><br></pre></td></tr></table></figure></li>
<li>jstat -gcoldcapacity pid 老年代内存空间统计<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 每隔2秒采集一次数据</span><br><span class="line">root@jav-collection01br-p001:~# jstat -gcoldcapacity 1808 2000</span><br><span class="line">   OGCMN       OGCMX        OGC         OC       YGC   FGC    FGCT     GCT</span><br><span class="line">    81920.0    699392.0    233472.0    233472.0 32144     5    0.469   93.478</span><br><span class="line">OGCMN：老年代最小容量</span><br><span class="line"></span><br><span class="line">OGCMX：老年代最大容量</span><br><span class="line"></span><br><span class="line">OGC：当前老年代大小</span><br><span class="line"></span><br><span class="line">OC：老年代大小</span><br><span class="line"></span><br><span class="line">YGC：年轻代垃圾回收次数</span><br><span class="line"></span><br><span class="line">FGC：老年代垃圾回收次数</span><br><span class="line"></span><br><span class="line">FGCT：老年代垃圾回收消耗时间</span><br><span class="line"></span><br><span class="line">GCT：垃圾回收消耗总时间</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h2><p><a href="https://www.cnblogs.com/ityouknow/p/5714703.html" target="_blank" rel="noopener">jvm系列(四):jvm调优-命令大全（jps jstat jmap jhat jstack jinfo） - 纯洁的微笑 - 博客园</a><br><a href="https://blog.csdn.net/u010758410/article/details/80315927" target="_blank" rel="noopener">JVM 堆内存设置原理 - 木子木泗的博客 - CSDN博客</a><br><a href="https://www.jianshu.com/p/ff46acfad03f" target="_blank" rel="noopener">jvm堆内存设置讲解 - 简书</a><br><a href="https://www.jianshu.com/p/845924a1b8f2" target="_blank" rel="noopener">jstat命令总结 - 简书</a><br><a href="https://www.jianshu.com/p/a09e08065720" target="_blank" rel="noopener">阿里员工都是这样排查Java问题的，附工具单 - 简书</a></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux的经典shell命令整理</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h3 id="Linux的经典shell命令整理"><a href="#Linux的经典shell命令整理" class="headerlink" title="Linux的经典shell命令整理"></a>Linux的经典shell命令整理</h3><ol>
<li>删除0字节文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find -type f -size 0 -exec rm -rf &#123;&#125; \\;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="2">
<li>查看进程</li>
</ol>
<p>按内存从大到小排列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -e -o “%C : %p : %z : %a”|sort -k5 -nr</span><br></pre></td></tr></table></figure>


<ol start="3">
<li>按cpu利用率从大到小排列<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -e -o “%C : %p : %z : %a”|sort -nr</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="4">
<li>打印说cache里的URL<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep -r -a jpg &#x2F;data&#x2F;cache&#x2F;* | strings | grep “http:” | awk -F’http:’ ‘&#123;print “http:”$2;&#125;’</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="5">
<li>查看http的并发请求数及其TCP连接状态：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netstat -n | awk ‘&#x2F;^tcp&#x2F; &#123;++S\[$NF\]&#125; END &#123;for(a in S) print a, S\[a\]&#125;’</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="6">
<li>修改sshd<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed -i ‘&#x2F;Root&#x2F;s&#x2F;no&#x2F;yes&#x2F;’ &#x2F;etc&#x2F;ssh&#x2F;sshd_config sed在这个文里Root的一行，匹配Root一行，将no替换成yes.</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="7">
<li>如何杀掉mysql进程：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps aux|grep mysql|grep -v grep|awk ‘&#123;print $2&#125;’|xargs kill -9</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>(从中了解到awk的用途)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pgrep mysql |xargs kill -9</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">killall -TERM mysqld</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kill -9 \&#96;cat &#x2F;usr&#x2F;local&#x2F;apache2&#x2F;logs&#x2F;httpd.pid\&#96;</span><br></pre></td></tr></table></figure>

<p>试试查杀进程PID</p>
<ol start="8">
<li>显示运行3级别开启的服务:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls &#x2F;etc&#x2F;rc3.d&#x2F;S* |cut -c 15-</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>(从中了解到cut的用途，截取数据)</p>
<ol start="9">
<li><p>如何在编写SHELL显示多个信息，用EOF</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt; EOF +--------------------------------------------------------------+ | &#x3D;&#x3D;&#x3D; Welcome to Tunoff services &#x3D;&#x3D;&#x3D; | +--------------------------------------------------------------+ EOF</span><br></pre></td></tr></table></figure>
</li>
<li><p>for 的巧用(如给mysql建软链接)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin for i in * do ln &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin&#x2F;$i &#x2F;usr&#x2F;bin&#x2F;$i done</span><br></pre></td></tr></table></figure>
</li>
<li><p>取IP地址：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ifconfig eth0|sed -n &#39;2p&#39;|awk &#39;&#123;print $2&#125;&#39;|cut -c 6-30 或者: ifconfig eth0 |grep &quot;inet addr:&quot; |awk &#39;&#123;print $2&#125;&#39;|cut -c 6- 或者 ifconfig | grep &#39;inet addr:&#39;| grep -v &#39;127.0.0.1&#39; | cut -d: -f2 | awk &#39;&#123; print $1&#125;&#39; 或者： ifconfig eth0 | sed -n &#39;&#x2F;inet &#x2F;&#123;s&#x2F;.\*addr:&#x2F;&#x2F;;s&#x2F; .\*&#x2F;&#x2F;;p&#125;&#39;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>Perl实现获取IP的方法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ifconfig -a | perl -ne &#39;if ( m&#x2F;^\\s\*inet (?:addr:)?(\[\\d.\]+).\*?cast&#x2F; ) &#123; print qq($1\\n); exit 0; &#125;&#39;</span><br></pre></td></tr></table></figure>

<ol start="12">
<li><p>内存的大小: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">free -m |grep &quot;Mem&quot; | awk &#39;&#123;print $2&#125;&#39;</span><br></pre></td></tr></table></figure></li>
<li><p>获取nginx的连接IP</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netstat -an -t | grep &quot;:80&quot; | grep ESTABLISHED | awk &#39;&#123;printf &quot;%s %s\\n&quot;,$5,$6&#125;&#39; | sort</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看Apache的并发请求数及其TCP连接状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netstat -n | awk &#39;&#x2F;^tcp&#x2F; &#123;++S\[$NF\]&#125; END &#123;for(a in S) print a, S\[a\]&#125;&#39;</span><br></pre></td></tr></table></figure>
</li>
<li><p>因为同事要统计一下服务器下面所有的jpg的文件的大小,写了个shell给他来统计.原来用xargs实现,但他一次处理一部分,搞的有多个总和….,下面的命令就能解决啦.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F; -name *.jpg -exec wc -c &#123;&#125; \\;|awk &#39;&#123;print $1&#125;&#39;|awk &#39;&#123;a+&#x3D;$1&#125;END&#123;print a&#125;&#39;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>CPU的数量（多核算多个CPU， cat /proc/cpuinfo |grep -c processor ）越多，系统负载越低，每秒能处理的请求数也越多。</p>
<p>--------------------------------------------------------------------------------------------------------------------</p>
<ol start="16">
<li><p>CPU负载 # cat /proc/loadavg 检查前三个输出值是否超过了系统逻辑CPU的4倍。</p>
</li>
<li><p>CPU负载 # mpstat 1 1 检查%idle是否过低(比如小于5%)</p>
</li>
<li><p>内存空间 # free 检查free值是否过低 也可以用 # cat /proc/meminfo</p>
</li>
<li><p>swap空间 # free 检查swap used值是否过高 如果swap used值过高，进一步检查swap动作是否频繁： # vmstat 1 5 观察si和so值是否较大</p>
</li>
<li><p>磁盘空间 # df -h 检查是否有分区使用率(Use%)过高(比如超过90%) 如发现某个分区空间接近用尽，可以进入该分区的挂载点，用以下命令找出占用空间最多的文件或目录： # du -cks * | sort -rn | head -n 10</p>
</li>
<li><p>磁盘I/O负载 # iostat -x 1 2 检查I/O使用率(%util)是否超过100%</p>
</li>
<li><p>网络负载 # sar -n DEV 检查网络流量(rxbyt/s, txbyt/s)是否过高</p>
</li>
<li><p>网络错误 # netstat -i 检查是否有网络错误(drop fifo colls carrier) 也可以用命令：# cat /proc/net/dev</p>
</li>
<li><p>网络连接数目 # netstat -an | grep -E “^(tcp)” | cut -c 68- | sort | uniq -c | sort -n</p>
</li>
<li><p>进程总数 # ps aux | wc -l 检查进程个数是否正常 (比如超过250)</p>
</li>
<li><p>可运行进程数目 # vmwtat 1 5 列给出的是可运行进程的数目，检查其是否超过系统逻辑CPU的4倍</p>
</li>
<li><p>进程 # top -id 1 观察是否有异常进程出现</p>
</li>
<li><p>网络状态 检查DNS, 网关等是否可以正常连通</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ping traceroute nslookup dig</span><br></pre></td></tr></table></figure>
</li>
<li><p>用户 # who | wc -l 检查登录用户是否过多 (比如超过50个) 也可以用命令：# uptime</p>
</li>
<li><p>系统日志 # cat /var/log/rflogview/*errors</p>
</li>
</ol>
<p>检查是否有异常错误记录 也可以搜寻一些异常关键字，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># grep -i error &#x2F;var&#x2F;log&#x2F;messages</span><br><span class="line"># grep -i fail &#x2F;var&#x2F;log&#x2F;messages</span><br><span class="line"># egrep -i &#39;error|warn&#39; &#x2F;var&#x2F;log&#x2F;messages 查看系统异常 32 核心日志</span><br></pre></td></tr></table></figure>
<h1 id="dmesg-检查是否有异常错误记录"><a href="#dmesg-检查是否有异常错误记录" class="headerlink" title="dmesg 检查是否有异常错误记录"></a>dmesg 检查是否有异常错误记录</h1><ol start="33">
<li>系统时间 # date 检查系统时间是否正确</li>
</ol>
<p>当前时间:  <code>date +&quot;%Y-%m-%d %H:%M:%S&quot;</code></p>
<ol start="34">
<li><p>打开文件数目 # lsof | wc -l 检查打开文件总数是否过多</p>
</li>
<li><p>日志 # logwatch ?print 配置/etc/log.d/logwatch.conf，将 Mailto 设置为自己的email 地址，启动mail服务 (sendmail或者postfix)，这样就可以每天收到日志报告了。</p>
</li>
</ol>
<p>缺省logwatch只报告昨天的日志，可以用# logwatch ?print ?range all 获得所有的日志分析结果。</p>
<p>可以用# logwatch ?print ?detail high 获得更具体的日志分析结果(而不仅仅是出错日志)。</p>
<ol start="36">
<li><p>杀掉80端口相关的进程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lsof -i :80|grep -v &quot;PID&quot;|awk &#39;&#123;print &quot;kill -9&quot;,$2&#125;&#39;|sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>清除僵死进程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -eal | awk &#39;&#123; if ($2 &#x3D;&#x3D; &quot;Z&quot;) &#123;print $4&#125;&#125;&#39; | kill -9</span><br></pre></td></tr></table></figure>
</li>
<li><p>tcpdump 抓包 ，用来防止80端口被人攻击时可以分析数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># tcpdump -c 10000 -i eth0 -n dst port 80 &gt; &#x2F;root&#x2F;pkts</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后检查IP的重复数 并从小到大排序 注意 “-t\ +0″ 中间是两个空格</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># less pkts | awk &#123;&#39;printf $3&quot;\\n&quot;&#39;&#125; | cut -d. -f 1-4 | sort | uniq -c | awk &#123;&#39;printf $1&quot; &quot;$2&quot;\\n&quot;&#39;&#125; | sort -n -t\ +0</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看有多少个活动的php-cgi进程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netstat -anp | grep php-cgi | grep ^tcp | wc -l</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用iptables对应简单攻击</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netstat -an | grep -v LISTEN | awk ‘&#123;print $5&#125;’ |grep -v 127.0.0.1|grep -v 本机ip|sed “s&#x2F;::ffff:&#x2F;&#x2F;g”|awk ‘BEGIN &#123; FS&#x3D;”:” &#125; &#123; Num\[$1\]++ &#125; END &#123; for(i in Num) if(Num&gt;8) &#123; print i&#125; &#125;’ |grep ‘\[0-9\]\\&#123;1,3\\&#125;\\.\[0-9\]\\&#123;1,3\\&#125;\\.\[0-9\]\\&#123;1,3\\&#125;\\.\[0-9\]\\&#123;1,3\\&#125;’| xargs -i\[\] iptables -I INPUT -s \[\] -j DROP</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>Num&gt;8部分设定值为阀值，这条句子会自动将netstat -an 中查到的来自同一ＩＰ的超过一定量的连接的列入禁止范围。 基中本机ip改成你的服务器的ip地址</p>
<ol start="42">
<li><p>怎样知道某个进程在哪个CPU上运行？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ps -eo pid,args,psr</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看硬件制造商</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dmidecode -s system-product-name</span><br></pre></td></tr></table></figure>
</li>
<li><p>perl如何编译成字节码，这样在处理复杂项目的时候会更快一点？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">perlcc -B -o webseek webseek.pl</span><br></pre></td></tr></table></figure>
</li>
<li><p>统计var目录下文件以M为大小,以列表形式列出来。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F;var -type f | xargs ls -s | sort -rn | awk ‘&#123;size&#x3D;$1&#x2F;1024; printf(“%dMb %s\\n”, size,$2);&#125;’ | head</span><br></pre></td></tr></table></figure>
<p>查找var目录下文件大于100M的文件，并统计文件的个数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F;var -size +100M -type f | tee file_list | wc -l</span><br></pre></td></tr></table></figure>
</li>
<li><p>sed 查找并替换内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed -i “s&#x2F;varnish&#x2F;LTCache&#x2F;g” \&#96;grep “Via” -rl &#x2F;usr&#x2F;local&#x2F;src&#x2F;varnish-2.0.4\&#96;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed -i “s&#x2F;X-Varnish&#x2F;X-LTCache&#x2F;g” \&#96;grep “X-Varnish” -rl &#x2F;usr&#x2F;local&#x2F;src&#x2F;varnish-2.0.4\&#96;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看服务器制造商</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dmidecode -s system-product-name</span><br></pre></td></tr></table></figure>
</li>
<li><p>wget 模拟user-agent抓取网页</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -m -e robots&#x3D;off -U “Mozilla&#x2F;5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9.1.6) Gecko&#x2F;20091201 Firefox&#x2F;3.5.6” http:&#x2F;&#x2F;www.example.com&#x2F;</span><br></pre></td></tr></table></figure>
</li>
<li><p>统计目录下文件的大小（按M打印显示）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">du $1 –max-depth&#x3D;1 | sort -n|awk ‘&#123;printf “%7.2fM —-&gt; %s\\n”,$1&#x2F;1024,$2&#125;’|sed ‘s:&#x2F;.*&#x2F;\\(\[^&#x2F;\]\\&#123;1,\\&#125;\\)$:\\1:g’</span><br></pre></td></tr></table></figure>
</li>
<li><p>关于CND实施几个相关的统计</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">统计一个目录中的目录个数</span><br><span class="line">ls -l | awk ‘&#x2F;^d&#x2F;’ | wc -l</span><br></pre></td></tr></table></figure>


</li>
</ol>
<p>统计一个目录中的文件个数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -l | awk ‘&#x2F;^-&#x2F;’ | wc -l</span><br></pre></td></tr></table></figure>

<p>统计一个目录中的全部文件数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find .&#x2F; -type f -print | wc -l</span><br></pre></td></tr></table></figure>

<p>统计一个目录中的全部子目录数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find .&#x2F; -type d -print | wc -l</span><br></pre></td></tr></table></figure>

<p>统计某类文件的大小:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find .&#x2F; -name “*.jpg” -exec wc -c &#123;&#125; \\;|awk ‘&#123;print $1&#125;’|awk ‘&#123;a+&#x3D;$1&#125;END&#123;print a&#125;’</span><br></pre></td></tr></table></figure>

<ol start="51">
<li><p>查找占用磁盘IO最多的进程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -c http:&#x2F;&#x2F;linux.web.psi.ch&#x2F;dist&#x2F;scientific&#x2F;5&#x2F;gfa&#x2F;all&#x2F;dstat-0.6.7-1.rf.noarch.rpm</span><br><span class="line"></span><br><span class="line">dstat -M topio -d -M topbio</span><br></pre></td></tr></table></figure>
</li>
<li><p>去掉第一列（如行号代码）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">awk ‘&#123;for(i&#x3D;2;i&lt;&#x3D;NF;i++) if(i!&#x3D;NF)&#123;printf $i&quot; &quot;&#125;else&#123;print $i&#125; &#125;&#39; list</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出256中色彩</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for i in &#123;0..255&#125;; do echo -e &quot;\\e\[38;05;$&#123;i&#125;m$&#123;i&#125;&quot;; done | column -c 80 -s &#39; &#39;; echo -e &quot;\\e\[m&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看机器支持内存 机器插内存情况：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dmidecode |grep -P &quot;Maximum\\s+Capacity&quot;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>机器最大支持内存： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dmidecode |grep -P &quot;Maximum\\s+Capacity&quot;</span><br></pre></td></tr></table></figure>

<ol start="55">
<li><p>查看PHP-CGI占用的内存总数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">total&#x3D;0; for i in \&#96;ps -C php-cgi -o rss&#x3D;\&#96;; do total&#x3D;$(($total+$i)); done; echo &quot;PHP-CGI Memory usage: $total kb&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看主板型号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># dmidecode |grep -A 8 &quot;System Information&quot;System Information</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看cpu型号，主频</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cat &#x2F;proc&#x2F;cpuinfo | grep name | cut -f2 -d: | uniq -c</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看内存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># free -m</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看内存条数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~\]# dmidecode -t memory|grep Size</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看硬盘大小，分区</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~\]# df -hFilesystem Size Used Avail Use% Mounted on&#x2F;dev&#x2F;sda3 119G 17G 96G 15% &#x2F;</span><br><span class="line">[root@localhost ~\]# dmesg |grep -i raid</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看网卡</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~\]# lspci | grep -i &#39;eth&#39;05:00.0 Ethernet controller: Intel Corporation 82576 Gigabit Network Connection (rev 01)05:00.1 Ethernet controller: Intel Corporation 82576 Gigabit Network Connection (rev 01)</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看2号网络流量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># sar -n DEV -f &#x2F;var&#x2F;log&#x2F;sa&#x2F;sa2 |grep eth|less</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看板载显示信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~\]# dmidecode |grep -A 5 &quot;On Board Device Information&quot;On Board Device</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>作者：NetSeek 来源：<a href="http://bbs.linuxtone.org/thread-16-1-1.html" target="_blank" rel="noopener">http://bbs.linuxtone.org/thread-16-1-1.html</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux运维高手必备的10个系统命令</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h2 id="Linux运维高手必备的10个系统命令"><a href="#Linux运维高手必备的10个系统命令" class="headerlink" title="Linux运维高手必备的10个系统命令"></a>Linux运维高手必备的10个系统命令</h2><h3 id="下面可能是你不曾用过的十个Linux的命令。相当的有用"><a href="#下面可能是你不曾用过的十个Linux的命令。相当的有用" class="headerlink" title="下面可能是你不曾用过的十个Linux的命令。相当的有用"></a>下面可能是你不曾用过的十个Linux的命令。相当的有用</h3><ol>
<li>pgrep<br>pgrep名字前有个p，我们可以猜到这和进程相关，又是grep，当然这是进程相关的grep命令。不过，这个命令主要是用来列举进程ID的。如：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pgrep -u hchen</span><br><span class="line">22441</span><br><span class="line">22444</span><br></pre></td></tr></table></figure>
这个命令相当于：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -ef | egrep &#39;^hchen&#39; | awk &#39;&#123;print $2&#125;&#39;</span><br></pre></td></tr></table></figure></li>
<li>pstree<br>这个命令可以以树形的方式列出进程。如下所示：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[hchen@RHELSVR5 ~]$ pstree</span><br><span class="line">init-+-acpid</span><br><span class="line">     |-auditd-+-python</span><br><span class="line">     |        &#96;-&#123;auditd&#125;</span><br><span class="line">     |-automount---4*[&#123;automount&#125;]</span><br><span class="line">     |-backup.sh---sleep</span><br><span class="line">     |-dbus-daemon</span><br><span class="line">     |-events&#x2F;0</span><br><span class="line">     |-events&#x2F;1</span><br><span class="line">     |-hald---hald-runner---hald-addon-acpi</span><br><span class="line">     |-httpd---10*[httpd]</span><br><span class="line">     |-irqbalance</span><br><span class="line">     |-khelper</span><br><span class="line">     |-klogd</span><br><span class="line">     |-ksoftirqd&#x2F;0</span><br><span class="line">     |-ksoftirqd&#x2F;1</span><br><span class="line">     |-kthread-+-aio&#x2F;0</span><br><span class="line">     |         |-aio&#x2F;1</span><br><span class="line">     |         |-ata&#x2F;0</span><br><span class="line">     |         |-ata&#x2F;1</span><br><span class="line">     |         |-ata_aux</span><br><span class="line">     |         |-cqueue&#x2F;0</span><br><span class="line">     |         |-cqueue&#x2F;1</span><br><span class="line">     |         |-kacpid</span><br><span class="line">     |         |-kauditd</span><br><span class="line">     |         |-kblockd&#x2F;0</span><br><span class="line">     |         |-kblockd&#x2F;1</span><br><span class="line">     |         |-kedac</span><br><span class="line">     |         |-khubd</span><br><span class="line">     |         |-6*[kjournald]</span><br><span class="line">     |         |-kmirrord</span><br><span class="line">     |         |-kpsmoused</span><br><span class="line">     |         |-kseriod</span><br><span class="line">     |         |-kswapd0</span><br><span class="line">     |         |-2*[pdflush]</span><br><span class="line">     |         |-scsi_eh_0</span><br><span class="line">     |         |-scsi_eh_1</span><br><span class="line">     |         |-xenbus</span><br><span class="line">     |         &#96;-xenwatch</span><br><span class="line">     |-migration&#x2F;0</span><br><span class="line">     |-migration&#x2F;1</span><br><span class="line">     |-6*[mingetty]</span><br><span class="line">     |-3*[multilog]</span><br><span class="line">     |-mysqld_safe---mysqld---9*[&#123;mysqld&#125;]</span><br><span class="line">     |-smartd</span><br><span class="line">     |-sshd---sshd---sshd---bash---pstree</span><br><span class="line">     |-svscanboot---svscan-+-3*[supervise---run]</span><br><span class="line">     |                     |-supervise---qmail-send-+-qmail-clean</span><br><span class="line">     |                     |                        |-qmail-lspawn</span><br><span class="line">     |                     |                        &#96;-qmail-rspawn</span><br><span class="line">     |                     &#96;-2*[supervise---tcpserver]</span><br><span class="line">     |-syslogd</span><br><span class="line">     |-udevd</span><br><span class="line">     |-watchdog&#x2F;0</span><br><span class="line">     |-watchdog&#x2F;1</span><br><span class="line">     &#96;-xinetd</span><br></pre></td></tr></table></figure></li>
<li>bc<br>这个命令主要是做一个精度比较高的数学运算的。比如开平方根等。下面是一个我们利用bc命令写的一个脚本（文件名：sqrt）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">if [ $</span><br><span class="line">then</span><br><span class="line">    echo &#39;Usage: sqrt number&#39;</span><br><span class="line">    exit 1</span><br><span class="line">else</span><br><span class="line">    echo -e &quot;sqrt($1)\nquit\n&quot; | bc -q -i</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
于是，我们可以这样使用这个脚本进行平方根运算：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[hchen@RHELSVR5]$ .&#x2F;sqrt 36</span><br><span class="line">6</span><br><span class="line">[hchen@RHELSVR5]$ .&#x2F;sqrt 2.0000</span><br><span class="line">1.4142</span><br><span class="line">[hchen@RHELSVR5]$ .&#x2F;sqrt 10.0000</span><br><span class="line">3.1622</span><br></pre></td></tr></table></figure></li>
<li>split<br>如果你有一个很大的文件，你想把其分割成一些小的文件，那么这个命令就是干这件事的了。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hchen@RHELSVR5 applebak]# ls -l largefile.tar.gz</span><br><span class="line">-rw-r--r-- 1 hchen hchen 436774774 04-17 02:00 largefile.tar.gz</span><br><span class="line"></span><br><span class="line">[hchen@RHELSVR5 applebak]# split -b 50m largefile.tar.gz LF_</span><br><span class="line"></span><br><span class="line">[hchen@RHELSVR5]# ls -l LF_*</span><br><span class="line">-rw-r--r-- 1 hchen hchen 52428800 05-10 18:34 LF_aa</span><br><span class="line">-rw-r--r-- 1 hchen hchen 52428800 05-10 18:34 LF_ab</span><br><span class="line">-rw-r--r-- 1 hchen hchen 52428800 05-10 18:34 LF_ac</span><br><span class="line">-rw-r--r-- 1 hchen hchen 52428800 05-10 18:34 LF_ad</span><br><span class="line">-rw-r--r-- 1 hchen hchen 52428800 05-10 18:34 LF_ae</span><br><span class="line">-rw-r--r-- 1 hchen hchen 52428800 05-10 18:35 LF_af</span><br><span class="line">-rw-r--r-- 1 hchen hchen 52428800 05-10 18:35 LF_ag</span><br><span class="line">-rw-r--r-- 1 hchen hchen 52428800 05-10 18:35 LF_ah</span><br><span class="line">-rw-r--r-- 1 hchen hchen 17344374 05-10 18:35 LF_ai</span><br></pre></td></tr></table></figure>
文件合并只需要使用简单的合并就行了，如:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[hchen@RHELSVR5]#  cat LF_* &gt;largefile.tar.gz</span><br></pre></td></tr></table></figure></li>
<li>nl<br>nl命令其它和cat命令很像，只不过它会打上行号。如下所示:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[hchen@RHELSVR5 include]# nl stdio.h | head -n 10</span><br><span class="line">     1  &#x2F;* Define ISO C stdio on top of C++ iostreams.</span><br><span class="line">     2     Copyright (C) 1991,1994-2004,2005,2006 Free Software Foundation, Inc.</span><br><span class="line">     3     This file is part of the GNU C Library.</span><br><span class="line"></span><br><span class="line">     4     The GNU C Library is free software; you can redistribute it and&#x2F;or</span><br><span class="line">     5     modify it under the terms of the GNU Lesser General Public</span><br><span class="line">     6     License as published by the Free Software Foundation; either</span><br><span class="line">     7     version 2.1 of the License, or (at your option) any later version.</span><br><span class="line"></span><br><span class="line">     8     The GNU C Library is distributed in the hope that it will be useful,</span><br></pre></td></tr></table></figure></li>
<li>mkfifo<br>熟悉Unix的人都应该知道这个是一个创建有名管道的系统调用或命令。平时，我们在命令行上使用竖线“|”把命令串起来可使用无命管道。而我们使用mkfifo则使用的是有名管道。下面是示例:<br>下面是创建一个有名管道:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[hchen@RHELSVR5 ~]# mkfifo &#x2F;tmp&#x2F;hchenpipe</span><br><span class="line"></span><br><span class="line">[hchen@RHELSVR5 ~]# ls -l &#x2F;tmp</span><br><span class="line">prw-rw-r-- 1 hchen  hchen  0 05-10 18:58 hchenpipe</span><br></pre></td></tr></table></figure>
然后，我们在一个shell中运行如下命令，这个命令不会返回，除非有人从这个有名管道中把信息读走<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[hchen@RHELSVR5 ~]# ls -al &gt; &#x2F;tmp&#x2F;hchenpipe</span><br></pre></td></tr></table></figure>
我们在另一个命令窗口中读取这个管道中的信息：（其会导致上一个命令返回）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[hchen@RHELSVR5 ~]# head &#x2F;tmp&#x2F;hchenpipe</span><br><span class="line">drwx------ 8 hchen hchen    4096 05-10 18:27 .</span><br><span class="line">drwxr-xr-x 7 root  root     4096 03-05 00:06 ..</span><br><span class="line">drwxr-xr-x 3 hchen hchen    4096 03-01 18:13 backup</span><br><span class="line">-rw------- 1 hchen hchen     721 05-05 22:12 .bash_history</span><br><span class="line">-rw-r--r-- 1 hchen hchen      24 02-28 22:20 .bash_logout</span><br><span class="line">-rw-r--r-- 1 hchen hchen     176 02-28 22:20 .bash_profile</span><br><span class="line">-rw-r--r-- 1 hchen hchen     124 02-28 22:20 .bashrc</span><br><span class="line">-rw-r--r-- 1 root  root    14002 03-07 00:29 index.htm</span><br><span class="line">-rw-r--r-- 1 hchen hchen   31465 03-01 23:48 index.php</span><br></pre></td></tr></table></figure></li>
<li>ldd<br>这个命令可以知道你的一个可执行文件所使用了动态链接库。如:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[hchen@RHELSVR5 ~]# ldd &#x2F;usr&#x2F;bin&#x2F;java</span><br><span class="line">        linux-gate.so.1 &#x3D;&gt;  (0x00cd9000)</span><br><span class="line">        libgij.so.7rh &#x3D;&gt; &#x2F;usr&#x2F;lib&#x2F;libgij.so.7rh (0x00ed3000)</span><br><span class="line">        libgcj.so.7rh &#x3D;&gt; &#x2F;usr&#x2F;lib&#x2F;libgcj.so.7rh (0x00ed6000)</span><br><span class="line">        libpthread.so.0 &#x3D;&gt; &#x2F;lib&#x2F;i686&#x2F;nosegneg&#x2F;libpthread.so.0 (0x00110000)</span><br><span class="line">        librt.so.1 &#x3D;&gt; &#x2F;lib&#x2F;i686&#x2F;nosegneg&#x2F;librt.so.1 (0x009c8000)</span><br><span class="line">        libdl.so.2 &#x3D;&gt; &#x2F;lib&#x2F;libdl.so.2 (0x008b5000)</span><br><span class="line">        libz.so.1 &#x3D;&gt; &#x2F;usr&#x2F;lib&#x2F;libz.so.1 (0x00bee000)</span><br><span class="line">        libgcc_s.so.1 &#x3D;&gt; &#x2F;lib&#x2F;libgcc_s.so.1 (0x00aa7000)</span><br><span class="line">        libc.so.6 &#x3D;&gt; &#x2F;lib&#x2F;i686&#x2F;nosegneg&#x2F;libc.so.6 (0x0022f000)</span><br><span class="line">        libm.so.6 &#x3D;&gt; &#x2F;lib&#x2F;i686&#x2F;nosegneg&#x2F;libm.so.6 (0x00127000)</span><br><span class="line">        &#x2F;lib&#x2F;ld-linux.so.2 (0x00214000)</span><br></pre></td></tr></table></figure></li>
<li>col<br>这个命令可以让你把man文件转成纯文本文件。如下示例：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># # man less | col -b &gt; less.txt</span><br></pre></td></tr></table></figure></li>
<li>xmlwf<br>这个命令可以让你检查一下一个XML文档是否是所有的tag都是正常的。如:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[hchen@RHELSVR5 ~]# curl &#39;https:&#x2F;&#x2F;coolshell.cn&#x2F;?feed&#x3D;rss2&#39; &gt; cocre.xml</span><br><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100 64882    0 64882    0     0  86455      0 --:--:-- --:--:-- --:--:-- 2073k</span><br><span class="line">[hchen@RHELSVR5 ~]# xmlwf cocre.xml</span><br><span class="line">[hchen@RHELSVR5 ~]# perl -i -pe &#39;s@&lt;link&gt;@&lt;br&gt;@g&#39; cocre.xml</span><br><span class="line">[hchen@RHELSVR5 ~]# xmlwf cocre.xml</span><br><span class="line">cocre.xml:13:23: mismatched tag</span><br></pre></td></tr></table></figure></li>
<li>lsof<br>可以列出打开了的文件。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@RHELSVR5 ~]# lsof | grep TCP</span><br><span class="line">httpd       548    apache    4u     IPv6   14300967    TCP *:http (LISTEN)</span><br><span class="line">httpd       548    apache    6u     IPv6   14300972    TCP *:https (LISTEN)</span><br><span class="line">httpd       561    apache    4u     IPv6   14300967    TCP *:http (LISTEN)</span><br><span class="line">httpd       561    apache    6u     IPv6   14300972    TCP *:https (LISTEN)</span><br><span class="line">sshd       1764      root    3u     IPv6       4993    TCP *:ssh (LISTEN)</span><br><span class="line">tcpserver  8965      root    3u     IPv4  153795500    TCP *:pop3 (LISTEN)</span><br><span class="line">mysqld    10202     mysql   10u     IPv4   73819697    TCP *:mysql (LISTEN)</span><br><span class="line">sshd      10735      root    3u     IPv6  160731956    TCP 210.51.0.232:ssh-&gt;123.117.239.68:31810 (ESTABLISHED)</span><br><span class="line">sshd      10767     hchen    3u     IPv6  160731956    TCP 210.51.0.232:ssh-&gt;123.117.239.68:31810 (ESTABLISHED)</span><br><span class="line">vsftpd    11095      root    3u     IPv4  152157957    TCP *:ftp (LISTEN)</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title> Logrotate日志切割</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h2 id="Logrotate日志切割"><a href="#Logrotate日志切割" class="headerlink" title="Logrotate日志切割"></a>Logrotate日志切割</h2><h3 id="crontab配置"><a href="#crontab配置" class="headerlink" title="crontab配置"></a>crontab配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">59 23 * * * &#x2F;usr&#x2F;sbin&#x2F;logrotate  -f  &#x2F;data&#x2F;scripts&#x2F;logrotate_pylog.conf</span><br></pre></td></tr></table></figure>

<h3 id="logrotate配置"><a href="#logrotate配置" class="headerlink" title="logrotate配置"></a>logrotate配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;data&#x2F;service&#x2F;proxy-pool-master-select&#x2F;nohup.out</span><br><span class="line">&#123;</span><br><span class="line">    rotate 1</span><br><span class="line">    daily</span><br><span class="line">    dateext</span><br><span class="line">    missingok</span><br><span class="line">    notifempty</span><br><span class="line">    compress</span><br><span class="line">    delaycompress</span><br><span class="line">    copytruncate</span><br><span class="line">    olddir &#x2F;data&#x2F;service&#x2F;proxy-pool-master-select</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;data&#x2F;service&#x2F;proxy-pool-master-core&#x2F;nohup.out</span><br><span class="line">&#123;</span><br><span class="line">    rotate 1</span><br><span class="line">    daily</span><br><span class="line">    dateext</span><br><span class="line">    missingok</span><br><span class="line">    notifempty</span><br><span class="line">    compress</span><br><span class="line">    delaycompress</span><br><span class="line">    copytruncate</span><br><span class="line">    olddir &#x2F;data&#x2F;service&#x2F;proxy-pool-master-core</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Lsof VS netstat</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h2 id="Lsof-VS-netstat"><a href="#Lsof-VS-netstat" class="headerlink" title="Lsof VS netstat"></a>Lsof VS netstat</h2><p>众所周知水果系统内核是有 BSD 血统的 Darwin，OS X 自带的很多 CLI 工具也是 BSD style 的，有一部分使用起来和 Linux 无异，有一部分可以通过 brew 安装 GNU 版本（如 tar），但是 OS X 的 netstat 不能查看使用端口的程序名让我一直很不爽，而且也没找到 GNU 版本，于是去搜了一下解决办法，stackoverflow 上的结论基本都是建议使用 lsof 代替 netstat 进行查看：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo lsof -nP -iTCP:端口号 -sTCP:LISTEN</span><br></pre></td></tr></table></figure>
<ul>
<li>-n 表示不显示主机名</li>
<li>-P 表示不显示端口俗称</li>
<li>不加 sudo 只能查看以当前用户运行的程序</li>
</ul>
<p>另外，还可以通过管道来过滤想要的信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo lsof -nP -iTCP -sTCP:LISTEN | grep python</span><br></pre></td></tr></table></figure>
<p>基本效果如下：<br>查看当前所有监听的端口以及对应的Command和PID</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  ~ lsof -nP -iTCP -sTCP:LISTEN</span><br><span class="line">COMMAND    PID     USER   FD   TYPE             DEVICE SIZE&#x2F;OFF NODE NAME</span><br><span class="line">SSH\x20Pr 1553 tonydeng    8u  IPv4 0xee7327e39355d175      0t0  TCP 127.0.0.1:8087 (LISTEN)</span><br><span class="line">SSH\x20Pr 1553 tonydeng    9u  IPv6 0xee7327e38aad6e15      0t0  TCP [::1]:8087 (LISTEN)</span><br><span class="line">java      2978 tonydeng  166u  IPv6 0xee7327e38aad7e35      0t0  TCP *:62622 (LISTEN)</span><br><span class="line">node      3319 tonydeng   31u  IPv4 0xee7327e39f0f8745      0t0  TCP *:4000 (LISTEN)</span><br></pre></td></tr></table></figure>
<p>查看指定端口对应的Command和PID</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  ~ lsof -nP -iTCP:4000 -sTCP:LISTEN</span><br><span class="line">COMMAND  PID     USER   FD   TYPE             DEVICE SIZE&#x2F;OFF NODE NAME</span><br><span class="line">node    3319 tonydeng   31u  IPv4 0xee7327e39f0f8745      0t0  TCP *:4000 (LISTEN)</span><br></pre></td></tr></table></figure>
<p>PS: 输出占用该端口的 PID</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lsof -nP -iTCP:4000 |grep LISTEN|awk &#39;&#123;print $2;&#125;&#39;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title> Mysql 表设计规范及开发</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h2 id="Mysql-规范"><a href="#Mysql-规范" class="headerlink" title="Mysql 规范"></a>Mysql 规范</h2><p>1.命名规范<br>(1)库名、表名、字段名必须使用小写字母,并采用下划线分割。</p>
<p>(2)库名、表名、字段名禁止超过32个字符。</p>
<p>(3)库名、表名、字段名必须见名知意。命名与业务、产品线等相关联。</p>
<p>(4)库名、表名、字段名禁止使用MySQL保留字。</p>
<p>(5)表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint（1 表示是， 0 表示否）</p>
<p>(6)表名不使用复数名词</p>
<p>(7)临时库、表名必须以tmp为前缀,并以日期为后缀。例如 tmp_test01_20130704。</p>
<p>(8)备份库、表必须以bak为前缀,并以日期为后缀。例如 bak_test01_20130704。</p>
<p>2.基础规范<br>(1)使用INNODB存储引擎。</p>
<p>(2)表字符集使用utf8字符集。如果要使用表情，那么使用 utf8mb4 来进行存储.</p>
<p>(3)所有表都需要添加注释;所有字段都需要增加注释。推荐采用英文标点,避免出现乱码。</p>
<p>(4)禁止在数据库中存储图片、文件等大数据。</p>
<p>(5)每张表数据量建议控制在5000W以内。</p>
<p>(6)禁止在线上做数据库压力测试。</p>
<p>(7)禁止从测试、开发环境直连生产数据库。</p>
<p>3.库表设计<br>(1)禁止使用分区表。</p>
<p>(2)将大字段、访问频率低的字段拆分到单独的表中存储,分离冷热数据。</p>
<p>(3)按日期时间分表需符合YYYY[MM][DD][HH]格式,例如2013071601。年份必须用4位数字表示。例如按日散表user_20110209、 按月散表user_201102。</p>
<p>(4)采用合适的分库分表策略。例如千库十表、十库百表等。</p>
<p>4.字段设计<br>(1)建议使用UNSIGNED存储非负数值。</p>
<p>(2)建议使用INT UNSIGNED存储IPV4。</p>
<p>(3)用DECIMAL代替FLOAT和DOUBLE存储精确浮点数。例如与货币、金融相关的数据。</p>
<p>(4)INT类型固定占用4字节存储,例如INT(4)仅代表显示字符宽度为4位,不代表存储长度。</p>
<p>(5)区分使用TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT数据类型。例如取值范围为0-80时,使用TINYINT UNSIGNED。</p>
<p>(6)强烈建议使用TINYINT来代替ENUM类型。</p>
<p>(7)尽可能不使用TEXT、BLOB类型。</p>
<p>(8)禁止在数据库中存储明文密码。</p>
<p>(9)使用VARBINARY存储大小写敏感的变长字符串或二进制内容。</p>
<p>(10)使用尽可能小的VARCHAR字段。VARCHAR(N)中的N表示字符数而非字节数。</p>
<p>(11)区分使用DATETIME和TIMESTAMP。存储年使用YEAR类型。存储日期使用DATE类型。 存储时间(精确到秒)建议使用TIMESTAMP类型。</p>
<p>(12)所有字段均定义为NOT NULL。</p>
<p>(13)字段允许适当冗余，以提高性能</p>
<p> 5.索引规范<br>(1)单张表中索引数量不超过5个。</p>
<p>(2)单个索引中的字段数不超过5个。</p>
<p>(3)索引名必须全部使用小写。</p>
<p>(4)非唯一索引按照“idx_字段名称[_字段名称]”进用行命名。例如idx_age_name。</p>
<p>(5)唯一索引按照“uniq_字段名称[_字段名称]”进用行命名。例如uniq_age_name。</p>
<p>(6)组合索引建议包含所有字段名,过长的字段名可以采用缩写形式。例如idx_age_name_add。</p>
<p>(7)表必须有主键,推荐使用UNSIGNED自增列作为主键。</p>
<p>(8)唯一键由3个以下字段组成,并且字段都是整形时,可使用唯一键作为主键。其他情况下,建议使用自增列或发号器作主键。</p>
<p>(9)禁止冗余索引。</p>
<p>(10)禁止重复索引。</p>
<p>(11)禁止使用外键。</p>
<p>(12)联表查询时,JOIN列的数据类型必须相同,并且要建立索引。</p>
<p>(13)不在低基数列上建立索引,例如“性别”。</p>
<p>(14)选择区分度大的列建立索引。组合索引中,区分度大的字段放在最前。</p>
<p>(15)对字符串使用前缀索引,前缀索引长度不超过8个字符。</p>
<p>(16)不对过长的VARCHAR字段建立索引。建议优先考虑前缀索引,或添加CRC32或MD5伪列并建立索引。</p>
<p>(17)合理创建联合索引,(a,b,c) 相当于 (a) 、(a,b) 、(a,b,c)。</p>
<p>(18)合理使用覆盖索引减少IO,避免排序。</p>
<p>6.SQL设计<br>(1)使用prepared statement,可以提升性能并避免SQL注入。</p>
<p>(2)使用IN代替OR。SQL语句中IN包含的值不应过多,应少于1000个。</p>
<p>(3)禁止隐式转换。数值类型禁止加引号;字符串类型必须加引号。</p>
<p>(4)避免使用JOIN和子查询。必要时推荐用JOIN代替子查询。超过3个表严禁join</p>
<p>(5)禁止在MySQL中进行数学运算和函数运算。</p>
<p>(6)减少与数据库交互次数,尽量采用批量SQL语句。</p>
<p>(7)拆分复杂SQL为多个小SQL,避免大事务。</p>
<p>(8)获取大量数据时,建议分批次获取数据,每次获取数据少于2000条,结果集应小于1M。</p>
<p>(9)使用UNION ALL代替UNION。</p>
<p>(10)统计行数使用COUNT(*)。</p>
<p>(11)SELECT只获取必要的字段,禁止使用SELECT *。</p>
<p>(12)SQL中避免出现now()、rand()、sysdate()、current_user()等不确定结果的函数。</p>
<p>13)INSERT语句必须指定字段列表,禁止使用 INSERT INTO TABLE()。</p>
<p>(14)禁止单条SQL语句同时更新多个表。</p>
<p>(15)禁止使用存储过程、触发器、视图、自定义函数等。</p>
<p>(16)建议使用合理的分页方式以提高分页效率。</p>
<p>(17)禁止在从库上执行后台管理和统计类功能的QUERY,必要时申请统计类从库。</p>
<p>(18)程序应有捕获SQL异常的处理机制,必要时通过rollback显式回滚。</p>
<p>(19)重要SQL必须被索引:update、delete的where条件列、order by、group by、distinct字段、多表join字段。</p>
<p>(20)禁止使用%前导查询,例如:like “%abc”,无法利用到索引。</p>
<p>(21)禁止使用负向查询,例如 not in、!=、not like。</p>
<p>(22)使用EXPLAIN判断SQL语句是否合理使用索引,尽量避免extra列出现:Using File Sort、Using Temporary。</p>
<p>(23)禁止使用order by rand()。</p>
<p>7.行为规范<br>(1)表结构变更必须通知DBA进行审核。</p>
<p>(2)禁止有super权限的应用程序账号存在。</p>
<p>(3)禁止有DDL、DCL权限的应用程序账号存在。</p>
<p>(4)重要项目的数据库方案选型和设计必须提前通知DBA参与。</p>
<p>(5)批量导入、导出数据必须通过DBA审核,并在执行过程中观察服务。</p>
<p>(6)批量更新数据,如UPDATE、DELETE操作,必须DBA进行审核,并在执行过程中观察服务。</p>
<p>(7)产品出现非数据库导致的故障时,如被攻击,必须及时通DBA,便于维护服务稳定。</p>
<p>(8)业务部门程序出现BUG等影响数据库服务的问题,必须及时通知DBA,便于维护服务稳定。</p>
<p>(9)业务部门推广活动或上线新功能,必须提前通知DBA进行服务和访问量评估,并留出必要时间以便DBA完成扩容。</p>
<p>(10)出现业务部门人为误操作导致数据丢失,需要恢复数据的,必须第一时间通知DBA,并提供准确时间点、 误操作语句等重要线索。</p>
<p>(11)提交线上建表改表需求,必须详细注明涉及到的所有SQL语句(包括INSERT、DELETE、UPDATE),便于DBA进⾏行审核和优化。</p>
<p>(12)对同一个表的多次alter操作必须合并为一次操作。</p>
<p>(13)不要在MySQL数据库中存放业务逻辑。</p>
<p>8.FAQ<br>1.库名、表名、字段名必须使用小写字母,并采用下划线分割。<br>a)MySQL有配置参数lower_case_table_names,不可动态更改,linux系统默认为 0,即库表名以实际情况存储,大小写敏感。如果是1,以小写存储,大小写不敏感。如果是2,以实际情况存储,但以小写比较。</p>
<p>b)如果大小写混合使用,可能存在abc,Abc,ABC等多个表共存,容易导致混乱。</p>
<p>c)字段名显式区分大小写,但实际使用不区分,即不可以建立两个名字一样但大小写不一样的字段。</p>
<p>d)为了统一规范, 库名、表名、字段名使用小写字母。</p>
<p>2.库名、表名、字段名禁止超过32个字符。<br>库名、表名、字段名支持最多64个字符,但为了统一规范、易于辨识以及减少传输量,禁止超过32个字符。 </p>
<p>3.使用INNODB存储引擎。<br>INNODB引擎是MySQL5.5版本以后的默认引擘,支持事务、行级锁,有更好的数据恢复能力、更好的并发性能,同时对多核、大内存、SSD等硬件支持更好,支持数据热备份等,因此INNODB相比MyISAM有明显优势。</p>
<p>4.库名、表名、字段名禁止使用MySQL保留字。<br>当库名、表名、字段名等属性含有保留字时,SQL语句必须用反引号引用属性名称,这将使得SQL语句书写、SHELL脚本中变量的转义等变得非常复杂。</p>
<p>5.禁止使用分区表。<br>分区表对分区键有严格要求;分区表在表变大后,执行DDL、SHARDING、单表恢复等都变得更加困难。因此禁止使用分区表,并建议业务端手动SHARDING。</p>
<p>6.建议使用UNSIGNED存储非负数值。<br>同样的字节数,非负存储的数值范围更大。如TINYINT有符号为 -128-127,无符号为0-255。</p>
<p>7.建议使用INT UNSIGNED存储IPV4。<br>UNSINGED INT存储IP地址占用4字节,CHAR(15)则占用15字节。另外,计算机处理整数类型比字符串类型快。使用INT UNSIGNED而不是CHAR(15)来存储IPV4地址,通过MySQL函数inet_ntoa和inet_aton来进行转化。IPv6地址目前没有转化函数,需要使用DECIMAL或两个BIGINT来存储。</p>
<p>例如:</p>
<p>SELECT INET_ATON(‘209.207.224.40’); 3520061480</p>
<p>SELECT INET_NTOA(3520061480); 209.207.224.40</p>
<p>8.强烈建议使用TINYINT来代替ENUM类型。<br>ENUM类型在需要修改或增加枚举值时,需要在线DDL,成本较大;ENUM列值如果含有数字类型,可能会引起默认值混淆。</p>
<p>9.使用VARBINARY存储大小写敏感的变长字符串或二进制内容。<br>VARBINARY默认区分大小写,没有字符集概念,速度快。</p>
<p>10.INT类型固定占用4字节存储,例如INT(4)仅代表显示字符宽度为4位,不代表存储长度。<br>数值类型括号后面的数字只是表示宽度而跟存储范围没有关系,比如INT(3)默认显示3位,空格补齐,超出时正常显示,python、java客户端等不具备这个功能。</p>
<p>11.区分使用DATETIME和TIMESTAMP。存储年使用YEAR类型。存储日期使用DATE类型。 存储时间(精确到秒)建议使用TIMESTAMP类型。<br>DATETIME和TIMESTAMP都是精确到秒,优先选择TIMESTAMP,因为TIMESTAMP只有4个字节,而DATETIME8个字节。同时TIMESTAMP具有自动赋值以及自动更新的特性。注意:在5.5和之前的版本中,如果一个表中有多个timestamp列,那么最多只能有一列能具有自动更新功能。</p>
<p>如何使用TIMESTAMP的自动赋值属性?<br>a)自动初始化,并自动更新: column1 TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP</p>
<p>b)只是自动初始化: column1 TIMESTAMP DEFAULT CURRENT_TIMESTAMP</p>
<p>c)自动更新,初始化的值为0: column1 TIMESTAMP DEFAULT 0 ON UPDATE CURRENT_TIMESTAMP</p>
<p>d)初始化的值为0: column1 TIMESTAMP DEFAULT 0</p>
<p>12.所有字段均定义为NOT NULL。<br>a)对表的每一行,每个为NULL的列都需要额外的空间来标识。</p>
<p>b)B树索引时不会存储NULL值,所以如果索引字段可以为NULL,索引效率会下降。</p>
<p>c)建议用0、特殊值或空串代替NULL值。</p>
<p>13.将大字段、访问频率低的字段拆分到单独的表中存储,分离冷热数据。<br>有利于有效利用缓存,防止读入无用的冷数据,较少磁盘IO,同时保证热数据常驻内存提高缓存命中率。 </p>
<p>14.禁止在数据库中存储明文密码。<br>采用加密字符串存储密码，并保证密码不可解密，同时采用随机字符串加盐保证密码安全。防止数据库数据被公司内部人员或黑客获取后，采用字典攻击等方式暴力破解用户密码。</p>
<p>15.表必须有主键,推荐使用UNSIGNED自增列作为主键。<br>表没有主键,INNODB会默认设置隐藏的主键列;没有主键的表在定位数据行的时候非常困难,也会降低基于行复制的效率。</p>
<p>16.禁止冗余索引。<br>索引是双刃剑,会增加维护负担,增大IO压力。(a,b,c)、(a,b),后者为冗余索引。可以利用前缀索引来达到加速目的,减轻维护负担。</p>
<p>17.禁止重复索引。<br>primary key a;uniq index a;重复索引增加维护负担、占用磁盘空间,同时没有任何益处。</p>
<p>18.不在低基数列上建立索引,例如“性别”。<br>大部分场景下,低基数列上建立索引的精确查找,相对于不建立索引的全表扫描没有任何优势,而且增大了IO负担。</p>
<p>19.合理使用覆盖索引减少IO,避免排序。<br>覆盖索引能从索引中获取需要的所有字段,从而避免回表进行二次查找,节省IO。INNODB存储引擎中, secondary index(非主键索引,又称为辅助索引、二级索引)没有直接存储行地址,而是存储主键值。如果用户需要查询secondary index中所不包含的数据列,则需要先通过secondary index查找到主键值,然后再通过主键查询到其他数据列,因此需要查询两次。覆盖索引则可以在一个索引中获取所有需要的数据,因此效率较高。主键查询是天然的覆盖索引。例如SELECT email,uid FROM user_email WHERE uid=xx,如果uid 不是主键,适当时候可以将索引添加为index(uid,email),以获得性能提升。</p>
<p>20.用IN代替OR。SQL语句中IN包含的值不应过多,应少于1000个。<br>IN是范围查找,MySQL内部会对IN的列表值进行排序后查找,比OR效率更高。</p>
<p>21.表字符集使用UTF8,必要时可申请使用UTF8MB4字符集。<br>a)UTF8字符集存储汉字占用3个字节,存储英文字符占用一个字节。</p>
<p>b)UTF8统一而且通用,不会出现转码出现乱码风险。</p>
<p>c)如果遇到EMOJ等表情符号的存储需求,可申请使用UTF8MB4字符集。</p>
<p>22.用UNION ALL代替UNION。<br>UNION ALL不需要对结果集再进行排序。</p>
<p>23.禁止使用order by rand()。<br>order by rand()会为表增加一个伪列,然后用rand()函数为每一行数据计算出rand()值,然后基于该行排序, 这通常都会生成磁盘上的临时表,因此效率非常低。建议先使用rand()函数获得随机的主键值,然后通过主键获取数据。</p>
<p>24.建议使用合理的分页方式以提高分页效率。<br>第一种分页写法：</p>
<p>select *<br>  from t<br> where thread_id = 771025<br>   and deleted = 0<br> order by gmt_create asc limit 0, 15;</p>
<p> 原理：一次性根据过滤条件取出所有字段进行排序返回。</p>
<p> 数据访问开销=索引IO+索引全部记录结果对应的表数据IO</p>
<p> 缺点：该种写法越翻到后面执行效率越差，时间越长，尤其表数据量很大的时候。</p>
<p>适用场景：当中间结果集很小（10000行以下）或者查询条件复杂（指涉及多个不同查询字段或者多表连接）时适用。</p>
<p>第二种分页写法：</p>
<p>select t.* from (</p>
<pre><code>select id from t

 where thread_id = 771025 and deleted = 0 order by gmt_create asc limit 0, 15) a, t </code></pre><p> where a.id = t.id;</p>
<p>前提：假设t表主键是id列，且有覆盖索引secondary key:(thread_id, deleted, gmt_create)</p>
<p>原理：先根据过滤条件利用覆盖索引取出主键id进行排序，再进行join操作取出其他字段。</p>
<p>数据访问开销=索引IO+索引分页后结果（例子中是15行）对应的表数据IO。</p>
<p>优点：每次翻页消耗的资源和时间都基本相同，就像翻第一页一样。</p>
<p>适用场景：当查询和排序字段（即where子句和order by子句涉及的字段）有对应覆盖索引时，且中间结果集很大的情况时适用。</p>
<p>25.SELECT只获取必要的字段,禁止使用SELECT *。<br>减少网络带宽消耗;</p>
<p>能有效利用覆盖索引;</p>
<p>表结构变更对程序基本无影响。</p>
<p>26.SQL中避免出现now()、rand()、sysdate()、current_user()等不确定结果的函数。<br>语句级复制场景下,引起主从数据不一致;不确定值的函数,产生的SQL语句无法利用QUERY CACHE。 </p>
<p>27.采用合适的分库分表策略。例如千库十表、十库百表等。<br>采用合适的分库分表策略,有利于业务发展后期快速对数据库进行水平拆分,同时分库可以有效利用MySQL的多线程复制特性。</p>
<p>28.减少与数据库交互次数,尽量采用批量SQL语句。<br>使用下面的语句来减少和db的交互次数:</p>
<p>a)INSERT … ON DUPLICATE KEY UPDATE</p>
<p>b)REPLACE INTO</p>
<p>c)INSERT IGNORE</p>
<p>d)INSERT INTO VALUES()</p>
<p>29.拆分复杂SQL为多个小SQL,避免大事务。<br>简单的SQL容易使用到MySQL的QUERY CACHE;减少锁表时间特别是MyISAM;可以使用多核CPU。</p>
<p>30.对同一个表的多次alter操作必须合并为一次操作。<br>mysql对表的修改绝大部分操作都需要锁表并重建表,而锁表则会对线上业务造成影响。为减少这种影响,必须把对表的多次alter操作合并为一次操作。例如,要给表t增加一个字段b,同时给已有的字段aa建立索引, 通常的做法分为两步:</p>
<p>alter table t add column b varchar(10);</p>
<p>然后增加索引:</p>
<p>alter table t add index idx_aa(aa);</p>
<p>正确的做法是:</p>
<p>alter table t add column b varchar(10),add index idx_aa(aa);</p>
<p>31.避免使用存储过程、触发器、视图、自定义函数等。<br>这些高级特性有性能问题,以及未知BUG较多。业务逻辑放到数据库会造成数据库的DDL、SCALE OUT、 SHARDING等变得更加困难。</p>
<p>32.禁止有super权限的应用程序账号存在。<br>安全第一。super权限会导致read only失效,导致较多诡异问题而且很难追踪。</p>
<p>33.提交线上建表改表需求,必须详细注明涉及到的所有SQL语句(包括INSERT、DELETE、UPDATE),便于DBA进行审核和优化。<br>并不只是SELECT语句需要用到索引。UPDATE、DELETE都需要先定位到数据才能执行变更。因此需要业务提供所有的SQL语句便于DBA审核。</p>
<p>34.不要在MySQL数据库中存放业务逻辑。<br>数据库是有状态的服务,变更复杂而且速度慢,如果把业务逻辑放到数据库中,将会限制业务的快速发展。建议把业务逻辑提前,放到前端或中间逻辑层,而把数据库作为存储层,实现逻辑与存储的分离。</p>
<h2 id="数据库开发规范"><a href="#数据库开发规范" class="headerlink" title="数据库开发规范"></a>数据库开发规范</h2><hr>
<p>建表栗子：</p>
<p>CREATE TABLE user (<br><code>id</code> bigint(11) NOT NULL AUTO_INCREMENT,<br><code>user_id</code> bigint(11) NOT NULL COMMENT ‘用户id<br>PRIMARY KEY (<code>id</code>),<br>UNIQUE KEY <code>ind_user_id</code> (<code>user_id</code>),<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=’网站用户基本信息’;</p>
<hr>
<p>inception强制限制</p>
<p>建表&amp;索引</p>
<p>1．表必须有主键，主键为ID,类型int 或者 bigint。<br>解读：<br>a,无主键的表，在row模式下主从延迟更高。<br>b,主键要选择较短的数据类型，Innodb引擎普通索引都会保存主键的值，主键小则索引小。</p>
<p>2, 建表时，列没有注释时报错。表没有注释时报错。</p>
<p>3, 禁止使用中文或者特殊字符或者SQL保留字。</p>
<p>4，不支持：分区表。仅支持字符集：utf8mb4,utf8。</p>
<p>5，单表索引个数不超过15个，复合索引列值不超过5个。</p>
<p>6，支持列设置字符集，支持列值为空。支持BLOB字段，不支持enum set bit。支持外键。（不建议使用BLOB, 不建议使用外键）</p>
<p>7，当char类型的长度大于36，就必须将其转换为VARCHAR。</p>
<p>8，timestamp设置为not null之后，默认值不能为’0000-00-00 00:00:00’。</p>
<p>9，id 为主键时，不能设置默认值</p>
<p>数据修改</p>
<p>1，数据修改禁止使用LIMIT，Order By，在DML语句中没有WHERE条件时，报错。</p>
<p>2，禁止单次修改超过1亿行。</p>
<p>3，drop truncate操作不支持。</p>
<p>4，delete需要写where条件。</p>
<hr>
<p>非强制，强烈建议。</p>
<ol>
<li>库，表，字段名称一律小写。下划线分隔。</li>
</ol>
<p>2．禁止使用procedure、view、trigger、Event。<br>解读：业务逻辑放到服务层相比procedure具备更好的扩展性，也降低DB的复杂度。Event显著增加数据库切换难度。</p>
<p>3．禁止使用BLOB。<br>解读：大文件，大照片，DB的读策略一般不缓存。</p>
<p>4，禁止使用外键。<br>解读：通过业务逻辑来解决主外键关系已经是主流了。</p>
<p>5．命名使用英文单词，避免拼音。表名称不能用双引号包含。<br>栗子：t_shiwu, t_foods。你看着选吧。</p>
<p>6.用DECIMAL代替FLOAT和DOUBLE存储精确浮点数。</p>
<ol start="7">
<li><p>金额相关的数据类型建议设置为bigint，以分计算。<br>解读： 不同的标准计算出来的总金额可能不一致。这可是银子。</p>
</li>
<li><p>线上数据只保留固定周期的数据（例如：半年），超过10G的表强制归档。<br>解读：线上数据越少，突然导致的性能问题越少。</p>
</li>
</ol>
<p>9．每个表增加最后更新时间。<br>update_time timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT ‘最后更新时间’<br>解读：数据组要求做增量更新用，此字段也无需维护。</p>
<ol start="10">
<li>新的应用访问DB请告之应用的功能，连接数，重要性等，降低因为缺乏沟通造成的潜在风险。<br>解读：新的mysql版本DBA会控制单用户默认连接数300，避免因程序bug导致的连接风暴。</li>
</ol>
<hr>
<p>性能规范</p>
<ol>
<li><p>只使用btree索引。<br>解读：简单，高效。</p>
</li>
<li><p>查询的字段建议创建索引。特别是在选择性高的列。<br>解读：SELECT、UPDATE、DELETE语句的WHERE条件列；2、多表JOIN的字段。</p>
</li>
<li><p>不在低基数列上建立索引，例如‘性别’。<br>解读：举个栗子：<br>0到100，索引查询1，选择度高，走索引。<br>100个人，50男，50女，选择度低，走索引性能比全表扫描更差，所以选择全表扫描。<br>全表扫描： 加载多个数据块到内存。<br>索引： 加载单个索引块，指针到数据块，加载数据块。</p>
</li>
</ol>
<p>4.避免冗余或重复索引。<br>解读：联合索引IX_a_b_c(a,b,c) 相当于 (a) 、(a,b) 、(a,b,c)，那么索引 (a) 、(a,b) 就是多余的。<br>但是不相当于(b)、（b,c）。</p>
<p>5.不使用SELECT *，只获取必要的字段。<br>解读：<br>消耗CPU和IO、消耗网络带宽；<br>无法使用覆盖索引。</p>
<p>6.避免数据类型不一致。<br>SELECT * FROM t WHERE id = ‘19’;<br>SELECT * FROM t WHERE id = 19;</p>
<p>8.禁止使用INSERT INTO t_xxx VALUES(xxx)，必须显示指定插入的列属性。<br>解读：容易在增加或者删除字段后出现程序BUG</p>
<p>9.禁止在WHERE条件的属性上使用函数或者表达式。<br>解读：SELECT uid FROM t_user WHERE from_unixtime(day)&gt;=’2017-02-15’ 会导致全表扫描<br>正确的写法是：SELECT uid FROM t_user WHERE day&gt;= unix_timestamp(‘2017-02-15 00:00:00’)</p>
<ol start="10">
<li><p>别用函数在字段上，这样不走索引。<br>数字存储：<br>性能差：FROM_UNIXTIME(pay_time) &gt;= curdate()<br>性能好：pay_time &gt;= UNIX_TIMESTAMP(CURDATE())</p>
</li>
<li><p>关键性能点减少表关联，解耦。这样方便拆分。<br>栗子：<br>很多业务都是围绕用户来的，所有很多线上业务都用用户表关联。长此以往，系统就变的不可拆分，而且臃肿。<br>正确的姿势因为是从接口获取用户数据，这样就没有强制的关联关系，方便业务拆分和扩展。</p>
</li>
</ol>
<hr>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx Rewrite</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h2 id="Nginx-Rewrite"><a href="#Nginx-Rewrite" class="headerlink" title="Nginx Rewrite"></a>Nginx Rewrite</h2><hr>


<p>网站在使用 Nginx 时都会进行个性化配置满足自己的业务需要，而 URL 重写几乎是每个网站都必做的事情，Nginx 的 URL 重写规则不像 Apache 那样简单直接，逻辑相对要复杂一些，本文将通过例子的方式帮助大家理解 Nginx rewrite 原理，希望能对您有些启发。</p>
<h2 id="Nginx-中重定向的多种方式"><a href="#Nginx-中重定向的多种方式" class="headerlink" title="Nginx 中重定向的多种方式"></a>Nginx 中重定向的多种方式</h2><h3 id="外部重定向"><a href="#外部重定向" class="headerlink" title="外部重定向"></a>外部重定向</h3><p>return 指令返回 301 或 302（return 也可以返回其他状态码），可以放在 server 或 location 块中。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">return 301 https:&#x2F;&#x2F;www.mi.com;</span><br><span class="line">or</span><br><span class="line">return 302 https:&#x2F;&#x2F;www.mi.com;</span><br></pre></td></tr></table></figure>

<p>还可以使用 rewrite 指令，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rewrite ^&#x2F;(.*)$   http:&#x2F;&#x2F;www.mi.com&#x2F;$1;</span><br><span class="line">or</span><br><span class="line">rewrite ^&#x2F;(.*)$   http:&#x2F;&#x2F;www.mi.com&#x2F; redirect;</span><br></pre></td></tr></table></figure>
<h3 id="内部重定向"><a href="#内部重定向" class="headerlink" title="内部重定向"></a>内部重定向</h3><p>return + error_page 指令的组合，或 try_files 指令和 rewrite 指令，非常灵活。</p>
<p>本文主要讲解 rewrite 的工作原理，其他指令的使用方法大家可以自行查阅 Nginx 官网。在使用 Nginx 的 rewrite 指令时，flag 可以设置为 last 和 break，这两个 flag 很容易混淆，后面我们会比较这两个 flag 的区别，下面通过示例我们来认识一下 rewrite 指令。</p>
<h2 id="rewrite-语法"><a href="#rewrite-语法" class="headerlink" title="rewrite 语法"></a>rewrite 语法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Syntax:    rewrite regex replacement [flag];</span><br><span class="line">Context:   server, location, if</span><br></pre></td></tr></table></figure>
<ul>
<li><p>regex： 对请求的 URI 做正则匹配</p>
</li>
<li><p>replacement：目标 uri 匹配成功后替换的 url</p>
</li>
<li><p>可以使用的 flag 有以下 4 个（flag 也可以为空）:</p>
<ul>
<li><p>redirect：返回 302 临时重定向，客户端地址栏会显示跳转后的地址；</p>
</li>
<li><p>permanent：返回 301 永久重定向，客户端地址栏会显示跳转后的地址；</p>
</li>
<li><p>last：内部重定向，停止处理后续 rewrite 模块中的指令（客户端无感知）；</p>
</li>
<li><p>break：内部重定向，停止处理后续 rewrite 模块中的指令（客户端无感知)。</p>
</li>
</ul>
</li>
</ul>
<h3 id="NOTE"><a href="#NOTE" class="headerlink" title="NOTE:"></a>NOTE:</h3><ol>
<li>regex 匹配的是 uri，不包含 hostname 和 query string，默认 query string 是被追加到 replacement 末尾，如果不希望在末尾追加请求的 query string，可以在 replacement 的末尾加一个 “?”。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    rewrite ^&#x2F;mi_one&#x2F;(.*)$  &#x2F;mi&#x2F;$1;</span><br><span class="line">    rewrite ^&#x2F;mi_two&#x2F;(.*)$  &#x2F;mi&#x2F;$1?x&#x3D;0&amp;y&#x3D;1?;</span><br><span class="line"></span><br><span class="line">    location &#x2F;mi&#x2F; &#123;        </span><br><span class="line">        echo $uri$is_args$args;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ curl &quot;http:&#x2F;&#x2F;localhost&#x2F;mi_one&#x2F;hello?a&#x3D;1&amp;b&#x3D;2&quot;</span><br><span class="line">output: &#x2F;mi&#x2F;hello?a&#x3D;1&amp;b&#x3D;2</span><br><span class="line"></span><br><span class="line">$ curl &quot;http:&#x2F;&#x2F;localhost&#x2F;mi_two&#x2F;hello?a&#x3D;1&amp;b&#x3D;2&quot;</span><br><span class="line">output: &#x2F;mi&#x2F;hello?x&#x3D;0&amp;y&#x3D;1</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>如果 replacement 是以 “http://“，”https://“ 或 $scheme” 开始的字符串，那么 rewrite 指令停止后面的处理，直接返回给客户端，没有指定 flag 时，与 redirect 效果相同。</p>
</li>
<li><p>没有 flag 的 rewrite 指令根据出现的顺序执行，flag 可以控制指令的执行顺序。</p>
</li>
<li><p>在配置中开启 rewrite_log 指令，日志文件中会记录 rewrite 的匹配过程，有助于调试 rewrite 问题。</p>
</li>
</ol>
<h2 id="Nginx-请求处理流程"><a href="#Nginx-请求处理流程" class="headerlink" title="Nginx 请求处理流程"></a>Nginx 请求处理流程</h2><p>在讲 rewrite 前我们先来简单了解下 Nginx 请求处理流程，为什么需要了解请求处理流程呢？因为 rewrite 操作与其中几个 phase 关系很密切，熟悉了请求处理流程，理解 rewrite 执行逻辑就会很容易。在 Nginx 内部将请求处理划分为 11 个 phase，每个 phase 会执行对应的 handler，这里我们不打算逐个进行讲解。在 11 个 phase 中与 rewrite 指令逻辑有关的只有 4 个，所以在本文我们主要关注 SERVER_REWRITE、FIND_CONFIG、REWRITE 和 POST_REWRITE 这四个 phase。</p>
<p>首先我们要清楚的是：</p>
<ul>
<li><p>server 块中的 rewrite 模块指令在 SERVER_REWRITE 阶段解析；</p>
</li>
<li><p>location 块中的 rewrite 模块指令在 REWRITE 阶段解析；</p>
</li>
<li><p>SERVER_REWRITE - 请求到达后首先处理这个阶段的 rewrite 指令操作</p>
</li>
<li><p>FIND_CONFIG - 根据 SERVER_REWRITE 阶段得到的 uri 查找 location</p>
</li>
<li><p>REWRITE - 确定 location 后执行 locaton 中 rewrite 操作</p>
</li>
<li><p>POST_REWRITE - 根据上一阶段的 uri 重写结果做决策，可能跳回 FIND_CONFIG 阶段重新查找 location，也可能继续执行后边的 phase。例如：在 location 中配置了 rewrite 指令并且指定 flag=break，执行完本条 rewrite 终止后边的 rewrite 匹配，然后执行 PREACCESS 阶段中的 handler。同样的场景下 flag=last，执行完本条 rewrite 终止后边的 rewrite 匹配，然后跳到 FIND_CONFIG 阶段再次查找 location。未指定 flag 的情况与 flag=last 类似，唯一区别是在同一层级中未指定 flag 的 rewrite 语句不会终止后续的 rewrite 匹配。</p>
</li>
</ul>
<h3 id="通过例子理解-rewrite-指令"><a href="#通过例子理解-rewrite-指令" class="headerlink" title="通过例子理解 rewrite 指令"></a>通过例子理解 rewrite 指令</h3><h3 id="1-未指定-flag"><a href="#1-未指定-flag" class="headerlink" title="1.未指定 flag"></a>1.未指定 flag</h3><p>未指定 flag 的 rewrite 会按照出现顺序进行匹配，server 块中 rewrite 匹配完以后根据改写的 uri 查找 location，然后再匹配 location 中的 rewrite，location 中的 rewrite 指令匹配成功后会再次查找 location。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    rewrite ^&#x2F;(.*)$         &#x2F;mi_one&#x2F;$1;</span><br><span class="line">    rewrite ^&#x2F;mi_one&#x2F;(.*)$  &#x2F;mi_two&#x2F;$1;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;        </span><br><span class="line">        echo &quot;This is default location&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location &#x2F;mi_one&#x2F; &#123;        </span><br><span class="line">        echo &quot;This is mi_one location&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location &#x2F;mi_two&#x2F; &#123;        </span><br><span class="line">        echo &quot;This is mi_two location&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ curl http:&#x2F;&#x2F;localhost&#x2F;mi_zero&#x2F;hello</span><br><span class="line">This is mi_two location</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li><p>匹配第一条 rewrite 成功，uri 被改写为 / mi_one/mi_zero/hello，没有指定 flag 的 rewrite 继续匹配后面的 rewrite</p>
</li>
<li><p>匹配第二条 rewrite 成功，此时 uri 被改写为 / mi_two/mi_zero/hello</p>
</li>
<li><p>查找 location，mi_two 被确定为最终的 location</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    rewrite ^&#x2F;(.*)$         &#x2F;mi_one&#x2F;$1;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;        </span><br><span class="line">        echo &quot;This is default location&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location &#x2F;mi_one&#x2F; &#123;</span><br><span class="line">        rewrite ^&#x2F;mi_one&#x2F;(.*)$  &#x2F;mi_two&#x2F;$1;        </span><br><span class="line">        echo &quot;This is mi_one location&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location &#x2F;mi_two&#x2F; &#123;        </span><br><span class="line">        echo &quot;This is mi_two location&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ curl http:&#x2F;&#x2F;localhost&#x2F;hello</span><br><span class="line">This is mi_two location</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>说明：</p>
<ol>
<li><p>匹配 server 块中的 rewrite 成功，uri 被改写为 / mi_one/hello</p>
</li>
<li><p>server 块中只有一条 rewrite 指令，开始查找 location</p>
</li>
<li><p>location mi_one 被找到，开始匹配 location 中 rewrite</p>
</li>
<li><p>location 中的 rewrite 匹配成功，uri 被改写为 / mi_two/hello</p>
</li>
<li><p>再次查找 location，mi_two 被确定为最终使用的 location</p>
</li>
</ol>
<p>再来看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    rewrite ^&#x2F;(.*)$         http:&#x2F;&#x2F;www.mi.com&#x2F;$1;</span><br><span class="line">    rewrite ^&#x2F;mi_one&#x2F;(.*)$  &#x2F;mi_two&#x2F;$1;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;        </span><br><span class="line">        echo &quot;This is default location&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location &#x2F;mi_one&#x2F; &#123;        </span><br><span class="line">        echo &quot;This is mi_one location&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location &#x2F;mi_two&#x2F; &#123;        </span><br><span class="line">        echo &quot;This is mi_two location&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ curl -I http:&#x2F;&#x2F;localhost&#x2F;mi_one&#x2F;hello</span><br><span class="line">http code: 302</span><br><span class="line">Location: http:&#x2F;&#x2F;www.mi.com&#x2F;mi_one&#x2F;hello</span><br></pre></td></tr></table></figure>
<p>说明：<br>匹配第一条 rewrite 成功，由于 replacement 是以 http:// 开始的字符串，所以 rewrite 指令直接返回给客户端 302，并且停止匹配后续的 rewrite。</p>
<h3 id="2-flag-指定为-redirect"><a href="#2-flag-指定为-redirect" class="headerlink" title="2.flag 指定为 redirect"></a>2.flag 指定为 redirect</h3><p>指定 flag 为 redirect 时，rewrite 匹配成功后直接返回给客户端 302，不会继续匹配后续的 rewrite。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    rewrite ^&#x2F;(.*)$         &#x2F;mi_one&#x2F;$1 redirect;</span><br><span class="line">    rewrite ^&#x2F;mi_one&#x2F;(.*)$  &#x2F;mi_two&#x2F;$1;</span><br><span class="line">    rewrite ^&#x2F;mi_two&#x2F;(.*)$  &#x2F;mi_three&#x2F;$1;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;        </span><br><span class="line">        echo &quot;This is default location&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location &#x2F;mi_one&#x2F; &#123;        </span><br><span class="line">        echo &quot;This is mi_one location&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location &#x2F;mi_two&#x2F; &#123;        </span><br><span class="line">        echo &quot;This is mi_two location&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location &#x2F;mi_three&#x2F; &#123;        </span><br><span class="line">        echo &quot;This is mi_three location&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ curl -I http:&#x2F;&#x2F;localhost&#x2F;mi_zero&#x2F;hello</span><br><span class="line">http code: 302</span><br><span class="line">Location: http:&#x2F;&#x2F;localhost&#x2F;mi_one&#x2F;mi_zero&#x2F;hello</span><br><span class="line"></span><br><span class="line">$ curl -I http:&#x2F;&#x2F;localhost&#x2F;mi_one&#x2F;hello</span><br><span class="line">http code: 302</span><br><span class="line">Location: http:&#x2F;&#x2F;localhost&#x2F;mi_one&#x2F;mi_one&#x2F;hello</span><br><span class="line"></span><br><span class="line">$ curl -I http:&#x2F;&#x2F;localhost&#x2F;mi_two&#x2F;hello</span><br><span class="line">http code: 302</span><br><span class="line">Location: http:&#x2F;&#x2F;localhost&#x2F;mi_one&#x2F;mi_two&#x2F;hello</span><br></pre></td></tr></table></figure>


<p>再来看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    rewrite ^&#x2F;mi_one&#x2F;(.*)$  &#x2F;mi_two&#x2F;$1;</span><br><span class="line">    rewrite ^&#x2F;mi_two&#x2F;(.*)$  &#x2F;mi_three&#x2F;$1 redirect;</span><br><span class="line">    rewrite ^&#x2F;(.*)$         &#x2F;mi_one&#x2F;$1;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;        </span><br><span class="line">        echo &quot;This is default location&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location &#x2F;mi_one&#x2F; &#123;        </span><br><span class="line">        echo &quot;This is mi_one location&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location &#x2F;mi_two&#x2F; &#123;        </span><br><span class="line">        echo &quot;This is mi_two location&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location &#x2F;mi_three&#x2F; &#123;        </span><br><span class="line">        echo &quot;This is mi_three location&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ curl -I http:&#x2F;&#x2F;localhost&#x2F;mi_one&#x2F;hello</span><br><span class="line">http code: 302</span><br><span class="line">Location: http:&#x2F;&#x2F;localhost&#x2F;mi_three&#x2F;hello</span><br><span class="line"></span><br><span class="line">$ curl -I http:&#x2F;&#x2F;localhost&#x2F;mi_two&#x2F;hello</span><br><span class="line">http code: 302</span><br><span class="line">Location: http:&#x2F;&#x2F;localhost&#x2F;mi_three&#x2F;hello</span><br><span class="line"></span><br><span class="line">$ curl http:&#x2F;&#x2F;localhost&#x2F;mi_zero&#x2F;hello</span><br><span class="line">This is mi_one location</span><br></pre></td></tr></table></figure>
<h3 id="3-flag-指定为-permanent"><a href="#3-flag-指定为-permanent" class="headerlink" title="3.flag 指定为 permanent"></a>3.flag 指定为 permanent</h3><p>指定 flag=permanent 时，与 redirect 效果相同，唯一的区别 http code 返回 301。</p>
<h3 id="4-flag-指定为-last"><a href="#4-flag-指定为-last" class="headerlink" title="4.flag 指定为 last"></a>4.flag 指定为 last</h3><p>rewrite 的 last 和 break 这两个 flag 使用场景很多并且也很容易混淆，他们的共同点都会停止当前层级后续的 rewrite 匹配，区别需要分两种情况：第一种使用在 server block 中，last 和 break 没有区别。第二种使用在 location block 中，last 会根据改写的 uri 重新查找 location，break 不会重新查找 location，而是在当前 location 中执行后续的指令。（注：last 和 break 不仅停止 rewrite 的匹配，同时还会停止 Nginx rewrite 模块中其他指令的执行，例如：set、return 指令)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    rewrite ^&#x2F;mi_one&#x2F;(.*)$  &#x2F;mi_two&#x2F;$1 last;</span><br><span class="line">    rewrite ^&#x2F;mi_two&#x2F;(.*)$  &#x2F;mi_three&#x2F;$1;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;        </span><br><span class="line">        echo &quot;This is default location&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location &#x2F;mi_one&#x2F; &#123;        </span><br><span class="line">        echo &quot;This is mi_one location&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location &#x2F;mi_two&#x2F; &#123;        </span><br><span class="line">        echo &quot;This is mi_two location&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location &#x2F;mi_three&#x2F; &#123;        </span><br><span class="line">        echo &quot;This is mi_three location&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ curl http:&#x2F;&#x2F;localhost&#x2F;mi_one&#x2F;hello</span><br><span class="line">This is mi_two location</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ol>
<li>匹配第一条 rewrite 成功，uri 被改写为 / mi_two/hello，由于 flag 指定为 last 会停止后续的 rewrite 的匹配（仅停止 server block 中的 rewrite 匹配），所以会根据改写的 uri 查找 location</li>
</ol>
<p>再来看一个 last 在 location block 中使用的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    rewrite ^&#x2F;(.*)$  &#x2F;mi_one&#x2F;$1;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;        </span><br><span class="line">        echo &quot;This is default location&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location &#x2F;mi_one&#x2F; &#123;</span><br><span class="line">        rewrite ^&#x2F;(.*)$             &#x2F;mi_three&#x2F;$1 last;</span><br><span class="line">        rewrite ^&#x2F;mi_three&#x2F;(.*)$    &#x2F;;        </span><br><span class="line">        </span><br><span class="line">        echo &quot;This is mi_one location&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location &#x2F;mi_two&#x2F; &#123;        </span><br><span class="line">        echo &quot;This is mi_two location&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location &#x2F;mi_three&#x2F; &#123;        </span><br><span class="line">        echo &quot;This is mi_three location&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ curl http:&#x2F;&#x2F;localhost&#x2F;hello</span><br><span class="line">This is mi_three location</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ol>
<li><p>匹配 server block 中第一条 rewrite 成功，uri 被改写为 / mi_one/hello</p>
</li>
<li><p>查找 location，mi_one 被确定为使用的 location</p>
</li>
<li><p>匹配 location block 中的 rewrite，location 中的第一条 rewrite 匹配成功，uri 被改写为 / mi_three/mi_one/hello，由于 flag 指定为 last，所以停止 location 中后续的 rewrite 匹配，此时再根据 uri=/mi_three/mi_one/hello 查找 location，最终 mi_three 被确定为使用的 location</p>
</li>
</ol>
<h3 id="5-flag-指定为-break"><a href="#5-flag-指定为-break" class="headerlink" title="5.flag 指定为 break"></a>5.flag 指定为 break</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    rewrite ^&#x2F;mi_one&#x2F;(.*)$  &#x2F;mi_two&#x2F;$1 break;</span><br><span class="line">    rewrite ^&#x2F;mi_two&#x2F;(.*)$  &#x2F;mi_three&#x2F;$1;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;        </span><br><span class="line">        echo &quot;This is default location&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location &#x2F;mi_one&#x2F; &#123;        </span><br><span class="line">        echo &quot;This is mi_one location&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location &#x2F;mi_two&#x2F; &#123;        </span><br><span class="line">        echo &quot;This is mi_two location&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location &#x2F;mi_three&#x2F; &#123;        </span><br><span class="line">        echo &quot;This is mi_three location&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ curl http:&#x2F;&#x2F;localhost&#x2F;mi_one&#x2F;hello</span><br><span class="line">This is mi_two location</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ol>
<li><p>匹配 server block 中第一条 rewrite 成功，uri 被改写为 / mi_two/hello，由于 flag 指定为 break 所以会停止 server block 中后续的 rewrite 匹配，根据 uri=/mi_two/hello 查找 location，最终 mi_two 被确定为使用的 location</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    rewrite ^&#x2F;(.*)$  &#x2F;mi_one&#x2F;$1;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;        </span><br><span class="line">        echo &quot;This is default location&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location &#x2F;mi_one&#x2F; &#123;</span><br><span class="line">        rewrite ^&#x2F;(.*)$         &#x2F;mi_three&#x2F;$1 break;</span><br><span class="line">        rewrite ^&#x2F;mi_two&#x2F;(.*)$  &#x2F;;        </span><br><span class="line">        </span><br><span class="line">        echo &quot;This is mi_one location&quot;;        </span><br><span class="line">        echo &quot;uri: $&#123;uri&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location &#x2F;mi_two&#x2F; &#123;        </span><br><span class="line">        echo &quot;This is mi_two location&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location &#x2F;mi_three&#x2F; &#123;        </span><br><span class="line">        echo &quot;This is mi_three location&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ curl http:&#x2F;&#x2F;localhost&#x2F;hello</span><br><span class="line">This is mi_one location</span><br><span class="line">uri: &#x2F;mi_three&#x2F;mi_one&#x2F;hello</span><br></pre></td></tr></table></figure>
<p>说明：</p>
</li>
<li><p>匹配 server block 中第一条 rewrite 成功，uri 被改写为 / mi_one/hello</p>
</li>
<li><p>根据 uri=/mi_one/hello 查找 location，mi_one 被确定为使用的 location</p>
</li>
<li><p>匹配 location block 中的 rewrite，location 中的第一条 rewrite 匹配成功，uri 被改写为 / mi_three/mi_one/hello，由于 flag 指定为 break，所以停止 location 中后续的 rewrite 匹配，并且把当前 location 作为最终使用的 location，不会重新查找 location（last 会继续查找 location）</p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在 Nginx 的配置中可以实现简单的编程，理解起来相对有点难度，通过阅读此文希望能对你有些启发，能够根据项目需求可以配置更复杂的 rewrite 规则。想要更深入的理解 rewrite，还需要大家自己动手实践。</p>
<h2 id="FYI"><a href="#FYI" class="headerlink" title="FYI"></a>FYI</h2><p><a href="https://github.com/agile6v/awesome-nginx" target="_blank" rel="noopener">https://github.com/agile6v/awesome-nginx</a></p>
<p><a href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html" target="_blank" rel="noopener">http://nginx.org/en/docs/http/ngx_http_rewrite_module.html</a></p>
<p><a href="https://www.nginx.com/blog/creating-nginx-rewrite-rules/" target="_blank" rel="noopener">https://www.nginx.com/blog/creating-nginx-rewrite-rules/</a></p>
<p><a href="https://www.nginx.com/blog/converting-apache-to-nginx-rewrite-rules" target="_blank" rel="noopener">https://www.nginx.com/blog/converting-apache-to-nginx-rewrite-rules</a></p>
<p><a href="http://www.thegeekstuff.com/2017/08/nginx-rewrite-examples/" target="_blank" rel="noopener">http://www.thegeekstuff.com/2017/08/nginx-rewrite-examples/</a></p>
<p><a href="http://winginx.com/en/htaccess" target="_blank" rel="noopener">http://winginx.com/en/htaccess</a></p>
<p><a href="https://w3techs.com/technologies/overview/web_server/all" target="_blank" rel="noopener">https://w3techs.com/technologies/overview/web_server/all</a></p>
<p><a href="http://nginx.org/en/docs/dev/development_guide.html#httpphases" target="_blank" rel="noopener">http://nginx.org/en/docs/dev/development_guide.html#httpphases</a></p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx配置项说明</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h2 id="Nginx配置"><a href="#Nginx配置" class="headerlink" title="Nginx配置"></a>Nginx配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">user  www www;</span><br><span class="line">worker_processes  8;</span><br><span class="line">worker_rlimit_nofile 100000; </span><br><span class="line"></span><br><span class="line">error_log  &#x2F;data&#x2F;nginx&#x2F;logs&#x2F;error.log  notice;</span><br><span class="line"></span><br><span class="line">pid        &#x2F;var&#x2F;run&#x2F;nginx.pid;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    use epoll;    #epoll是多路复用IO(I&#x2F;O Multiplexing)中的一种方式,但是仅用于linux2.6以上内核,可以大大提高nginx的性能</span><br><span class="line">    #multi_accept on;</span><br><span class="line">    worker_connections  52000;  #单个后台worker process进程的最大并发链接数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;  #设定mime类型,类型由mime.type文件定义</span><br><span class="line">    default_type  application&#x2F;octet-stream;</span><br><span class="line">    #charset UTF-8; #设置我们的头文件中的默认的字符集</span><br><span class="line"></span><br><span class="line">#设置日志格式</span><br><span class="line">    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;</span><br><span class="line">                      &#39;$status $body_bytes_sent $request_body  &quot;$http_referer&quot; &#39;</span><br><span class="line">                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;</span><br><span class="line"></span><br><span class="line">    access_log  off;</span><br><span class="line"></span><br><span class="line">#sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件，对于普通应用，</span><br><span class="line">    #必须设为 on,如果用来进行下载等应用磁盘IO重负载应用，可设置为 off，以平衡磁盘与网络I&#x2F;O处理速度，降低系统的uptime.</span><br><span class="line">    server_tokens off; #并不会让nginx执行的速度更快，但它可以关闭在错误页面中的nginx版本数字，这样对于安全性是有好处的。</span><br><span class="line">    sendfile       on；#sendfile可以让sendfile()发挥作用。sendfile()可以在磁盘和TCP socket之间互相拷贝数据(或任意两个文件描述符)。</span><br><span class="line">    tcp_nopush     on; #告诉nginx在一个数据包里发送所有头文件，而不一个接一个的发送</span><br><span class="line">    tcp_nodelay     on;#告诉nginx不要缓存数据，而是一段一段的发送--当需要及时发送数据时，就应该给应用设置这个属性，这样发送一小块数据信息时就不能立即得到返回值。</span><br><span class="line">#设置超时时间</span><br><span class="line">    keepalive_timeout  10; #给客户端分配keep-alive链接超时时间。服务器将在这个超时时间过后关闭链接</span><br><span class="line">    client_header_timeout 10; #client_header_timeout 和client_body_timeout 设置请求头和请求体(各自)的超时时间。我们也可以把这个设置低些。</span><br><span class="line">    client_body_timeout 10; </span><br><span class="line">    reset_timedout_connection on; #告诉nginx关闭不响应的客户端连接。这将会释放那个客户端所占有的内存空间。</span><br><span class="line">    send_timeout 10; #指定客户端的响应超时时间。这个设置不会用于整个转发器，而是在两次客户端读取操作之间。如果在这段时间内，客户端没有读取任何数据，nginx就会关闭连接</span><br><span class="line"></span><br><span class="line">#开启gzip压缩</span><br><span class="line">gzip on;</span><br><span class="line">gzip_disable &quot;msie6&quot;;</span><br><span class="line"># gzip_static on;</span><br><span class="line">gzip_proxied any;</span><br><span class="line">gzip_min_length 1000;</span><br><span class="line">gzip_comp_level 4;</span><br><span class="line">gzip_types text&#x2F;plain text&#x2F;css application&#x2F;json application&#x2F;x-javascript text&#x2F;xml application&#x2F;xml application&#x2F;xml+rss text&#x2F;javascript;</span><br><span class="line"></span><br><span class="line">#gzip是告诉nginx采用gzip压缩的形式发送数据。这将会减少我们发送的数据量。</span><br><span class="line">#gzip_disable为指定的客户端禁用gzip功能。我们设置成IE6或者更低版本以使我们的方案能够广泛兼容。</span><br><span class="line">#gzip_static告诉nginx在压缩资源之前，先查找是否有预先gzip处理过的资源。这要求你预先压缩你的文件（在这个例子中被注释掉了），从而允许你使用最高压缩比，这样nginx就不用再压缩这些文件了（想要更详尽的gzip_static的信息，请点击这里）。</span><br><span class="line">#gzip_proxied允许或者禁止压缩基于请求和响应的响应流。我们设置为any，意味着将会压缩所有的请求。</span><br><span class="line">#gzip_min_length设置对数据启用压缩的最少字节数。如果一个请求小于1000字节，我们最好不要压缩它，因为压缩这些小的数据会降低处理此请求的所有进程的速度。</span><br><span class="line">#gzip_comp_level设置数据的压缩等级。这个等级可以是1-9之间的任意数值，9是最慢但是压缩比最大的。我们设置为4，这是一个比较折中的设置。</span><br><span class="line"></span><br><span class="line">open_file_cache max&#x3D;100000 inactive&#x3D;20s;</span><br><span class="line">open_file_cache_valid 30s;</span><br><span class="line">open_file_cache_min_uses 2;</span><br><span class="line">open_file_cache_errors on;</span><br><span class="line">#open_file_cache打开缓存的同时也指定了缓存最大数目，以及缓存的时间。我们可以设置一个相对高的最大时间，这样我们可以在它们不活动超过20秒后清除掉。</span><br><span class="line">#open_file_cache_valid 在open_file_cache中指定检测正确信息的间隔时间。</span><br><span class="line">#open_file_cache_min_uses 定义了open_file_cache中指令参数不活动时间期间里最小的文件数。</span><br><span class="line">#open_file_cache_errors指定了当搜索一个文件时是否缓存错误信息，也包括再次给配置中添加文件。我们也包括了服务器模块，这些是在不同文件中定义的。如果你的服务器模块不在这些位置，你就得修改这一行来指定正确的位置。</span><br><span class="line"></span><br><span class="line">#设定请求缓冲</span><br><span class="line">    client_max_body_size    8m;</span><br><span class="line">    client_body_buffer_size    512k;</span><br><span class="line">    client_header_buffer_size    32k;</span><br><span class="line">    large_client_header_buffers  4 32k;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    proxy_connect_timeout 60;</span><br><span class="line">    proxy_read_timeout 60;</span><br><span class="line">    proxy_send_timeout 60;</span><br><span class="line">    proxy_buffer_size 16k;</span><br><span class="line">    proxy_buffers 6 512k;</span><br><span class="line">    proxy_busy_buffers_size 1024k;</span><br><span class="line">    proxy_temp_file_write_size 512k;</span><br><span class="line"></span><br><span class="line">#设定负载均衡的服务器列表</span><br><span class="line">#weigth参数表示权值，权值越高被分配到的几率越大</span><br><span class="line">    upstream tdx &#123;</span><br><span class="line">     #ip_hash;</span><br><span class="line">         server node1:80 max_fails&#x3D;3 fail_timeout&#x3D;30s weight&#x3D;6;</span><br><span class="line">         server  node2:80 max_fails&#x3D;3 fail_timeout&#x3D;30s weight&#x3D;6; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    upstream test &#123;</span><br><span class="line">     #ip_hash;</span><br><span class="line">         server node1:81 max_fails&#x3D;3 fail_timeout&#x3D;30s weight&#x3D;1;</span><br><span class="line">         server  node2:81 max_fails&#x3D;3 fail_timeout&#x3D;30s weight&#x3D;6; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen  80;</span><br><span class="line">        #server_name  wwww.xxx.com;</span><br><span class="line">        access_log  &#x2F;data&#x2F;nginx&#x2F;logs&#x2F;tdx_access.log  combined;</span><br><span class="line"></span><br><span class="line">#默认请求</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            root   &#x2F;data&#x2F;nginx&#x2F;htdocs&#x2F;tdx;  #定义服务器的默认网站根目录位置</span><br><span class="line">            index  index.php index.html index.htm; #定义首页索引文件的名称</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;tdx;  #请求转向tdx定义的服务器列表</span><br><span class="line">        proxy_redirect off;   #禁用缓存</span><br><span class="line">        #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line"></span><br><span class="line">        client_max_body_size 10m;  #允许客户端请求的最大单文件字节数</span><br><span class="line">        client_body_buffer_size 128k;  #缓冲区代理缓冲用户端请求的最大字节数</span><br><span class="line">        proxy_connect_timeout 90; #nginx跟后端服务器连接超时时间(代理连接超时)</span><br><span class="line">        proxy_send_timeout 90;</span><br><span class="line">        proxy_read_timeout 90; #连接成功后，后端服务器响应时间(代理接收超时)</span><br><span class="line">        proxy_buffer_size 4k; #设置代理服务器（nginx）保存用户头信息的缓冲区大小</span><br><span class="line">        proxy_buffers 4 32k; #proxy_buffers缓冲区，网页平均在32k以下的话，这样设置</span><br><span class="line">        proxy_busy_buffers_size 64k; #高负荷下缓冲大小（proxy_buffers*2）</span><br><span class="line">        proxy_temp_file_write_size 64k; #设定缓存文件夹大小，大于这个值，将从upstream服务器传</span><br><span class="line">        &#125;</span><br><span class="line">#定义错误提示页面</span><br><span class="line">        error_page   500 502 503 504  &#x2F;50x.html;</span><br><span class="line">        location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">            root   &#x2F;usr&#x2F;local&#x2F;web_app&#x2F;nginx&#x2F;html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location ~ \.php$ &#123;</span><br><span class="line">        root &#x2F;data&#x2F;nginx&#x2F;htdocs&#x2F;tdx;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;tdx;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">#PHP 脚本请求全部转发到 FastCGI处理. 使用FastCGI默认配置</span><br><span class="line">       # proxy_redirect off;</span><br><span class="line">           # fastcgi_pass   unix:&#x2F;tmp&#x2F;php-fcgi.sock;</span><br><span class="line">           # fastcgi_index  index.php;</span><br><span class="line">           # fastcgi_param  SCRIPT_FILENAME  &#x2F;data&#x2F;nginx&#x2F;htdocs&#x2F;tdx&#x2F;$fastcgi_script_name;</span><br><span class="line">           # include        fastcgi_params;</span><br><span class="line">        &#125;</span><br><span class="line">#禁止访问.htxxx文件</span><br><span class="line">        location ~ &#x2F;\.ht &#123;</span><br><span class="line">            deny  all;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen  81;</span><br><span class="line">        server_name  ip;</span><br><span class="line"></span><br><span class="line">        access_log  &#x2F;data&#x2F;nginx&#x2F;logs&#x2F;test_access.log  combined;</span><br><span class="line"></span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            root   &#x2F;data&#x2F;nginx&#x2F;htdocs&#x2F;test;</span><br><span class="line">            index  index.php index.html index.htm;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;test;</span><br><span class="line">        proxy_redirect off;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        client_max_body_size 10m;</span><br><span class="line">        client_body_buffer_size 128k; </span><br><span class="line">        proxy_connect_timeout 90;</span><br><span class="line">        proxy_send_timeout 90;</span><br><span class="line">        proxy_read_timeout 90;</span><br><span class="line">        proxy_buffer_size 4k;</span><br><span class="line">        proxy_buffers 4 32k;</span><br><span class="line">        proxy_busy_buffers_size 64k;</span><br><span class="line">        proxy_temp_file_write_size 64k;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page   500 502 503 504  &#x2F;50x.html;</span><br><span class="line">        location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">            root   &#x2F;usr&#x2F;local&#x2F;web_app&#x2F;nginx&#x2F;html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class="line">        location ~ \.php$ &#123;</span><br><span class="line">        root &#x2F;data&#x2F;nginx&#x2F;htdocs&#x2F;test;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;test;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">           #fastcgi_pass   unix:&#x2F;tmp&#x2F;php-fcgi.sock;</span><br><span class="line">           #fastcgi_index  index.php;</span><br><span class="line">           #fastcgi_param  SCRIPT_FILENAME  &#x2F;data&#x2F;nginx&#x2F;htdocs&#x2F;test&#x2F;$fastcgi_script_name;</span><br><span class="line">           #include        fastcgi_params;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location ~ &#x2F;\.ht &#123;</span><br><span class="line">            deny  all;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://www.ttlsa.com/nginx/using-nginx-as-http-loadbalancer/" target="_blank" rel="noopener">http://www.ttlsa.com/nginx/using-nginx-as-http-loadbalancer/</a> 负载均衡三种模式区别<br><a href="http://www.ttlsa.com/nginx/nginx-load-balancing-from-theory-to-practice/" target="_blank" rel="noopener">http://www.ttlsa.com/nginx/nginx-load-balancing-from-theory-to-practice/</a> 负载均衡实践<br><a href="http://www.ttlsa.com/nginx/nginx-configure-descriptions/" target="_blank" rel="noopener">http://www.ttlsa.com/nginx/nginx-configure-descriptions/</a>  编译安装nginx参数详细<br><a href="http://www.ttlsa.com/nginx/nginx-battle-ready-optimization-guide/" target="_blank" rel="noopener">http://www.ttlsa.com/nginx/nginx-battle-ready-optimization-guide/</a> 优化指南</p>
<p>http段完整配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">user www-data;</span><br><span class="line">pid &#x2F;var&#x2F;run&#x2F;nginx.pid;</span><br><span class="line">worker_processes auto;</span><br><span class="line">worker_rlimit_nofile 100000;</span><br><span class="line">events &#123;</span><br><span class="line"> worker_connections 2048;</span><br><span class="line"> multi_accept on;</span><br><span class="line"> use epoll;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">  server_tokens off;</span><br><span class="line"> sendfile on;</span><br><span class="line">tcp_nopush on;</span><br><span class="line"> tcp_nodelay on;</span><br><span class="line"> access_log off;</span><br><span class="line"> error_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log crit;</span><br><span class="line"> keepalive_timeout 10;</span><br><span class="line"> client_header_timeout 10;</span><br><span class="line"> client_body_timeout 10;</span><br><span class="line">reset_timedout_connection on;</span><br><span class="line"> send_timeout 10;</span><br><span class="line"> limit_conn_zone $binary_remote_addr zone&#x3D;addr:5m;</span><br><span class="line"> limit_conn addr 100;</span><br><span class="line"> include &#x2F;etc&#x2F;nginx&#x2F;mime.types;</span><br><span class="line"> default_type text&#x2F;html;</span><br><span class="line">charset UTF-8;</span><br><span class="line">gzip on;</span><br><span class="line"> gzip_disable &quot;msie6&quot;;</span><br><span class="line">gzip_proxied any;</span><br><span class="line">gzip_min_length 1000;</span><br><span class="line">gzip_comp_level 6;</span><br><span class="line"> gzip_types text&#x2F;plain text&#x2F;css application&#x2F;json application&#x2F;x-javascript text&#x2F;xml application&#x2F;xml application&#x2F;xml+rss text&#x2F;javascript;</span><br><span class="line"> open_file_cache max&#x3D;100000 inactive&#x3D;20s;</span><br><span class="line">open_file_cache_valid 30s;</span><br><span class="line">open_file_cache_min_uses 2;</span><br><span class="line">open_file_cache_errors on;</span><br><span class="line"> include &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;*.conf;</span><br><span class="line"> include &#x2F;etc&#x2F;nginx&#x2F;sites-enabled&#x2F;*;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Python可迭代对象、迭代器和生成器(一)</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h3 id="Python可迭代对象、迭代器和生成器-一"><a href="#Python可迭代对象、迭代器和生成器-一" class="headerlink" title="Python可迭代对象、迭代器和生成器(一)"></a>Python可迭代对象、迭代器和生成器(一)</h3><p>我们都知道，序列可以迭代。但是，你知道为什么吗？ 本文来探讨一下迭代背后的原理。</p>
<p>序列可以迭代的原因：iter 函数。解释器需要迭代对象 x 时，会自动调用 iter(x)。内置的 iter 函数有以下作用：</p>
<p>(1) 检查对象是否实现了 iter 方法，如果实现了就调用它，获取一个迭代器。 </p>
<p>(2) 如果没有实现 iter 方法，但是实现了 getitem 方法，而且其参数是从零开始的索引，Python 会创建一个迭代器，尝试按顺序（从索引 0 开始）获取元素。 </p>
<p>(3) 如果前面两步都失败，Python 抛出 TypeError 异常，通常会提示“C objectis not iterable”（C 对象不可迭代），其中 C 是目标对象所属的类。</p>
<p>由此我们可以明确知道什么是 可迭代的对象： 使用 iter 内置函数可以获取迭代器的对象。即要么对象实现了能返回迭代器的 iter 方法，要么对象实现了 getitem 方法，而且其参数是从零开始的索引。</p>
<p>下面看一个实现了getitem方法的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Example1:</span><br><span class="line">    def __init__(self, text):</span><br><span class="line">        self.text &#x3D; text</span><br><span class="line">        self.sub_text &#x3D; text.split(&#39; &#39;)</span><br><span class="line"></span><br><span class="line">    def __getitem__(self, index):</span><br><span class="line">        return self.sub_text[index]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj1 &#x3D; Example1(&quot;Hello,have a beautiful day!&quot;)</span><br><span class="line">for i in obj1:</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">Hello,have</span><br><span class="line">a</span><br><span class="line">beautiful</span><br><span class="line">day!</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>我们创建了一个类Example1，并且为这个类实现了 getitem 方法，它的实例化对象obj1就是可迭代对象。</p>
<p>下面我们看一个实现 iter 方法的例子，因为用到了迭代器，所以在此我们必须在明确一下迭代器的用法。 标准的迭代器接口有两个方法：</p>
<p><strong>next</strong></p>
<p>返回下一个可用的元素，如果没有元素了，抛出 StopIteration异常。</p>
<p><strong>iter</strong></p>
<p>返回 self，以便在应该使用可迭代对象的地方使用迭代器，例如在 for 循环中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Example2:</span><br><span class="line">    def __init__(self, text):</span><br><span class="line">        self.text &#x3D; text</span><br><span class="line">        self.sub_text &#x3D; text.split(&#39; &#39;)</span><br><span class="line"></span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return Example2Iterator(self.sub_text)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Example2Iterator:</span><br><span class="line">    def __init__(self, sub_text):</span><br><span class="line">        self.sub_text &#x3D; sub_text</span><br><span class="line">        self.index &#x3D; 0</span><br><span class="line"></span><br><span class="line">    def __next__(self):</span><br><span class="line">        try:</span><br><span class="line">            subtext &#x3D; self.sub_text[self.index]</span><br><span class="line">        except IndexError:</span><br><span class="line">            raise StopIteration()</span><br><span class="line">        self.index +&#x3D; 1</span><br><span class="line">        return subtext</span><br><span class="line"></span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return self</span><br></pre></td></tr></table></figure>
<p>我们创建了Example2类，并为它实现了 iter 方法，此方法返回一个迭代器Example2Iterator。 Example2Iterator实现了我们之前所说的next和iter方法。 实例化对象，并循环输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">obj2 &#x3D; Example2(&quot;Hello,have a beautiful day!&quot;)</span><br><span class="line">for i in obj2:</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">Hello,have</span><br><span class="line">a</span><br><span class="line">beautiful</span><br><span class="line">day!</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>
<p>可见，和obj1是一样的。</p>
<p>我们通过两种方法实现了一个自己的可迭代对象，再此过程中我们要明确可迭代的对象和迭代器之间的关系：</p>
<p>Python 从可迭代的对象中获取迭代器。</p>
<p>iter方法从我们自己创建的迭代器类中获取迭代器，而getitem方法是python内部自动创建迭代器。</p>
<p>至此，我们明白了如何正确地实现可迭代对象，并且引出了怎样实现迭代器，但是使用迭代器方法（即上面的例子2）的代码量有点大，下面我们来了解一下如何使用更符合 Python习惯的方式实现Example2类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Example3:</span><br><span class="line">    def __init__(self, text):</span><br><span class="line">        self.text &#x3D; text</span><br><span class="line">        self.sub_text &#x3D; text.split(&#39; &#39;)</span><br><span class="line"></span><br><span class="line">    def __iter__(self):</span><br><span class="line">        for item in self.sub_text:</span><br><span class="line">            yield item</span><br></pre></td></tr></table></figure>

<p>哦了！就这么简单优雅！不用再单独定义一个迭代器类！ </p>
<p>这里我们使用了yield 关键字， 只要 Python 函数的定义体中有 yield 关键字，该函数就是生成器函数。调用生成器函数时，会返回一个生成器对象。也就是说，生成器函数是生成器工厂。 当然，例子3的代码还可以使用yield from进一步简化：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Example4:</span><br><span class="line">    def __init__(self, text):</span><br><span class="line">        self.text &#x3D; text</span><br><span class="line">        self.sub_text &#x3D; text.split(&#39; &#39;)</span><br><span class="line"></span><br><span class="line">    def __iter__(self):</span><br><span class="line">        yield from self.sub_text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj4 &#x3D; Example4(&quot;Hello,have a beautiful day!&quot;)</span><br><span class="line">for i in obj4:</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">Hello,have</span><br><span class="line">a</span><br><span class="line">beautiful</span><br><span class="line">day!</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>
<p>到这里我们明白了 可迭代对象 和 迭代器，还引申出了生成器，但还有一点没有提，那就是生成器表达式。<br>使用生成器表达式例子4的代码可以修改为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Example5:</span><br><span class="line">    def __init__(self, text):</span><br><span class="line">        self.text &#x3D; text</span><br><span class="line">        self.sub_text &#x3D; text.split(&#39; &#39;)</span><br><span class="line"></span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return (item for item in self.sub_text)</span><br></pre></td></tr></table></figure>
<p>在python中，所有生成器都是迭代器。<br>最后，总结一下：</p>
<ul>
<li>什么是可迭代对象？ 可迭代对象要么实现了能返回迭代器的 iter 方法，要么实现了 getitem 方法而且其参数是从零开始的索引。</li>
<li>什么是迭代器？ 迭代器是这样的对象：实现了无参数的 next 方法，返回下一个元素，如果没有元素了，那么抛出 StopIteration 异常；并且实现iter 方法，返回迭代器本身。</li>
<li>什么是生成器？ 生成器是带有 yield 关键字的函数。调用生成器函数时，会返回一个生成器对象。</li>
<li>什么是生成器表达式？ 生成器表达式是创建生成器的简洁句法，这样无需先定义函数再调用。</li>
</ul>
<p><a href="https://mp.weixin.qq.com/s/x1oxunw5buuPqujhZRYdjg" target="_blank" rel="noopener">原文地址</a></p>
]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>PYTHON</tag>
      </tags>
  </entry>
  <entry>
    <title>Python后端开发面试总结</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h2 id="Python后端开发面试总结"><a href="#Python后端开发面试总结" class="headerlink" title="Python后端开发面试总结"></a>Python后端开发面试总结</h2><h3 id="1-is和-的区别？"><a href="#1-is和-的区别？" class="headerlink" title="1. is和==的区别？"></a>1. is和==的区别？</h3><p>is判断两个引用是否指向的是同一个变量，即内存id是否相等，==则是调用的<strong>eq</strong>方法，一般是用于判断值是否相等，也可以重写<strong>eq</strong>方法实现想要的效果。</p>
<h3 id="2-dict与list的查找复杂度？"><a href="#2-dict与list的查找复杂度？" class="headerlink" title="2. dict与list的查找复杂度？"></a>2. dict与list的查找复杂度？</h3><p>dict用hash实现，查找的时间复杂度是O(1)，list则为O(n)。</p>
<h3 id="3-a-b-c三个装饰器依次装饰函数fun-，装饰器的执行顺序？"><a href="#3-a-b-c三个装饰器依次装饰函数fun-，装饰器的执行顺序？" class="headerlink" title="3. a/b/c三个装饰器依次装饰函数fun()，装饰器的执行顺序？"></a>3. a/b/c三个装饰器依次装饰函数fun()，装饰器的执行顺序？</h3><p>注意装饰器函数本身一般有两层，在装饰的时候外层和内层顺序是相反的，详情可以参考这边文章python 多个装饰器的调用顺序。</p>
<h3 id="4-如何运行一个字符串？"><a href="#4-如何运行一个字符串？" class="headerlink" title="4. 如何运行一个字符串？"></a>4. 如何运行一个字符串？</h3><p>eval和exec。</p>
<h2 id="5-Python多线程能否充分利用CPU多核心，为什么？"><a href="#5-Python多线程能否充分利用CPU多核心，为什么？" class="headerlink" title="5. Python多线程能否充分利用CPU多核心，为什么？"></a>5. Python多线程能否充分利用CPU多核心，为什么？</h2><p>这里回答的是GIL相关的东西，可深可浅，自己把握~</p>
<h3 id="6-什么是上下文管理器？如何实现？"><a href="#6-什么是上下文管理器？如何实现？" class="headerlink" title="6. 什么是上下文管理器？如何实现？"></a>6. 什么是上下文管理器？如何实现？</h3><p>广泛意义上来说，上下文是指程序运行的环境，Python中常见于打开文件或网络连接，其实就是with关键字，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with open(&quot;test.txt&quot;) as file:  </span><br><span class="line">    print(file.read())</span><br></pre></td></tr></table></figure>
<p>可以确保文件在最后会被关闭，只要对一个对象实现了<strong>enter</strong>和<strong>exit</strong>函数，就可以构造自己的上下文管理器了</p>
<h3 id="7-同步-异步-阻塞-非阻塞都是什么？"><a href="#7-同步-异步-阻塞-非阻塞都是什么？" class="headerlink" title="7. 同步/异步/阻塞/非阻塞都是什么？"></a>7. 同步/异步/阻塞/非阻塞都是什么？</h3><p>感觉直接解释概念不好解释，这里我回答的思路是举例子，异步说白了就是任务不需要同步进行，比如用爬虫爬取一个数据，然后再保存数据，接下来再去爬另一个数据，这是同步；异步就是爬虫不用等着数据保存好，爬完一个直接去爬另一个，数据保存的事情交给别的逻辑去慢慢处理；阻塞和非阻塞也是基于此的，同步的情况下会阻塞爬虫，爬虫需要等待数据的保存.(非专业解释)</p>
<h3 id="8-如何判断两个浮点数是否相等？"><a href="#8-如何判断两个浮点数是否相等？" class="headerlink" title="8. 如何判断两个浮点数是否相等？"></a>8. 如何判断两个浮点数是否相等？</h3><p>之前完全没想过这个的问题，我的回答就是按一个差不多的精度去比较，比如到小数点第几位之前都是相等的，就认为两个数相等，或者Math模块里可能有什么方法可以去精确对比，当时是这么回答的，现在查了一下基本也是这个思路，Math模块中有一个isclose函数用来判断两个浮点数的值是否接近或相等.</p>
<h3 id="9-MySQL的索引一般是怎么实现的？"><a href="#9-MySQL的索引一般是怎么实现的？" class="headerlink" title="9. MySQL的索引一般是怎么实现的？"></a>9. MySQL的索引一般是怎么实现的？</h3><p>B-Tree(一般是B+Tree)和Hash，然后再简单介绍一下。</p>
<h3 id="10-对于Flask的实现有了解吗？"><a href="#10-对于Flask的实现有了解吗？" class="headerlink" title="10. 对于Flask的实现有了解吗？"></a>10. 对于Flask的实现有了解吗？</h3><p>只知道WSGI，其余的不清楚，暂时还没去深入看Flask的源码。</p>
<h2 id="Part-二"><a href="#Part-二" class="headerlink" title="Part 二"></a>Part 二</h2><h4 id="1-一个木棍任意截成三段，围成三角形的概率？"><a href="#1-一个木棍任意截成三段，围成三角形的概率？" class="headerlink" title="1. 一个木棍任意截成三段，围成三角形的概率？"></a>1. 一个木棍任意截成三段，围成三角形的概率？</h4><p>咩咩咩？不知道。（回来查了是25%，具体可以自行搜索，反正脱离数学N年是无论如何都想不出来的）。</p>
<h4 id="2-一个函数RAND7-随机返回1-7，使用它构造一个RAND10-函数随机返回10。"><a href="#2-一个函数RAND7-随机返回1-7，使用它构造一个RAND10-函数随机返回10。" class="headerlink" title="2. 一个函数RAND7()随机返回1~7，使用它构造一个RAND10()函数随机返回10。"></a>2. 一个函数RAND7()随机返回1~7，使用它构造一个RAND10()函数随机返回10。</h4><p>一开始写了个函数如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def rand10():  </span><br><span class="line">a &#x3D; rand7() + 3&#x2F;10  </span><br><span class="line">b &#x3D; rand7() - 4  </span><br><span class="line">if b &lt; 0:  </span><br><span class="line">b &#x3D; 0  </span><br><span class="line">return a + b</span><br></pre></td></tr></table></figure>
<p>也是脑袋抽了，想得太简单，这个rand10虽然能返回1~10的随机数，但每个数出现的概率不是1/10，后面时间快到了检查的时候才反应过来。正确的思路是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def rand10():  </span><br><span class="line">while  1:  </span><br><span class="line">       res &#x3D; (rand7()-1)*7+rand7()    \# res等概率随机1~49  </span><br><span class="line">if res &lt; 40: \# 只取出0~39共40个数，每个数出现的概率也是相等的  </span><br><span class="line">return res % 10 \+ 1 \# 随机输出1~10</span><br></pre></td></tr></table></figure>
<h4 id="3-把一段JAVA代码改成Python，并增加单元测试。"><a href="#3-把一段JAVA代码改成Python，并增加单元测试。" class="headerlink" title="3. 把一段JAVA代码改成Python，并增加单元测试。"></a>3. 把一段JAVA代码改成Python，并增加单元测试。</h4><p>JAVA代码本身很简单，即使没学过也能看懂，改后的Python代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MyClass:  </span><br><span class="line">__current &#x3D; 0  </span><br><span class="line">def next(self):  </span><br><span class="line">MyClass.__current +&#x3D; 1  </span><br><span class="line">return MyClass.__current</span><br></pre></td></tr></table></figure>
<p>但是对于单元测试则仅限于听过的地步，需要用到unittest，好像也有别的模块。</p>
<h4 id="4-给定一个数组，按奇数在前升序，偶数在后降序排列，一行代码实现。"><a href="#4-给定一个数组，按奇数在前升序，偶数在后降序排列，一行代码实现。" class="headerlink" title="4. 给定一个数组，按奇数在前升序，偶数在后降序排列，一行代码实现。"></a>4. 给定一个数组，按奇数在前升序，偶数在后降序排列，一行代码实现。</h4><p>没啥好说的，一行代码必然是列表生成式，假设数组是nums，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sorted(\[n for n in nums if n % 2\]) \+ sorted(\[n for n in nums if  not n % 2\], reverse&#x3D;True)</span><br></pre></td></tr></table></figure>

<h3 id="5-实现单例。"><a href="#5-实现单例。" class="headerlink" title="5. 实现单例。"></a>5. 实现单例。</h3><p>单例就是说一个class只能有一个instance，实现的方法有很多，例如改写<strong>new</strong>方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Singleton(object):  </span><br><span class="line">_instance &#x3D; None  </span><br><span class="line">def \_\_new\_\_(cls, \*args, \*\*kw):  </span><br><span class="line">if  not cls._instance:  </span><br><span class="line">           cls.\_instance &#x3D; super(Singleton, cls).\_\_new__(cls, \*args, \*\*kw)    </span><br><span class="line">return cls._instance</span><br></pre></td></tr></table></figure>
<h4 id="6-有一个问答平台，每个用户对一个问题最多只能回答一次，同一个问题最多只能对一个答案点赞；1-设计合适的数据库结构；2-写出SQL获取点赞数最多的10个问题；"><a href="#6-有一个问答平台，每个用户对一个问题最多只能回答一次，同一个问题最多只能对一个答案点赞；1-设计合适的数据库结构；2-写出SQL获取点赞数最多的10个问题；" class="headerlink" title="6. 有一个问答平台，每个用户对一个问题最多只能回答一次，同一个问题最多只能对一个答案点赞；1)设计合适的数据库结构；2)写出SQL获取点赞数最多的10个问题；"></a>6. 有一个问答平台，每个用户对一个问题最多只能回答一次，同一个问题最多只能对一个答案点赞；1)设计合适的数据库结构；2)写出SQL获取点赞数最多的10个问题；</h4><p>我平时也就用数据库查数据，在设计数据库上没有深入研究，因此的我答案就简单写了有哪些表，字段分别是什么，至于题中的条件限制，就交由后台的程序逻辑去处理，而不是在数据库设计层面去限制。因为是自己设计的表结构，SQL本身也就不难。</p>
<h4 id="7-设计一个栈，实现pop-push及max方法，要求能在O-1-时间内取得最大值。"><a href="#7-设计一个栈，实现pop-push及max方法，要求能在O-1-时间内取得最大值。" class="headerlink" title="7. 设计一个栈，实现pop/push及max方法，要求能在O(1)时间内取得最大值。"></a>7. 设计一个栈，实现pop/push及max方法，要求能在O(1)时间内取得最大值。</h4><p>LeetCode原题啊！list怎么能O(1)取得最大值呢，无非是空间换时间，每push一个数就同时记录当前的最大值。</p>
<h4 id="8-手写快排。"><a href="#8-手写快排。" class="headerlink" title="8. 手写快排。"></a>8. 手写快排。</h4><p>呵呵。</p>
<h2 id="其他针对简历的提问"><a href="#其他针对简历的提问" class="headerlink" title="其他针对简历的提问"></a>其他针对简历的提问</h2><h4 id="1-你的网站，你觉得如果访问量上去了，最先出现瓶颈问题的点是哪？怎么优化？"><a href="#1-你的网站，你觉得如果访问量上去了，最先出现瓶颈问题的点是哪？怎么优化？" class="headerlink" title="1. 你的网站，你觉得如果访问量上去了，最先出现瓶颈问题的点是哪？怎么优化？"></a>1. 你的网站，你觉得如果访问量上去了，最先出现瓶颈问题的点是哪？怎么优化？</h4><p>我答的是数据库，因为好多不必要或者可以使用缓存的地方也频繁操作数据库，而且是使用的ORM，但之前从哪看到ORM不能确保对应的SQL语句是最优的，因此可以尝试使用原生SQL或者增加Redis缓存。</p>
<h3 id="2-如果要扩展后台服务器，需要怎么做？"><a href="#2-如果要扩展后台服务器，需要怎么做？" class="headerlink" title="2. 如果要扩展后台服务器，需要怎么做？"></a>2. 如果要扩展后台服务器，需要怎么做？</h3><p>(话说这不是运维的工作么。。。)呃，就是增加服务器啊，然后前面加一层负载均衡，把请求分配给不同的服务器.(那不同的服务器怎么使用你的Session？)再加个Session服务器。</p>
<h3 id="3-我看你平时刷编程题，有遇到什么有意思的题目吗？"><a href="#3-我看你平时刷编程题，有遇到什么有意思的题目吗？" class="headerlink" title="3. 我看你平时刷编程题，有遇到什么有意思的题目吗？"></a>3. 我看你平时刷编程题，有遇到什么有意思的题目吗？</h3><p>LeetCode才开始刷，就举了两道Codewars上的题目，我也真是傻了，真的举了两道有意思(但自己没做好)的题。</p>
<p>其他就无非是一些为什么想做后端开发之类的问题了，个人感觉题目大部分也挺简单的，我的表现也算中规中矩吧，但面试官说我要进一步加强基础知识，具体哪方面(数据库、网络协议、还是Python本身)又语焉不详。</p>
<p><a href="https://mp.weixin.qq.com/s/ULeyIN825L59LF9-CHocKg" target="_blank" rel="noopener">原文地址</a></p>
]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>PYTHON</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 中更优雅的日志记录方案</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<hr>
<p>title: Python 中更优雅的日志记录方案<br>date: 2020-04-19 20:27:25<br>categories: </p>
<ul>
<li>PYTHON</li>
<li>DevOps<br>description: Python 中更优雅的日志记录方案<br>tags: PYTHON</li>
</ul>
<hr>
<blockquote class="blockquote-center">优秀的人，不是不合群，而是他们合群的人里面没有你</blockquote>


<h2 id="Python-中更优雅的日志记录方案"><a href="#Python-中更优雅的日志记录方案" class="headerlink" title="Python 中更优雅的日志记录方案"></a>Python 中更优雅的日志记录方案</h2><p>在 Python 中，一般情况下我们可能直接用自带的 logging 模块来记录日志，包括我之前的时候也是一样。在使用时我们需要配置一些 Handler、Formatter 来进行一些处理，比如把日志输出到不同的位置，或者设置一个不同的输出格式，或者设置日志分块和备份。但其实个人感觉 logging 用起来其实并不是那么好用，其实主要还是配置较为繁琐.</p>
<h2 id="常见使用"><a href="#常见使用" class="headerlink" title="常见使用"></a>常见使用</h2><p>首先看看 logging 常见的解决方案吧，我一般会配置输出到文件、控制台和 Elasticsearch。输出到控制台就仅仅是方便直接查看的；输出到文件是方便直接存储，保留所有历史记录的备份；输出到 Elasticsearch，直接将 Elasticsearch 作为存储和分析的中心，使用 Kibana 可以非常方便地分析和查看运行情况。<br>所以在这里我基本会对 logging 做如下的封装写法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mport logging</span><br><span class="line">import sys</span><br><span class="line">from os import makedirs</span><br><span class="line">from os.path import dirname, exists</span><br><span class="line"></span><br><span class="line">from cmreslogging.handlers import CMRESHandler</span><br><span class="line"></span><br><span class="line">loggers &#x3D; &#123;&#125;</span><br><span class="line"></span><br><span class="line">LOG_ENABLED &#x3D; True  # 是否开启日志</span><br><span class="line">LOG_TO_CONSOLE &#x3D; True  # 是否输出到控制台</span><br><span class="line">LOG_TO_FILE &#x3D; True  # 是否输出到文件</span><br><span class="line">LOG_TO_ES &#x3D; True  # 是否输出到 Elasticsearch</span><br><span class="line"></span><br><span class="line">LOG_PATH &#x3D; &#39;.&#x2F;runtime.log&#39;  # 日志文件路径</span><br><span class="line">LOG_LEVEL &#x3D; &#39;DEBUG&#39;  # 日志级别</span><br><span class="line">LOG_FORMAT &#x3D; &#39;%(levelname)s - %(asctime)s - process: %(process)d - %(filename)s - %(name)s - %(lineno)d - %(module)s - %(message)s&#39;  # 每条日志输出格式</span><br><span class="line">ELASTIC_SEARCH_HOST &#x3D; &#39;eshost&#39;  # Elasticsearch Host</span><br><span class="line">ELASTIC_SEARCH_PORT &#x3D; 9200  # Elasticsearch Port</span><br><span class="line">ELASTIC_SEARCH_INDEX &#x3D; &#39;runtime&#39;  # Elasticsearch Index Name</span><br><span class="line">APP_ENVIRONMENT &#x3D; &#39;dev&#39;  # 运行环境，如测试环境还是生产环境</span><br><span class="line"></span><br><span class="line">def get_logger(name&#x3D;None):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    get logger by name</span><br><span class="line">    :param name: name of logger</span><br><span class="line">    :return: logger</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    global loggers</span><br><span class="line"></span><br><span class="line">    if not name: name &#x3D; __name__</span><br><span class="line"></span><br><span class="line">    if loggers.get(name):</span><br><span class="line">        return loggers.get(name)</span><br><span class="line"></span><br><span class="line">    logger &#x3D; logging.getLogger(name)</span><br><span class="line">    logger.setLevel(LOG_LEVEL)</span><br><span class="line"></span><br><span class="line">    # 输出到控制台</span><br><span class="line">    if LOG_ENABLED and LOG_TO_CONSOLE:</span><br><span class="line">        stream_handler &#x3D; logging.StreamHandler(sys.stdout)</span><br><span class="line">        stream_handler.setLevel(level&#x3D;LOG_LEVEL)</span><br><span class="line">        formatter &#x3D; logging.Formatter(LOG_FORMAT)</span><br><span class="line">        stream_handler.setFormatter(formatter)</span><br><span class="line">        logger.addHandler(stream_handler)</span><br><span class="line"></span><br><span class="line">    # 输出到文件</span><br><span class="line">    if LOG_ENABLED and LOG_TO_FILE:</span><br><span class="line">        # 如果路径不存在，创建日志文件文件夹</span><br><span class="line">        log_dir &#x3D; dirname(log_path)</span><br><span class="line">        if not exists(log_dir): makedirs(log_dir)</span><br><span class="line">        # 添加 FileHandler</span><br><span class="line">        file_handler &#x3D; logging.FileHandler(log_path, encoding&#x3D;&#39;utf-8&#39;)</span><br><span class="line">        file_handler.setLevel(level&#x3D;LOG_LEVEL)</span><br><span class="line">        formatter &#x3D; logging.Formatter(LOG_FORMAT)</span><br><span class="line">        file_handler.setFormatter(formatter)</span><br><span class="line">        logger.addHandler(file_handler)</span><br><span class="line"></span><br><span class="line">    # 输出到 Elasticsearch</span><br><span class="line">    if LOG_ENABLED and LOG_TO_ES:</span><br><span class="line">        # 添加 CMRESHandler</span><br><span class="line">        es_handler &#x3D; CMRESHandler(hosts&#x3D;[&#123;&#39;host&#39;: ELASTIC_SEARCH_HOST, &#39;port&#39;: ELASTIC_SEARCH_PORT&#125;],</span><br><span class="line">                                  # 可以配置对应的认证权限</span><br><span class="line">                                  auth_type&#x3D;CMRESHandler.AuthType.NO_AUTH,  </span><br><span class="line">                                  es_index_name&#x3D;ELASTIC_SEARCH_INDEX,</span><br><span class="line">                                  # 一个月分一个 Index</span><br><span class="line">                                  index_name_frequency&#x3D;CMRESHandler.IndexNameFrequency.MONTHLY,</span><br><span class="line">                                  # 额外增加环境标识</span><br><span class="line">                                  es_additional_fields&#x3D;&#123;&#39;environment&#39;: APP_ENVIRONMENT&#125;  </span><br><span class="line">                                  )</span><br><span class="line">        es_handler.setLevel(level&#x3D;LOG_LEVEL)</span><br><span class="line">        formatter &#x3D; logging.Formatter(LOG_FORMAT)</span><br><span class="line">        es_handler.setFormatter(formatter)</span><br><span class="line">        logger.addHandler(es_handler)</span><br><span class="line"></span><br><span class="line">    # 保存到全局 loggers</span><br><span class="line">    loggers[name] &#x3D; logger</span><br><span class="line">    return logger</span><br></pre></td></tr></table></figure>
<p>定义完了怎么使用呢？只需要使用定义的方法获取一个 logger，然后 log 对应的内容即可:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logger &#x3D; get_logger()</span><br><span class="line">logger.debug(&#39;this is a message&#39;)</span><br></pre></td></tr></table></figure>
<p>运行结果如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DEBUG - 2019-10-11 22:27:35,923 - process: 99490 - logger.py - __main__ - 81 - logger - this is a message</span><br></pre></td></tr></table></figure>
<p>我们看看这个定义的基本实现吧。首先这里一些常量是用来定义 <code>logging</code> 模块的一些基本属性的，比如 LOG_ENABLED 代表是否开启日志功能，<code>LOG_TO_E</code>S 代表是否将日志输出到 Elasticsearch，另外还有很多其他的日志基本配置，如 <code>LOG_FORMAT</code> 配置了日志每个条目输出的基本格式，另外还有一些连接的必要信息。这些变量可以和运行时的命令行或环境变量对接起来，可以方便地实现一些开关和配置的更换。</p>
<p>然后定义了这么一个 <code>get_logger</code> 方法，接收一个参数 name。首先该方法拿到 name 之后，会到全局的 loggers 变量里面查找，loggers 变量是一个全局字典，如果有已经声明过的 logger，直接将其获取返回即可，不用再将其二次初始化。如果 loggers 里面没有找到 name 对应的 logger，那就进行创建即可。创建 logger 之后，可以为其添加各种对应的 Handler，如输出到控制台就用 StreamHandler，输出到文件就用 FileHandler 或 RotatingFileHandler，输出到 Elasticsearch 就用 CMRESHandler，分别配置好对应的信息即可。</p>
<p>最后呢，将新建的 logger 保存到全局的 loggers 里面并返回即可，这样如果有同名的 logger 便可以直接查找 loggers 直接返回了。<br>在这里依赖了额外的输出到 Elasticsearch 的包，叫做 CMRESHandler，它可以支持将日志输出到 Elasticsearch 里面，如果要使用的话可以安装一下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install CMRESHandler</span><br></pre></td></tr></table></figure>
<p>其 GitHub 地址是：<code>https://github.com/cmanaha/python-elasticsearch-logger</code>，具体的使用方式可以看看它的官方说明，如配置认证信息，配置 Index 分隔信息等等。<br>好，上面就是我之前常用的 logging 配置，通过如上的配置，我就可以实现将 logging 输出到三个位置，并可以实现对应的效果。比如输出到 Elasticsearch 之后，我就可以非常方便地使用 Kibana 来查看当前运行情况，ERROR Log 的比例等等.<br>也可以在它的基础上做更进一步的统计分析.</p>
<h2 id="loguru"><a href="#loguru" class="headerlink" title="loguru"></a>loguru</h2><p>上面的实现方式已经是一个较为可行的配置方案了。然而，我还是会感觉到有些 Handler 配起来麻烦，尤其是新建一个项目的很多时候懒得去写一些配置。即使是不用上文的配置，用最基本的几行 logging 配置，像如下的通用配置:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import logging</span><br><span class="line">logging.basicConfig(level &#x3D; logging.INFO,format &#x3D; &#39;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#39;)</span><br><span class="line">logger &#x3D; logging.getLogger(__name__)</span><br></pre></td></tr></table></figure>
<p>我也懒得去写，感觉并不是一个优雅的实现方式。<br>有需求就有动力啊，这不，就有人实现了这么一个库，叫做 loguru，可以将 log 的配置和使用更加简单和方便。<br>下面我们来看看它到底是怎么用的吧.</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先，这个库的安装方式很简单，就用基本的 pip 安装即可，Python 3 版本的安装如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install loguru</span><br></pre></td></tr></table></figure>
<p>安装完毕之后，我们就可以在项目里使用这个 loguru 库了.</p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>那么这个库怎么来用呢？我们先用一个实例感受下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from loguru import logger</span><br><span class="line"></span><br><span class="line">logger.debug(&#39;this is a debug message&#39;)</span><br></pre></td></tr></table></figure>
<p>看到了吧，不需要配置什么东西，直接引入一个 logger，然后调用其 debug 方法即可。</p>
<p>在 loguru 里面有且仅有一个主要对象，那就是 logger，loguru 里面有且仅有一个 logger，而且它已经被提前配置了一些基础信息，比如比较友好的格式化、文本颜色信息等等。</p>
<p>上面的代码运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2019-10-13 22:46:12.367 | DEBUG    | __main__:&lt;module&gt;:4 - this is a debug message</span><br></pre></td></tr></table></figure>
<p>可以看到其默认的输出格式是上面的内容，有时间、级别、模块名、行号以及日志信息，不需要手动创建 logger，直接使用即可，另外其输出还是彩色的，看起来会更加友好。</p>
<p>以上的日志信息是直接输出到控制台的，并没有输出到其他的地方，如果想要输出到其他的位置，比如存为文件，我们只需要使用一行代码声明即可。</p>
<p>例如将结果同时输出到一个 runtime.log 文件里面，可以这么写:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from loguru import logger</span><br><span class="line"></span><br><span class="line">logger.add(&#39;runtime.log&#39;)</span><br><span class="line">logger.debug(&#39;this is a debug&#39;)</span><br></pre></td></tr></table></figure>
<p>很简单吧，我们也不需要再声明一个 FileHandler 了，就一行 add 语句搞定，运行之后会发现目录下 runtime.log 里面同样出现了刚刚控制台输出的 DEBUG 信息。</p>
<p>上面就是一些基本的使用，但这还远远不够，下面我们来详细了解下它的一些功能模块.</p>
<h2 id="详细使用"><a href="#详细使用" class="headerlink" title="详细使用"></a>详细使用</h2><p>既然是日志，那么最常见的就是输出到文件了。loguru 对输出到文件的配置有非常强大的支持，比如支持输出到多个文件，分级别分别输出，过大创建新文件，过久自动删除等等。</p>
<p>下面我们分别看看这些怎样来实现，这里基本上就是 add 方法的使用介绍。因为这个 add 方法就相当于给 logger 添加了一个 Handler，它给我们暴露了许多参数来实现 Handler 的配置，下面我们来详细介绍下。<br>首先看看它的方法定义吧:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def add(</span><br><span class="line">        self,</span><br><span class="line">        sink,</span><br><span class="line">        *,</span><br><span class="line">        level&#x3D;_defaults.LOGURU_LEVEL,</span><br><span class="line">        format&#x3D;_defaults.LOGURU_FORMAT,</span><br><span class="line">        filter&#x3D;_defaults.LOGURU_FILTER,</span><br><span class="line">        colorize&#x3D;_defaults.LOGURU_COLORIZE,</span><br><span class="line">        serialize&#x3D;_defaults.LOGURU_SERIALIZE,</span><br><span class="line">        backtrace&#x3D;_defaults.LOGURU_BACKTRACE,</span><br><span class="line">        diagnose&#x3D;_defaults.LOGURU_DIAGNOSE,</span><br><span class="line">        enqueue&#x3D;_defaults.LOGURU_ENQUEUE,</span><br><span class="line">        catch&#x3D;_defaults.LOGURU_CATCH,</span><br><span class="line">        **kwargs</span><br><span class="line">    ):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>
<p>看看它的源代码，它支持这么多的参数，如 level、format、filter、color 等等。</p>
<blockquote>
<p>sink<br>另外我们还注意到它有个非常重要的参数 sink，我们看看官方文档：<code>https://loguru.readthedocs.io/en/stable/api/logger.html#sink</code>，可以了解到通过 sink 我们可以传入多种不同的数据结构，汇总如下:</p>
</blockquote>
<ul>
<li>sink 可以传入一个 file 对象，例如 sys.stderr 或者 open(‘file.log’, ‘w’) 都可以。</li>
<li>sink 可以直接传入一个 str 字符串或者 pathlib.Path 对象，其实就是代表文件路径的，如果识别到是这种类型，它会自动创建对应路径的日志文件并将日志输出进去。</li>
<li>sink 可以是一个方法，可以自行定义输出实现。</li>
<li>sink 可以是一个 logging 模块的 Handler，比如 FileHandler、StreamHandler 等等，或者上文中我们提到的 CMRESHandler 照样也是可以的，这样就可以实现自定义 Handler 的配置。</li>
<li>sink 还可以是一个自定义的类，具体的实现规范可以参见官方文档.<br>所以说，刚才我们所演示的输出到文件，仅仅给它传了一个 str 字符串路径，他就给我们创建了一个日志文件，就是这个原理。</li>
</ul>
<blockquote>
<blockquote>
<p>format, filter, level<br>下面我们再了解下它的其他参数，例如 format、filter、level 等等。<br>其实它们的概念和格式和 logging 模块都是基本一样的了，例如这里使用 format、filter、level 来规定输出的格式:</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logger.add(&#39;runtime.log&#39;, format&#x3D;&quot;&#123;time&#125; &#123;level&#125; &#123;message&#125;&quot;, filter&#x3D;&quot;my_module&quot;, level&#x3D;&quot;INFO&quot;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>删除sink<br>另外添加 sink 之后我们也可以对其进行删除，相当于重新刷新并写入新的内容。<br>删除的时候根据刚刚 add 方法返回的 id 进行删除即可，看下面的例子:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from loguru import logger</span><br><span class="line"></span><br><span class="line">trace &#x3D; logger.add(&#39;runtime.log&#39;)</span><br><span class="line">logger.debug(&#39;this is a debug message&#39;)</span><br><span class="line">logger.remove(trace)</span><br><span class="line">logger.debug(&#39;this is another debug message&#39;)</span><br></pre></td></tr></table></figure>
<p>看这里，我们首先 add 了一个 sink，然后获取它的返回值，赋值为 trace。随后输出了一条日志，然后将 trace 变量传给 remove 方法，再次输出一条日志，看看结果是怎样的。<br>控制台输出如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">019-10-13 23:18:26.469 | DEBUG    | __main__:&lt;module&gt;:4 - this is a debug message</span><br><span class="line">2019-10-13 23:18:26.469 | DEBUG    | __main__:&lt;module&gt;:6 - this is another debug message</span><br></pre></td></tr></table></figure>
<p>日志文件 runtime.log 内容如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2019-10-13 23:18:26.469 | DEBUG    | __main__:&lt;module&gt;:4 - this is a debug message</span><br></pre></td></tr></table></figure>
<p>可以发现，在调用 remove 方法之后，确实将历史 log 删除了。<br>这样我们就可以实现日志的刷新重新写入操作。</p>
<blockquote>
<p>rotation 配置<br>用了 loguru 我们还可以非常方便地使用 rotation 配置，比如我们想一天输出一个日志文件，或者文件太大了自动分隔日志文件，我们可以直接使用 add 方法的 rotation 参数进行配置。<br>我们看看下面的例子：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logger.add(&#39;runtime_&#123;time&#125;.log&#39;, rotation&#x3D;&quot;500 MB&quot;)</span><br></pre></td></tr></table></figure>
<p>通过这样的配置我们就可以实现每 500MB 存储一个文件，每个 log 文件过大就会新创建一个 log 文件。我们在配置 log 名字时加上了一个 time 占位符，这样在生成时可以自动将时间替换进去，生成一个文件名包含时间的 log 文件。<br>另外我们也可以使用 rotation 参数实现定时创建 log 文件，例如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logger.add(&#39;runtime_&#123;time&#125;.log&#39;, rotation&#x3D;&#39;00:00&#39;)</span><br></pre></td></tr></table></figure>
<p>这样就可以实现每天 0 点新创建一个 log 文件输出了。<br>另外我们也可以配置 log 文件的循环时间，比如每隔一周创建一个 log 文件，写法如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logger.add(&#39;runtime_&#123;time&#125;.log&#39;, rotation&#x3D;&#39;1 week&#39;)</span><br></pre></td></tr></table></figure>
<p>这样我们就可以实现一周创建一个 log 文件了。</p>
<blockquote>
<p>retention 配置<br>很多情况下，一些非常久远的 log 对我们来说并没有什么用处了，它白白占据了一些存储空间，不清除掉就会非常浪费。retention 这个参数可以配置日志的最长保留时间。<br>比如我们想要设置日志文件最长保留 10 天，可以这么来配置:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logger.add(&#39;runtime.log&#39;, retention&#x3D;&#39;10 days&#39;)</span><br></pre></td></tr></table></figure>
<p>这样 log 文件里面就会保留最新 10 天的 log，妈妈再也不用担心 log 沉积的问题啦。</p>
<blockquote>
<p>compression 配置<br>loguru 还可以配置文件的压缩格式，比如使用 zip 文件格式保存，示例如下:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logger.add(&#39;runtime.log&#39;, compression&#x3D;&#39;zip&#39;)</span><br></pre></td></tr></table></figure>
<p>这样可以更加节省存储空间。</p>
<blockquote>
<p>字符串格式化<br>loguru 在输出 log 的时候还提供了非常友好的字符串格式化功能，像这样:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logger.info(&#39;If you are using Python &#123;&#125;, prefer &#123;feature&#125; of course!&#39;, 3.6, feature&#x3D;&#39;f-strings&#39;)</span><br></pre></td></tr></table></figure>
<p>这样在添加参数就非常方便了。</p>
<blockquote>
<p>Traceback 记录<br>在很多情况下，如果遇到运行错误，而我们在打印输出 log 的时候万一不小心没有配置好 Traceback 的输出，很有可能我们就没法追踪错误所在了。<br>但用了 loguru 之后，我们用它提供的装饰器就可以直接进行 Traceback 的记录，类似这样的配置即可:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@logger.catch</span><br><span class="line">def my_function(x, y, z):</span><br><span class="line">    # An error? It&#39;s caught anyway!</span><br><span class="line">    return 1 &#x2F; (x + y + z)</span><br></pre></td></tr></table></figure>
<p>我们做个测试，我们在调用时三个参数都传入 0，直接引发除以 0 的错误，看看会出现什么情况:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">my_function(0, 0, 0)</span><br></pre></td></tr></table></figure>
<p>运行完毕之后，可以发现 log 里面就出现了 Traceback 信息，而且给我们输出了当时的变量值，真的是不能再赞了！结果如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; File &quot;run.py&quot;, line 15, in &lt;module&gt;</span><br><span class="line">    my_function(0, 0, 0)</span><br><span class="line">    └ &lt;function my_function at 0x1171dd510&gt;</span><br><span class="line"></span><br><span class="line">  File &quot;&#x2F;private&#x2F;var&#x2F;py&#x2F;logurutest&#x2F;demo5.py&quot;, line 13, in my_function</span><br><span class="line">    return 1 &#x2F; (x + y + z)</span><br><span class="line">                │   │   └ 0</span><br><span class="line">                │   └ 0</span><br><span class="line">                └ 0</span><br><span class="line"></span><br><span class="line">ZeroDivisionError: division by zero</span><br></pre></td></tr></table></figure>
<p>因此，用 loguru 可以非常方便地实现日志追踪，debug 效率可能要高上十倍了？<br>另外 loguru 还有很多很多强大的功能，这里就不再一一展开讲解了，更多的内容大家可以看看 loguru 的官方文档详细了解一下：<code>https://loguru.readthedocs.io/en/stable/index.html</code><br>看完之后，是时候把自己的 logging 模块替换成 loguru 啦！</p>
]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>PYTHON</tag>
      </tags>
  </entry>
  <entry>
    <title>Python在字典中将键映射到多个值上</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h2 id="Python在字典中将键映射到多个值上"><a href="#Python在字典中将键映射到多个值上" class="headerlink" title="Python在字典中将键映射到多个值上"></a>Python在字典中将键映射到多个值上</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>我们想要一个能将键（key）能映射到多个值的字典（即所谓的一键多值字典multidict）。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>字典是一种关联容器。每个键都映射到单独的值上。如果想让键映射到多个值，需要将这多个值保存到另一个容器如列表或集合中。例如，可能会像这样创建字典：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d &#x3D; &#123;</span><br><span class="line">    &#39;a&#39; : [1, 2, 3],</span><br><span class="line">    &#39;b&#39; : [4, 5]</span><br><span class="line">&#125;</span><br><span class="line">e &#x3D; &#123;</span><br><span class="line">    &#39;a&#39; : &#123;1, 2, 3&#125;,</span><br><span class="line">    &#39;b&#39; : &#123;4, 5&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要使用列表还是集合完全取决于应用的意图。如果希望保留元素插入的顺序，就用列表。如果希望消除重复元素（且不在意它们的顺序），就用集合。<br>为了能方便的创建这样的字典，可以利用collections模块中的defaultdict类。defaultdict的一个特点就是它会自动初始化第一个值，这样只需关注添加元素即可。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from collections import defaultdict</span><br><span class="line">d &#x3D; defaultdict(list)</span><br><span class="line">d[&#39;a&#39;].append(1)</span><br><span class="line">d[&#39;a&#39;].append(2)</span><br><span class="line">d[&#39;a&#39;].append(3)</span><br><span class="line">d[&#39;b&#39;].append(4)</span><br><span class="line">d[&#39;b&#39;].append(5)</span><br><span class="line">print(d) # outputs : defaultdict(&lt;class &#39;list&#39;&gt;, &#123;&#39;a&#39;: [1, 2, 3], &#39;b&#39;: [4, 5]&#125;)</span><br><span class="line">d &#x3D; defaultdict(set)</span><br><span class="line">d[&#39;a&#39;].add(1)</span><br><span class="line">d[&#39;a&#39;].add(2)</span><br><span class="line">d[&#39;a&#39;].add(3)</span><br><span class="line">d[&#39;b&#39;].add(4)</span><br><span class="line">d[&#39;b&#39;].add(5)</span><br><span class="line">print(d) # outputs : defaultdict(&lt;class &#39;set&#39;&gt;, &#123;&#39;a&#39;: &#123;1, 2, 3&#125;, &#39;b&#39;: &#123;4, 5&#125;&#125;)</span><br></pre></td></tr></table></figure>
<p>关于defaultdict，需要注意的一个地方是，它会自动创建字典表项以待稍后的访问(即使这些表项当前在字典中还没有找到),例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from collections import defaultdict</span><br><span class="line">d &#x3D; defaultdict(list)</span><br><span class="line">if d[&#39;a&#39;]:</span><br><span class="line">    pass</span><br><span class="line">print(d) # outputs : defaultdict(&lt;class &#39;list&#39;&gt;, &#123;&#39;a&#39;: []&#125;)</span><br></pre></td></tr></table></figure>
<p>如果不想要这个功能，可以在普通的字典上调用setdefault()方法来取代。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from collections import defaultdict</span><br><span class="line">d &#x3D; &#123;&#125;</span><br><span class="line">d.setdefault(&#39;a&#39;, []).append(1)</span><br><span class="line">d.setdefault(&#39;a&#39;, []).append(2)</span><br><span class="line">d.setdefault(&#39;a&#39;, []).append(3)</span><br><span class="line">d.setdefault(&#39;b&#39;, []).append(4)</span><br><span class="line">d.setdefault(&#39;b&#39;, []).append(5)</span><br><span class="line">print(d) # outputs : &#123;&#39;a&#39;: [1, 2, 3], &#39;b&#39;: [4, 5]&#125;</span><br></pre></td></tr></table></figure>
<p>然后，总感觉使用setdefault()有点不自然，更别提每次调用它时都会创建一个初始值的新实例了（例子中的空列表[]）。</p>
<h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>原则上，构建一个一键多值字典是很容易的。但是试着自己对第一个值做初始化操作，这就会变得很杂乱。例如，可能会写下这样的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d &#x3D; &#123;&#125;</span><br><span class="line">for key, value in pairs:</span><br><span class="line">    if key not in d:</span><br><span class="line">        d[key] &#x3D; value</span><br><span class="line">    d[key].append(value)</span><br><span class="line">&#96;&#96;&#96;    </span><br><span class="line">使用defaultdict后代码会清晰很多：</span><br></pre></td></tr></table></figure>
<p>d = defaultdict(list)<br>for key, value in pairs:<br>    d[key].append(value)</p>
<pre><code>
[原文地址](http://www.revotu.com/mapping-keys-to-multiple-values-in-a-dictionary.html)</code></pre>]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>PYTHON</tag>
      </tags>
  </entry>
  <entry>
    <title>Python合并两个字典成一个新字典的几种方法分析比较</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h2 id="Python合并两个字典成一个新字典的几种方法分析比较"><a href="#Python合并两个字典成一个新字典的几种方法分析比较" class="headerlink" title="Python合并两个字典成一个新字典的几种方法分析比较"></a>Python合并两个字典成一个新字典的几种方法分析比较</h2><p>两个字典如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; d1 &#x3D; &#123;&#39;name&#39; : &#39;revotu&#39;, &#39;age&#39; : 99&#125;</span><br><span class="line">&gt;&gt;&gt; d2 &#x3D; &#123;&#39;age&#39; : 24, &#39;sex&#39; : &#39;male&#39;&#125;</span><br></pre></td></tr></table></figure>
<p>合并后的结果如下（即，key相同时后面字典值覆盖前面字典）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&#39;sex&#39;: &#39;male&#39;, &#39;name&#39;: &#39;revotu&#39;, &#39;age&#39;: 24&#125;</span><br></pre></td></tr></table></figure>
<p>首先，说明字典并不支持+加法运算：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; d1 + d2</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: unsupported operand type(s) for +: &#39;dict&#39; and &#39;dict&#39;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>现总结如下几种方法以及简要分析比较。</p>
<ol>
<li><p>多次更新<br>下面是最简单的合并字典的方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; d &#x3D; &#123;&#125;</span><br><span class="line">&gt;&gt;&gt; d.update(d1)</span><br><span class="line">&gt;&gt;&gt; d.update(d2)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>首先创建一个空字典，并使用update方法向字典中添加元素。注意，先添加的是d1，以保证后面添加的d2重复键会覆盖d1。<br>此方法满足了我们的要求，而且清晰明确，可是三行代码总感觉不够Pythonic。</p>
</blockquote>
</li>
<li><p>先复制，后更新<br>先复制d1字典创建一个新字典，然后使用d2来更新前面创建的新字典。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; d &#x3D; d1.copy()</span><br><span class="line">&gt;&gt;&gt; d.update(d2)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对比方法一，这种复制d1的方法，更明显的表现出d1作为默认值。</p>
</blockquote>
</li>
<li><p>字典构造器<br>还可以使用字典的构造器dict()复制字典，然后再更新：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; d &#x3D; dict(d1)</span><br><span class="line">&gt;&gt;&gt; d.update(d2)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>与方法二很相似，但是没有方法二直接明了。</p>
</blockquote>
</li>
<li><p>关键字参数hack<br>你可能见过下面这个巧妙的解决办法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; d &#x3D; dict(d1 , **d2)</span><br></pre></td></tr></table></figure>
<p>只有一行代码，看上去很酷，但是有一个问题，这种hack技巧只有在字典的键是字符串时才有效。</p>
<blockquote>
<p>看上去很cool，但是不通用，字典的键必须是字符串才可以用这种关键字参数方法。</p>
</blockquote>
</li>
<li><p>字典推导式<br>可以用字典推导式解决此问题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; d &#x3D; &#123;k:v for d in [d1, d2] for k,v in d.items()&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>字典推导式方法满足要求，只是嵌套的字典推导式，不那么清晰，不易于理解。</p>
</blockquote>
</li>
<li><p>元素拼接<br>我们从每个字典中获取一个元素列表，将列表拼接起来，然后再用拼接的列表构造字典：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; d &#x3D; dict(list(d1.items()) + list(d2.items()))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>而且，d2的元素在列表后面，所以在键重复时可以覆盖d1。如果在Python2中，items()方法本身返回的就是列表，无需用list()转成列表。</p>
</blockquote>
</li>
</ol>
<p>元素拼接在构造字典可以满足要求，只是看上去代码有些重复。</p>
<ol start="7">
<li><p>元素并集<br>在Python3中，字典返回的是视图对象，键的视图对象是一个类似集合的对象，如果字典中的值可以保证是唯一的可哈希的，此时items返回的视图对象也是一个类似集合的对象：</p>
<figure class="highlight plain"><figcaption><span>d </span></figcaption><table><tr><td class="code"><pre><span class="line">&gt; 这种方法挺有意思，可是并不准确，因为集合是无序的，键重复时不能保证谁覆盖谁，而且字典中的值通常也是不可哈希的，当然也就不能返回一个类似集合的对象。</span><br><span class="line"></span><br><span class="line">8. chain items</span><br><span class="line">目前为止，我们讨论的解决方案中，最符合Python语言习惯而且只有一行代码实现的，是创建两个items的列表，然后拼接成字典。</span><br><span class="line">我们可以用itertools.chain来简化items拼接过程：</span><br><span class="line">&#96;&#96;&#96;&gt;&gt;&gt; d &#x3D; dict(chain(d1.items(), d2.items()))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这种方案很不错，可能比另外创建两个不必要的列表更高效。</p>
</blockquote>
</li>
<li><p>ChainMap<br>collections.ChainMap可以将多个字典或映射，在逻辑上将它们合并为一个单独的映射结构：</p>
<figure class="highlight plain"><figcaption><span>from collections import ChainMap</span></figcaption><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; d &#x3D; dict(ChainMap(d1, d2))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这种方法也很pythonic，而且也是通用方法。</p>
</blockquote>
</li>
<li><p>字典拆分<br>在Python3.5+中，可以使用一种全新的字典合并方式：</p>
<figure class="highlight plain"><figcaption><span>d </span></figcaption><table><tr><td class="code"><pre><span class="line">&gt; 这行代码很pythonic，如果是你的python版本是3.5+，用这种方法是很不错的选择。</span><br><span class="line"></span><br><span class="line">### 总结</span><br><span class="line">上面说了十种可以合并两个字典成一个新字典的方式，具体用哪个取决于你。</span><br><span class="line">如果使用的是Python3.5+的版本，那么字典拆分这种新语法应该很适合你：</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<blockquote>
<p>d = {*<em>d1, *</em>d2}</p>
</blockquote>
</blockquote>
</blockquote>
<pre><code></code></pre></li>
</ol>
<p><a href="http://www.revotu.com/python-merge-two-dicts-into-one-dict.html#more" target="_blank" rel="noopener">原文博客</a>  </p>
]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>PYTHON</tag>
      </tags>
  </entry>
  <entry>
    <title>Python如何递归删除空文件夹</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h2 id="Python如何递归删除空文件夹"><a href="#Python如何递归删除空文件夹" class="headerlink" title="Python如何递归删除空文件夹"></a>Python如何递归删除空文件夹</h2><p>Python如何递归删除空文件夹，这个问题很常见。但大多数人的解决办法都是自己实现递归函数解决这个问题，其实根本不用那么麻烦。Python中的os.walk提供了一种从内到外的遍历目录树的方法（设置topdown=False），这样由内到外判断当前目录树下是否有文件和文件夹，如果都没有则意味着当前目录树为空文件夹，os.rmdir删除即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#Recursively Remove Empty Directories</span><br><span class="line">import os</span><br><span class="line">for root, dirs, files in os.walk(path, topdown&#x3D;False):</span><br><span class="line">    if not files and not dirs:</span><br><span class="line">        os.rmdir(root)</span><br><span class="line">&#96;&#96;&#96;        </span><br><span class="line">如果在遍历文件夹同时，先做了一些操作，比如删除文件操作os.remove，然后再判断此时文件夹是否为空，为空则删除。需要用os.listdir判断当前文件夹是否为空，因为dirs和files还是刚进入当前文件夹root时得到的。</span><br></pre></td></tr></table></figure>
<p>#Recursively Remove Empty Directories, During do something like os.remove(file)<br>import os<br>for root, dirs, files in os.walk(path, topdown=False):<br>    # do something like os.remove(file)<br>    if not os.listdir(root):<br>        os.rmdir(root)<br>```        </p>
]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>PYTHON</tag>
      </tags>
  </entry>
  <entry>
    <title>Python小技巧和有趣的内置函数</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h2 id="Python小技巧和有趣的内置函数"><a href="#Python小技巧和有趣的内置函数" class="headerlink" title="Python小技巧和有趣的内置函数"></a>Python小技巧和有趣的内置函数</h2><blockquote>
<p>一个python小技巧的集合和一些很有用的Python内置函数,这些函数简直是屌爆了，我认为每个 Pythoner 都应该知道这些函数。</p>
</blockquote>
<h3 id="1-1-拆箱"><a href="#1-1-拆箱" class="headerlink" title="1.1 拆箱"></a>1.1 拆箱</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a, b, c &#x3D; 1, 2, 3  </span><br><span class="line">&gt;&gt;&gt; a, b, c  </span><br><span class="line">(1, 2, 3)  </span><br><span class="line">&gt;&gt;&gt; a, b, c &#x3D; [1, 2, 3]  </span><br><span class="line">&gt;&gt;&gt; a, b, c  </span><br><span class="line">(1, 2, 3)  </span><br><span class="line">&gt;&gt;&gt; a, b, c &#x3D; (2 * i + 1  for i in range(3))  </span><br><span class="line">&gt;&gt;&gt; a, b, c  </span><br><span class="line">(1, 3, 5)  </span><br><span class="line">&gt;&gt;&gt; a, (b, c), d &#x3D; [1, (2, 3), 4]  </span><br><span class="line">&gt;&gt;&gt; a  </span><br><span class="line">1  </span><br><span class="line">&gt;&gt;&gt; b  </span><br><span class="line">2  </span><br><span class="line">&gt;&gt;&gt; c  </span><br><span class="line">3  </span><br><span class="line">&gt;&gt;&gt; d  </span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<h3 id="1-2-拆箱变量交换"><a href="#1-2-拆箱变量交换" class="headerlink" title="1.2 拆箱变量交换"></a>1.2 拆箱变量交换</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a, b &#x3D; 1, 2  </span><br><span class="line">&gt;&gt;&gt; a, b &#x3D; b, a  </span><br><span class="line">&gt;&gt;&gt; a, b  </span><br><span class="line">(2, 1)</span><br></pre></td></tr></table></figure>
<h3 id="1-3-扩展拆箱-只兼容python3"><a href="#1-3-扩展拆箱-只兼容python3" class="headerlink" title="1.3 扩展拆箱(只兼容python3)"></a>1.3 扩展拆箱(只兼容python3)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a, *b, c &#x3D; [1, 2, 3, 4, 5]  </span><br><span class="line">&gt;&gt;&gt; a  </span><br><span class="line">1  </span><br><span class="line">&gt;&gt;&gt; b  </span><br><span class="line">[2, 3, 4]  </span><br><span class="line">&gt;&gt;&gt; c  </span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<h3 id="1-4-负数索引"><a href="#1-4-负数索引" class="headerlink" title="1.4 负数索引"></a>1.4 负数索引</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]  </span><br><span class="line">&gt;&gt;&gt; a[-1]  </span><br><span class="line">10  </span><br><span class="line">&gt;&gt;&gt; a[-3]  </span><br><span class="line">8</span><br></pre></td></tr></table></figure>
<h3 id="1-5-切割列表"><a href="#1-5-切割列表" class="headerlink" title="1.5 切割列表"></a>1.5 切割列表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]  </span><br><span class="line">&gt;&gt;&gt; a &#x3D; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]  </span><br><span class="line">&gt;&gt;&gt; a[2:8]  </span><br><span class="line">[2, 3, 4, 5, 6, 7]</span><br></pre></td></tr></table></figure>
<h3 id="1-6-负数索引切割列表"><a href="#1-6-负数索引切割列表" class="headerlink" title="1.6 负数索引切割列表"></a>1.6 负数索引切割列表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]  </span><br><span class="line">&gt;&gt;&gt; a[-4:-2]  </span><br><span class="line">[7, 8]</span><br></pre></td></tr></table></figure>
<h3 id="1-7指定步长切割列表"><a href="#1-7指定步长切割列表" class="headerlink" title="1.7指定步长切割列表"></a>1.7指定步长切割列表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]  </span><br><span class="line">&gt;&gt;&gt; a[::2]  </span><br><span class="line">[0, 2, 4, 6, 8, 10]  </span><br><span class="line">&gt;&gt;&gt; a[::3]  </span><br><span class="line">[0, 3, 6, 9]  </span><br><span class="line">&gt;&gt;&gt; a[2:8:2]  </span><br><span class="line">[2, 4, 6]</span><br></pre></td></tr></table></figure>
<h3 id="1-8-负数步长切割列表"><a href="#1-8-负数步长切割列表" class="headerlink" title="1.8 负数步长切割列表"></a>1.8 负数步长切割列表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]  </span><br><span class="line">&gt;&gt;&gt; a[::-1]  </span><br><span class="line">[10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]  </span><br><span class="line">&gt;&gt;&gt; a[::-2]  </span><br><span class="line">[10, 8, 6, 4, 2, 0]</span><br></pre></td></tr></table></figure>
<h3 id="1-9-列表切割赋值"><a href="#1-9-列表切割赋值" class="headerlink" title="1.9 列表切割赋值"></a>1.9 列表切割赋值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; [1, 2, 3, 4, 5]  </span><br><span class="line">&gt;&gt;&gt; a[2:3] &#x3D; [0, 0]  </span><br><span class="line">&gt;&gt;&gt; a  </span><br><span class="line">[1, 2, 0, 0, 4, 5]  </span><br><span class="line">&gt;&gt;&gt; a[1:1] &#x3D; [8, 9]  </span><br><span class="line">&gt;&gt;&gt; a  </span><br><span class="line">[1, 8, 9, 2, 0, 0, 4, 5]  </span><br><span class="line">&gt;&gt;&gt; a[1:-1] &#x3D; []  </span><br><span class="line">&gt;&gt;&gt; a  </span><br><span class="line">[1, 5]</span><br></pre></td></tr></table></figure>
<h3 id="1-10-命名列表切割方式"><a href="#1-10-命名列表切割方式" class="headerlink" title="1.10 命名列表切割方式"></a>1.10 命名列表切割方式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; [0, 1, 2, 3, 4, 5]  </span><br><span class="line">&gt;&gt;&gt; LASTTHREE &#x3D; slice(-3, None)  </span><br><span class="line">&gt;&gt;&gt; LASTTHREE  </span><br><span class="line">slice(-3, None, None)  </span><br><span class="line">&gt;&gt;&gt; a[LASTTHREE]  </span><br><span class="line">[3, 4, 5]</span><br></pre></td></tr></table></figure>
<h3 id="1-11-列表以及迭代器的压缩和解压缩"><a href="#1-11-列表以及迭代器的压缩和解压缩" class="headerlink" title="1.11 列表以及迭代器的压缩和解压缩"></a>1.11 列表以及迭代器的压缩和解压缩</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; [1, 2, 3]  </span><br><span class="line">&gt;&gt;&gt; b &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]  </span><br><span class="line">&gt;&gt;&gt; z &#x3D; zip(a, b)  </span><br><span class="line">&gt;&gt;&gt; z  </span><br><span class="line">[(1, &#39;a&#39;), (2, &#39;b&#39;), (3, &#39;c&#39;)]  </span><br><span class="line">&gt;&gt;&gt; zip(*z)  </span><br><span class="line">[(1, 2, 3), (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)]</span><br></pre></td></tr></table></figure>
<h3 id="1-12-列表相邻元素压缩器"><a href="#1-12-列表相邻元素压缩器" class="headerlink" title="1.12 列表相邻元素压缩器"></a>1.12 列表相邻元素压缩器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; [1, 2, 3, 4, 5, 6]  </span><br><span class="line">&gt;&gt;&gt; zip(*([iter(a)] * 2))  </span><br><span class="line">[(1, 2), (3, 4), (5, 6)]  </span><br><span class="line">&gt;&gt;&gt; group_adjacent &#x3D; lambda a, k: zip(*([iter(a)] * k))  </span><br><span class="line">&gt;&gt;&gt; group_adjacent(a, 3)  </span><br><span class="line">[(1, 2, 3), (4, 5, 6)]  </span><br><span class="line">&gt;&gt;&gt; group_adjacent(a, 2)  </span><br><span class="line">[(1, 2), (3, 4), (5, 6)]  </span><br><span class="line">&gt;&gt;&gt; group_adjacent(a, 1)  </span><br><span class="line">[(1,), (2,), (3,), (4,), (5,), (6,)]  </span><br><span class="line">  </span><br><span class="line">&gt;&gt;&gt; zip(a[::2], a[1::2])  </span><br><span class="line">[(1, 2), (3, 4), (5, 6)]  </span><br><span class="line">  </span><br><span class="line">&gt;&gt;&gt; zip(a[::3], a[1::3], a[2::3])  </span><br><span class="line">[(1, 2, 3), (4, 5, 6)]  </span><br><span class="line">  </span><br><span class="line">&gt;&gt;&gt; group_adjacent &#x3D; lambda a, k: zip(*(a[i::k] for i in range(k)))  </span><br><span class="line">&gt;&gt;&gt; group_adjacent(a, 3)  </span><br><span class="line">[(1, 2, 3), (4, 5, 6)]  </span><br><span class="line">&gt;&gt;&gt; group_adjacent(a, 2)  </span><br><span class="line">[(1, 2), (3, 4), (5, 6)]  </span><br><span class="line">&gt;&gt;&gt; group_adjacent(a, 1)  </span><br><span class="line">[(1,), (2,), (3,), (4,), (5,), (6,)]</span><br></pre></td></tr></table></figure>
<h3 id="1-13-在列表中用压缩器和迭代器滑动取值窗口"><a href="#1-13-在列表中用压缩器和迭代器滑动取值窗口" class="headerlink" title="1.13 在列表中用压缩器和迭代器滑动取值窗口"></a>1.13 在列表中用压缩器和迭代器滑动取值窗口</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; def n_grams(a, n):  </span><br><span class="line">... z &#x3D; [iter(a[i:]) for i in range(n)]  </span><br><span class="line">... return zip(*z)  </span><br><span class="line">...  </span><br><span class="line">&gt;&gt;&gt; a &#x3D; [1, 2, 3, 4, 5, 6]  </span><br><span class="line">&gt;&gt;&gt; n_grams(a, 3)  </span><br><span class="line">[(1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 5, 6)]  </span><br><span class="line">&gt;&gt;&gt; n_grams(a, 2)  </span><br><span class="line">[(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]  </span><br><span class="line">&gt;&gt;&gt; n_grams(a, 4)  </span><br><span class="line">[(1, 2, 3, 4), (2, 3, 4, 5), (3, 4, 5, 6)]</span><br></pre></td></tr></table></figure>
<h3 id="用压缩器反转字典"><a href="#用压缩器反转字典" class="headerlink" title="用压缩器反转字典"></a>用压缩器反转字典</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; m &#x3D; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4&#125;  </span><br><span class="line">&gt;&gt;&gt; m.items()  </span><br><span class="line">[(&#39;a&#39;, 1), (&#39;c&#39;, 3), (&#39;b&#39;, 2), (&#39;d&#39;, 4)]  </span><br><span class="line">&gt;&gt;&gt; zip(m.values(), m.keys())  </span><br><span class="line">[(1, &#39;a&#39;), (3, &#39;c&#39;), (2, &#39;b&#39;), (4, &#39;d&#39;)]  </span><br><span class="line">&gt;&gt;&gt; mi &#x3D; dict(zip(m.values(), m.keys()))  </span><br><span class="line">&gt;&gt;&gt; mi  </span><br><span class="line">&#123;1: &#39;a&#39;, 2: &#39;b&#39;, 3: &#39;c&#39;, 4: &#39;d&#39;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-15-列表展开"><a href="#1-15-列表展开" class="headerlink" title="1.15 列表展开"></a>1.15 列表展开</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; [[1, 2], [3, 4], [5, 6]]  </span><br><span class="line">&gt;&gt;&gt; list(itertools.chain.from_iterable(a))  </span><br><span class="line">[1, 2, 3, 4, 5, 6]  </span><br><span class="line">  </span><br><span class="line">&gt;&gt;&gt; sum(a, [])  </span><br><span class="line">[1, 2, 3, 4, 5, 6]  </span><br><span class="line">  </span><br><span class="line">&gt;&gt;&gt; [x for l in a for x in l]  </span><br><span class="line">[1, 2, 3, 4, 5, 6]  </span><br><span class="line">  </span><br><span class="line">&gt;&gt;&gt; a &#x3D; [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]  </span><br><span class="line">&gt;&gt;&gt; [x for l1 in a for l2 in l1 for x in l2]  </span><br><span class="line">[1, 2, 3, 4, 5, 6, 7, 8]  </span><br><span class="line">  </span><br><span class="line">&gt;&gt;&gt; a &#x3D; [1, 2, [3, 4], [[5, 6], [7, 8]]]  </span><br><span class="line">&gt;&gt;&gt; flatten &#x3D; lambda x: [y for l in x for y in flatten(l)] if type(x) is list else [x]  </span><br><span class="line">&gt;&gt;&gt; flatten(a)  </span><br><span class="line">[1, 2, 3, 4, 5, 6, 7, 8]</span><br></pre></td></tr></table></figure>
<h3 id="1-16-生成器表达式"><a href="#1-16-生成器表达式" class="headerlink" title="1.16 生成器表达式"></a>1.16 生成器表达式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; g &#x3D; (x ** 2  for x in xrange(10))  </span><br><span class="line">&gt;&gt;&gt; next(g)  </span><br><span class="line">0  </span><br><span class="line">&gt;&gt;&gt; next(g)  </span><br><span class="line">1  </span><br><span class="line">&gt;&gt;&gt; next(g)  </span><br><span class="line">4  </span><br><span class="line">&gt;&gt;&gt; next(g)  </span><br><span class="line">9  </span><br><span class="line">&gt;&gt;&gt; sum(x ** 3  for x in xrange(10))  </span><br><span class="line">2025  </span><br><span class="line">&gt;&gt;&gt; sum(x ** 3  for x in xrange(10) if x % 3 &#x3D;&#x3D; 1)  </span><br><span class="line">408</span><br></pre></td></tr></table></figure>
<h3 id="1-17-字典推导"><a href="#1-17-字典推导" class="headerlink" title="1.17 字典推导"></a>1.17 字典推导</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; m &#x3D; &#123;x: x ** 2  for x in range(5)&#125;  </span><br><span class="line">&gt;&gt;&gt; m  </span><br><span class="line">&#123;0: 0, 1: 1, 2: 4, 3: 9, 4: 16&#125;  </span><br><span class="line">  </span><br><span class="line">&gt;&gt;&gt; m &#x3D; &#123;x: &#39;A&#39; + str(x) for x in range(10)&#125;  </span><br><span class="line">&gt;&gt;&gt; m  </span><br><span class="line">&#123;0: &#39;A0&#39;, 1: &#39;A1&#39;, 2: &#39;A2&#39;, 3: &#39;A3&#39;, 4: &#39;A4&#39;, 5: &#39;A5&#39;, 6: &#39;A6&#39;, 7: &#39;A7&#39;, 8: &#39;A8&#39;, 9: &#39;A9&#39;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-18-用字典推导反转字典"><a href="#1-18-用字典推导反转字典" class="headerlink" title="1.18 用字典推导反转字典"></a>1.18 用字典推导反转字典</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; m &#x3D; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4&#125;  </span><br><span class="line">&gt;&gt;&gt; m  </span><br><span class="line">&#123;&#39;d&#39;: 4, &#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3&#125;  </span><br><span class="line">&gt;&gt;&gt; &#123;v: k for k, v in m.items()&#125;  </span><br><span class="line">&#123;1: &#39;a&#39;, 2: &#39;b&#39;, 3: &#39;c&#39;, 4: &#39;d&#39;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-19-命名元组"><a href="#1-19-命名元组" class="headerlink" title="1.19 命名元组"></a>1.19 命名元组</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; Point &#x3D; collections.namedtuple(&#39;Point&#39;, [&#39;x&#39;, &#39;y&#39;])  </span><br><span class="line">&gt;&gt;&gt; p &#x3D; Point(x&#x3D;1.0, y&#x3D;2.0)  </span><br><span class="line">&gt;&gt;&gt; p  </span><br><span class="line">Point(x&#x3D;1.0, y&#x3D;2.0)  </span><br><span class="line">&gt;&gt;&gt; p.x  </span><br><span class="line">1.0  </span><br><span class="line">&gt;&gt;&gt; p.y  </span><br><span class="line">2.0</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="http://python.jobbole.com/63320/" target="_blank" rel="noopener">更多请查看原文</a>  </p>
</blockquote>
<h3 id="函数部分"><a href="#函数部分" class="headerlink" title="函数部分"></a>函数部分</h3><h3 id="all-iterable"><a href="#all-iterable" class="headerlink" title="all(iterable)"></a>all(iterable)</h3><p>如果可迭代的对象(数组，字符串，列表等，下同)中的元素都是true(或者为空)的话返回True</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_all &#x3D; True  </span><br><span class="line">for item in iterable:  </span><br><span class="line">if  not item:  </span><br><span class="line">_all &#x3D; False  </span><br><span class="line">break  </span><br><span class="line">if _all:  </span><br><span class="line"># do stuff</span><br></pre></td></tr></table></figure>
<p>更简便的写法是:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if all(iterable):  </span><br><span class="line"># do stuff</span><br></pre></td></tr></table></figure>

<h3 id="any-iterable"><a href="#any-iterable" class="headerlink" title="any(iterable)"></a>any(iterable)</h3><p>如果可迭代的对象中任何一个元素为true的话返回True,如果可迭代的对象为空则返回False</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_any &#x3D; False  </span><br><span class="line">for item in iterable:  </span><br><span class="line">if item:  </span><br><span class="line">_any &#x3D; True  </span><br><span class="line">break  </span><br><span class="line">if _any:  </span><br><span class="line"># do stuff</span><br></pre></td></tr></table></figure>
<p>更简便的写法是:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if any(iterable):  </span><br><span class="line"># do stuff</span><br></pre></td></tr></table></figure>
<h3 id="cmp-x-y"><a href="#cmp-x-y" class="headerlink" title="cmp(x, y)"></a>cmp(x, y)</h3><p>比较两个对象 x 和 y , x &lt; y 的时候返回负数， x ==y 的时候返回 0， x &gt; y 的时候返回正数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def compare(x,y):  </span><br><span class="line">if x &lt; y:  </span><br><span class="line">return -1  </span><br><span class="line">elif x &#x3D;&#x3D; y:  </span><br><span class="line">return  0  </span><br><span class="line">else:  </span><br><span class="line">return  1</span><br></pre></td></tr></table></figure>
<p>你完全可以使用一句 cmp(x, y) 来替代。</p>
<h3 id="dict-arg"><a href="#dict-arg" class="headerlink" title="dict([arg])"></a>dict([arg])</h3><p>使用 arg 提供的条目生成一个新的字典。<br>arg 通常是未知的，但是它很方便！比如说，如果我们想把一个含两个元组的列表转换成一个字典，我们可以这么做。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l &#x3D; [(&#39;Knights&#39;, &#39;Ni&#39;), (&#39;Monty&#39;, &#39;Python&#39;), (&#39;SPAM&#39;, &#39;SPAAAM&#39;)]  </span><br><span class="line">d &#x3D; dict()  </span><br><span class="line">for tuple in l:  </span><br><span class="line">   d[tuple[0]] &#x3D; tuple[1]  </span><br><span class="line"># &#123;&#39;Knights&#39;: &#39;Ni&#39;, &#39;Monty&#39;: &#39;Python&#39;, &#39;SPAM&#39;: &#39;SPAAAM&#39;&#125;</span><br></pre></td></tr></table></figure>
<p>或者这样:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l &#x3D; [(&#39;Knights&#39;, &#39;Ni&#39;), (&#39;Monty&#39;, &#39;Python&#39;), (&#39;SPAM&#39;, &#39;SPAAAM&#39;)]  </span><br><span class="line">d &#x3D; dict(l) # &#123;&#39;Knights&#39;: &#39;Ni&#39;, &#39;Monty&#39;: &#39;Python&#39;, &#39;SPAM&#39;: &#39;SPAAAM&#39;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="enumerate-iterable-start-0"><a href="#enumerate-iterable-start-0" class="headerlink" title="enumerate(iterable [,start=0])"></a>enumerate(iterable [,start=0])</h3><p>我真的是超级喜欢这个!如果你以前写过C语言，那么你可能会这么写:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for i in range(len(list)):  </span><br><span class="line"># do stuff with list[i], for example, print it  </span><br><span class="line">print i, list[i]</span><br></pre></td></tr></table></figure>
<p>噢,不用那么麻烦!你可以使用enumerate()来提高可读性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for i, item in enumerate(list):  </span><br><span class="line"># so stuff with item, for example print it  </span><br><span class="line">print i, item</span><br></pre></td></tr></table></figure>
<h3 id="isinstance-object-classinfo"><a href="#isinstance-object-classinfo" class="headerlink" title="isinstance(object, classinfo)"></a>isinstance(object, classinfo)</h3><p>如果 object 参数是 classinfo 参数的一个实例或者子类(直接或者间接)的话返回 True<br>当你想检验一个对象的类型的时候,第一个想到的应该是使用type()函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if type(obj) &#x3D;&#x3D; type(dict):  </span><br><span class="line"># do stuff  </span><br><span class="line">elif type(obj) &#x3D;&#x3D; type(list):  </span><br><span class="line"># do other stuff  </span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>或者你可以这么写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if isinstance(obj, dict):  </span><br><span class="line"># do stuff  </span><br><span class="line">elif isinstance(obj, list):  </span><br><span class="line"># do other stuff  </span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="pow-x-y-z"><a href="#pow-x-y-z" class="headerlink" title="pow(x, y [,z])"></a>pow(x, y [,z])</h3><p>返回 x 的 y 次幂(如果 z 存在的话则以 z 为模)。<br>如果你想计算 x 的 y 次方，以 z 为模，那么你可以这么写:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mod &#x3D; (x ** y) % z</span><br></pre></td></tr></table></figure>
<p>但是当 x=1234567， y=4567676， z=56 的时候我的电脑足足跑了 64 秒！<br>不要用 ** 和 % 了，使用 pow(x, y, z) 吧！这个例子可以写成 pow(1234567, 4567676, 56) ，只用了 0.034 秒就出了结果！</p>
<h3 id="zip-iterable"><a href="#zip-iterable" class="headerlink" title="zip([iterable, ])"></a>zip([iterable, ])</h3><p>这个函数返回一个含元组的列表，具体请看例子:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l1 &#x3D; (&#39;You gotta&#39;, &#39;the&#39;)  </span><br><span class="line">l2 &#x3D; (&#39;love&#39;, &#39;built-in&#39;)  </span><br><span class="line">out &#x3D; []  </span><br><span class="line">if len(l1) &#x3D;&#x3D; len(l2):  </span><br><span class="line">for i in range(len(l1)):  </span><br><span class="line">       out.append((l1[i], l2[i]))  </span><br><span class="line"># out &#x3D; [(&#39;You gotta&#39;, &#39;love&#39;), (&#39;the&#39;, &#39;built-in)]</span><br></pre></td></tr></table></figure>
<p>或者这么写:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l1 &#x3D; [&#39;You gotta&#39;, &#39;the&#39;]  </span><br><span class="line">l2 &#x3D; [&#39;love&#39;, &#39;built-in&#39;]  </span><br><span class="line">out &#x3D; zip(l1, l2) # [(&#39;You gotta&#39;, &#39;love&#39;), (&#39;the&#39;, &#39;built-in)]</span><br></pre></td></tr></table></figure>
<p>如果你想得到倒序的话加上 * 操作符就可以了:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print zip(*out)  </span><br><span class="line"># [(&#39;You gotta&#39;, &#39;the&#39;), (&#39;love&#39;, &#39;built-in&#39;)]</span><br></pre></td></tr></table></figure>

<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>Python 内置函数很方便，它们很快并且经过了优化，所以它们可能效率更高。<br>我真心认为每个 Python 开发者都应该好好看看内置函数的文档(引言部分)。<br>忘了说了，在 itertools 模块中有很多很不错的函数。</p>
]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>PYTHON</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基于列表实现数据结构栈stack和队列queue</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h2 id="Python基于列表实现数据结构栈stack和队列queue"><a href="#Python基于列表实现数据结构栈stack和队列queue" class="headerlink" title="Python基于列表实现数据结构栈stack和队列queue"></a>Python基于列表实现数据结构栈stack和队列queue</h2><h3 id="python中栈的实现"><a href="#python中栈的实现" class="headerlink" title="python中栈的实现"></a>python中栈的实现</h3><p>栈是一种后进先出（LIFO）的数据结构，只能在一端（栈顶）插入和删除元素，而python中的列表的append()方法对应的就是向栈顶添加元素，列表的pop()方法对应的就是弹出栈顶元素，因此，python中的列表可以作为栈这种数据结构。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; stack &#x3D; [3, 4, 5]</span><br><span class="line">&gt;&gt;&gt; stack.append(6)</span><br><span class="line">&gt;&gt;&gt; stack.append(7)</span><br><span class="line">&gt;&gt;&gt; stack</span><br><span class="line">[3, 4, 5, 6, 7]</span><br><span class="line">&gt;&gt;&gt; stack.pop()</span><br><span class="line">7</span><br><span class="line">&gt;&gt;&gt; stack.pop()</span><br><span class="line">6</span><br><span class="line">&gt;&gt;&gt; stack.pop()</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; stack.pop()</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; stack</span><br><span class="line">[3]</span><br></pre></td></tr></table></figure>

<h3 id="python中队列的实现"><a href="#python中队列的实现" class="headerlink" title="python中队列的实现"></a>python中队列的实现</h3><p>队列是一种先进先出（FIFO）的数据结构，在一端（队尾）插入元素，在另一端（队首）删除元素。而如果用列表实现这种数据结构不是很高效，原因在于在列表尾插入和删除元素是很快的（时间复杂度O(1)），而在列表头插入元素是很慢的（时间复杂度O(n)），因为在列表头部插入和删除元素，列表中其余所有元素都要移动。<br>为了实现队列，用collections.deque双端队列，可以在两端快速的插入和删除元素（时间复杂度都是O(1)）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import deque</span><br><span class="line">&gt;&gt;&gt; queue &#x3D; deque([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;])</span><br><span class="line">&gt;&gt;&gt; queue.append(&#39;D&#39;)</span><br><span class="line">&gt;&gt;&gt; queue.append(&#39;E&#39;)</span><br><span class="line">&gt;&gt;&gt; queue</span><br><span class="line">deque([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;])</span><br><span class="line">&gt;&gt;&gt; queue.popleft()</span><br><span class="line">&#39;A&#39;</span><br><span class="line">&gt;&gt;&gt; queue.popleft()</span><br><span class="line">&#39;B&#39;</span><br><span class="line">&gt;&gt;&gt; queue.popleft()</span><br><span class="line">&#39;C&#39;</span><br><span class="line">&gt;&gt;&gt; queue.popleft()</span><br><span class="line">&#39;D&#39;</span><br><span class="line">&gt;&gt;&gt; queue</span><br><span class="line">deque([&#39;E&#39;])</span><br></pre></td></tr></table></figure>
<p>双端队列collections.deque也是基于列表实现的，由此可以看出基础的数据结构，在Python中通常无需我们自己实现，基于python现有的强大的数据类型，很容易构造出我们想要的数据结构。</p>
]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>PYTHON</tag>
      </tags>
  </entry>
  <entry>
    <title>Python操作MySQL</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h2 id="Python操作MySQL"><a href="#Python操作MySQL" class="headerlink" title="Python操作MySQL"></a>Python操作MySQL</h2><h3 id="一-python操作数据库介绍"><a href="#一-python操作数据库介绍" class="headerlink" title="一. python操作数据库介绍"></a>一. python操作数据库介绍</h3><p>Python 标准数据库接口为 Python DB-API，Python DB-API为开发人员提供了数据库应用编程接口。<br>Python 数据库接口支持非常多的数据库，你可以选择适合你项目的数据库：</p>
<ul>
<li>GadFly</li>
<li>mSQL</li>
<li>MySQL</li>
<li>PostgreSQL</li>
<li>Microsoft SQL Server 2000</li>
<li>Informix</li>
<li>Interbase</li>
<li>Oracle</li>
<li>Sybase</li>
<li>…<br>你可以访问<a href="https://wiki.python.org/moin/DatabaseInterfaces" target="_blank" rel="noopener">Python数据库接口及API</a>查看详细的支持数据库列表。<br>不同的数据库你需要下载不同的DB API模块，例如你需要访问Oracle数据库和Mysql数据，你需要下载Oracle和MySQL数据库模块。<br>DB-API 是一个规范. 它定义了一系列必须的对象和数据库存取方式, 以便为各种各样的底层数据库系统和多种多样的数据库接口程序提供一致的访问接口 。<br>Python的DB-API，为大多数的数据库实现了接口，使用它连接各数据库后，就可以用相同的方式操作各数据库。</li>
</ul>
<p>Python DB-API使用流程：<br>引入 API 模块。<br>获取与数据库的连接。<br>执行SQL语句和存储过程。<br>关闭数据库连接。</p>
<h2 id="二-python操作MySQL模块"><a href="#二-python操作MySQL模块" class="headerlink" title="二. python操作MySQL模块"></a>二. python操作MySQL模块</h2><p>Python操作MySQL主要使用两种方式：</p>
<ol>
<li>DB模块(原生SQL) <ul>
<li>PyMySQL(支持python2.x/3.x)</li>
<li>MySQLdb(目前仅支持python2.x)</li>
</ul>
</li>
<li>ORM框架<ul>
<li>SQLAchemy<h3 id="2-1-PyMySQL模块"><a href="#2-1-PyMySQL模块" class="headerlink" title="2.1 PyMySQL模块"></a>2.1 PyMySQL模块</h3>本文主要介绍PyMySQL模块,MySQLdb使用方式类似</li>
</ul>
</li>
</ol>
<h4 id="2-1-1-安装PyMySQL"><a href="#2-1-1-安装PyMySQL" class="headerlink" title="2.1.1 安装PyMySQL"></a>2.1.1 安装PyMySQL</h4><p>PyMySQL是一个Python编写的MySQL驱动程序，让我们可以用Python语言操作MySQL数据库。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install PyMySQL</span><br></pre></td></tr></table></figure>

<h3 id="2-2-基本使用"><a href="#2-2-基本使用" class="headerlink" title="2.2 基本使用"></a>2.2 基本使用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># __author__ &#x3D; &quot;shuke&quot;</span><br><span class="line"># Date: 2018&#x2F;5&#x2F;13</span><br><span class="line"></span><br><span class="line">import pymysql</span><br><span class="line"></span><br><span class="line"># 创建连接</span><br><span class="line">conn &#x3D; pymysql.connect(host&#x3D;&quot;127.0.0.1&quot;, port&#x3D;3306, user&#x3D;&#39;zff&#39;, passwd&#x3D;&#39;zff123&#39;, db&#x3D;&#39;zff&#39;, charset&#x3D;&#39;utf8mb4&#39;)</span><br><span class="line"></span><br><span class="line"># 创建游标(查询数据返回为元组格式)</span><br><span class="line"># cursor &#x3D; conn.cursor()</span><br><span class="line"></span><br><span class="line"># 创建游标(查询数据返回为字典格式)</span><br><span class="line">cursor &#x3D; conn.cursor(pymysql.cursors.DictCursor)</span><br><span class="line"></span><br><span class="line"># 1. 执行SQL,返回受影响的行数</span><br><span class="line">effect_row1 &#x3D; cursor.execute(&quot;select * from USER&quot;)</span><br><span class="line"></span><br><span class="line"># 2. 执行SQL,返回受影响的行数,一次插入多行数据</span><br><span class="line">effect_row2 &#x3D; cursor.executemany(&quot;insert into USER (NAME) values(%s)&quot;, [(&quot;jack&quot;), (&quot;boom&quot;), (&quot;lucy&quot;)])  # 3</span><br><span class="line"></span><br><span class="line"># 查询所有数据,返回数据为元组格式</span><br><span class="line">result &#x3D; cursor.fetchall()</span><br><span class="line"></span><br><span class="line"># 增&#x2F;删&#x2F;改均需要进行commit提交,进行保存</span><br><span class="line">conn.commit()</span><br><span class="line"></span><br><span class="line"># 关闭游标</span><br><span class="line">cursor.close()</span><br><span class="line"></span><br><span class="line"># 关闭连接</span><br><span class="line">conn.close()</span><br><span class="line"></span><br><span class="line">print(result)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">[&#123;&#39;id&#39;: 6, &#39;name&#39;: &#39;boom&#39;&#125;, &#123;&#39;id&#39;: 5, &#39;name&#39;: &#39;jack&#39;&#125;, &#123;&#39;id&#39;: 7, &#39;name&#39;: &#39;lucy&#39;&#125;, &#123;&#39;id&#39;: 4, &#39;name&#39;: &#39;tome&#39;&#125;, &#123;&#39;id&#39;: 3, &#39;name&#39;: &#39;zff&#39;&#125;, &#123;&#39;id&#39;: 1, &#39;name&#39;: &#39;zhaofengfeng&#39;&#125;, &#123;&#39;id&#39;: 2, &#39;name&#39;: &#39;zhaofengfeng02&#39;&#125;]</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-获取最新创建的数据自增ID"><a href="#2-3-获取最新创建的数据自增ID" class="headerlink" title="2.3 获取最新创建的数据自增ID"></a>2.3 获取最新创建的数据自增ID</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># __author__ &#x3D; &quot;shuke&quot;</span><br><span class="line"># Date: 2018&#x2F;5&#x2F;13</span><br><span class="line"></span><br><span class="line">import pymysql</span><br><span class="line"></span><br><span class="line"># 创建连接</span><br><span class="line">conn &#x3D; pymysql.connect(host&#x3D;&quot;127.0.0.1&quot;, port&#x3D;3306, user&#x3D;&#39;zff&#39;, passwd&#x3D;&#39;zff123&#39;, db&#x3D;&#39;zff&#39;, charset&#x3D;&#39;utf8mb4&#39;)</span><br><span class="line"></span><br><span class="line"># 创建游标(查询数据返回为元组格式)</span><br><span class="line">cursor &#x3D; conn.cursor()</span><br><span class="line"></span><br><span class="line"># 获取新创建数据自增ID</span><br><span class="line">effect_row &#x3D; cursor.executemany(&quot;insert into USER (NAME)values(%s)&quot;, [(&quot;eric&quot;)])</span><br><span class="line"></span><br><span class="line"># 增删改均需要进行commit提交</span><br><span class="line">conn.commit()</span><br><span class="line"></span><br><span class="line"># 关闭游标</span><br><span class="line">cursor.close()</span><br><span class="line"></span><br><span class="line"># 关闭连接</span><br><span class="line">conn.close()</span><br><span class="line"></span><br><span class="line">new_id &#x3D; cursor.lastrowid</span><br><span class="line">print(new_id)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">8</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-查询操作"><a href="#2-4-查询操作" class="headerlink" title="2.4 查询操作"></a>2.4 查询操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># __author__ &#x3D; &quot;shuke&quot;</span><br><span class="line"># Date: 2018&#x2F;5&#x2F;13</span><br><span class="line"></span><br><span class="line">import pymysql</span><br><span class="line"></span><br><span class="line"># 创建连接</span><br><span class="line">conn &#x3D; pymysql.connect(host&#x3D;&quot;127.0.0.1&quot;, port&#x3D;3306, user&#x3D;&#39;zff&#39;, passwd&#x3D;&#39;zff123&#39;, db&#x3D;&#39;zff&#39;, charset&#x3D;&#39;utf8mb4&#39;)</span><br><span class="line"></span><br><span class="line"># 创建游标</span><br><span class="line">cursor &#x3D; conn.cursor()</span><br><span class="line"></span><br><span class="line">cursor.execute(&quot;select * from USER&quot;)</span><br><span class="line"></span><br><span class="line"># 获取第一行数据</span><br><span class="line">row_1 &#x3D; cursor.fetchone()</span><br><span class="line"></span><br><span class="line"># 获取前n行数据</span><br><span class="line">row_2 &#x3D; cursor.fetchmany(3)</span><br><span class="line">#</span><br><span class="line"># # 获取所有数据</span><br><span class="line">row_3 &#x3D; cursor.fetchall()</span><br><span class="line"></span><br><span class="line"># 关闭游标</span><br><span class="line">cursor.close()</span><br><span class="line"></span><br><span class="line"># 关闭连接</span><br><span class="line">conn.close()</span><br><span class="line">print(row_1)</span><br><span class="line">print(row_2)</span><br><span class="line">print(row_3)</span><br></pre></td></tr></table></figure>
<p>⚠️ 在fetch数据时按照顺序进行，可以使用cursor.scroll(num,mode)来移动游标位置，如：</p>
<ul>
<li>cursor.scroll(1,mode=’relative’)  # 相对当前位置移动</li>
<li>cursor.scroll(2,mode=’absolute’)  # 相对绝对位置移动</li>
</ul>
<h3 id="2-5-防止SQL注入"><a href="#2-5-防止SQL注入" class="headerlink" title="2.5 防止SQL注入"></a>2.5 防止SQL注入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># __author__ &#x3D; &quot;shuke&quot;</span><br><span class="line"># Date: 2018&#x2F;5&#x2F;13</span><br><span class="line"></span><br><span class="line">import pymysql</span><br><span class="line"></span><br><span class="line"># 创建连接</span><br><span class="line">conn &#x3D; pymysql.connect(host&#x3D;&quot;127.0.0.1&quot;, port&#x3D;3306, user&#x3D;&#39;zff&#39;, passwd&#x3D;&#39;zff123&#39;, db&#x3D;&#39;zff&#39;, charset&#x3D;&#39;utf8mb4&#39;)</span><br><span class="line"></span><br><span class="line"># 创建游标</span><br><span class="line">cursor &#x3D; conn.cursor()</span><br><span class="line"></span><br><span class="line"># 存在sql注入情况(不要用格式化字符串的方式拼接SQL)</span><br><span class="line">sql &#x3D; &quot;insert into USER (NAME) values(&#39;%s&#39;)&quot; % (&#39;zhangsan&#39;,)</span><br><span class="line">effect_row &#x3D; cursor.execute(sql)</span><br><span class="line"></span><br><span class="line"># 正确方式一</span><br><span class="line"># execute函数接受一个元组&#x2F;列表作为SQL参数,元素个数只能有1个</span><br><span class="line">sql &#x3D; &quot;insert into USER (NAME) values(%s)&quot;</span><br><span class="line">effect_row1 &#x3D; cursor.execute(sql, [&#39;wang6&#39;])</span><br><span class="line">effect_row2 &#x3D; cursor.execute(sql, (&#39;wang7&#39;,))</span><br><span class="line"></span><br><span class="line"># 正确方式二</span><br><span class="line">sql &#x3D; &quot;insert into USER (NAME) values(%(name)s)&quot;</span><br><span class="line">effect_row1 &#x3D; cursor.execute(sql, &#123;&#39;name&#39;: &#39;wudalang&#39;&#125;)</span><br><span class="line"></span><br><span class="line"># 写入插入多行数据</span><br><span class="line">effect_row2 &#x3D; cursor.executemany(&quot;insert into USER (NAME) values(%s)&quot;, [(&#39;ermazi&#39;), (&#39;dianxiaoer&#39;)])</span><br><span class="line"></span><br><span class="line"># 提交</span><br><span class="line">conn.commit()</span><br><span class="line"># 关闭游标</span><br><span class="line">cursor.close()</span><br><span class="line"># 关闭连接</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure>
<p>这样，SQL操作就更安全了。如果需要更详细的文档参考PyMySQL文档吧。不过好像这些SQL数据库的实现还不太一样，PyMySQL的参数占位符使用%s这样的C格式化符，而Python自带的sqlite3模块的占位符好像是问号(?)。因此在使用其他数据库的时候还是仔细阅读文档吧。<br><a href="https://pymysql.readthedocs.io/en/latest/" target="_blank" rel="noopener">Welcome to PyMySQL’s documentation</a></p>
<h2 id="三-数据库连接池"><a href="#三-数据库连接池" class="headerlink" title="三. 数据库连接池"></a>三. 数据库连接池</h2><p>上文中的方式存在一个问题,单线程情况下可以满足,程序需要频繁的创建释放连接来完成对数据库的操作,那么,我们的程序/脚本在多线程情况下会引发什么问题呢?此时,我们就需要使用数据库连接池来解决这个问题!</p>
<h3 id="3-1-DBUtils模块"><a href="#3-1-DBUtils模块" class="headerlink" title="3.1 DBUtils模块"></a>3.1 DBUtils模块</h3><p>DBUtils是Python的一个用于实现数据库连接池的模块。</p>
<p>此连接池有两种连接模式：</p>
<ul>
<li>为每个线程创建一个连接，线程即使调用了close方法，也不会关闭，只是把连接重新放到连接池，供自己线程再次使用。当线程终止时，连接才会自动关闭</li>
<li>创建一批连接到连接池，供所有线程共享使用(推荐使用)</li>
</ul>
<h3 id="3-2-模式一"><a href="#3-2-模式一" class="headerlink" title="3.2 模式一"></a>3.2 模式一</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># __author__ &#x3D; &quot;shuke&quot;</span><br><span class="line"># Date: 2018&#x2F;5&#x2F;13</span><br><span class="line"></span><br><span class="line">from DBUtils.PersistentDB import PersistentDB</span><br><span class="line">import pymysql</span><br><span class="line"></span><br><span class="line">POOL &#x3D; PersistentDB(</span><br><span class="line">    creator&#x3D;pymysql,  # 使用链接数据库的模块</span><br><span class="line">    maxusage&#x3D;None,  # 一个链接最多被重复使用的次数，None表示无限制</span><br><span class="line">    setsession&#x3D;[],  # 开始会话前执行的命令列表。如：[&quot;set datestyle to ...&quot;, &quot;set time zone ...&quot;]</span><br><span class="line">    ping&#x3D;0,</span><br><span class="line">    # ping MySQL服务端，检查是否服务可用。# 如：0 &#x3D; None &#x3D; never, 1 &#x3D; default &#x3D; whenever it is requested, 2 &#x3D; when a cursor is created, 4 &#x3D; when a query is executed, 7 &#x3D; always</span><br><span class="line">    closeable&#x3D;False,</span><br><span class="line">    # 如果为False时， conn.close() 实际上被忽略，供下次使用，再线程关闭时，才会自动关闭链接。如果为True时， conn.close()则关闭链接，那么再次调用pool.connection时就会报错，因为已经真的关闭了连接（pool.steady_connection()可以获取一个新的链接）</span><br><span class="line">    threadlocal&#x3D;None,  # 本线程独享值得对象，用于保存链接对象，如果链接对象被重置</span><br><span class="line">    host&#x3D;&#39;127.0.0.1&#39;,</span><br><span class="line">    port&#x3D;3306,</span><br><span class="line">    user&#x3D;&#39;zff&#39;,</span><br><span class="line">    password&#x3D;&#39;zff123&#39;,</span><br><span class="line">    database&#x3D;&#39;zff&#39;,</span><br><span class="line">    charset&#x3D;&#39;utf8&#39;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def func():</span><br><span class="line">    conn &#x3D; POOL.connection(shareable&#x3D;False)</span><br><span class="line">    cursor &#x3D; conn.cursor()</span><br><span class="line">    cursor.execute(&#39;select * from USER&#39;)</span><br><span class="line">    result &#x3D; cursor.fetchall()</span><br><span class="line">    cursor.close()</span><br><span class="line">    conn.close()</span><br><span class="line">    return result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">result &#x3D; func()</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>

<h3 id="3-2-模式二"><a href="#3-2-模式二" class="headerlink" title="3.2 模式二"></a>3.2 模式二</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># __author__ &#x3D; &quot;shuke&quot;</span><br><span class="line"># Date: 2018&#x2F;5&#x2F;13</span><br><span class="line"></span><br><span class="line">import time</span><br><span class="line">import pymysql</span><br><span class="line">import threading</span><br><span class="line">from DBUtils.PooledDB import PooledDB, SharedDBConnection</span><br><span class="line"></span><br><span class="line">POOL &#x3D; PooledDB(</span><br><span class="line">    creator&#x3D;pymysql,  # 使用链接数据库的模块</span><br><span class="line">    maxconnections&#x3D;6,  # 连接池允许的最大连接数，0和None表示不限制连接数</span><br><span class="line">    mincached&#x3D;2,  # 初始化时，链接池中至少创建的空闲的链接，0表示不创建</span><br><span class="line">    maxcached&#x3D;5,  # 链接池中最多闲置的链接，0和None不限制</span><br><span class="line">    maxshared&#x3D;3,</span><br><span class="line">    # 链接池中最多共享的链接数量，0和None表示全部共享。PS: 无用，因为pymysql和MySQLdb等模块的 threadsafety都为1，所有值无论设置为多少，_maxcached永远为0，所以永远是所有链接都共享。</span><br><span class="line">    blocking&#x3D;True,  # 连接池中如果没有可用连接后，是否阻塞等待。True，等待；False，不等待然后报错</span><br><span class="line">    maxusage&#x3D;None,  # 一个链接最多被重复使用的次数，None表示无限制</span><br><span class="line">    setsession&#x3D;[],  # 开始会话前执行的命令列表。如：[&quot;set datestyle to ...&quot;, &quot;set time zone ...&quot;]</span><br><span class="line">    ping&#x3D;0,</span><br><span class="line">    # ping MySQL服务端，检查是否服务可用。# 如：0 &#x3D; None &#x3D; never, 1 &#x3D; default &#x3D; whenever it is requested, 2 &#x3D; when a cursor is created, 4 &#x3D; when a query is executed, 7 &#x3D; always</span><br><span class="line">    host&#x3D;&#39;127.0.0.1&#39;,</span><br><span class="line">    port&#x3D;3306,</span><br><span class="line">    user&#x3D;&#39;zff&#39;,</span><br><span class="line">    password&#x3D;&#39;zff123&#39;,</span><br><span class="line">    database&#x3D;&#39;zff&#39;,</span><br><span class="line">    charset&#x3D;&#39;utf8&#39;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def func():</span><br><span class="line">    # 检测当前正在运行连接数的是否小于最大链接数，如果不小于则：等待或报raise TooManyConnections异常</span><br><span class="line">    # 否则</span><br><span class="line">    # 则优先去初始化时创建的链接中获取链接 SteadyDBConnection。</span><br><span class="line">    # 然后将SteadyDBConnection对象封装到PooledDedicatedDBConnection中并返回。</span><br><span class="line">    # 如果最开始创建的链接没有链接，则去创建一个SteadyDBConnection对象，再封装到PooledDedicatedDBConnection中并返回。</span><br><span class="line">    # 一旦关闭链接后，连接就返回到连接池让后续线程继续使用。</span><br><span class="line">    conn &#x3D; POOL.connection()</span><br><span class="line"></span><br><span class="line">    # print(&#39;连接被拿走了&#39;, conn._con)</span><br><span class="line">    # print(&#39;池子里目前有&#39;, POOL._idle_cache, &#39;\r\n&#39;)</span><br><span class="line"></span><br><span class="line">    cursor &#x3D; conn.cursor()</span><br><span class="line">    cursor.execute(&#39;select * from USER&#39;)</span><br><span class="line">    result &#x3D; cursor.fetchall()</span><br><span class="line">    conn.close()</span><br><span class="line">    return result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">result &#x3D; func()</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>
<p>⚠️ 由于pymysql、MySQLdb等threadsafety值为1，所以该模式连接池中的线程会被所有线程共享,因此是线程安全的。<br>如果没有连接池，使用pymysql来连接数据库时，单线程应用完全没有问题，但如果涉及到多线程应用那么就需要加锁，一旦加锁那么连接势必就会排队等待，当请求比较多时，性能就会降低了。</p>
<h3 id="3-3-加锁"><a href="#3-3-加锁" class="headerlink" title="3.3 加锁"></a>3.3 加锁</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># __author__ &#x3D; &quot;shuke&quot;</span><br><span class="line"># Date: 2018&#x2F;5&#x2F;13</span><br><span class="line"></span><br><span class="line">import pymysql</span><br><span class="line">import threading</span><br><span class="line">from threading import RLock</span><br><span class="line"></span><br><span class="line">LOCK &#x3D; RLock()</span><br><span class="line">CONN &#x3D; pymysql.connect(host&#x3D;&#39;127.0.0.1&#39;,</span><br><span class="line">                       port&#x3D;3306,</span><br><span class="line">                       user&#x3D;&#39;zff&#39;,</span><br><span class="line">                       password&#x3D;&#39;zff123&#39;,</span><br><span class="line">                       database&#x3D;&#39;zff&#39;,</span><br><span class="line">                       charset&#x3D;&#39;utf8&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def task(arg):</span><br><span class="line">    with LOCK:</span><br><span class="line">        cursor &#x3D; CONN.cursor()</span><br><span class="line">        cursor.execute(&#39;select * from USER &#39;)</span><br><span class="line">        result &#x3D; cursor.fetchall()</span><br><span class="line">        cursor.close()</span><br><span class="line"></span><br><span class="line">        print(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i in range(10):</span><br><span class="line">    t &#x3D; threading.Thread(target&#x3D;task, args&#x3D;(i,))</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure>

<h3 id="3-4-无锁-报错"><a href="#3-4-无锁-报错" class="headerlink" title="3.4 无锁(报错)"></a>3.4 无锁(报错)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># __author__ &#x3D; &quot;shuke&quot;</span><br><span class="line"># Date: 2018&#x2F;5&#x2F;13</span><br><span class="line"></span><br><span class="line">import pymysql</span><br><span class="line">import threading</span><br><span class="line"></span><br><span class="line">CONN &#x3D; pymysql.connect(host&#x3D;&#39;127.0.0.1&#39;,</span><br><span class="line">                       port&#x3D;3306,</span><br><span class="line">                       user&#x3D;&#39;zff&#39;,</span><br><span class="line">                       password&#x3D;&#39;zff123&#39;,</span><br><span class="line">                       database&#x3D;&#39;zff&#39;,</span><br><span class="line">                       charset&#x3D;&#39;utf8&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def task(arg):</span><br><span class="line">    cursor &#x3D; CONN.cursor()</span><br><span class="line">    cursor.execute(&#39;select * from USER &#39;)</span><br><span class="line">    # cursor.execute(&#39;select sleep(10)&#39;)</span><br><span class="line">    result &#x3D; cursor.fetchall()</span><br><span class="line">    cursor.close()</span><br><span class="line">    print(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i in range(10):</span><br><span class="line">    t &#x3D; threading.Thread(target&#x3D;task, args&#x3D;(i,))</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure>
<p>此时可以在数据库中查看连接情况: show status like ‘Threads%’;</p>
<h2 id="四-数据库连接池结合pymsql使用"><a href="#四-数据库连接池结合pymsql使用" class="headerlink" title="四. 数据库连接池结合pymsql使用"></a>四. 数据库连接池结合pymsql使用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cat sql_helper.py</span><br><span class="line"></span><br><span class="line">import pymysql</span><br><span class="line">import threading</span><br><span class="line">from DBUtils.PooledDB import PooledDB, SharedDBConnection</span><br><span class="line">POOL &#x3D; PooledDB(</span><br><span class="line">    creator&#x3D;pymysql,  # 使用链接数据库的模块</span><br><span class="line">    maxconnections&#x3D;20,  # 连接池允许的最大连接数，0和None表示不限制连接数</span><br><span class="line">    mincached&#x3D;2,  # 初始化时，链接池中至少创建的空闲的链接，0表示不创建</span><br><span class="line">    maxcached&#x3D;5,  # 链接池中最多闲置的链接，0和None不限制</span><br><span class="line">    #maxshared&#x3D;3,  # 链接池中最多共享的链接数量，0和None表示全部共享。PS: 无用，因为pymysql和MySQLdb等模块的 threadsafety都为1，所有值无论设置为多少，_maxcached永远为0，所以永远是所有链接都共享。</span><br><span class="line">    blocking&#x3D;True,  # 连接池中如果没有可用连接后，是否阻塞等待。True，等待；False，不等待然后报错</span><br><span class="line">    maxusage&#x3D;None,  # 一个链接最多被重复使用的次数，None表示无限制</span><br><span class="line">    setsession&#x3D;[],  # 开始会话前执行的命令列表。如：[&quot;set datestyle to ...&quot;, &quot;set time zone ...&quot;]</span><br><span class="line">    ping&#x3D;0,</span><br><span class="line">    # ping MySQL服务端，检查是否服务可用。# 如：0 &#x3D; None &#x3D; never, 1 &#x3D; default &#x3D; whenever it is requested, 2 &#x3D; when a cursor is created, 4 &#x3D; when a query is executed, 7 &#x3D; always</span><br><span class="line">    host&#x3D;&#39;192.168.11.38&#39;,</span><br><span class="line">    port&#x3D;3306,</span><br><span class="line">    user&#x3D;&#39;root&#39;,</span><br><span class="line">    passwd&#x3D;&#39;apNXgF6RDitFtDQx&#39;,</span><br><span class="line">    db&#x3D;&#39;m2day03db&#39;,</span><br><span class="line">    charset&#x3D;&#39;utf8&#39;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def connect():</span><br><span class="line">    # 创建连接</span><br><span class="line">    # conn &#x3D; pymysql.connect(host&#x3D;&#39;192.168.11.38&#39;, port&#x3D;3306, user&#x3D;&#39;root&#39;, passwd&#x3D;&#39;apNXgF6RDitFtDQx&#39;, db&#x3D;&#39;m2day03db&#39;)</span><br><span class="line">    conn &#x3D; POOL.connection()</span><br><span class="line">    # 创建游标</span><br><span class="line">    cursor &#x3D; conn.cursor(pymysql.cursors.DictCursor)</span><br><span class="line"></span><br><span class="line">    return conn,cursor</span><br><span class="line"></span><br><span class="line">def close(conn,cursor):</span><br><span class="line">    # 关闭游标</span><br><span class="line">    cursor.close()</span><br><span class="line">    # 关闭连接</span><br><span class="line">    conn.close()</span><br><span class="line"></span><br><span class="line">def fetch_one(sql,args):</span><br><span class="line">    conn,cursor &#x3D; connect()</span><br><span class="line">    # 执行SQL，并返回收影响行数</span><br><span class="line">    effect_row &#x3D; cursor.execute(sql,args)</span><br><span class="line">    result &#x3D; cursor.fetchone()</span><br><span class="line">    close(conn,cursor)</span><br><span class="line"></span><br><span class="line">    return result</span><br><span class="line"></span><br><span class="line">def fetch_all(sql,args):</span><br><span class="line">    conn, cursor &#x3D; connect()</span><br><span class="line"></span><br><span class="line">    # 执行SQL，并返回收影响行数</span><br><span class="line">    cursor.execute(sql,args)</span><br><span class="line">    result &#x3D; cursor.fetchall()</span><br><span class="line"></span><br><span class="line">    close(conn, cursor)</span><br><span class="line">    return result</span><br><span class="line"></span><br><span class="line">def insert(sql,args):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    创建数据</span><br><span class="line">    :param sql: 含有占位符的SQL</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    conn, cursor &#x3D; connect()</span><br><span class="line"></span><br><span class="line">    # 执行SQL，并返回收影响行数</span><br><span class="line">    effect_row &#x3D; cursor.execute(sql,args)</span><br><span class="line">    conn.commit()</span><br><span class="line"></span><br><span class="line">    close(conn, cursor)</span><br><span class="line"></span><br><span class="line">def delete(sql,args):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    创建数据</span><br><span class="line">    :param sql: 含有占位符的SQL</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    conn, cursor &#x3D; connect()</span><br><span class="line"></span><br><span class="line">    # 执行SQL，并返回收影响行数</span><br><span class="line">    effect_row &#x3D; cursor.execute(sql,args)</span><br><span class="line"></span><br><span class="line">    conn.commit()</span><br><span class="line"></span><br><span class="line">    close(conn, cursor)</span><br><span class="line"></span><br><span class="line">    return effect_row</span><br><span class="line"></span><br><span class="line">def update(sql,args):</span><br><span class="line">    conn, cursor &#x3D; connect()</span><br><span class="line"></span><br><span class="line">    # 执行SQL，并返回收影响行数</span><br><span class="line">    effect_row &#x3D; cursor.execute(sql, args)</span><br><span class="line"></span><br><span class="line">    conn.commit()</span><br><span class="line"></span><br><span class="line">    close(conn, cursor)</span><br><span class="line"></span><br><span class="line">    return effect_row</span><br></pre></td></tr></table></figure>
<p>PS: 可以利用静态方法封装到一个类中,方便使用</p>
]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>PYTHON</tag>
      </tags>
  </entry>
  <entry>
    <title>Python文件内容按行读取到列表中</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h2 id="Python文件内容按行读取到列表中"><a href="#Python文件内容按行读取到列表中" class="headerlink" title="Python文件内容按行读取到列表中"></a>Python文件内容按行读取到列表中</h2><h3 id="示例文件内容如下"><a href="#示例文件内容如下" class="headerlink" title="示例文件内容如下:"></a>示例文件内容如下:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hello</span><br><span class="line">World</span><br><span class="line">Python</span><br></pre></td></tr></table></figure>
<p>通常来讲，我们如果只是迭代文件对象每一行，并做一些处理，是不需要将文件对象转成列表的，因为文件对象本身可迭代，而且是按行迭代：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with open(&#39;somefile&#39;, &#39;r&#39;) as f:</span><br><span class="line">    for line in f:</span><br><span class="line">        print(line, end&#x3D;&#39;&#39;)</span><br><span class="line">        </span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">Hello</span><br><span class="line">World</span><br><span class="line">Python</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<h3 id="转换为列表进行操作"><a href="#转换为列表进行操作" class="headerlink" title="转换为列表进行操作"></a>转换为列表进行操作</h3><ol>
<li>包含换行符</li>
</ol>
<ul>
<li>方式一<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with open(&#39;somefile&#39;,&#39;r&#39;) as f:</span><br><span class="line">    content &#x3D; list(f)</span><br><span class="line">    print(content)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">[&#39;Hello\n&#39;, &#39;World\n&#39;, &#39;Python&#39;]</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure></li>
<li>方式二<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with open(&#39;somefile&#39;,&#39;r&#39;) as f:</span><br><span class="line">    content &#x3D; f.readlines()</span><br><span class="line">    print(content)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">[&#39;Hello\n&#39;, &#39;World\n&#39;, &#39;Python&#39;]</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>
其中，content结果都是没有去掉每一行行尾的换行符的(somefile.txt文件中最后一行本来就没有换行符)</li>
</ul>
<ol start="2">
<li>去掉换行符</li>
</ol>
<ul>
<li>方式一<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with open(&#39;somefile&#39;,&#39;r&#39;) as f:</span><br><span class="line">    content &#x3D; f.read().splitlines()</span><br><span class="line">    print(content)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">[&#39;Hello&#39;, &#39;World&#39;, &#39;Python&#39;]</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure></li>
<li>方式二<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with open(&#39;somefile&#39;,&#39;r&#39;) as f:</span><br><span class="line">    content &#x3D; [line.rstrip(&#39;\n&#39;) for line in f]</span><br><span class="line">    print(content)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">[&#39;Hello&#39;, &#39;World&#39;, &#39;Python&#39;]</span><br><span class="line">&quot;&quot;&quot;    </span><br><span class="line">&#96;&#96;&#96;    </span><br><span class="line">其中，content结果都是去掉每一行行尾的换行符</span><br><span class="line"></span><br><span class="line">3. 去掉行首行尾的空白字符</span><br></pre></td></tr></table></figure>
with open(‘somefile’,’r’) as f:<br>  content = [line.strip() for line in f]<br>  print(content)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 按行读取文件内容并得到当前行号</span><br><span class="line">文件对象是可迭代的（按行迭代），使用enumerate()即可在迭代的同时，得到数字索引(行号),enumerate()的默认数字初始值是0，如需指定1为起始，可以设置其第二个参数：</span><br></pre></td></tr></table></figure>
with open(‘somefile’, ‘r’) as f:<br>  for number, line in enumerate(f,start=1):<pre><code>print(number, line, end=&apos;&apos;)</code></pre>“””<br>1 Hello<br>2 World<br>3 Python<br>“””<pre><code>
</code></pre></li>
</ul>
<p><a href="http://www.revotu.com/read-file-to-list-by-line.html#more" target="_blank" rel="noopener">参考博客</a></p>
]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>PYTHON</tag>
      </tags>
  </entry>
  <entry>
    <title>Python语言实现工厂方法设计模式</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h2 id="Python语言实现工厂方法设计模式"><a href="#Python语言实现工厂方法设计模式" class="headerlink" title="Python语言实现工厂方法设计模式"></a>Python语言实现工厂方法设计模式</h2><blockquote>
<p>根据软件设计原则中开放封闭原则的指导思想, 一个类写好后，尽量不要修改里面的内容, 而是通过添加新的继承应对变化, 简单工厂不符合这个设计原则, 所以本篇文章将使用伪代码介绍工厂方法设计模式的使用</p>
</blockquote>
<p>背景: 现公司监控系统报警需要对接企业微信公众号, 由于未认证企业微信推送消息的限制, 默认每天推送条数上限为6000条, 考虑到报警系统多, 规则没有收敛, 接收的人员多, 每天6000条可能不够用, 所以需要创建多个未认证的企业微信账号用于发送报警信息. 我们将以此需求为背景, 演示工厂方法的设计模式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class WeChat:</span><br><span class="line"></span><br><span class="line">    def send_message(self, content):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def send_image(self, imageid):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class AccountA(WeChat):</span><br><span class="line"></span><br><span class="line">    def send_message(self, content):</span><br><span class="line">        print(&quot;使用企业微信账号A推送信息: &quot;, content)</span><br><span class="line"></span><br><span class="line">    def send_image(self, imageid):</span><br><span class="line">        print(&quot;使用企业微信账号A推送图片: &quot;, imageid)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class AccountB(WeChat):</span><br><span class="line"></span><br><span class="line">    def send_message(self, content):</span><br><span class="line">        print(&quot;使用企业微信账号B推送信息: &quot;, content)</span><br><span class="line"></span><br><span class="line">    def send_image(self, imageid):</span><br><span class="line">        print(&quot;使用企业微信账号B推送图片: &quot;, imageid)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class WeChatFactory:</span><br><span class="line"></span><br><span class="line">    def create_wechat(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class AccountAFactory(WeChatFactory):</span><br><span class="line"></span><br><span class="line">    def create_wechat(self):</span><br><span class="line">        return AccountA()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class AccountBFactory(WeChatFactory):</span><br><span class="line"></span><br><span class="line">    def create_wechat(self):</span><br><span class="line">        return AccountB()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">	# 实例化账号A</span><br><span class="line">    wechat_factory_a &#x3D; AccountAFactory()</span><br><span class="line">	# 创建账号A的微信对象</span><br><span class="line">    wechat1 &#x3D; wechat_factory_a.create_wechat()</span><br><span class="line">    wechat2 &#x3D; wechat_factory_a.create_wechat()</span><br><span class="line">    wechat3 &#x3D; wechat_factory_a.create_wechat()</span><br><span class="line">	# 使用账号A对象发送信息</span><br><span class="line">    wechat1.send_message(content&#x3D;&quot;haha&quot;)</span><br><span class="line">    wechat2.send_message(content&#x3D;&quot;hehe&quot;)</span><br><span class="line">    wechat3.send_message(content&#x3D;&quot;xixi&quot;)</span><br><span class="line"></span><br><span class="line">	# 实例化账号B</span><br><span class="line">    wechat_factory_b &#x3D; AccountBFactory()</span><br><span class="line">	# 创建账号B的微信对象</span><br><span class="line">    wechat4 &#x3D; wechat_factory_b.create_wechat()</span><br><span class="line">    wechat5 &#x3D; wechat_factory_b.create_wechat()</span><br><span class="line">	# 使用账号B对象发送信息</span><br><span class="line">    wechat4.send_message(content&#x3D;&quot;heihei&quot;)</span><br><span class="line">    wechat5.send_message(content&#x3D;&quot;pupu&quot;)</span><br></pre></td></tr></table></figure>
<p>执行结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用企业微信账号A推送信息:  haha</span><br><span class="line">使用企业微信账号A推送信息:  hehe</span><br><span class="line">使用企业微信账号A推送信息:  xixi</span><br><span class="line">使用企业微信账号B推送信息:  heihei</span><br><span class="line">使用企业微信账号B推送信息:  pupu</span><br></pre></td></tr></table></figure>
<p>如果此时, 两个微信账号都不够用了, 需要增加第三个账号时, 所有的类都不需要修改, 只需创建新的类即可, 符合开放封闭原则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class AccountC(WeChat):</span><br><span class="line"></span><br><span class="line">    def send_message(self, content):</span><br><span class="line">        print(&quot;使用企业微信账号C推送信息: &quot;, content)</span><br><span class="line"></span><br><span class="line">    def send_image(self, imageid):</span><br><span class="line">        print(&quot;使用企业微信账号C推送图片: &quot;, imageid)</span><br><span class="line">      </span><br><span class="line">    </span><br><span class="line">class AccountCFactory(WeChatFactory):</span><br><span class="line"></span><br><span class="line">    def create_wechat(self):</span><br><span class="line">        return AccountC()</span><br></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>PYTHON</tag>
      </tags>
  </entry>
  <entry>
    <title>Python类中的特殊成员</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h2 id="Python类中的特殊成员"><a href="#Python类中的特殊成员" class="headerlink" title="Python类中的特殊成员"></a>Python类中的特殊成员</h2><blockquote>
<p>Python Version: 3.5+</p>
</blockquote>
<p><strong>init</strong><br>构造方法，每个对象被实例化出来的时候都将首先去执行<strong>init</strong>方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A:</span><br><span class="line">	def __init__(self):</span><br><span class="line">		print(&quot;在创建对象的时候会首先自动执行__init__&quot;)</span><br><span class="line">&#96;&#96;&#96;        </span><br><span class="line">__del__</span><br><span class="line">析构方法，每个对象在被垃圾回收机制回收之前执行的方法</span><br></pre></td></tr></table></figure>
<p>class A:<br>    def <strong>del</strong>(self):<br>        print(“在对象销毁之前会执行<strong>del</strong>“)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__doc__</span><br><span class="line">类的描述信息</span><br></pre></td></tr></table></figure>
<p>class A:<br>    “””我是A类的描述信息”””<br>    pass</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__module__</span><br><span class="line">表示当前操作的对象在哪个模块</span><br></pre></td></tr></table></figure>
<p>class A:<br>    “””我是A类的描述信息”””<br>    pass</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;&#96;&#96;</span><br><span class="line">from lib import A</span><br><span class="line">a &#x3D; A()</span><br><span class="line">print(a.__module__)</span><br></pre></td></tr></table></figure>
<p><strong>class</strong><br>表示当前操作的对象的类是什么</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A:</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">a &#x3D; A()</span><br><span class="line">print(a.__class__)</span><br></pre></td></tr></table></figure>
<p><strong>call</strong><br>类名后面加括号表示创建一个对象；如果在对象后面加括号，就需要使用<strong>call</strong>方法了，如果不定义这个方法，在执行对象()的时候就会报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A:</span><br><span class="line"></span><br><span class="line">    def __call__(self, *args, **kwargs):</span><br><span class="line">        print(&quot;call&quot;)</span><br><span class="line"></span><br><span class="line">a &#x3D; A()</span><br><span class="line">a()</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">call</span><br></pre></td></tr></table></figure>
<p>创建对象的时候首先执行<strong>init</strong>,在对象被调用的时候执行<strong>call</strong></p>
<p>也可以在一行执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; A()()</span><br></pre></td></tr></table></figure>
<p><strong>str</strong><br>print对象的时候显示的内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A:</span><br><span class="line">	pass</span><br><span class="line"></span><br><span class="line">a &#x3D; A()</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">&lt;__main__.A object at 0x101b77128&gt;</span><br></pre></td></tr></table></figure>
<p>在没有定义<strong>str</strong>的情况下，输出的是a对象的内存地址信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A:</span><br><span class="line">    def __str__(self):</span><br><span class="line">        return &quot;A~&quot;</span><br><span class="line"></span><br><span class="line">a &#x3D; A()</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">A~</span><br></pre></td></tr></table></figure>
<p>str的应用实例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class B:</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name &#x3D; name</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.name</span><br><span class="line"></span><br><span class="line">b &#x3D; B(&quot;ps&quot;)</span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">ps</span><br></pre></td></tr></table></figure>
<p>str类型转换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class B:</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name &#x3D; name</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.name</span><br><span class="line"></span><br><span class="line">b &#x3D; B(&quot;ps&quot;)</span><br><span class="line">ret &#x3D; str(b)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>
<p>str(b)和print()都会自动去调用b对象中的<strong>str</strong>方法</p>
<p><strong>dict</strong><br>对象的dict<br>在对象中默认已经有dict，不需要自定义。该方法用来获取对象中所有封装的对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class B:</span><br><span class="line">    def __init__(self, name, age):</span><br><span class="line">        self.name &#x3D; name</span><br><span class="line">        self.age &#x3D; age</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.name</span><br><span class="line"></span><br><span class="line">b &#x3D; B(&quot;ps&quot;, 26)</span><br><span class="line">print(b.__dict__)</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">&#123;&#39;age&#39;: 26, &#39;name&#39;: &#39;ps&#39;&#125;</span><br></pre></td></tr></table></figure>
<p>类的dict<br>列出类中所有可以调用的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class B:</span><br><span class="line">    def __init__(self, name, age):</span><br><span class="line">        self.name &#x3D; name</span><br><span class="line">        self.age &#x3D; age</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.name</span><br><span class="line"></span><br><span class="line">b &#x3D; B(&quot;ps&quot;, 26)</span><br><span class="line">print(B.__dict__)</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">&#123;&#39;__weakref__&#39;: &lt;attribute &#39;__weakref__&#39; of &#39;B&#39; objects&gt;, &#39;__module__&#39;: &#39;__main__&#39;, &#39;__str__&#39;: &lt;function B.__str__ at 0x10137b730&gt;, &#39;__init__&#39;: &lt;function B.__init__ at 0x10137b6a8&gt;, &#39;__doc__&#39;: None, &#39;__dict__&#39;: &lt;attribute &#39;__dict__&#39; of &#39;B&#39; objects&gt;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>add</strong><br>当执行一个对象 + 一个对象的时候，就会自动去执行这个方法</p>
<p>注意，执行的是第一个对象的add方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A:</span><br><span class="line">    def __init__(self, num):</span><br><span class="line">        self.num &#x3D; num</span><br><span class="line"></span><br><span class="line">    def __add__(self, other):</span><br><span class="line">        return self.num + other.num</span><br><span class="line"></span><br><span class="line">class B:</span><br><span class="line">    def __init__(self, num):</span><br><span class="line">        self.num &#x3D; num        </span><br><span class="line">a &#x3D; A(5)</span><br><span class="line">b &#x3D; B(9)</span><br><span class="line">c &#x3D; a + b</span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure>
<p><strong>getitem</strong> <strong>setitem</strong> <strong>delitem</strong><br>用于索引操作，如字典。以上分别表示获取、设置、删除数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d &#x3D; &#123;&quot;k&quot;: &quot;v&quot;&#125;</span><br><span class="line">print(d[&quot;k&quot;])</span><br><span class="line">d[&quot;k&quot;] &#x3D; &quot;vv&quot;</span><br><span class="line">del d[&quot;k&quot;]</span><br></pre></td></tr></table></figure>
<p>上面的代码展示了一个字典对象的取值、赋值和删除的操作。在自定义的类中，也可以实现类似于字典这样的操作<br>对象后面加小括号是执行<strong>call</strong>方法，那么对象后面加中括号又是怎样处理的呢？</p>
<p>使用key进行的操作<br>取值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class B:</span><br><span class="line">    def __init__(self, name, age):</span><br><span class="line">        self.name &#x3D; name</span><br><span class="line">        self.age &#x3D; age</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.name</span><br><span class="line"></span><br><span class="line">    def __getitem__(self, item):</span><br><span class="line">        print(&quot;执行了getitem方法&quot;, item)</span><br><span class="line"></span><br><span class="line">b &#x3D; B(&quot;ps&quot;, 26)</span><br><span class="line">b[&quot;name&quot;]</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">执行了getitem方法 name</span><br></pre></td></tr></table></figure>
<p>赋值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class B:</span><br><span class="line">    def __init__(self, name, age):</span><br><span class="line">        self.name &#x3D; name</span><br><span class="line">        self.age &#x3D; age</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.name</span><br><span class="line"></span><br><span class="line">    def __getitem__(self, item):</span><br><span class="line">        print(&quot;执行了getitem方法&quot;, item)</span><br><span class="line"></span><br><span class="line">    def __setitem__(self, key, value):</span><br><span class="line">        print(&quot;你要为%s重新赋值为%s&quot; % (key, value))</span><br><span class="line"></span><br><span class="line">b &#x3D; B(&quot;ps&quot;, 26)</span><br><span class="line">print(b.name)</span><br><span class="line">b[&quot;name&quot;] &#x3D; &quot;lr&quot;</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">ps</span><br></pre></td></tr></table></figure>
<p>你要为name重新赋值为lr<br>删除</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class B:</span><br><span class="line">    def __init__(self, name, age):</span><br><span class="line">        self.name &#x3D; name</span><br><span class="line">        self.age &#x3D; age</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.name</span><br><span class="line"></span><br><span class="line">    def __getitem__(self, item):</span><br><span class="line">        print(&quot;执行了getitem方法&quot;, item)</span><br><span class="line"></span><br><span class="line">    def __setitem__(self, key, value):</span><br><span class="line">        print(&quot;你要为%s重新赋值为%s&quot; % (key, value))</span><br><span class="line"></span><br><span class="line">    def __delitem__(self, key):</span><br><span class="line">        print(&quot;你要删除%s&quot; % key)</span><br><span class="line"></span><br><span class="line">b &#x3D; B(&quot;ps&quot;, 26)</span><br><span class="line">del b[&quot;age&quot;]</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">你要删除age</span><br></pre></td></tr></table></figure>
<p>在web开发中，自定义session框架的时候会用到</p>
<p>使用下标进行的操作<br>使用下标和使用key的形式类似，使用key， item接收的是一个字符串，使用下标， item接收的是一个int类型的数字，可以在方法体内通过判断传递过来数据的数据类型来进行对应的操作</p>
<p>使用切片的操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l &#x3D; [1,2,3,4,5,6,7,8,9]</span><br><span class="line">l[1:5:2]</span><br></pre></td></tr></table></figure>
<p>在Python2.x中使用<strong>getslice</strong> <strong>setslice</strong> <strong>delslice</strong>来实现切片的操作，但是Python3.x中被遗弃，所有切片的功能都集中在了<strong>getitem</strong> <strong>setitem</strong> <strong>delitem</strong>中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class B:</span><br><span class="line">    def __init__(self, name, age):</span><br><span class="line">        self.name &#x3D; name</span><br><span class="line">        self.age &#x3D; age</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.name</span><br><span class="line"></span><br><span class="line">    def __getitem__(self, item):</span><br><span class="line">        # print(&quot;执行了getitem方法&quot;, item)</span><br><span class="line">        print(type(item))</span><br><span class="line"></span><br><span class="line">    def __setitem__(self, key, value):</span><br><span class="line">        print(&quot;你要为%s重新赋值为%s&quot; % (key, value))</span><br><span class="line"></span><br><span class="line">    def __delitem__(self, key):</span><br><span class="line">        print(&quot;你要删除%s&quot; % key)</span><br><span class="line"></span><br><span class="line">b &#x3D; B(&quot;ps&quot;, 26)</span><br><span class="line">b[&quot;name&quot;]</span><br><span class="line">b[1]</span><br><span class="line">b[1:5:2]</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">&lt;class &#39;str&#39;&gt;</span><br><span class="line">&lt;class &#39;int&#39;&gt;</span><br><span class="line">&lt;class &#39;slice&#39;&gt;</span><br></pre></td></tr></table></figure>
<p>item为slice时表示调用了切片的操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class B:</span><br><span class="line">    def __init__(self, name, age):</span><br><span class="line">        self.name &#x3D; name</span><br><span class="line">        self.age &#x3D; age</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.name</span><br><span class="line"></span><br><span class="line">    def __getitem__(self, item):</span><br><span class="line">        print(&quot;起点索引&quot;, item.start)</span><br><span class="line">        print(&quot;终点索引&quot;, item.stop)</span><br><span class="line">        print(&quot;步长&quot;, item.step)</span><br><span class="line">        return &quot;haha&quot;</span><br><span class="line"></span><br><span class="line">    def __setitem__(self, key, value):</span><br><span class="line">        print(&quot;你要为%s重新赋值为%s&quot; % (key, value))</span><br><span class="line"></span><br><span class="line">    def __delitem__(self, key):</span><br><span class="line">        print(&quot;你要删除%s&quot; % key)</span><br><span class="line"></span><br><span class="line">b &#x3D; B(&quot;ps&quot;, 26)</span><br><span class="line">ret &#x3D; b[1:5:2]</span><br><span class="line">print(ret)</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">起点索引 1</span><br><span class="line">终点索引 5</span><br><span class="line">步长 2</span><br><span class="line">haha</span><br></pre></td></tr></table></figure>
<p>相对应的，取值可以通过判断item的类型做相应的操作，赋值和删除也可以通过判断key的类型来进行想对应的切片操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class B:</span><br><span class="line">    def __init__(self, name, age):</span><br><span class="line">        self.name &#x3D; name</span><br><span class="line">        self.age &#x3D; age</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.name</span><br><span class="line"></span><br><span class="line">    def __getitem__(self, item):</span><br><span class="line">        print(&quot;起点索引&quot;, item.start)</span><br><span class="line">        print(&quot;终点索引&quot;, item.stop)</span><br><span class="line">        print(&quot;步长&quot;, item.step)</span><br><span class="line">        return &quot;haha&quot;</span><br><span class="line"></span><br><span class="line">    def __setitem__(self, key, value):</span><br><span class="line">        print(&quot;起点索引&quot;, key.start)</span><br><span class="line">        print(&quot;终点索引&quot;, key.stop)</span><br><span class="line">        print(&quot;步长&quot;, key.step)</span><br><span class="line">        print(&quot;新值为&quot;, value)</span><br><span class="line"></span><br><span class="line">    def __delitem__(self, key):</span><br><span class="line">        print(&quot;起点索引&quot;, key.start)</span><br><span class="line">        print(&quot;终点索引&quot;, key.stop)</span><br><span class="line">        print(&quot;步长&quot;, key.step)</span><br><span class="line"></span><br><span class="line">b &#x3D; B(&quot;ps&quot;, 26)</span><br><span class="line">print(&quot;切片取值&quot;)</span><br><span class="line">ret &#x3D; b[1:5:2]</span><br><span class="line"></span><br><span class="line">print(&quot;切片赋值&quot;)</span><br><span class="line">b[1:5:2] &#x3D; &quot;hehe&quot;</span><br><span class="line"></span><br><span class="line">print(&quot;切片删除&quot;)</span><br><span class="line">print(ret)</span><br><span class="line">del b[1:5:2]</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">切片取值</span><br><span class="line">起点索引 1</span><br><span class="line">终点索引 5</span><br><span class="line">步长 2</span><br><span class="line">切片赋值</span><br><span class="line">起点索引 1</span><br><span class="line">终点索引 5</span><br><span class="line">步长 2</span><br><span class="line">新值为 hehe</span><br><span class="line">切片删除</span><br><span class="line">haha</span><br><span class="line">起点索引 1</span><br><span class="line">终点索引 5</span><br><span class="line">步长 2</span><br></pre></td></tr></table></figure>
<p><strong>iter</strong><br>一个自定义类实例化的对象，默认是不可迭代的，在类中使用<strong>iter</strong>方法后，对象就变成了可迭代对象。当对象被迭代时，会自动调用iter方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A:</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">a &#x3D; A()</span><br><span class="line">for i in a:</span><br><span class="line">    print(i)</span><br><span class="line">    </span><br><span class="line">------------</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&#x2F;Users&#x2F;lvrui&#x2F;PycharmProjects&#x2F;untitled&#x2F;8&#x2F;c8.py&quot;, line 5, in &lt;module&gt;</span><br><span class="line">    for i in a:</span><br><span class="line">TypeError: &#39;A&#39; object is not iterable</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A:</span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return iter([1, 2])  # return了一个可迭代对象</span><br><span class="line"></span><br><span class="line">a &#x3D; A()</span><br><span class="line">for i in a:</span><br><span class="line">    print(i)</span><br><span class="line">    </span><br><span class="line">------------</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A:</span><br><span class="line">    def __iter__(self):  # 返回了一个生成器</span><br><span class="line">        yield 1</span><br><span class="line">        yield 2</span><br><span class="line"></span><br><span class="line">a &#x3D; A()</span><br><span class="line">for i in a:</span><br><span class="line">    print(i)</span><br><span class="line">    </span><br><span class="line">------------</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>先去a对象中找到iter方法执行，并拿到返回值进行迭代</p>
<p><strong>new</strong> <strong>metaclass</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A(object):</span><br><span class="line"> </span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass     </span><br><span class="line"></span><br><span class="line">a &#x3D; A()   # a是通过A类实例化的对象</span><br></pre></td></tr></table></figure>
<p>上述代码中，a 是通过 A 类实例化的对象，其实，不仅 a 是一个对象，A类本身也是一个对象，因为在Python中一切事物都是对象。</p>
<p>如果按照一切事物都是对象的理论：a对象是通过执行A类的构造方法创建，那么A类对象应该也是通过执行某个类的构造方法创建。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print type(a) # 输出：&lt;class &#39;__main__.A&#39;&gt;     表示，a对象由A类创建</span><br><span class="line">print type(A) # 输出：&lt;type &#39;type&#39;&gt;              表示，A类对象由type类创建</span><br></pre></td></tr></table></figure>
<p>所以，a对象是A类的一个实例，A类对象是type类的一个实例，即：A类对象是通过type类的构造方法创建</p>
<p>那么，创建类就可以有两种方式：</p>
<ul>
<li>普通方式<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A(object):</span><br><span class="line"> </span><br><span class="line">    def func(self):</span><br><span class="line">        print(&quot;ps&quot;)</span><br><span class="line">&#96;&#96;&#96;        </span><br><span class="line">- 特殊方式（type类的构造函数）</span><br></pre></td></tr></table></figure>
def func(self):<br>  print(“ps”)</li>
</ul>
<p>A = type(‘A’,(object,), {‘func’: func})<br>#type第一个参数：类名<br>#type第二个参数：当前类的基类<br>#type第三个参数：类的成员</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">–&gt; 类是由type类实例化产生</span><br><span class="line"></span><br><span class="line">那么问题来了，类默认是由 type 类实例化产生，type类中如何实现的创建类？类又是如何创建对象？</span><br><span class="line"></span><br><span class="line">答：类中有一个属性__metaclass__ 其用来表示该类由谁来实例化创建，所以，我们可以为__metaclass__设置一个type类的派生类，从而查看类创建的过程:</span><br><span class="line">![类创建的过程](https:&#x2F;&#x2F;note.youdao.com&#x2F;yws&#x2F;api&#x2F;personal&#x2F;file&#x2F;WEB469fc5ed373325db33598c76c5c2e865?method&#x3D;download&amp;shareKey&#x3D;387854780b812acd0ae47ca87a1d2b69)</span><br></pre></td></tr></table></figure>
<p>class MyType(type):</p>
<pre><code>def __init__(self, what, bases=None, dict=None):
    super(MyType, self).__init__(what, bases, dict)

def __call__(self, *args, **kwargs):
    obj = self.__new__(self, *args, **kwargs)

    self.__init__(obj)</code></pre><p>class A(object):</p>
<pre><code>__metaclass__ = MyType

def __init__(self, name):
    self.name = name

def __new__(cls, *args, **kwargs):
    return object.__new__(cls, *args, **kwargs)</code></pre><h1 id="第一阶段：解释器从上到下执行代码创建A类"><a href="#第一阶段：解释器从上到下执行代码创建A类" class="headerlink" title="第一阶段：解释器从上到下执行代码创建A类"></a>第一阶段：解释器从上到下执行代码创建A类</h1><h1 id="第二阶段：通过A类创建a对象"><a href="#第二阶段：通过A类创建a对象" class="headerlink" title="第二阶段：通过A类创建a对象"></a>第二阶段：通过A类创建a对象</h1><p>a = A()</p>
<pre><code>
[原文地址](https://docs.lvrui.io/2016/07/03/Python%E7%B1%BB%E4%B8%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98/)  


</code></pre>]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>PYTHON</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ-2使用</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h1 id="RabbitMQ-2"><a href="#RabbitMQ-2" class="headerlink" title="RabbitMQ-2"></a>RabbitMQ-2</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>RabbitMQ：接受消息再传递消息，可以视为一个”邮局”。发送者和接受者通过队列来进行交互，队列的大小可以视为无限的，多个发送者可以发生给一个队列，多个接收者也可以从一个队列中接受消息。</p>
<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><p>rabbitmq使用的协议是amqp，用于python的推荐客户端是pika</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install pika -i https:&#x2F;&#x2F;pypi.douban.com&#x2F;simple&#x2F;</span><br></pre></td></tr></table></figure>
<p>生产者：send.py</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pika     # 建立一个连接</span><br><span class="line">connection &#x3D; pika.BlockingConnection(pika.ConnectionParameters( &#39;localhost&#39;))  # 连接本地的RabbitMQ服务器</span><br><span class="line">channel &#x3D; connection.channel()      # 获得channel</span><br></pre></td></tr></table></figure>
<p>这里链接的是本机的，如果想要连接其他机器上的服务器，只要填入地址或主机名即可。<br>接下来我们开始发送消息了，注意要确保接受消息的队列是存在的，否则rabbitmq就丢弃掉该消息.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">channel.queue_declare(queue&#x3D;&#39;hello&#39;)    # 在RabbitMQ中创建hello这个队列</span><br><span class="line">channel.basic_publish(exchange&#x3D;&#39;&#39;,      # 使用默认的exchange来发送消息到队列</span><br><span class="line">                  routing_key&#x3D;&#39;hello&#39;,  # 发送到该队列 hello 中</span><br><span class="line">                  body&#x3D;&#39;Hello World!&#39;)  # 消息内容</span><br><span class="line"> connection.close() # 关闭 同时flush</span><br></pre></td></tr></table></figure>
<p>RabbitMQ默认需要1GB的空闲磁盘空间，否则发送会失败。<br>这时已在本地队列hello中存放了一个消息，如果使用 rabbitmqctl list_queues 可看到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello 1</span><br></pre></td></tr></table></figure>
<p>说明有一个hello队列 里面存放了一个消息<br>消费者：receive.py</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pika</span><br><span class="line">connection &#x3D; pika.BlockingConnection(pika.ConnectionParameters( &#39;localhost&#39;))</span><br><span class="line">channel &#x3D; connection.channel()</span><br></pre></td></tr></table></figure>
<p>还是先链接到服务器，和之前发送时相同</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">channel.queue_declare(queue&#x3D;&#39;hello&#39;)  # 此处就是声明了 来确保该队列 hello 存在 可以多次声明 这里主要是为了防止接受程序先运行时出错</span><br><span class="line"></span><br><span class="line">def callback(ch, method, properties, body):  # 用于接收到消息后的回调</span><br><span class="line">    print(&quot; [x] Received %r&quot; % body)</span><br><span class="line"></span><br><span class="line">channel.basic_consume(callback,</span><br><span class="line">                      queue&#x3D;&#39;hello&#39;,  # 收指定队列hello的消息</span><br><span class="line">                      no_ack&#x3D;True)  #在处理完消息后不发送ack给服务器</span><br><span class="line">channel.start_consuming()  # 启动消息接受 这会进入一个死循环</span><br></pre></td></tr></table></figure>
<h2 id="工作队列-任务队列"><a href="#工作队列-任务队列" class="headerlink" title="工作队列(任务队列)"></a>工作队列(任务队列)</h2><p>工作队列是用于分发耗时任务给多个工作进程的。不立即做那些耗费资源的任务（需要等待这些任务完成），而是安排这些任务之后执行。例如我们把task作为message发送到队列里，启动工作进程来接受并最终执行，且可启动多个工作进程来工作。这适用于web应用，即不应在一个http请求的处理窗口内完成复杂任务。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">routing_key&#x3D;&#39;task_queue&#39;,</span><br><span class="line">                 body&#x3D;message,</span><br><span class="line">                 properties&#x3D;pika.BasicProperties(</span><br><span class="line">                    delivery_mode &#x3D; 2, # 使得消息持久化</span><br><span class="line">                 ))</span><br></pre></td></tr></table></figure>
<p>分配消息的方式为 轮询 即每个工作进程获得相同的消息数。</p>
<h2 id="消息ack"><a href="#消息ack" class="headerlink" title="消息ack"></a>消息ack</h2><p>如果消息分配给某个工作进程，但是该工作进程未处理完成就崩溃了，可能该消息就丢失了，因为rabbitmq一旦把一个消息分发给工作进程，它就把该消息删掉了。<br>为了预防消息丢失，rabbitmq提供了ack，即工作进程在收到消息并处理后，发送ack给rabbitmq，告知rabbitmq这时候可以把该消息从队列中删除了。如果工作进程挂掉了，rabbitmq没有收到ack，那么会把该消息 重新分发给其他工作进程。不需要设置timeout，即使该任务需要很长时间也可以处理。<br>ack默认是开启的，之前我们的工作进程显示指定了<code>no_ack=True</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">channel.basic_consume(callback, queue&#x3D;&#39;hello&#39;)  # 会启用ack</span><br></pre></td></tr></table></figure>
<p>带ack的callback:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def callback(ch, method, properties, body): </span><br><span class="line">    print &quot; [x] Received %r&quot; % (body,)</span><br><span class="line">    time.sleep( body.count(&#39;.&#39;) )</span><br><span class="line">    print &quot; [x] Done&quot;</span><br><span class="line">    ch.basic_ack(delivery_tag &#x3D; method.delivery_tag)  # 发送ack</span><br></pre></td></tr></table></figure>
<h2 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h2><p>但是，有时RabbitMQ重启了，消息也会丢失。可在创建队列时设置持久化：<br>(队列的性质一旦确定无法改变）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">channel.queue_declare(queue&#x3D;&#39;task_queue&#39;, durable&#x3D;True)</span><br></pre></td></tr></table></figure>
<p>同时在发送消息时也得设置该消息的持久化属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">channel.basic_publish(exchange&#x3D;&#39;&#39;,</span><br><span class="line">routing_key&#x3D;&quot;task_queue&quot;,</span><br><span class="line">body&#x3D;message,</span><br><span class="line">properties&#x3D;pika.BasicProperties(</span><br><span class="line">delivery_mode &#x3D; 2, # make message persistent</span><br><span class="line">))</span><br></pre></td></tr></table></figure>
<p>但是，如果在RabbitMQ刚接收到消息还没来得及存储，消息还是会丢失。同时，RabbitMQ也不是在接受到每个消息都进行存盘操作。如果还需要更完善的保证，需要使用publisher confirm。</p>
<h2 id="公平的消息分发"><a href="#公平的消息分发" class="headerlink" title="公平的消息分发"></a>公平的消息分发</h2><p>轮询模式的消息分发可能并不公平，例如奇数的消息都是繁重任务的话，某些进程则会一直运行繁 重任务。即使某工作进程上有积压的消息未处理，如很多都没发ack，但是RabbitMQ还是会按照顺序发消息给它。可以在接受进程中加设置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">channel.basic_qos(prefetch_count&#x3D;1)</span><br></pre></td></tr></table></figure>
<p>告知RabbitMQ，这样在一个工作进程没回发ack情况下是不会再分配消息给它。</p>
<h2 id="群发"><a href="#群发" class="headerlink" title="群发"></a>群发</h2><p>一般情况下，一条消息是发送给一个工作进程，然后完成，有时想把一条消息同时发送给多个进程：</p>
<h3 id="exchange"><a href="#exchange" class="headerlink" title="exchange"></a>exchange</h3><p>发送者是不是直接发送消息到队列中的，事实上发生者根本不知道消息会发送到那个队列，发送者只能把消息发送到exchange里。exchange一方面收生产者的消息，另一方面把他们推送到队列中。所以作为exchange，它需要知道当收到消息时它需要做什么，是应该把它加到一个特殊的队列中还是放到很多的队列中，或者丢弃。exchange有direct、topic、headers、fanout等种类，而群发使用的即fanout。之前在发布消息时，exchange的值为 ‘’ 即使用default exchange。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">channel.exchange_declare(exchange&#x3D;&#39;logs&#39;, type&#x3D;&#39;fanout&#39;)  # 该exchange会把消息发送给所有它知道的队列中</span><br></pre></td></tr></table></figure>
<h3 id="临时队列"><a href="#临时队列" class="headerlink" title="临时队列"></a>临时队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">result &#x3D; channel.queue_declare()  # 创建一个随机队列</span><br><span class="line">result &#x3D; channel.queue_declare(exclusive&#x3D;True)  # 创建一个随机队列，同时在没有接收者连接该队列后则销毁它</span><br><span class="line">queue_name &#x3D; result.method.queue</span><br></pre></td></tr></table></figure>
<p>这样result.method.queue即是队列名称，在发送或接受时即可使用。</p>
<h3 id="绑定exchange和队列"><a href="#绑定exchange和队列" class="headerlink" title="绑定exchange和队列"></a>绑定exchange和队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">channel.queue_bind(exchange&#x3D;&#39;logs&#39;,</span><br><span class="line">               queue&#x3D;&#39;hello&#39;)</span><br></pre></td></tr></table></figure>
<p>logs在发送消息时给hello也发一份。<br>在发送消息时使用刚刚创建的logs exchange</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">channel.basic_publish(exchange&#x3D;&#39;logs&#39;,</span><br><span class="line">                  routing_key&#x3D;&#39;&#39;,</span><br><span class="line">                  body&#x3D;message)</span><br></pre></td></tr></table></figure>
<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>之前已经使用过bind，即建立exchange和queue的关系(该队列对来自该exchange的消息有兴趣)bind时可另外指定routing_key选项。</p>
<h2 id="使用direct-exchange"><a href="#使用direct-exchange" class="headerlink" title="使用direct exchange"></a>使用direct exchange</h2><p>将对应routing key的消息发送到绑定相同routing key的队列中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">channel.exchange_declare(exchange&#x3D;&#39;direct_logs&#39;,</span><br><span class="line">                     type&#x3D;&#39;direct&#39;)</span><br></pre></td></tr></table></figure>
<p>发送函数，发布不同severity的消息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">channel.basic_publish(exchange&#x3D;&#39;direct_logs&#39;,</span><br><span class="line">                  routing_key&#x3D;severity,</span><br><span class="line">                  body&#x3D;message)</span><br></pre></td></tr></table></figure>
<h2 id="使用topic-exchange"><a href="#使用topic-exchange" class="headerlink" title="使用topic exchange"></a>使用topic exchange</h2><p>之前使用的direct exchange 只能绑定一个routing key，可以使用这种可以拿.隔开routing key的topic exchange，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;stock.usd.nyse&quot; &quot;nyse.vmw&quot;</span><br></pre></td></tr></table></figure>
<p>和direct exchange一样，在接受者那边绑定的key与发送时指定的routing key相同即可，另外有些特殊的值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 代表1个单词</span><br><span class="line">* # 代表0个或多个单词</span><br></pre></td></tr></table></figure>
<p>如果发送者发出的routing key都是3个部分的，如：celerity.colour.species。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Q1: *.orange.* 对应的是中间的colour都为orange的</span><br><span class="line">Q2: *.*.rabbit  对应的是最后部分的species为rabbit的</span><br><span class="line">lazy.# 对应的是第一部分是lazy的</span><br></pre></td></tr></table></figure>
<p>qucik.orange.rabbit Q1 Q2都可接收到，quick.orange.fox 只有Q1能接受到，对于lazy.pink.rabbit虽然匹配到了Q2两次，但是只会发送一次。如果绑定时直接绑定#，则会收到所有的。</p>
<h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p>在远程机器上运行一个函数然后获得结果。</p>
<h3 id="１-客户端启动-同时设置一个临时队列用于接受回调，绑定该队列"><a href="#１-客户端启动-同时设置一个临时队列用于接受回调，绑定该队列" class="headerlink" title="１.客户端启动　同时设置一个临时队列用于接受回调，绑定该队列"></a>１.客户端启动　同时设置一个临时队列用于接受回调，绑定该队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">self.connection &#x3D; pika.BlockingConnection(pika.ConnectionParameters(</span><br><span class="line">            host&#x3D;&#39;localhost&#39;))</span><br><span class="line">    self.channel &#x3D; self.connection.channel()</span><br><span class="line">    result &#x3D; self.channel.queue_declare(exclusive&#x3D;True)</span><br><span class="line">    self.callback_queue &#x3D; result.method.queue</span><br><span class="line">    self.channel.basic_consume(self.on_response, no_ack&#x3D;True,</span><br><span class="line">                               queue&#x3D;self.callback_queue)</span><br></pre></td></tr></table></figure>
<h3 id="２-客户端发送rpc请求，同时附带reply-to对应回调队列，correlation-id设置为每个请求的唯一id（虽然说可以为每一次RPC请求都创建一个回调队列，但是这样效率不高，如果一个客户端只使用一个队列，则需要使用correlation-id来匹配是哪个请求），之后阻塞在回调队列直到收到回复"><a href="#２-客户端发送rpc请求，同时附带reply-to对应回调队列，correlation-id设置为每个请求的唯一id（虽然说可以为每一次RPC请求都创建一个回调队列，但是这样效率不高，如果一个客户端只使用一个队列，则需要使用correlation-id来匹配是哪个请求），之后阻塞在回调队列直到收到回复" class="headerlink" title="２.客户端发送rpc请求，同时附带reply_to对应回调队列，correlation_id设置为每个请求的唯一id（虽然说可以为每一次RPC请求都创建一个回调队列，但是这样效率不高，如果一个客户端只使用一个队列，则需要使用correlation_id来匹配是哪个请求），之后阻塞在回调队列直到收到回复"></a>２.客户端发送rpc请求，同时附带reply_to对应回调队列，correlation_id设置为每个请求的唯一id（虽然说可以为每一次RPC请求都创建一个回调队列，但是这样效率不高，如果一个客户端只使用一个队列，则需要使用correlation_id来匹配是哪个请求），之后阻塞在回调队列直到收到回复</h3><p>注意: 如果收到了非法的correlation_id直接丢弃即可，因为有这种情况–服务器已经发了响应但是还没发ack就挂了，等一会服务器重启了又会重新处理该任务，又发了一遍相应，但是这时那个请求已经被处理掉了.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">channel.basic_publish(exchange&#x3D;&#39;&#39;,</span><br><span class="line">                       routing_key&#x3D;&#39;rpc_queue&#39;,</span><br><span class="line">                       properties&#x3D;pika.BasicProperties(</span><br><span class="line">                             reply_to &#x3D; self.callback_queue,</span><br><span class="line">                             correlation_id &#x3D; self.corr_id,</span><br><span class="line">                             ),</span><br><span class="line">                       body&#x3D;str(n))  # 发出调用</span><br><span class="line"></span><br><span class="line">while self.response is None:  # 这边就相当于阻塞了</span><br><span class="line">    self.connection.process_data_events()  # 查看回调队列</span><br><span class="line">return int(self.response)</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>请求会发送到rpc_queue队列  </li>
<li>RPC服务器从rpc_queue中取出，执行，发送回复<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">channel.basic_consume(on_request, queue&#x3D;&#39;rpc_queue&#39;)  # 绑定 等待请求</span><br><span class="line"></span><br><span class="line"># 处理之后：</span><br><span class="line">ch.basic_publish(exchange&#x3D;&#39;&#39;,</span><br><span class="line">                 routing_key&#x3D;props.reply_to,</span><br><span class="line">                 properties&#x3D;pika.BasicProperties(correlation_id &#x3D; \</span><br><span class="line">                                                     props.correlation_id),</span><br><span class="line">                 body&#x3D;str(response))  # 发送回复到回调队列</span><br><span class="line">ch.basic_ack(delivery_tag &#x3D; method.delivery_tag)  # 发送ack</span><br></pre></td></tr></table></figure></li>
<li>客户端从回调队列中取出数据，检查correlation_id，执行相应操作<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if self.corr_id &#x3D;&#x3D; props.correlation_id:</span><br><span class="line">        self.response &#x3D; body</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><a href="https://www.cnblogs.com/yuanchenqi/articles/8510585.html" target="_blank" rel="noopener">原文地址</a></p>
]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Salt API</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h2 id="Salt-API"><a href="#Salt-API" class="headerlink" title="Salt API"></a>Salt API</h2><blockquote>
<p>使用salt执行原生linux命令</p>
</blockquote>
<ol>
<li><p>安装salt-ssh</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pip install salt-ssh</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用底层API执行shell命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from salt.client.ssh.shell import Shell</span><br><span class="line"></span><br><span class="line">shell &#x3D; Shell(&#123;&quot;_ssh_version&quot;: (4,9)&#125;,&quot;192.168.1.100&quot;,&quot;root&quot;,22,&quot;root123&quot;,timeout&#x3D;60)</span><br><span class="line">result &#x3D; shell.exec_cmd(&quot;df -h&quot;)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>
<h3 id="salt-shell-api"><a href="#salt-shell-api" class="headerlink" title="salt shell api"></a>salt shell api</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from salt.client.ssh.client import SSHClient</span><br><span class="line"></span><br><span class="line">clinet &#x3D; SSHClient()</span><br><span class="line"></span><br><span class="line">ret &#x3D; client.cmd(&quot;*&quot;,&quot;cmd.run&quot;,(&quot;df -h&quot;,),30)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>


</li>
</ol>
]]></content>
      <categories>
        <category>Salt</category>
      </categories>
      <tags>
        <tag>Salt</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ-1使用</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h2 id="一-RabbitMQ-1"><a href="#一-RabbitMQ-1" class="headerlink" title="一. RabbitMQ-1"></a>一. RabbitMQ-1</h2><h3 id="什么叫消息队列"><a href="#什么叫消息队列" class="headerlink" title="什么叫消息队列"></a>什么叫消息队列</h3><p>消息（Message）是指在应用间传送的数据。消息可以非常简单，比如只包含文本字符串，也可以更复杂，可能包含嵌入对象。<br>消息队列（Message Queue）是一种应用间的通信方式，消息发送后可以立即返回，由消息系统来确保消息的可靠传递。消息发布者只管把消息发布到 MQ 中而不用管谁来取，消息使用者只管从 MQ 中取消息而不管是谁发布的。这样发布者和使用者都不用知道对方的存在。</p>
<h3 id="为何使用消息队列"><a href="#为何使用消息队列" class="headerlink" title="为何使用消息队列"></a>为何使用消息队列</h3><p>从上面的描述中可以看出消息队列是一种应用间的异步协作机制，那什么时候需要使用 MQ 呢?<br>以常见的订单系统为例，用户点击【下单】按钮之后的业务逻辑可能包括：扣减库存、生成相应单据、发红包、发短信通知。在业务发展初期这些逻辑可能放在一起同步执行，随着业务的发展订单量增长，需要提升系统服务的性能，这时可以将一些不需要立即生效的操作拆分出来异步执行，比如发放红包、发短信通知等。这种场景下就可以用 MQ ，在下单的主流程（比如扣减库存、生成相应单据）完成之后发送一条消息到 MQ 让主流程快速完结，而由另外的单独线程拉取MQ的消息（或者由 MQ 推送消息），当发现 MQ 中有发红包或发短信之类的消息时，执行相应的业务逻辑。<br><a href="https://blog.csdn.net/whoamiyang/article/details/54954780" target="_blank" rel="noopener">详细</a></p>
<h3 id="RabbitMQ介绍"><a href="#RabbitMQ介绍" class="headerlink" title="RabbitMQ介绍"></a>RabbitMQ介绍</h3><p>RabbitMQ 是一个由 Erlang 语言开发的 AMQP 的开源实现。<br>rabbitMQ是一款基于AMQP协议的消息中间件，它能够在应用之间提供可靠的消息传输。在易用性，扩展性，高可用性上表现优秀。使用消息中间件利于应用之间的解耦，生产者（客户端）无需知道消费者（服务端）的存在。而且两端可以使用不同的语言编写，大大提供了灵活性。<br><a href="https://www.rabbitmq.com/tutorials/tutorial-one-python.html" target="_blank" rel="noopener">中文文档</a></p>
<h2 id="二-rabbitMQ安装"><a href="#二-rabbitMQ安装" class="headerlink" title="二. rabbitMQ安装"></a>二. rabbitMQ安装</h2><h3 id="2-1-Linux"><a href="#2-1-Linux" class="headerlink" title="2.1 Linux"></a>2.1 Linux</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">安装配置epel源</span><br><span class="line">   $ rpm -ivh http:&#x2F;&#x2F;dl.fedoraproject.org&#x2F;pub&#x2F;epel&#x2F;6&#x2F;i386&#x2F;epel-release-6-8.noarch.rpm</span><br><span class="line"> </span><br><span class="line">安装erlang</span><br><span class="line">   $ yum -y install erlang</span><br><span class="line"> </span><br><span class="line">安装RabbitMQ</span><br><span class="line">   $ yum -y install rabbitmq-server</span><br><span class="line">注意：service rabbitmq-server start&#x2F;stop</span><br></pre></td></tr></table></figure>
<h3 id="2-2-Mac"><a href="#2-2-Mac" class="headerlink" title="2.2 Mac"></a>2.2 Mac</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># brew install rabbitmq</span><br><span class="line"># export PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;sbin</span><br><span class="line"># rabbitmq-server</span><br></pre></td></tr></table></figure>
<h3 id="2-2-rabbitMQ工作模型"><a href="#2-2-rabbitMQ工作模型" class="headerlink" title="2.2 rabbitMQ工作模型"></a>2.2 rabbitMQ工作模型</h3><h4 id="2-2-1-简单模式"><a href="#2-2-1-简单模式" class="headerlink" title="2.2.1 简单模式"></a>2.2.1 简单模式</h4><p>示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ######################### 生产者 #########################</span><br><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line">import pika</span><br><span class="line">connection &#x3D; pika.BlockingConnection(pika.ConnectionParameters( host&#x3D;&#39;localhost&#39;))</span><br><span class="line"></span><br><span class="line">channel &#x3D; connection.channel()</span><br><span class="line"></span><br><span class="line">channel.queue_declare(queue&#x3D;&#39;hello&#39;)</span><br><span class="line"></span><br><span class="line">channel.basic_publish(exchange&#x3D;&#39;&#39;,</span><br><span class="line">                      routing_key&#x3D;&#39;hello&#39;,</span><br><span class="line">                      body&#x3D;&#39;Hello World!&#39;)</span><br><span class="line"></span><br><span class="line">print(&quot; [x] Sent &#39;Hello World!&#39;&quot;)</span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ########################## 消费者 ##########################</span><br><span class="line"> </span><br><span class="line">connection &#x3D; pika.BlockingConnection(pika.ConnectionParameters(host&#x3D;&#39;localhost&#39;))</span><br><span class="line">channel &#x3D; connection.channel()</span><br><span class="line"> </span><br><span class="line">channel.queue_declare(queue&#x3D;&#39;hello&#39;)</span><br><span class="line"> </span><br><span class="line">def callback(ch, method, properties, body):</span><br><span class="line">    print(&quot; [x] Received %r&quot; % body)</span><br><span class="line"> </span><br><span class="line"># 需要producer确认之后在删除消息内容的时候需要将no_ack置为False </span><br><span class="line">channel.basic_consume( callback,</span><br><span class="line">                       queue&#x3D;&#39;hello&#39;,</span><br><span class="line">                       no_ack&#x3D;True)</span><br><span class="line"> </span><br><span class="line">print(&#39; [*] Waiting for messages. To exit press CTRL+C&#39;)</span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure>
<h3 id="相关参数说明"><a href="#相关参数说明" class="headerlink" title="相关参数说明"></a>相关参数说明</h3><blockquote>
<p>no-ack ＝ False，如果消费者遇到情况(its channel is closed, connection is closed, or TCP connection is lost)挂掉了，那么，RabbitMQ会重新将该任务添加到队列中。</p>
</blockquote>
<ul>
<li>回调函数中的<code>ch.basic_ack(delivery_tag=method.delivery_tag)</code></li>
<li>basic_comsume中的<code>no_ack=False</code></li>
</ul>
<ol>
<li>消息接收端应该这么写<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pika</span><br><span class="line"></span><br><span class="line">connection &#x3D; pika.BlockingConnection(pika.ConnectionParameters(</span><br><span class="line">        host&#x3D;&#39;10.211.55.4&#39;))</span><br><span class="line">channel &#x3D; connection.channel()</span><br><span class="line"></span><br><span class="line">channel.queue_declare(queue&#x3D;&#39;hello&#39;)</span><br><span class="line"></span><br><span class="line">def callback(ch, method, properties, body):</span><br><span class="line">    print(&quot; [x] Received %r&quot; % body)</span><br><span class="line">    import time</span><br><span class="line">    time.sleep(10)</span><br><span class="line">    print &#39;ok&#39;</span><br><span class="line">    ch.basic_ack(delivery_tag &#x3D; method.delivery_tag)</span><br><span class="line"></span><br><span class="line">channel.basic_consume(callback,</span><br><span class="line">                      queue&#x3D;&#39;hello&#39;,</span><br><span class="line">                      no_ack&#x3D;False)</span><br><span class="line"></span><br><span class="line">print(&#39; [*] Waiting for messages. To exit press CTRL+C&#39;)</span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure></li>
<li>durable:消息不丢失<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 生产者</span><br><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line">import pika</span><br><span class="line"></span><br><span class="line">connection &#x3D; pika.BlockingConnection(pika.ConnectionParameters(host&#x3D;&#39;10.211.55.4&#39;))</span><br><span class="line">channel &#x3D; connection.channel()</span><br><span class="line"></span><br><span class="line"># make message persistent</span><br><span class="line">channel.queue_declare(queue&#x3D;&#39;hello&#39;, durable&#x3D;True)</span><br><span class="line"></span><br><span class="line">channel.basic_publish(exchange&#x3D;&#39;&#39;,</span><br><span class="line">                      routing_key&#x3D;&#39;hello&#39;,</span><br><span class="line">                      body&#x3D;&#39;Hello World!&#39;,</span><br><span class="line">                      properties&#x3D;pika.BasicProperties(</span><br><span class="line">                          delivery_mode&#x3D;2, # make message persistent</span><br><span class="line">                      ))</span><br><span class="line">print(&quot; [x] Sent &#39;Hello World!&#39;&quot;)</span><br><span class="line">connection.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 消费者</span><br><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">import pika</span><br><span class="line"></span><br><span class="line">connection &#x3D; pika.BlockingConnection(pika.ConnectionParameters(host&#x3D;&#39;10.211.55.4&#39;))</span><br><span class="line">channel &#x3D; connection.channel()</span><br><span class="line"></span><br><span class="line"># make message persistent</span><br><span class="line">channel.queue_declare(queue&#x3D;&#39;hello&#39;, durable&#x3D;True)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def callback(ch, method, properties, body):</span><br><span class="line">    print(&quot; [x] Received %r&quot; % body)</span><br><span class="line">    import time</span><br><span class="line">    time.sleep(10)</span><br><span class="line">    print &#39;ok&#39;</span><br><span class="line">    ch.basic_ack(delivery_tag &#x3D; method.delivery_tag)</span><br><span class="line"></span><br><span class="line">channel.basic_consume(callback,</span><br><span class="line">                      queue&#x3D;&#39;hello&#39;,</span><br><span class="line">                      no_ack&#x3D;False)</span><br><span class="line"></span><br><span class="line">print(&#39; [*] Waiting for messages. To exit press CTRL+C&#39;)</span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure></li>
<li>消息获取顺序<br>默认消息队列里的数据是按照顺序被消费者拿走，例如：消费者1 去队列中获取 奇数 序列的任务，消费者1去队列中获取 偶数 序列的任务。<br>channel.basic_qos(prefetch_count=1) 表示谁来谁获取消费就分发给消费者，不再按照奇偶数排列<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">import pika</span><br><span class="line"></span><br><span class="line">connection &#x3D; pika.BlockingConnection(pika.ConnectionParameters(host&#x3D;&#39;10.211.55.4&#39;))</span><br><span class="line">channel &#x3D; connection.channel()</span><br><span class="line"></span><br><span class="line"># make message persistent</span><br><span class="line">channel.queue_declare(queue&#x3D;&#39;hello&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def callback(ch, method, properties, body):</span><br><span class="line">    print(&quot; [x] Received %r&quot; % body)</span><br><span class="line">    import time</span><br><span class="line">    time.sleep(10)</span><br><span class="line">    print &#39;ok&#39;</span><br><span class="line">    ch.basic_ack(delivery_tag &#x3D; method.delivery_tag)</span><br><span class="line"></span><br><span class="line">channel.basic_qos(prefetch_count&#x3D;1)</span><br><span class="line"></span><br><span class="line">channel.basic_consume(callback,</span><br><span class="line">                      queue&#x3D;&#39;hello&#39;,</span><br><span class="line">                      no_ack&#x3D;False)</span><br><span class="line"></span><br><span class="line">print(&#39; [*] Waiting for messages. To exit press CTRL+C&#39;)</span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure>
<h2 id="三-exchange交换机模型"><a href="#三-exchange交换机模型" class="headerlink" title="三. exchange交换机模型"></a>三. exchange交换机模型</h2><h3 id="3-1-发布订阅"><a href="#3-1-发布订阅" class="headerlink" title="3.1 发布订阅"></a>3.1 发布订阅</h3><img src="https://images2015.cnblogs.com/blog/425762/201607/425762-20160717140730998-2143093474.png" alt="模型图"><br>发布订阅和简单的消息队列区别在于，发布订阅会将消息发送给所有的订阅者，而消息队列中的数据被消费一次便消失。所以，RabbitMQ实现发布和订阅时，会为每一个订阅者创建一个队列，而发布者发布消息时，会将消息放置在所有相关队列中。<br>exchange_type = fanout<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 生产者</span><br><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line">import pika</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">connection &#x3D; pika.BlockingConnection(pika.ConnectionParameters(</span><br><span class="line">        host&#x3D;&#39;localhost&#39;))</span><br><span class="line">channel &#x3D; connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange&#x3D;&#39;logs&#39;,</span><br><span class="line">                         exchange_type&#x3D;&#39;fanout&#39;)</span><br><span class="line"></span><br><span class="line">message &#x3D; &#39; &#39;.join(sys.argv[1:]) or &quot;info: Hello World!&quot;</span><br><span class="line">channel.basic_publish(exchange&#x3D;&#39;logs&#39;,</span><br><span class="line">                      routing_key&#x3D;&#39;&#39;,</span><br><span class="line">                      body&#x3D;message)</span><br><span class="line">print(&quot; [x] Sent %r&quot; % message)</span><br><span class="line">connection.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 消费者</span><br><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line">import pika</span><br><span class="line"></span><br><span class="line">connection &#x3D; pika.BlockingConnection(pika.ConnectionParameters(</span><br><span class="line">        host&#x3D;&#39;localhost&#39;))</span><br><span class="line">channel &#x3D; connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange&#x3D;&#39;logs&#39;,</span><br><span class="line">                         exchange_type&#x3D;&#39;fanout&#39;)</span><br><span class="line"></span><br><span class="line">result &#x3D; channel.queue_declare(exclusive&#x3D;True)</span><br><span class="line">queue_name &#x3D; result.method.queue</span><br><span class="line"></span><br><span class="line">channel.queue_bind(exchange&#x3D;&#39;logs&#39;,</span><br><span class="line">                   queue&#x3D;queue_name)</span><br><span class="line"></span><br><span class="line">print(&#39; [*] Waiting for logs. To exit press CTRL+C&#39;)</span><br><span class="line"></span><br><span class="line">def callback(ch, method, properties, body):</span><br><span class="line">    print(&quot; [x] %r&quot; % body)</span><br><span class="line"></span><br><span class="line">channel.basic_consume(callback,</span><br><span class="line">                      queue&#x3D;queue_name,</span><br><span class="line">                      no_ack&#x3D;True)</span><br><span class="line"></span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure>
<h3 id="3-2-关键字发送"><a href="#3-2-关键字发送" class="headerlink" title="3.2 关键字发送"></a>3.2 关键字发送</h3><img src="https://images2015.cnblogs.com/blog/425762/201607/425762-20160717140748795-1181706200.png" alt="模型图"><br>exchange_type = direct<br>之前示例，发送消息时明确指定某个队列并向其中发送消息，RabbitMQ还支持根据关键字发送，即：队列绑定关键字，发送者将数据根据关键字发送到消息exchange，exchange根据 关键字 判定应该将数据发送至指定队列。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line">import pika</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">connection &#x3D; pika.BlockingConnection(pika.ConnectionParameters(</span><br><span class="line">        host&#x3D;&#39;localhost&#39;))</span><br><span class="line">channel &#x3D; connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange&#x3D;&#39;direct_logs&#39;,</span><br><span class="line">                         exchange_type&#x3D;&#39;direct&#39;)</span><br><span class="line"></span><br><span class="line">result &#x3D; channel.queue_declare(exclusive&#x3D;True)</span><br><span class="line">queue_name &#x3D; result.method.queue</span><br><span class="line"></span><br><span class="line">severities &#x3D; sys.argv[1:]</span><br><span class="line">if not severities:</span><br><span class="line">    sys.stderr.write(&quot;Usage: %s [info] [warning] [error]\n&quot; % sys.argv[0])</span><br><span class="line">    sys.exit(1)</span><br><span class="line"></span><br><span class="line">for severity in severities:</span><br><span class="line">    channel.queue_bind(exchange&#x3D;&#39;direct_logs&#39;,</span><br><span class="line">                       queue&#x3D;queue_name,</span><br><span class="line">                       routing_key&#x3D;severity)</span><br><span class="line"></span><br><span class="line">print(&#39; [*] Waiting for logs. To exit press CTRL+C&#39;)</span><br><span class="line"></span><br><span class="line">def callback(ch, method, properties, body):</span><br><span class="line">    print(&quot; [x] %r:%r&quot; % (method.routing_key, body))</span><br><span class="line"></span><br><span class="line">channel.basic_consume(callback,</span><br><span class="line">                      queue&#x3D;queue_name,</span><br><span class="line">                      no_ack&#x3D;True)</span><br><span class="line"></span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure>
<h3 id="3-3-模糊匹配"><a href="#3-3-模糊匹配" class="headerlink" title="3.3 模糊匹配"></a>3.3 模糊匹配</h3><img src="https://images2015.cnblogs.com/blog/425762/201607/425762-20160717140807232-1395723247.png" alt="模型图"><br>exchange_type = topic</li>
</ol>
<p>发送者路由值              队列中<br><a href="http://www.weshuke.python" target="_blank" rel="noopener">www.weshuke.python</a>          old.*  – 不匹配<br>age.weshuke.python          old.#  – 匹配<br>在topic类型下，可以让队列绑定几个模糊的关键字，之后发送者将数据发送到exchange，exchange将传入”路由值“和 ”关键字“进行匹配，匹配成功，则将数据发送到指定队列。</p>
<ul>
<li># 表示可以匹配 0 个 或 多个 单词</li>
<li>*  表示只能匹配 一个 单词<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line">import pika</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">connection &#x3D; pika.BlockingConnection(pika.ConnectionParameters(</span><br><span class="line">        host&#x3D;&#39;localhost&#39;))</span><br><span class="line">channel &#x3D; connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange&#x3D;&#39;topic_logs&#39;,</span><br><span class="line">                         exchange_type&#x3D;&#39;topic&#39;)</span><br><span class="line"></span><br><span class="line">result &#x3D; channel.queue_declare(exclusive&#x3D;True)</span><br><span class="line">queue_name &#x3D; result.method.queue</span><br><span class="line"></span><br><span class="line">binding_keys &#x3D; sys.argv[1:]</span><br><span class="line">if not binding_keys:</span><br><span class="line">    sys.stderr.write(&quot;Usage: %s [binding_key]...\n&quot; % sys.argv[0])</span><br><span class="line">    sys.exit(1)</span><br><span class="line"></span><br><span class="line">for binding_key in binding_keys:</span><br><span class="line">    channel.queue_bind(exchange&#x3D;&#39;topic_logs&#39;,</span><br><span class="line">                       queue&#x3D;queue_name,</span><br><span class="line">                       routing_key&#x3D;binding_key)</span><br><span class="line"></span><br><span class="line">print(&#39; [*] Waiting for logs. To exit press CTRL+C&#39;)</span><br><span class="line"></span><br><span class="line">def callback(ch, method, properties, body):</span><br><span class="line">    print(&quot; [x] %r:%r&quot; % (method.routing_key, body))</span><br><span class="line"></span><br><span class="line">channel.basic_consume(callback,</span><br><span class="line">                      queue&#x3D;queue_name,</span><br><span class="line">                      no_ack&#x3D;True)</span><br><span class="line"></span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure>
<h2 id="基于RabbitMQ的RPC"><a href="#基于RabbitMQ的RPC" class="headerlink" title="基于RabbitMQ的RPC"></a>基于RabbitMQ的RPC</h2><h3 id="Callback-queue-回调队列"><a href="#Callback-queue-回调队列" class="headerlink" title="Callback queue 回调队列"></a>Callback queue 回调队列</h3>一个客户端向服务器发送请求，服务器端处理请求后，将其处理结果保存在一个存储体中。而客户端为了获得处理结果，那么客户在向服务器发送请求时，同时发送一个回调队列地址<code>reply_to</code>。<h3 id="Correlation-id-关联标识"><a href="#Correlation-id-关联标识" class="headerlink" title="Correlation id 关联标识"></a>Correlation id 关联标识</h3>一个客户端可能会发送多个请求给服务器，当服务器处理完后，客户端无法辨别在回调队列中的响应具体和那个请求时对应的。为了处理这种情况，客户端在发送每个请求时，同时会附带一个独有<code>correlation_id</code>属性，这样客户端在回调队列中根据<code>correlation_id</code>字段的值就可以分辨此响应属于哪个请求。</li>
</ul>
<ol>
<li>客户端发送请求：某个应用将请求信息交给客户端，然后客户端发送RPC请求，在发送RPC请求到RPC请求队列时，客户端至少发送带有reply_to以及correlation_id两个属性的信息</li>
<li>服务器端工作流： 等待接受客户端发来RPC请求，当请求出现的时候，服务器从RPC请求队列中取出请求，然后处理后，将响应发送到reply_to指定的回调队列中.</li>
<li>客户端接受处理结果： 客户端等待回调队列中出现响应，当响应出现时，它会根据响应中correlation_id字段的值，将其返回给对应的应用.</li>
</ol>
<h3 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line">import pika</span><br><span class="line"></span><br><span class="line"># 建立连接，服务器地址为localhost，可指定ip地址</span><br><span class="line">connection &#x3D; pika.BlockingConnection(pika.ConnectionParameters(</span><br><span class="line">        host&#x3D;&#39;localhost&#39;))</span><br><span class="line"></span><br><span class="line"># 建立会话</span><br><span class="line">channel &#x3D; connection.channel()</span><br><span class="line"></span><br><span class="line"># 声明RPC请求队列</span><br><span class="line">channel.queue_declare(queue&#x3D;&#39;rpc_queue&#39;)</span><br><span class="line"></span><br><span class="line"># 数据处理方法</span><br><span class="line">def fib(n):</span><br><span class="line">    if n &#x3D;&#x3D; 0:</span><br><span class="line">        return 0</span><br><span class="line">    elif n &#x3D;&#x3D; 1:</span><br><span class="line">        return 1</span><br><span class="line">    else:</span><br><span class="line">        return fib(n-1) + fib(n-2)</span><br><span class="line"></span><br><span class="line"># 对RPC请求队列中的请求进行处理</span><br><span class="line">def on_request(ch, method, props, body):</span><br><span class="line">    n &#x3D; int(body)</span><br><span class="line"></span><br><span class="line">    print(&quot; [.] fib(%s)&quot; % n)</span><br><span class="line"></span><br><span class="line">    # 调用数据处理方法</span><br><span class="line">    response &#x3D; fib(n)</span><br><span class="line"></span><br><span class="line">    # 将处理结果(响应)发送到回调队列</span><br><span class="line">    ch.basic_publish(exchange&#x3D;&#39;&#39;,</span><br><span class="line">                     routing_key&#x3D;props.reply_to,</span><br><span class="line">                     properties&#x3D;pika.BasicProperties(correlation_id &#x3D; \</span><br><span class="line">                                                         props.correlation_id),</span><br><span class="line">                     body&#x3D;str(response))</span><br><span class="line">    ch.basic_ack(delivery_tag &#x3D; method.delivery_tag)</span><br><span class="line"></span><br><span class="line"># 负载均衡，同一时刻发送给该服务器的请求不超过一个</span><br><span class="line">channel.basic_qos(prefetch_count&#x3D;1)</span><br><span class="line"></span><br><span class="line">channel.basic_consume(on_request, queue&#x3D;&#39;rpc_queue&#39;)</span><br><span class="line"></span><br><span class="line">print(&quot; [x] Awaiting RPC requests&quot;)</span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line">import pika</span><br><span class="line">import uuid</span><br><span class="line"></span><br><span class="line">class FibonacciRpcClient(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        ”“”</span><br><span class="line">        客户端启动时，创建回调队列，会开启会话用于发送RPC请求以及接受响应</span><br><span class="line">        </span><br><span class="line">        “”“</span><br><span class="line">        </span><br><span class="line">        # 建立连接，指定服务器的ip地址</span><br><span class="line">        self.connection &#x3D; pika.BlockingConnection(pika.ConnectionParameters(</span><br><span class="line">                host&#x3D;&#39;localhost&#39;))</span><br><span class="line">                </span><br><span class="line">        # 建立一个会话，每个channel代表一个会话任务</span><br><span class="line">        self.channel &#x3D; self.connection.channel()</span><br><span class="line">        </span><br><span class="line">        # 声明回调队列，再次声明的原因是，服务器和客户端可能先后开启，该声明是幂等的，多次声明，但只生效一次</span><br><span class="line">        result &#x3D; self.channel.queue_declare(exclusive&#x3D;True)</span><br><span class="line">        # 将次队列指定为当前客户端的回调队列</span><br><span class="line">        self.callback_queue &#x3D; result.method.queue</span><br><span class="line">        </span><br><span class="line">        # 客户端订阅回调队列，当回调队列中有响应时，调用&#96;on_response&#96;方法对响应进行处理; </span><br><span class="line">        self.channel.basic_consume(self.on_response, no_ack&#x3D;True,</span><br><span class="line">                                   queue&#x3D;self.callback_queue)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # 对回调队列中的响应进行处理的函数</span><br><span class="line">    def on_response(self, ch, method, props, body):</span><br><span class="line">        if self.corr_id &#x3D;&#x3D; props.correlation_id:</span><br><span class="line">            self.response &#x3D; body</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # 发出RPC请求</span><br><span class="line">    def call(self, n):</span><br><span class="line">    </span><br><span class="line">        # 初始化 response</span><br><span class="line">        self.response &#x3D; None</span><br><span class="line">        </span><br><span class="line">        #生成correlation_id </span><br><span class="line">        self.corr_id &#x3D; str(uuid.uuid4())</span><br><span class="line">        </span><br><span class="line">        # 发送RPC请求内容到RPC请求队列&#96;rpc_queue&#96;，同时发送的还有&#96;reply_to&#96;和&#96;correlation_id&#96;</span><br><span class="line">        self.channel.basic_publish(exchange&#x3D;&#39;&#39;,</span><br><span class="line">                                   routing_key&#x3D;&#39;rpc_queue&#39;,</span><br><span class="line">                                   properties&#x3D;pika.BasicProperties(</span><br><span class="line">                                         reply_to &#x3D; self.callback_queue,</span><br><span class="line">                                         correlation_id &#x3D; self.corr_id,</span><br><span class="line">                                         ),</span><br><span class="line">                                   body&#x3D;str(n))</span><br><span class="line">                                   </span><br><span class="line">        </span><br><span class="line">        while self.response is None:</span><br><span class="line">            self.connection.process_data_events()</span><br><span class="line">        return int(self.response)</span><br><span class="line"></span><br><span class="line"># 建立客户端</span><br><span class="line">fibonacci_rpc &#x3D; FibonacciRpcClient()</span><br><span class="line"></span><br><span class="line"># 发送RPC请求</span><br><span class="line">print(&quot; [x] Requesting fib(30)&quot;)</span><br><span class="line">response &#x3D; fibonacci_rpc.call(30)</span><br><span class="line">print(&quot; [.] Got %r&quot; % response)</span><br></pre></td></tr></table></figure>


<p><a href="http://www.cnblogs.com/yuanchenqi/articles/8507109.html" target="_blank" rel="noopener">原文链接</a></p>
]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>SHELL 获取网卡流量</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h2 id="SHELL-获取网卡流量"><a href="#SHELL-获取网卡流量" class="headerlink" title="SHELL 获取网卡流量"></a>SHELL 获取网卡流量</h2><h3 id="1-版本一"><a href="#1-版本一" class="headerlink" title="1. 版本一"></a>1. 版本一</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">#使用方法</span><br><span class="line">usage()</span><br><span class="line">&#123;</span><br><span class="line">  echo &quot;useage: $0 ethname intervel&quot;</span><br><span class="line">  exit 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#网口配置</span><br><span class="line">if [ $# -gt 1 ];then</span><br><span class="line">  ethname&#x3D;$1</span><br><span class="line">  num&#x3D;&#96;ifconfig|grep $&#123;ethname&#125;|wc -l&#96;</span><br><span class="line">  if [ $num -gt 0 ];then</span><br><span class="line">   ethname&#x3D;$1</span><br><span class="line">  else</span><br><span class="line">    echo &quot;Can&#39;t find $ethname,Please Check&quot;</span><br><span class="line">    exit 1</span><br><span class="line">  fi</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">#时间配置</span><br><span class="line">intervel&#x3D;1</span><br><span class="line">if [ $# -gt 0 ]; then</span><br><span class="line">  interval&#x3D;$2</span><br><span class="line">  test&#x3D;&#96;expr &quot;$interval&quot; \* 0&#96;</span><br><span class="line">  if [ &quot;$test&quot; !&#x3D; &quot;0&quot; ]; then </span><br><span class="line">        echo &quot;Invalid &lt;interval&gt; param &#39;$interval&#39; . It should be a integer number. Usage: $0 ethname intervel&quot;</span><br><span class="line">        exit -1  </span><br><span class="line">  fi</span><br><span class="line">  if [ $interval -lt 1 ]; then</span><br><span class="line">        echo &quot;Invalid &lt;interval&gt; param &#39;$interval&#39; . It should be &gt; 0 (seconds). Usage: $0 ethname intervel&quot;</span><br><span class="line">        exit -1</span><br><span class="line">  fi</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">#函数判断</span><br><span class="line">if [ $# -ne 2 ]</span><br><span class="line">then</span><br><span class="line"> usage</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo &quot;$0 is starting,Device is $1,Intervel is $2&quot;</span><br><span class="line">echo -e &quot;\n&quot;</span><br><span class="line"></span><br><span class="line">typeset Rev old_Rev</span><br><span class="line"></span><br><span class="line">eth&#x3D;$1</span><br><span class="line">intervel&#x3D;$2</span><br><span class="line"></span><br><span class="line">old_Rev&#x3D;&#96;cat &#x2F;proc&#x2F;net&#x2F;dev|grep $eth| awk &#39;&#123;print $1&#125;&#39;| awk -F : &#39;&#123;print $2&#125;&#39;&#96;</span><br><span class="line">old_Send&#x3D;&#96;cat &#x2F;proc&#x2F;net&#x2F;dev|grep $eth|awk &#39;&#123;print $9&#125;&#39;&#96;</span><br><span class="line">#echo &quot;old_Rev is $old_Rev&quot;</span><br><span class="line">#echo &quot;Old_send is $old_Send&quot;</span><br><span class="line"></span><br><span class="line">while true</span><br><span class="line"> do</span><br><span class="line"> sleep $intervel</span><br><span class="line"></span><br><span class="line"> Rev&#x3D;&#96;cat &#x2F;proc&#x2F;net&#x2F;dev|grep $eth|awk &#39;&#123;print $1&#125;&#39;|awk -F : &#39;&#123;print $2&#125;&#39;&#96;</span><br><span class="line"> Send&#x3D;&#96;cat &#x2F;proc&#x2F;net&#x2F;dev|grep $eth|awk &#39;&#123;print $9&#125;&#39;&#96;</span><br><span class="line">#echo &quot;Rev is $Rev&quot;</span><br><span class="line">#echo &quot;Send is $Send&quot;</span><br><span class="line"></span><br><span class="line"> diff_1&#x3D;&#96;awk -v Rev&#x3D;$Rev -v old_Rev&#x3D;$old_Rev -v intervel&#x3D;$intervel &#39;BEGIN&#123;printf &quot;Receive is %6.2f&quot;, ( Rev - old_Rev ) &#x2F; 1024 &#x2F; 1024 &#x2F; intervel * 8&#125;&#39;&#96;</span><br><span class="line"></span><br><span class="line"> diff_2&#x3D;&#96;awk -v Send&#x3D;$Send -v old_Send&#x3D;$old_Send -v intervel&#x3D;$intervel &#39;BEGIN&#123;printf &quot;Send is %6.2f&quot;, ( Send - old_Send ) &#x2F; 1024 &#x2F; 1024 &#x2F; intervel * 8&#125;&#39;&#96; </span><br><span class="line"></span><br><span class="line"> echo &quot;&#96;date +&#39;%Y-%m-%d %H:%M:%S&#39;&#96; Speed: IN $&#123;diff_1&#125; mbps OUT $&#123;diff_2&#125; mbps&quot;</span><br><span class="line"></span><br><span class="line"> old_Rev&#x3D;$Rev</span><br><span class="line"> old_Send&#x3D;$Send</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h3 id="2-版本二"><a href="#2-版本二" class="headerlink" title="2. 版本二"></a>2. 版本二</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">#network</span><br><span class="line">#by rocdk890</span><br><span class="line">while : ; do</span><br><span class="line">      time&#x3D;&#96;date +%m&quot;-&quot;%d&quot; &quot;%k&quot;:&quot;%M&#96;</span><br><span class="line">      day&#x3D;&#96;date +%m&quot;-&quot;%d&#96;</span><br><span class="line">      port&#x3D;&#96;ifconfig |grep em|awk &#39;&#123;print $1&#125;&#39;&#96;</span><br><span class="line">      rx_before&#x3D;&#96;ifconfig $port|sed -n &quot;8&quot;p|awk &#39;&#123;print $2&#125;&#39;|cut -c7-&#96;</span><br><span class="line">      tx_before&#x3D;&#96;ifconfig $port|sed -n &quot;8&quot;p|awk &#39;&#123;print $6&#125;&#39;|cut -c7-&#96;</span><br><span class="line">      sleep 2</span><br><span class="line">      rx_after&#x3D;&#96;ifconfig $port|sed -n &quot;8&quot;p|awk &#39;&#123;print $2&#125;&#39;|cut -c7-&#96;</span><br><span class="line">      tx_after&#x3D;&#96;ifconfig $port|sed -n &quot;8&quot;p|awk &#39;&#123;print $6&#125;&#39;|cut -c7-&#96;</span><br><span class="line">      rx_result&#x3D;$[(rx_after-rx_before)&#x2F;256]</span><br><span class="line">      tx_result&#x3D;$[(tx_after-tx_before)&#x2F;256]</span><br><span class="line">      echo &quot;$time Now_In_Speed: &quot;$rx_result&quot;kbps Now_OUt_Speed: &quot;$tx_result&quot;kbps&quot;</span><br><span class="line">      sleep 2</span><br><span class="line">done</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SHELL</category>
      </categories>
      <tags>
        <tag>SHELL</tag>
      </tags>
  </entry>
  <entry>
    <title>Swagger介绍</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h2 id="Swagger介绍"><a href="#Swagger介绍" class="headerlink" title="Swagger介绍"></a>Swagger介绍</h2><blockquote>
<p>Swagger是一种REST APIs的简单但强大的表示方式，标准的，语言无关，这种表示方式不但人可读，而且机器可读。可以作为REST APIs的交互式文档，也可以作为REST APIs的形式化的接口描述，生成客户端和服务端的代码。<br> <a href="https://swagger.io/" target="_blank" rel="noopener">官网</a><br> <a href="https://github.com/swagger-api/swagger-ui" target="_blank" rel="noopener">GitHub - swagger-api/swagger-ui</a>)<br> <a href="https://github.com/swagger-api/swagger-editor" target="_blank" rel="noopener">GitHub - swagger-api/swagger-editor: Swagger Editor</a><br> <a href="https://github.com/Swagger2Markup/swagger2markup" target="_blank" rel="noopener">GitHub - Swagger2Markup/swagger2markup: Swagger2Markup</a>  </p>
</blockquote>
<h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h3><p>在没有产品经理或者项目经理的情况下，对于前端和后端打交道来说，无非就是对接口的争争吵吵，字段多多少少的事。大多时候前端都喜欢直接使用后端提供的接口，而后端有时候却不知道前端到底要什么数据，就这样，Swagger这样的神器被我找到了，对于Swagger高级的应用，比如集成到IDE中自动生成文档,支持GO/python/Java等多种语言的IDE集成环境!</p>
<h3 id="2-Swagger-UI和Swagger-Editor"><a href="#2-Swagger-UI和Swagger-Editor" class="headerlink" title="2. Swagger UI和Swagger Editor"></a>2. Swagger UI和Swagger Editor</h3><ol>
<li>swagger ui是一个API在线文档生成和测试的利器,目前发现最好用的。</li>
</ol>
<ul>
<li>支持API自动生成同步的在线文档</li>
<li>这些文档可用于项目内部API审核</li>
<li>方便测试人员了解API</li>
<li>这些文档可作为客户产品文档的一部分进行发布</li>
<li>支持API规范生成代码，生成的客户端和服务器端骨架代码可以加速开发和测试速度</li>
</ul>
<ol start="2">
<li>使用Swagger Editor编写API文档</li>
</ol>
<ul>
<li>Swagger Editor上的是基于yaml/JSON的语法</li>
</ul>
<h3 id="3-为什么选择Swagger"><a href="#3-为什么选择Swagger" class="headerlink" title="3. 为什么选择Swagger"></a>3. 为什么选择Swagger</h3><ol>
<li>使用Swagger UI生成的界面比Javadoc生成的界面美观</li>
<li>swagger可以实时同步API文档(代码修改后，文档同步修改)</li>
<li>swagger解析速度快，效率高(使用轻量级数据交换格式JSON)</li>
<li>对现有SpringMVC工程支持友好</li>
<li>Swagger可以充当前后端交流的重要桥梁，方便快捷。很实用。</li>
<li>Swagger项目允许你生产，显示和消费你自己的RESTful服务。不需要代理和第三方服务。是一个依赖自由的资源集合，它能通过Swagger-API动态的生成漂亮的文档和沙盒,因为Swagger-UI没有依赖，你可以把他部署到任何服务器环境或者是你自己的机器</li>
</ol>
<h3 id="4-Swagger组件介绍"><a href="#4-Swagger组件介绍" class="headerlink" title="4. Swagger组件介绍"></a>4. Swagger组件介绍</h3><ol>
<li>部署安装略,可自行在github中查找,建议使用Docker方式安装部署,简单方便;</li>
<li>Swagger生态工具组件较多,本文主要介绍Swagger-Editor以及Swagger-UI的使用,Editor用于生成各语言客户端/服务端的依赖文件,UI部分主要针对客户端工具生成的swagger.json或swagger.yml文件进行接口的查看和接口测试;</li>
<li>Swagger也有支持生成MarkDown文档格式的组件(Swagger2Markup);<br>PS: Swgger UI的站点域名要和发送请求的域名一样,不然浏览器会报跨域错误。</li>
<li>示例Demo<br><a href="http://10.21.26.240:81/" target="_blank" rel="noopener">Swagger Editor</a><br><a href="http://10.21.26.240" target="_blank" rel="noopener">Swagger UI</a>  </li>
</ol>
<h3 id="5-Swagger-Editor使用说明"><a href="#5-Swagger-Editor使用说明" class="headerlink" title="5. Swagger Editor使用说明"></a>5. Swagger Editor使用说明</h3><h4 id="5-1-我们可以在Swagger-Editor中编辑swagger-json-swagger-yaml文件-编写项目的API-编写完成后下载文件-通过Swagger-UI进行展示和调试相关操作"><a href="#5-1-我们可以在Swagger-Editor中编辑swagger-json-swagger-yaml文件-编写项目的API-编写完成后下载文件-通过Swagger-UI进行展示和调试相关操作" class="headerlink" title="5.1 我们可以在Swagger Editor中编辑swagger.json/swagger.yaml文件,编写项目的API,编写完成后下载文件,通过Swagger UI进行展示和调试相关操作;"></a>5.1 我们可以在Swagger Editor中编辑swagger.json/swagger.yaml文件,编写项目的API,编写完成后下载文件,通过Swagger UI进行展示和调试相关操作;</h4><p>Swagger API语法说明:   <a href="https://huangwenchao.gitbooks.io/swagger/content/" target="_blank" rel="noopener">参考-Swagger从入门到精通</a>  </p>
<h4 id="5-2-如何下载文件"><a href="#5-2-如何下载文件" class="headerlink" title="5.2 如何下载文件?"></a>5.2 如何下载文件?</h4><p><img src="https://note.youdao.com/yws/api/personal/file/WEB1525428cb3824945193555edd9a8dc3b?method=download&shareKey=84d50c122964b88eda3ec345c896515d" alt="Swagger-json/Swagger-yaml">  </p>
<h4 id="5-3-下载CLient包"><a href="#5-3-下载CLient包" class="headerlink" title="5.3 下载CLient包?"></a>5.3 下载CLient包?</h4><p><img src="https://note.youdao.com/yws/api/personal/file/WEBbb49e77b2635fcf8fd33179488526763?method=download&shareKey=a5191b45239cdf1c76c23727074e0c4c" alt="Swagger-cleint">  </p>
<h3 id="6-Swagger-UI"><a href="#6-Swagger-UI" class="headerlink" title="6. Swagger UI"></a>6. Swagger UI</h3><p>主要用于展示Swagger-json/Swagger-yaml文件内容<br><img src="https://note.youdao.com/yws/api/personal/file/WEBabf5c04995f32e14e0092062760de81a?method=download&shareKey=f725621241eb4e9bb7ab95d5b5f73318" alt="Web接口展示"><br><img src="https://note.youdao.com/yws/api/personal/file/WEB5cdc68f7e2d3f84f766a18c34adf2e94?method=download&shareKey=41b341528ab6e9d0bbf981adcbb79c6a" alt="Web接口测试">  </p>
]]></content>
      <categories>
        <category>swagger</category>
      </categories>
      <tags>
        <tag>swagger</tag>
      </tags>
  </entry>
  <entry>
    <title>kafka专题</title>
    <url>/2020/04/20/kafka%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<h1 id="kafka专题"><a href="#kafka专题" class="headerlink" title="kafka专题"></a>kafka专题</h1><blockquote>
<p><a href="https://www.cnblogs.com/BYRans/p/6054930.html" target="_blank" rel="noopener">Kafka简介</a></p>
</blockquote>
<h2 id="消息系统介绍"><a href="#消息系统介绍" class="headerlink" title="消息系统介绍"></a>消息系统介绍</h2><p>一个消息系统负责将数据从一个应用传递到另外一个应用，应用只需关注于数据，无需关注数据在两个或多个应用间是如何传递的。分布式消息传递基于可靠的消息队列，在客户端应用和消息系统之间异步传递消息。有两种主要的消息传递模式：点对点传递模式、发布-订阅模式。大部分的消息系统选用发布-订阅模式。</p>
<h2 id="点对点消息系统"><a href="#点对点消息系统" class="headerlink" title="点对点消息系统"></a>点对点消息系统</h2><p>在点对点消息系统中，消息持久化到一个队列中。此时，将有一个或多个消费者消费队列中的数据。但是一条消息只能被消费一次。当一个消费者消费了队列中的某条数据之后，该条数据则从消息队列中删除。该模式即使有多个消费者同时消费数据，也能保证数据处理的顺序.</p>
<h2 id="发布-订阅消息系统"><a href="#发布-订阅消息系统" class="headerlink" title="发布-订阅消息系统"></a>发布-订阅消息系统</h2><p>在发布-订阅消息系统中，消息被持久化到一个topic中。与点对点消息系统不同的是，消费者可以订阅一个或多个topic，消费者可以消费该topic中所有的数据，同一条数据可以被多个消费者消费，数据被消费后不会立马删除。在发布-订阅消息系统中，消息的生产者称为发布者，消费者称为订阅者。该模式的示例图如下：</p>
<h2 id="Kafka概述"><a href="#Kafka概述" class="headerlink" title="Kafka概述"></a>Kafka概述</h2><p>Apache Kafka是一个分布式的发布-订阅消息系统，能够支撑海量数据的数据传递。在离线和实时的消息处理业务系统中，Kafka都有广泛的应用。Kafka将消息持久化到磁盘中，并对消息创建了备份保证了数据的安全。Kafka在保证了较高的处理速度的同时，又能保证数据处理的低延迟和数据的零丢失。</p>
<p>Kafka的优势在于：</p>
<p>可靠性：Kafka是一个具有分区机制、副本机制和容错机制的分布式消息系统<br>可扩展性：Kafka消息系统支持集群规模的热扩展<br>高性能：Kafka在数据发布和订阅过程中都能保证数据的高吞吐量。即便在TB级数据存储的情况下，仍然能保证稳定的性能。</p>
<h2 id="Kafka-专用术语"><a href="#Kafka-专用术语" class="headerlink" title="Kafka 专用术语"></a>Kafka 专用术语</h2><p>一个topic配置了3个partition。Partition1有两个offset：0和1。Partition2有4个offset。Partition3有1个offset。副本的id和副本所在的机器的id恰好相同。</p>
<p>如果一个topic的副本数为3，那么Kafka将在集群中为每个partition创建3个相同的副本。集群中的每个broker存储一个或多个partition。多个producer和consumer可同时生产和消费数据。</p>
<p>各个术语的详细介绍如下:</p>
<ul>
<li>Topic：在Kafka中，使用一个类别属性来划分数据的所属类，划分数据的这个类称为topic。如果把Kafka看做为一个数据库，topic可以理解为数据库中的一张表，topic的名字即为表名。</li>
<li>Partition：topic中的数据分割为一个或多个partition。每个topic至少有一个partition。每个partition中的数据使用多个segment文件存储。partition中的数据是有序的，partition间的数据丢失了数据的顺序。如果topic有多个partition，消费数据时就不能保证数据的顺序。在需要严格保证消息的消费顺序的场景下，需要将partition数目设为1。</li>
<li>Partition offset：每条消息都有一个当前Partition下唯一的64字节的offset，它指明了这条消息的起始位置。</li>
<li>Replicas of partition：副本是一个分区的备份。副本不会被消费者消费，副本只用于防止数据丢失，即消费者不从为follower的partition中消费数据，而是从为leader的partition中读取数据。</li>
<li>Broker：<ul>
<li>Kafka 集群包含一个或多个服务器，服务器节点称为broker。</li>
<li>broker存储topic的数据。如果某topic有N个partition，集群有N个broker，那么每个broker存储该topic的一个partition。</li>
<li>如果某topic有N个partition，集群有(N+M)个broker，那么其中有N个broker存储该topic的一个partition，剩下的M个broker不存储该topic的partition数据。</li>
<li>如果某topic有N个partition，集群中broker数目少于N个，那么一个broker存储该topic的一个或多个partition。在实际生产环境中，尽量避免这种情况的发生，这种情况容易导致Kafka集群数据不均衡。</li>
</ul>
</li>
<li>Producer：生产者即数据的发布者，该角色将消息发布到Kafka的topic中。broker接收到生产者发送的消息后，broker将该消息追加到当前用于追加数据的segment文件中。生产者发送的消息，存储到一个partition中，生产者也可以指定数据存储的partition。</li>
<li>Consumer：消费者可以从broker中读取数据。消费者可以消费多个topic中的数据。</li>
<li>Leader：每个partition有多个副本，其中有且仅有一个作为Leader，Leader是当前负责数据的读写的partition。</li>
<li>Follower：Follower跟随Leader，所有写请求都通过Leader路由，数据变更会广播给所有Follower，Follower与Leader保持数据同步。如果Leader失效，则从Follower中选举出一个新的Leader。当Follower与Leader挂掉、卡住或者同步太慢，leader会把这个follower从“in sync replicas”（ISR）列表中删除，重新创建一个Follower。</li>
</ul>
<h2 id="Kafka架构"><a href="#Kafka架构" class="headerlink" title="Kafka架构"></a>Kafka架构</h2><ul>
<li>Broker：Kafka的broker是无状态的，broker使用Zookeeper维护集群的状态。Leader的选举也由Zookeeper负责。</li>
<li>Zookeeper：Zookeeper负责维护和协调broker。当Kafka系统中新增了broker或者某个broker发生故障失效时，由ZooKeeper通知生产者和消费者。生产者和消费者依据Zookeeper的broker状态信息与broker协调数据的发布和订阅任务。</li>
<li>Producer：生产者将数据推送到broker上，当集群中出现新的broker时，所有的生产者将会搜寻到这个新的broker，并自动将数据发送到这个broker上。</li>
<li>Consumer：因为Kafka的broker是无状态的，所以consumer必须使用partition offset来记录消费了多少数据。如果一个consumer指定了一个topic的offset，意味着该consumer已经消费了该offset之前的所有数据。consumer可以通过指定offset，从topic的指定位置开始消费数据。consumer的offset存储在Zookeeper中。</li>
</ul>
<h2 id="Kafka工作流程"><a href="#Kafka工作流程" class="headerlink" title="Kafka工作流程"></a>Kafka工作流程</h2><p>Kafka将某topic的数据存储到一个或多个partition中。一个partition内数据是有序的，每条数据都有一个唯一的index，这个index叫做offset。新来的数据追加到partition的尾部。每条数据可以在不同的broker上做备份，从而保证了Kafka使用的可靠性。</p>
<p>生产者将消息发送到topic中，消费者可以选择多种消费方式消费Kafka中的数据。下面介绍两种消费方式的流程。</p>
<h3 id="一个消费者订阅数据："><a href="#一个消费者订阅数据：" class="headerlink" title="一个消费者订阅数据："></a>一个消费者订阅数据：</h3><ul>
<li>生产者将数据发送到指定topic中</li>
<li>Kafka将数据以partition的方式存储到broker上。Kafka支持数据均衡，例如生产者生成了两条消息，topic有两个partition，那么Kafka将在两个partition上分别存储一条消息</li>
<li>消费者订阅指定topic的数据</li>
<li>当消费者订阅topic中消息时，Kafka将当前的offset发给消费者，同时将offset存储到Zookeeper中</li>
<li>消费者以特定的间隔（如100ms）向Kafka请求数据</li>
<li>当Kafka接收到生产者发送的数据时，Kafka将这些数据推送给消费者</li>
<li>消费者受到Kafka推送的数据，并进行处理</li>
<li>当消费者处理完该条消息后，消费者向Kafka broker发送一个该消息已被消费的反馈</li>
<li>当Kafka接到消费者的反馈后，Kafka更新offset包括Zookeeper中的offset。</li>
<li>以上过程一直重复，直到消费者停止请求数据</li>
<li>消费者可以重置offset，从而可以灵活消费存储在Kafka上的数据</li>
</ul>
<h3 id="消费者组数据消费流程"><a href="#消费者组数据消费流程" class="headerlink" title="消费者组数据消费流程"></a>消费者组数据消费流程</h3><p>Kafka支持消费者组内的多个消费者同时消费一个topic，一个消费者组由具有同一个Group ID的多个消费者组成。具体流程如下：</p>
<ol>
<li>生产者发送数据到指定的topic</li>
<li>Kafka将数据存储到broker上的partition中</li>
<li>假设现在有一个消费者订阅了一个topic，topic名字为“test”，消费者的Group ID为“Group1”</li>
<li>此时Kafka的处理方式与只有一个消费者的情况一样</li>
<li>当Kafka接收到一个同样Group ID为“Group1”、消费的topic同样为“test”的消费者的请求时，Kafka把数据操作模式切换为分享模式，此时数据将在两个消费者上共享。</li>
<li>当消费者的数目超过topic的partition数目时，后来的消费者将消费不到Kafka中的数据。因为在Kafka给每一个消费者消费者至少分配一个partition，一旦partition都被指派给消费者了，新来的消费者将不会再分配partition。即一个partition只能分配给一个消费者，一个消费者可以消费多个partition。</li>
</ol>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="http://kafka.apache.org/" target="_blank" rel="noopener">Apache Kafka</a></p>
<h2 id="安装zookeeper依赖"><a href="#安装zookeeper依赖" class="headerlink" title="安装zookeeper依赖"></a>安装zookeeper依赖</h2><p><a href="http://zookeeper.apache.org/" target="_blank" rel="noopener">Apache ZooKeeper - Home</a><br>启动kafka很简单，配置好前置的操作后，先进入zookeeper的目录下，启动zookeeper,可以单独安装,也可以使用kafka中集成的zookeeper,默认在bin目录下有zookeeper的启动脚本,zookeeper和kafka的配置均在kafka安装包下的config目录下,下面采用单独安装kafka的方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;data&#x2F;soft&#x2F;zookeeper</span><br><span class="line">&#x2F;&#x2F; 启动脚本使用方法</span><br><span class="line">Usage: .&#x2F;bin&#x2F;zkServer.sh &#123;start|start-foreground|stop|restart|status|upgrade|print-cmd&#125;</span><br><span class="line">&#x2F;&#x2F; 启动Zookeeper</span><br><span class="line">.&#x2F;bin&#x2F;zkServer.sh  start</span><br><span class="line">&#x2F;&#x2F; 关闭Zookeeper</span><br><span class="line">.&#x2F;bin&#x2F;zkServer.sh  stop</span><br><span class="line">&#x2F;&#x2F; 查看进程是否启动</span><br><span class="line">ps -ef | grep zookeepe</span><br></pre></td></tr></table></figure>
<p>PS：因为kafka是需要注册在zookeeper上面，通过zookeeper进行管理和调度的，所以启动kafka之前，我们必须要启动zookeeper。</p>
<h2 id="2-kafka安装"><a href="#2-kafka安装" class="headerlink" title="2. kafka安装"></a>2. kafka安装</h2><p>随后我们进入Kafka目录下，启动kafka，具体操作命令如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;kafka_2.11-1.0.0</span><br><span class="line">&#x2F;&#x2F; 修改配置</span><br><span class="line">vim &#x2F;usr&#x2F;local&#x2F;kafka&#x2F;config&#x2F;server.properties  kafka配置</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;kafka&#x2F;config&#x2F;zookeeper.properties   kafka集成的zookeeper配置</span><br><span class="line">&#x2F;&#x2F; 启动kafka</span><br><span class="line">.&#x2F;bin&#x2F;kafka-server-start.sh -daemon .&#x2F;config&#x2F;server.properties</span><br><span class="line">&#x2F;&#x2F; 查看</span><br><span class="line">jps -lm</span><br><span class="line">11776 &#x2F;usr&#x2F;local&#x2F;cerebro-0.7.2&#x2F;lib&#x2F;cerebro.cerebro-0.7.2-launcher.jar</span><br><span class="line">1392 &#x2F;usr&#x2F;share&#x2F;jenkins&#x2F;jenkins.war --webroot&#x3D;&#x2F;var&#x2F;cache&#x2F;jenkins&#x2F;war --httpPort&#x3D;8080</span><br><span class="line">24209 sun.tools.jps.Jps -lm</span><br><span class="line">20867 com.github.ltsopensource.startup.jobtracker.JobTrackerStartup &#x2F;data&#x2F;soft&#x2F;lts&#x2F;conf&#x2F;zoo</span><br><span class="line">20755 com.github.ltsopensource.startup.admin.JettyContainer &#x2F;data&#x2F;soft&#x2F;lts</span><br><span class="line">7972 org.apache.zookeeper.server.quorum.QuorumPeerMain &#x2F;data&#x2F;soft&#x2F;zookeeper-3.3.6&#x2F;bin&#x2F;..&#x2F;conf&#x2F;zoo.cfg</span><br><span class="line">10486 kafka.Kafka ..&#x2F;config&#x2F;server.properties</span><br><span class="line">12029 com.quantifind.kafka.offsetapp.OffsetGetterWeb --zk 127.0.0.1:2181 --port 9001 --refresh 10.seconds --retain 2.days</span><br><span class="line">11471 org.elasticsearch.bootstrap.Elasticsearch</span><br><span class="line">PS: 可以看到zookeeper和kafka都已经运行起来了，当然这个是单机的命令，集群的命令后面再讲。</span><br></pre></td></tr></table></figure>

<h2 id="kafka常用命令总结"><a href="#kafka常用命令总结" class="headerlink" title="kafka常用命令总结"></a>kafka常用命令总结</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 查看topic的详细信息</span><br><span class="line">bin&#x2F;kafka-topics.sh -zookeeper 127.0.0.1:2181 -describe -topic testKJ1</span><br><span class="line">2. 为topic增加副本</span><br><span class="line">bin&#x2F;kafka-reassign -partitions.sh -zookeeper 127.0.0.1:2181 -reassignment-json-file json&#x2F;partitions-to-move.json -execute</span><br><span class="line">3. 创建topic</span><br><span class="line">bin&#x2F;kafka-topics.sh --create --zookeeper localhost:2181 --replication -factor1 --partitions 1 --topic testKJ1</span><br><span class="line">4. 为topic增加partition</span><br><span class="line">bin&#x2F;bin&#x2F;kafka-topics.sh –zookeeper 127.0.0.1:2181 –alter –partitions2 –topic testKJ1</span><br><span class="line">5. kafka生产者客户端命令</span><br><span class="line">bin&#x2F;kafka-console-producer.sh --broker-list localhost:9092 --topic testKJ1</span><br><span class="line">6. kafka消费者客户端命令</span><br><span class="line">bin&#x2F;kafka-console-consumer.sh -zookeeper localhost:2181 --from-beginning --topic testKJ1</span><br><span class="line">7. kafka服务启动</span><br><span class="line">bin&#x2F;kafka-server-start.sh -daemon ..&#x2F;config&#x2F;server.properties</span><br><span class="line">8. 下线broker</span><br><span class="line">bin&#x2F;kafka-run-class.sh kafka.admin.ShutdownBroker --zookeeper 127.0.0.1:2181 --broker #brokerId# --num.retries3--retry.interval.ms 60</span><br><span class="line">shutdown broker</span><br><span class="line">9. 删除topic,只会删除zookeeper中的元数据，消息文件须手动删除</span><br><span class="line">bin&#x2F;kafka-run-class.sh kafka.admin.DeleteTopicCommand --topic testKJ1 --zookeeper 127.0.0.1:2181</span><br><span class="line">10. 查看topic消费进度</span><br><span class="line">这个会显示出consumer group的offset情况， 必须参数为--group， 不指定--topic，默认为所有topic</span><br><span class="line">查看consumer组内消费的offset</span><br><span class="line">bin&#x2F;kafka-run-class.sh kafka.tools.ConsumerOffsetChecker --zookeeper localhost:2181 --group test --topic testKJ1</span><br><span class="line">bin&#x2F;kafka-consumer-offset-checker.sh --zookeeper 192.168.0.201:12181 --group group1 --topic group1</span><br><span class="line">11. 列出所有的TOPIC</span><br><span class="line">bin&#x2F;kafka-topics.sh --zookeeper 127.0.0.1:2181 --list</span><br></pre></td></tr></table></figure>
<h2 id="Connecting-to-ZooKeeper"><a href="#Connecting-to-ZooKeeper" class="headerlink" title="Connecting to ZooKeeper"></a>Connecting to ZooKeeper</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. check status</span><br><span class="line">$ bin&#x2F;zkServer.sh status</span><br><span class="line">2. connect</span><br><span class="line">$ bin&#x2F;zkCli.sh -server 127.0.0.1:2181</span><br></pre></td></tr></table></figure>
<p>更多信息: <a href="http://zookeeper.apache.org/doc/current/zookeeperStarted.html" target="_blank" rel="noopener">ZooKeeper Getting Started Guide</a></p>
]]></content>
      <categories>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>WebSocket小试牛刀</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h2 id="WebSocket小试牛刀"><a href="#WebSocket小试牛刀" class="headerlink" title="WebSocket小试牛刀"></a>WebSocket小试牛刀</h2><h2 id="一-为什么需要WebSocket"><a href="#一-为什么需要WebSocket" class="headerlink" title="一. 为什么需要WebSocket?"></a>一. 为什么需要WebSocket?</h2><h3 id="1-1-初次接触-WebSocket-的人，都会问同样的问题：我们已经有了-HTTP-协议，为什么还需要另一个协议？"><a href="#1-1-初次接触-WebSocket-的人，都会问同样的问题：我们已经有了-HTTP-协议，为什么还需要另一个协议？" class="headerlink" title="1.1 初次接触 WebSocket 的人，都会问同样的问题：我们已经有了 HTTP 协议，为什么还需要另一个协议？"></a>1.1 初次接触 WebSocket 的人，都会问同样的问题：我们已经有了 HTTP 协议，为什么还需要另一个协议？</h3><p>WebSocket是HTML5出的东西（协议），也就是说HTTP协议没有变化，或者说没关系，但HTTP是不支持持久连接的（长连接，循环连接的不算）首先HTTP有1.1和1.0之说，也就是所谓的keep-alive，把多个HTTP请求合并为一个，但是Websocket其实是一个新协议，跟HTTP协议基本没有关系，只是为了兼容现有浏览器的握手规范而已，也就是说它是HTTP协议上的一种补充.<br>答案其实很简单，因为 HTTP 协议有一个缺陷：通信只能由客户端发起,特别是短链接,无状态,请求在获取相应信息之后立刻断开连接.</p>
<h3 id="1-2-那么-WebSocet到底是什么呢-它能带来什么好处？"><a href="#1-2-那么-WebSocet到底是什么呢-它能带来什么好处？" class="headerlink" title="1.2 那么,WebSocet到底是什么呢?它能带来什么好处？"></a>1.2 那么,WebSocet到底是什么呢?它能带来什么好处？</h3><p>Websocket是什么样的协议，具体有什么优点首先，Websocket是一个持久化的协议，相对于HTTP这种非持久的协议来说。<br>简单的举个例子吧，用目前应用比较广泛的PHP生命周期来解释。</p>
<ul>
<li>HTTP的生命周期通过Request来界定，也就是一个Request 一个Response，那么在HTTP1.0中，这次HTTP请求就结束了。</li>
<li>在HTTP1.1中进行了改进，使得有一个keep-alive，也就是说，在一个HTTP连接中，可以发送多个Request，接收多个Response。但是请记住 Request = Response,在HTTP中永远是这样，也就是说一个request只能有一个response。而且这个response也是被动的，不能主动发起。</li>
</ul>
<h4 id="1-3-教练，你BB了这么多，跟Websocket有什么关系呢？"><a href="#1-3-教练，你BB了这么多，跟Websocket有什么关系呢？" class="headerlink" title="1.3 教练，你BB了这么多，跟Websocket有什么关系呢？"></a>1.3 教练，你BB了这么多，跟Websocket有什么关系呢？</h4><p>好吧，我正准备说Websocket呢。。首先Websocket是基于HTTP协议的，或者说借用了HTTP的协议来完成一部分握手。在握手阶段是一样的,以下涉及专业技术内容，不想看的可以跳过.<br>首先我们来看个典型的Websocket握手</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;chat HTTP&#x2F;1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw&#x3D;&#x3D;</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Origin: http:&#x2F;&#x2F;example.com</span><br></pre></td></tr></table></figure>
<p>熟悉HTTP的童鞋可能发现了，这段类似HTTP协议的握手请求中，多了几个东西。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br></pre></td></tr></table></figure>
<p>这个就是Websocket的核心了，告诉Apache、Nginx等服务器：注意啦，窝发起的是Websocket协议，快点帮我找到对应的助理处理~不是那个老土的HTTP:)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw&#x3D;&#x3D;</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br></pre></td></tr></table></figure>
<p>首先，Sec-WebSocket-Key 是一个Base64 encode的值，这个是浏览器随机生成的，告诉服务器：泥煤，不要忽悠窝，我要验证尼是不是真的是Websocket助理。然后，Sec_WebSocket-Protocol 是一个用户定义的字符串，用来区分同URL下，不同的服务所需要的协议。简单理解：今晚我要服务A，别搞错啦<del>最后，Sec-WebSocket-Version 是告诉服务器所使用的Websocket Draft（协议版本），在最初的时候，Websocket协议还在 Draft 阶段，各种奇奇怪怪的协议都有，而且还有很多期奇奇怪怪不同的东西，什么Firefox和Chrome用的不是一个版本之类的，当初Websocket协议太多可是一个大难题。。不过现在还好，已经定下来啦</del>大家都使用的一个东西~ 脱水：服务员，我要的是13岁的噢→_→<br>然后服务器会返回下列东西，表示已经接受到请求， 成功建立Websocket啦！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk&#x3D;</span><br><span class="line">Sec-WebSocket-Protocol: chat</span><br></pre></td></tr></table></figure>
<p>这里开始就是HTTP最后负责的区域了，告诉客户，我已经成功切换协议啦~</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br></pre></td></tr></table></figure>
<p>依然是固定的，告诉客户端即将升级的是Websocket协议，而不是mozillasocket，lurnarsocket或者shitsocket。然后，Sec-WebSocket-Accept 这个则是经过服务器确认，并且加密过后的 Sec-WebSocket-Key。服务器：好啦好啦，知道啦，给你看我的ID CARD来证明行了吧。。后面的，Sec-WebSocket-Protocol 则是表示最终使用的协议。至此，HTTP已经完成它所有工作了，接下来就是完全按照Websocket协议进行了。<br>⚠️ : WebSocket两个重要的流程: 1. 握手; 2. 加密;</p>
<h2 id="二-剖析WebSocket请求流程"><a href="#二-剖析WebSocket请求流程" class="headerlink" title="二. 剖析WebSocket请求流程"></a>二. 剖析WebSocket请求流程</h2><p>下面讲使用Python编写Socket服务端，一步一步分析请求过程!!!</p>
<h3 id="2-1-服务端"><a href="#2-1-服务端" class="headerlink" title="2.1 服务端"></a>2.1 服务端</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">sock &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</span><br><span class="line">sock.bind((&#39;127.0.0.1&#39;, 8002))</span><br><span class="line">sock.listen(5)</span><br><span class="line"># 等待用户连接</span><br><span class="line">conn, address &#x3D; sock.accept()</span><br></pre></td></tr></table></figure>
<p>启动Socket服务器后，等待用户【连接】，然后进行收发数据。</p>
<h3 id="2-2-客户端连接"><a href="#2-2-客户端连接" class="headerlink" title="2.2 客户端连接"></a>2.2 客户端连接</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;WebSocket协议学习&lt;&#x2F;h1&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">        &#x2F;&#x2F; 向 127.0.0.1:8002 发送一个WebSocket请求</span><br><span class="line">        var socket &#x3D; new WebSocket(&quot;ws:&#x2F;&#x2F;127.0.0.1:8002&quot;);</span><br><span class="line">        socket.onmessage &#x3D; function (event) &#123;</span><br><span class="line">        &#x2F;* 服务器端向客户端发送数据时，自动执行(回掉函数) *&#x2F;</span><br><span class="line">        var response &#x3D; event.data;</span><br><span class="line">        console.log(response);</span><br><span class="line">    &#125;;</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<p>当客户端向服务端发送连接请求时，不仅连接还会发送[握手]信息，并等待服务端响应，至此连接才创建成功！</p>
<h3 id="2-3-建立连接"><a href="#2-3-建立连接" class="headerlink" title="2.3 建立连接"></a>2.3 建立连接</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line"> </span><br><span class="line">sock &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</span><br><span class="line">sock.bind((&#39;127.0.0.1&#39;, 8002))</span><br><span class="line">sock.listen(5)</span><br><span class="line"># 获取客户端socket对象</span><br><span class="line">conn, address &#x3D; sock.accept()</span><br><span class="line"># 获取客户端的【握手】信息</span><br><span class="line">data &#x3D; conn.recv(1024)</span><br><span class="line">...</span><br><span class="line">conn.send(&#39;响应【握手】信息&#39;)</span><br></pre></td></tr></table></figure>
<p>请求和响应的【握手】信息需要遵循规则:</p>
<ol>
<li>从请求【握手】信息中提取 Sec-WebSocket-Key</li>
<li>利用magic_string 和 Sec-WebSocket-Key 进行hmac1加密，再进行base64加密</li>
<li>将加密结果响应给客户端<br>⚠️ ：magic string为：258EAFA5-E914-47DA-95CA-C5AB0DC85B11<br>请求【握手】信息格式为:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;chatsocket HTTP&#x2F;1.1</span><br><span class="line">Host: 127.0.0.1:8002</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Origin: http:&#x2F;&#x2F;localhost:63342</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Sec-WebSocket-Key: mnwFxiOlctXFN&#x2F;DeMt1Amg&#x3D;&#x3D;</span><br><span class="line">Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits</span><br></pre></td></tr></table></figure>
<h3 id="2-4-提取Sec-WebSocket-Key值并加密："><a href="#2-4-提取Sec-WebSocket-Key值并加密：" class="headerlink" title="2.4 提取Sec-WebSocket-Key值并加密："></a>2.4 提取Sec-WebSocket-Key值并加密：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import socket</span><br><span class="line">import base64</span><br><span class="line">import hashlib</span><br><span class="line"> </span><br><span class="line">def get_headers(data):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    将请求头格式化成字典</span><br><span class="line">    :param data:</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    header_dict &#x3D; &#123;&#125;</span><br><span class="line">    data &#x3D; str(data, encoding&#x3D;&#39;utf-8&#39;)</span><br><span class="line"> </span><br><span class="line">    for i in data.split(&#39;\r\n&#39;):</span><br><span class="line">        print(i)</span><br><span class="line">    header, body &#x3D; data.split(&#39;\r\n\r\n&#39;, 1)</span><br><span class="line">    header_list &#x3D; header.split(&#39;\r\n&#39;)</span><br><span class="line">    for i in range(0, len(header_list)):</span><br><span class="line">        if i &#x3D;&#x3D; 0:</span><br><span class="line">            if len(header_list[i].split(&#39; &#39;)) &#x3D;&#x3D; 3:</span><br><span class="line">                header_dict[&#39;method&#39;], header_dict[&#39;url&#39;], header_dict[&#39;protocol&#39;] &#x3D; header_list[i].split(&#39; &#39;)</span><br><span class="line">        else:</span><br><span class="line">            k, v &#x3D; header_list[i].split(&#39;:&#39;, 1)</span><br><span class="line">            header_dict[k] &#x3D; v.strip()</span><br><span class="line">    return header_dict</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">sock &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</span><br><span class="line">sock.bind((&#39;127.0.0.1&#39;, 8002))</span><br><span class="line">sock.listen(5)</span><br><span class="line"> </span><br><span class="line">conn, address &#x3D; sock.accept()</span><br><span class="line">data &#x3D; conn.recv(1024)</span><br><span class="line">headers &#x3D; get_headers(data) # 提取请求头信息</span><br><span class="line"># 对请求头中的sec-websocket-key进行加密</span><br><span class="line">response_tpl &#x3D; &quot;HTTP&#x2F;1.1 101 Switching Protocols\r\n&quot; \</span><br><span class="line">      &quot;Upgrade:websocket\r\n&quot; \</span><br><span class="line">      &quot;Connection: Upgrade\r\n&quot; \</span><br><span class="line">      &quot;Sec-WebSocket-Accept: %s\r\n&quot; \</span><br><span class="line">      &quot;WebSocket-Location: ws:&#x2F;&#x2F;%s%s\r\n\r\n&quot;</span><br><span class="line">magic_string &#x3D; &#39;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&#39;</span><br><span class="line">value &#x3D; headers[&#39;Sec-WebSocket-Key&#39;] + magic_string</span><br><span class="line">ac &#x3D; base64.b64encode(hashlib.sha1(value.encode(&#39;utf-8&#39;)).digest())</span><br><span class="line">response_str &#x3D; response_tpl % (ac.decode(&#39;utf-8&#39;), headers[&#39;Host&#39;], headers[&#39;url&#39;])</span><br><span class="line"># 响应【握手】信息</span><br><span class="line">conn.send(bytes(response_str, encoding&#x3D;&#39;utf-8&#39;))</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="三-客户端和服务端收发数据"><a href="#三-客户端和服务端收发数据" class="headerlink" title="三. 客户端和服务端收发数据"></a>三. 客户端和服务端收发数据</h2><p>客户端和服务端传输数据时，需要对数据进行【封包】和【解包】。客户端的JavaScript类库已经封装【封包】和【解包】过程，但Socket服务端需要手动实现。</p>
<h3 id="3-1-第一步：获取客户端发送的数据【解包】"><a href="#3-1-第一步：获取客户端发送的数据【解包】" class="headerlink" title="3.1 第一步：获取客户端发送的数据【解包】"></a>3.1 第一步：获取客户端发送的数据【解包】</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 基于python实现的解包</span><br><span class="line"></span><br><span class="line">info &#x3D; conn.recv(8096)</span><br><span class="line">payload_len &#x3D; info[1] &amp; 127</span><br><span class="line">if payload_len &#x3D;&#x3D; 126:</span><br><span class="line">    extend_payload_len &#x3D; info[2:4]</span><br><span class="line">    mask &#x3D; info[4:8]</span><br><span class="line">    decoded &#x3D; info[8:]</span><br><span class="line">elif payload_len &#x3D;&#x3D; 127:</span><br><span class="line">    extend_payload_len &#x3D; info[2:10]</span><br><span class="line">    mask &#x3D; info[10:14]</span><br><span class="line">    decoded &#x3D; info[14:]</span><br><span class="line">else:</span><br><span class="line">    extend_payload_len &#x3D; None</span><br><span class="line">    mask &#x3D; info[2:6]</span><br><span class="line">    decoded &#x3D; info[6:]</span><br><span class="line"></span><br><span class="line">bytes_list &#x3D; bytearray()</span><br><span class="line">for i in range(len(decoded)):</span><br><span class="line">    chunk &#x3D; decoded[i] ^ mask[i % 4]</span><br><span class="line">    bytes_list.append(chunk)</span><br><span class="line">body &#x3D; str(bytes_list, encoding&#x3D;&#39;utf-8&#39;)</span><br><span class="line">print(body)</span><br></pre></td></tr></table></figure>
<h3 id="3-2-解包详细过程"><a href="#3-2-解包详细过程" class="headerlink" title="3.2 解包详细过程:"></a>3.2 解包详细过程:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-------+-+-------------+-------------------------------+</span><br><span class="line">|F|R|R|R| opcode|M| Payload len |    Extended payload length    |</span><br><span class="line">|I|S|S|S|  (4)  |A|     (7)     |             (16&#x2F;64)           |</span><br><span class="line">|N|V|V|V|       |S|             |   (if payload len&#x3D;&#x3D;126&#x2F;127)   |</span><br><span class="line">| |1|2|3|       |K|             |                               |</span><br><span class="line">+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +</span><br><span class="line">|     Extended payload length continued, if payload len &#x3D;&#x3D; 127  |</span><br><span class="line">+ - - - - - - - - - - - - - - - +-------------------------------+</span><br><span class="line">|                               |Masking-key, if MASK set to 1  |</span><br><span class="line">+-------------------------------+-------------------------------+</span><br><span class="line">| Masking-key (continued)       |          Payload Data         |</span><br><span class="line">+-------------------------------- - - - - - - - - - - - - - - - +</span><br><span class="line">:                     Payload Data continued ...                :</span><br><span class="line">+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</span><br><span class="line">|                     Payload Data continued ...                |</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure>
<h4 id="3-2-1-官方解释"><a href="#3-2-1-官方解释" class="headerlink" title="3.2.1 官方解释"></a>3.2.1 官方解释</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The MASK bit simply tells whether the message is encoded. Messages from the client must be masked, so your server should expect this to be 1. (In fact, section 5.1 of the spec says that your server must disconnect from a client if that client sends an unmasked message.) When sending a frame back to the client, do not mask it and do not set the mask bit. We&#39;ll explain masking later. Note: You have to mask messages even when using a secure socket.RSV1-3 can be ignored, they are for extensions.</span><br><span class="line"></span><br><span class="line">The opcode field defines how to interpret the payload data: 0x0 for continuation, 0x1 for text (which is always encoded in UTF-8), 0x2 for binary, and other so-called &quot;control codes&quot; that will be discussed later. In this version of WebSockets, 0x3 to 0x7 and 0xB to 0xF have no meaning.</span><br><span class="line"></span><br><span class="line">The FIN bit tells whether this is the last message in a series. If it&#39;s 0, then the server will keep listening for more parts of the message; otherwise, the server should consider the message delivered. More on this later.</span><br><span class="line"></span><br><span class="line">Decoding Payload Length</span><br><span class="line"></span><br><span class="line">To read the payload data, you must know when to stop reading. That&#39;s why the payload length is important to know. Unfortunately, this is somewhat complicated. To read it, follow these steps:</span><br><span class="line"></span><br><span class="line">Read bits 9-15 (inclusive) and interpret that as an unsigned integer. If it&#39;s 125 or less, then that&#39;s the length; you&#39;re done. If it&#39;s 126, go to step 2. If it&#39;s 127, go to step 3.</span><br><span class="line">Read the next 16 bits and interpret those as an unsigned integer. You&#39;re done.</span><br><span class="line">Read the next 64 bits and interpret those as an unsigned integer (The most significant bit MUST be 0). You&#39;re done.</span><br><span class="line">Reading and Unmasking the Data</span><br><span class="line"></span><br><span class="line">If the MASK bit was set (and it should be, for client-to-server messages), read the next 4 octets (32 bits); this is the masking key. Once the payload length and masking key is decoded, you can go ahead and read that number of bytes from the socket. Let&#39;s call the data ENCODED, and the key MASK. To get DECODED, loop through the octets (bytes a.k.a. characters for text data) of ENCODED and XOR the octet with the (i modulo 4)th octet of MASK. In pseudo-code (that happens to be valid JavaScript):</span><br><span class="line"></span><br><span class="line">var DECODED &#x3D; &quot;&quot;;</span><br><span class="line">for (var i &#x3D; 0; i &lt; ENCODED.length; i++) &#123;</span><br><span class="line">    DECODED[i] &#x3D; ENCODED[i] ^ MASK[i % 4];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Now you can figure out what DECODED means depending on your application.</span><br></pre></td></tr></table></figure>
<h3 id="3-3-向客户端发送数据【封包】"><a href="#3-3-向客户端发送数据【封包】" class="headerlink" title="3.3 向客户端发送数据【封包】"></a>3.3 向客户端发送数据【封包】</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def send_msg(conn, msg_bytes):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    WebSocket服务端向客户端发送消息</span><br><span class="line">    :param conn: 客户端连接到服务器端的socket对象,即： conn,address &#x3D; socket.accept()</span><br><span class="line">    :param msg_bytes: 向客户端发送的字节</span><br><span class="line">    :return: </span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    import struct</span><br><span class="line"></span><br><span class="line">    token &#x3D; b&quot;\x81&quot;</span><br><span class="line">    length &#x3D; len(msg_bytes)</span><br><span class="line">    if length &lt; 126:</span><br><span class="line">        token +&#x3D; struct.pack(&quot;B&quot;, length)</span><br><span class="line">    elif length &lt;&#x3D; 0xFFFF:</span><br><span class="line">        token +&#x3D; struct.pack(&quot;!BH&quot;, 126, length)</span><br><span class="line">    else:</span><br><span class="line">        token +&#x3D; struct.pack(&quot;!BQ&quot;, 127, length)</span><br><span class="line"></span><br><span class="line">    msg &#x3D; token + msg_bytes</span><br><span class="line">    conn.send(msg)</span><br><span class="line">    return True</span><br></pre></td></tr></table></figure>

<h2 id="四-基于python实现简单示例"><a href="#四-基于python实现简单示例" class="headerlink" title="四. 基于python实现简单示例"></a>四. 基于python实现简单示例</h2><h3 id="4-1-基于Python-socket实现的WebSocket服务端"><a href="#4-1-基于Python-socket实现的WebSocket服务端" class="headerlink" title="4.1 基于Python socket实现的WebSocket服务端"></a>4.1 基于Python socket实现的WebSocket服务端</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># __author__ &#x3D; &quot;shuke&quot;</span><br><span class="line"># Date: 2018&#x2F;5&#x2F;12</span><br><span class="line"></span><br><span class="line">import socket</span><br><span class="line">import hashlib</span><br><span class="line">import base64</span><br><span class="line"></span><br><span class="line">def get_headers(data):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    将请求头格式化成字典</span><br><span class="line">    :param data:</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    header_dict &#x3D; &#123;&#125;</span><br><span class="line">    data &#x3D; str(data, encoding&#x3D;&#39;utf-8&#39;)</span><br><span class="line"></span><br><span class="line">    header, body &#x3D; data.split(&#39;\r\n\r\n&#39;, 1)</span><br><span class="line">    header_list &#x3D; header.split(&#39;\r\n&#39;)</span><br><span class="line">    for i in range(0, len(header_list)):</span><br><span class="line">        if i &#x3D;&#x3D; 0:</span><br><span class="line">            if len(header_list[i].split(&#39; &#39;)) &#x3D;&#x3D; 3:</span><br><span class="line">                header_dict[&#39;method&#39;], header_dict[&#39;url&#39;], header_dict[&#39;protocol&#39;] &#x3D; header_list[i].split(&#39; &#39;)</span><br><span class="line">        else:</span><br><span class="line">            k, v &#x3D; header_list[i].split(&#39;:&#39;, 1)</span><br><span class="line">            header_dict[k] &#x3D; v.strip()</span><br><span class="line">    return header_dict</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def send_msg(conn, msg_bytes):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    WebSocket服务端向客户端发送消息</span><br><span class="line">    :param conn: 客户端连接到服务器端的socket对象,即： conn,address &#x3D; socket.accept()</span><br><span class="line">    :param msg_bytes: 向客户端发送的字节</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    import struct</span><br><span class="line"></span><br><span class="line">    token &#x3D; b&quot;\x81&quot;</span><br><span class="line">    length &#x3D; len(msg_bytes)</span><br><span class="line">    if length &lt; 126:</span><br><span class="line">        token +&#x3D; struct.pack(&quot;B&quot;, length)</span><br><span class="line">    elif length &lt;&#x3D; 0xFFFF:</span><br><span class="line">        token +&#x3D; struct.pack(&quot;!BH&quot;, 126, length)</span><br><span class="line">    else:</span><br><span class="line">        token +&#x3D; struct.pack(&quot;!BQ&quot;, 127, length)</span><br><span class="line"></span><br><span class="line">    msg &#x3D; token + msg_bytes</span><br><span class="line">    conn.send(msg)</span><br><span class="line">    return True</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sock &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)</span><br><span class="line">sock.bind((&#39;127.0.0.1&#39;, 8002))</span><br><span class="line">sock.listen(5)</span><br><span class="line"></span><br><span class="line"># 等待用户连接</span><br><span class="line">conn, address &#x3D; sock.accept()</span><br><span class="line"></span><br><span class="line"># WebSocket发来的连接</span><br><span class="line"># 1. 获取握手数据</span><br><span class="line">data &#x3D; conn.recv(1024)</span><br><span class="line">headers &#x3D; get_headers(data)</span><br><span class="line"></span><br><span class="line"># 2. 对握手信息进行加密：</span><br><span class="line">magic_string &#x3D; &#39;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&#39;</span><br><span class="line">value &#x3D; headers[&#39;Sec-WebSocket-Key&#39;] + magic_string</span><br><span class="line">ac &#x3D; base64.b64encode(hashlib.sha1(value.encode(&#39;utf-8&#39;)).digest())</span><br><span class="line"></span><br><span class="line"># 3. 返回握手信息</span><br><span class="line">response_tpl &#x3D; &quot;HTTP&#x2F;1.1 101 Switching Protocols\r\n&quot; \</span><br><span class="line">               &quot;Upgrade:websocket\r\n&quot; \</span><br><span class="line">               &quot;Connection: Upgrade\r\n&quot; \</span><br><span class="line">               &quot;Sec-WebSocket-Accept: %s\r\n&quot; \</span><br><span class="line">               &quot;WebSocket-Location: ws:&#x2F;&#x2F;127.0.0.1:8002\r\n\r\n&quot;</span><br><span class="line"></span><br><span class="line">response_str &#x3D; response_tpl % (ac.decode(&#39;utf-8&#39;),)</span><br><span class="line"></span><br><span class="line">conn.sendall(bytes(response_str, encoding&#x3D;&#39;utf-8&#39;))</span><br><span class="line"></span><br><span class="line"># 之后，才能进行收发数据。</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    # 对数据进行解密</span><br><span class="line">    # send_msg(conn, bytes(&#39;alex&#39;, encoding&#x3D;&#39;utf-8&#39;))</span><br><span class="line">    # send_msg(conn, bytes(&#39;SB&#39;, encoding&#x3D;&#39;utf-8&#39;))</span><br><span class="line">    # info &#x3D; conn.recv(8096)</span><br><span class="line">    # print(info)</span><br><span class="line"></span><br><span class="line">    info &#x3D; conn.recv(8096)</span><br><span class="line">    payload_len &#x3D; info[1] &amp; 127</span><br><span class="line">    if payload_len &#x3D;&#x3D; 126:</span><br><span class="line">        extend_payload_len &#x3D; info[2:4]</span><br><span class="line">        mask &#x3D; info[4:8]</span><br><span class="line">        decoded &#x3D; info[8:]</span><br><span class="line">    elif payload_len &#x3D;&#x3D; 127:</span><br><span class="line">        extend_payload_len &#x3D; info[2:10]</span><br><span class="line">        mask &#x3D; info[10:14]</span><br><span class="line">        decoded &#x3D; info[14:]</span><br><span class="line">    else:</span><br><span class="line">        extend_payload_len &#x3D; None</span><br><span class="line">        mask &#x3D; info[2:6]</span><br><span class="line">        decoded &#x3D; info[6:]</span><br><span class="line"></span><br><span class="line">    bytes_list &#x3D; bytearray()</span><br><span class="line">    for i in range(len(decoded)):</span><br><span class="line">        chunk &#x3D; decoded[i] ^ mask[i % 4]</span><br><span class="line">        bytes_list.append(chunk)</span><br><span class="line">    msg &#x3D; str(bytes_list, encoding&#x3D;&#39;utf-8&#39;)</span><br><span class="line"></span><br><span class="line">    rep &#x3D; msg + &#39; hello&#39;</span><br><span class="line">    send_msg(conn, bytes(rep, encoding&#x3D;&#39;utf-8&#39;))</span><br></pre></td></tr></table></figure>

<h3 id="4-2-利用JavaScript类库实现客户端"><a href="#4-2-利用JavaScript类库实现客户端" class="headerlink" title="4.2 利用JavaScript类库实现客户端"></a>4.2 利用JavaScript类库实现客户端</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;txt&quot;&#x2F;&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;button&quot; id&#x3D;&quot;btn&quot; value&#x3D;&quot;提交&quot; onclick&#x3D;&quot;sendMsg();&quot;&#x2F;&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;button&quot; id&#x3D;&quot;close&quot; value&#x3D;&quot;关闭连接&quot; onclick&#x3D;&quot;closeConn();&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;content&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var socket &#x3D; new WebSocket(&quot;ws:&#x2F;&#x2F;127.0.0.1:8003&#x2F;chatsocket&quot;);</span><br><span class="line"> </span><br><span class="line">    socket.onopen &#x3D; function () &#123;</span><br><span class="line">        &#x2F;* 与服务器端连接成功后，自动执行 *&#x2F;</span><br><span class="line"> </span><br><span class="line">        var newTag &#x3D; document.createElement(&#39;div&#39;);</span><br><span class="line">        newTag.innerHTML &#x3D; &quot;【连接成功】&quot;;</span><br><span class="line">        document.getElementById(&#39;content&#39;).appendChild(newTag);</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    socket.onmessage &#x3D; function (event) &#123;</span><br><span class="line">        &#x2F;* 服务器端向客户端发送数据时，自动执行 *&#x2F;</span><br><span class="line">        var response &#x3D; event.data;</span><br><span class="line">        var newTag &#x3D; document.createElement(&#39;div&#39;);</span><br><span class="line">        newTag.innerHTML &#x3D; response;</span><br><span class="line">        document.getElementById(&#39;content&#39;).appendChild(newTag);</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    socket.onclose &#x3D; function (event) &#123;</span><br><span class="line">        &#x2F;* 服务器端主动断开连接时，自动执行 *&#x2F;</span><br><span class="line">        var newTag &#x3D; document.createElement(&#39;div&#39;);</span><br><span class="line">        newTag.innerHTML &#x3D; &quot;【关闭连接】&quot;;</span><br><span class="line">        document.getElementById(&#39;content&#39;).appendChild(newTag);</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    function sendMsg() &#123;</span><br><span class="line">        var txt &#x3D; document.getElementById(&#39;txt&#39;);</span><br><span class="line">        socket.send(txt.value);</span><br><span class="line">        txt.value &#x3D; &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    function closeConn() &#123;</span><br><span class="line">        socket.close();</span><br><span class="line">        var newTag &#x3D; document.createElement(&#39;div&#39;);</span><br><span class="line">        newTag.innerHTML &#x3D; &quot;【关闭连接】&quot;;</span><br><span class="line">        document.getElementById(&#39;content&#39;).appendChild(newTag);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<p>此时,我们在浏览器的Console控制台利用Socket对象发送消息,将会收到返回信息</p>
<h2 id="五-基于Tornado框架实现Web聊天室"><a href="#五-基于Tornado框架实现Web聊天室" class="headerlink" title="五. 基于Tornado框架实现Web聊天室"></a>五. 基于Tornado框架实现Web聊天室</h2><p>Tornado是一个支持WebSocket的优秀框架，其内部原理正如1~5步骤描述，当然Tornado内部封装功能更加完整。<br>以下是基于Tornado实现的聊天室示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cat app.py</span><br><span class="line"></span><br><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">import uuid</span><br><span class="line">import json</span><br><span class="line">import tornado.ioloop</span><br><span class="line">import tornado.web</span><br><span class="line">import tornado.websocket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class IndexHandler(tornado.web.RequestHandler):</span><br><span class="line">    def get(self):</span><br><span class="line">        self.render(&#39;index.html&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ChatHandler(tornado.websocket.WebSocketHandler):</span><br><span class="line">    # 用户存储当前聊天室用户</span><br><span class="line">    waiters &#x3D; set()</span><br><span class="line">    # 用于存储历时消息</span><br><span class="line">    messages &#x3D; []</span><br><span class="line"></span><br><span class="line">    def open(self):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        客户端连接成功时，自动执行</span><br><span class="line">        :return: </span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        ChatHandler.waiters.add(self)</span><br><span class="line">        uid &#x3D; str(uuid.uuid4())</span><br><span class="line">        self.write_message(uid)</span><br><span class="line"></span><br><span class="line">        for msg in ChatHandler.messages:</span><br><span class="line">            content &#x3D; self.render_string(&#39;message.html&#39;, **msg)</span><br><span class="line">            self.write_message(content)</span><br><span class="line"></span><br><span class="line">    def on_message(self, message):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        客户端连发送消息时，自动执行</span><br><span class="line">        :param message: </span><br><span class="line">        :return: </span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        msg &#x3D; json.loads(message)</span><br><span class="line">        ChatHandler.messages.append(message)</span><br><span class="line"></span><br><span class="line">        for client in ChatHandler.waiters:</span><br><span class="line">            content &#x3D; client.render_string(&#39;message.html&#39;, **msg)</span><br><span class="line">            client.write_message(content)</span><br><span class="line"></span><br><span class="line">    def on_close(self):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        客户端关闭连接时，，自动执行</span><br><span class="line">        :return: </span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        ChatHandler.waiters.remove(self)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def run():</span><br><span class="line">    settings &#x3D; &#123;</span><br><span class="line">        &#39;template_path&#39;: &#39;templates&#39;,</span><br><span class="line">        &#39;static_path&#39;: &#39;static&#39;,</span><br><span class="line">    &#125;</span><br><span class="line">    application &#x3D; tornado.web.Application([</span><br><span class="line">        (r&quot;&#x2F;&quot;, IndexHandler),</span><br><span class="line">        (r&quot;&#x2F;chat&quot;, ChatHandler),</span><br><span class="line">    ], **settings)</span><br><span class="line">    application.listen(8888)</span><br><span class="line">    tornado.ioloop.IOLoop.instance().start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    run()</span><br><span class="line">&#96;&#96;&#96;    </span><br><span class="line">客户端</span><br></pre></td></tr></table></figure>
<h1 id="cat-index-html"><a href="#cat-index-html" class="headerlink" title="cat index.html"></a>cat index.html</h1><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Python聊天室</title>
<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="shuke's Blog" type="application/atom+xml">
</head>
<body>
    <div>
        <input type="text" id="txt"/>
        <input type="button" id="btn" value="提交" onclick="sendMsg();"/>
        <input type="button" id="close" value="关闭连接" onclick="closeConn();"/>
    </div>
    <div id="container" style="border: 1px solid #dddddd;margin: 20px;min-height: 500px;">

<pre><code>&lt;/div&gt;

&lt;script src=&quot;/static/jquery-2.1.4.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    $(function () {
        wsUpdater.start();
    });

    var wsUpdater = {
        socket: null,
        uid: null,
        start: function() {
            var url = &quot;ws://127.0.0.1:8888/chat&quot;;
            wsUpdater.socket = new WebSocket(url);
            wsUpdater.socket.onmessage = function(event) {
                console.log(event);
                if(wsUpdater.uid){
                    wsUpdater.showMessage(event.data);
                }else{
                    wsUpdater.uid = event.data;
                }
            }
        },
        showMessage: function(content) {
            $(&apos;#container&apos;).append(content);
        }
    };

    function sendMsg() {
        var msg = {
            uid: wsUpdater.uid,
            message: $(&quot;#txt&quot;).val()
        };
        wsUpdater.socket.send(JSON.stringify(msg));
    }</code></pre><p></script></p>
</body>
</html>
```

<p><a href="https://files.cnblogs.com/files/aslongas/2.WebSocket%E7%A4%BA%E4%BE%8B%EF%BC%9AFlask.rar" target="_blank" rel="noopener">Flask-WebSocket投票示例</a></p>
<p><a href="http://www.cnblogs.com/wupeiqi/p/6558766.html" target="_blank" rel="noopener">原文参考</a></p>
]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>PYTHON</tag>
      </tags>
  </entry>
  <entry>
    <title>SqlAlchemy玩转MySQL</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h2 id="SqlAlchemy玩转MySQL"><a href="#SqlAlchemy玩转MySQL" class="headerlink" title="SqlAlchemy玩转MySQL"></a>SqlAlchemy玩转MySQL</h2><h3 id="一-ORM框架"><a href="#一-ORM框架" class="headerlink" title="一. ORM框架"></a>一. ORM框架</h3><ol>
<li>Web 开发中，一个重要的组成部分便是数据库了。Web 程序中最常用的莫过于关系型数据库了，也称 SQL 数据库。另外，文档数据库（如 mongodb）、键值对数据库（如 redis）近几年也逐渐在 web 开发中流行起来，我们习惯把这两种数据库称为 NoSQL 数据库。</li>
<li>大多数的关系型数据库引擎（比如 MySQL、Postgres 和 SQLite）都有对应的 Python 包。在这里，我们不直接使用这些数据库引擎提供的 Python 包，而是使用对象关系映射（Object-Relational Mapper, ORM）框架，它将低层的数据库操作指令抽象成高层的面向对象操作。也就是说，如果我们直接使用数据库引擎，我们就要写 SQL 操作语句，但是，如果我们使用了 ORM 框架，我们对诸如表、文档此类的数据库实体就可以简化成对 Python 对象的操作。</li>
<li>Python 中最广泛使用的 ORM 框架是 SQLAlchemy，它是一个很强大的关系型数据库框架，不仅支持高层的 ORM，也支持使用低层的 SQL 操作，另外，它也支持多种数据库引擎，如 MySQL、Postgres 和 SQLite 等。</li>
</ol>
<h3 id="二-介绍"><a href="#二-介绍" class="headerlink" title="二. 介绍"></a>二. 介绍</h3><p>SQLAlchemy是一个基于Python实现的ORM框架。该框架建立在 DB API之上，使用关系对象映射进行数据库操作，简言之：将类和对象转换成SQL，然后使用数据库模块调用DB-API执行SQL并获取执行结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install sqlalchemy</span><br></pre></td></tr></table></figure>
<p>由于sqlalchemy模块依赖于第三方DB-API模块,因此,我们还需要安装数据库模块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install pymysql</span><br></pre></td></tr></table></figure>

<h3 id="三-框架基本结构"><a href="#三-框架基本结构" class="headerlink" title="三. 框架基本结构"></a>三. 框架基本结构</h3><p>组成部分：<br>Engine，框架的引擎<br>Connection Pooling ，数据库连接池<br>Dialect，选择连接数据库的DB API种类<br>Schema/Types，架构和类型<br>SQL Exprression Language，SQL表达式语言  </p>
<h3 id="四-连接串"><a href="#四-连接串" class="headerlink" title="四. 连接串"></a>四. 连接串</h3><p>SQLAlchemy本身无法操作数据库，其必须以来pymsql等第三方插件，Dialect用于和数据API进行交流，根据配置文件的不同调用不同的数据库API，从而实现对数据库的操作，如：<br>|数据库引擎|URL|<br>|—-|—-|<br>|MySQL-Pytho|mysql+mysqldb://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;[:&lt;port&gt;]/&lt;dbname&gt;|<br>|pymysql| mysql+pymysql://&lt;username&gt;:&lt;password&gt;@&lt;host&gt;/&lt;dbname&gt;[?&lt;options&gt;]|<br>|MySQL-Connector|mysql+mysqlconnector://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;[:&lt;port&gt;]/&lt;dbname&gt;|<br>|Postgres|postgresql://username:password@hostname/database|<br>|SQLite (Unix)|sqlite:////absolute/path/to/database|<br>|SQLite (Windows)|sqlite:///c:/absolute/path/to/database|<br>|cx_Oracle|oracle+cx_oracle://user:pass@host:port/dbname[?key=value&amp;key=value…]|<br>上面的表格中，username 和 password 表示登录数据库的用户名和密码，hostname 表示 SQL 服务所在的主机，可以是本地主机（localhost）也可以是远程服务器，database 表示要使用的数据库。有一点需要注意的是，SQLite 数据库不需要使用服务器，它使用硬盘上的文件名作为 database。<br><a href="http://docs.sqlalchemy.org/en/latest/dialects/index.html" target="_blank" rel="noopener">更多</a></p>
<h3 id="五-使用"><a href="#五-使用" class="headerlink" title="五. 使用"></a>五. 使用</h3><h4 id="5-1-执行原生SQL"><a href="#5-1-执行原生SQL" class="headerlink" title="5.1 执行原生SQL"></a>5.1 执行原生SQL</h4><ul>
<li>方式一<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import time</span><br><span class="line">import threading</span><br><span class="line">import sqlalchemy</span><br><span class="line">from sqlalchemy import create_engine</span><br><span class="line">from sqlalchemy.engine.base import Engine</span><br><span class="line"></span><br><span class="line">engine &#x3D; create_engine(</span><br><span class="line">    &quot;mysql+pymysql:&#x2F;&#x2F;zff:zff123@127.0.0.1:3306&#x2F;zff?charset&#x3D;utf8&quot;,</span><br><span class="line">    max_overflow&#x3D;0,  # 超过连接池大小外最多创建的连接</span><br><span class="line">    pool_size&#x3D;5,  # 连接池大小</span><br><span class="line">    pool_timeout&#x3D;30,  # 池中没有线程最多等待的时间，否则报错</span><br><span class="line">    pool_recycle&#x3D;-1  # 多久之后对线程池中的线程进行一次连接的回收(重置)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">def task(arg):</span><br><span class="line">    conn &#x3D; engine.raw_connection()</span><br><span class="line">    cursor &#x3D; conn.cursor()</span><br><span class="line">    cursor.execute(</span><br><span class="line">        &quot;select * from USER &quot;</span><br><span class="line">    )</span><br><span class="line">    result &#x3D; cursor.fetchall()</span><br><span class="line">    cursor.close()</span><br><span class="line">    conn.close()</span><br><span class="line">    print(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i in range(20):</span><br><span class="line">    t &#x3D; threading.Thread(target&#x3D;task, args&#x3D;(i,))</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure></li>
<li>方式二<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line">from sqlalchemy import create_engine</span><br><span class="line"></span><br><span class="line">engine &#x3D; create_engine(&quot;mysql+pymysql:&#x2F;&#x2F;zff:zff123@127.0.0.1:3306&#x2F;zff&quot;, max_overflow&#x3D;0, pool_size&#x3D;5)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def task(arg):</span><br><span class="line">    conn &#x3D; engine.contextual_connect()</span><br><span class="line">    with conn:</span><br><span class="line">        cur &#x3D; conn.execute(</span><br><span class="line">            &quot;select * from USER &quot;</span><br><span class="line">        )</span><br><span class="line">        result &#x3D; cur.fetchall()</span><br><span class="line">        print(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i in range(20):</span><br><span class="line">    t &#x3D; threading.Thread(target&#x3D;task, args&#x3D;(i,))</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure></li>
<li>方式三<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line">from sqlalchemy import create_engine</span><br><span class="line"></span><br><span class="line">engine &#x3D; create_engine(&quot;mysql+pymysql:&#x2F;&#x2F;zff:zff123@127.0.0.1:3306&#x2F;zff&quot;, max_overflow&#x3D;0, pool_size&#x3D;5)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def task(arg):</span><br><span class="line">    cur &#x3D; engine.execute(&quot;select * from USER &quot;)</span><br><span class="line">    # cur &#x3D; engine.execute(&quot;select sleep(10)&quot;)</span><br><span class="line">    result &#x3D; cur.fetchall()</span><br><span class="line">    cur.close()</span><br><span class="line">    print(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i in range(20):</span><br><span class="line">    t &#x3D; threading.Thread(target&#x3D;task, args&#x3D;(i,))</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure>
⚠️ 查看连接 show status like ‘Threads%’;</li>
</ul>
<h3 id="六-ORM使用"><a href="#六-ORM使用" class="headerlink" title="六. ORM使用"></a>六. ORM使用</h3><h4 id="6-1-创建数据库表"><a href="#6-1-创建数据库表" class="headerlink" title="6.1 创建数据库表"></a>6.1 创建数据库表</h4><ul>
<li><p>单表示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import datetime</span><br><span class="line">from sqlalchemy import create_engine</span><br><span class="line">from sqlalchemy.ext.declarative import declarative_base</span><br><span class="line">from sqlalchemy import Column, Integer, String, Text, ForeignKey, DateTime, UniqueConstraint, Index</span><br><span class="line"></span><br><span class="line"># 基类</span><br><span class="line">Base &#x3D; declarative_base()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Users(Base):</span><br><span class="line">    __tablename__ &#x3D; &#39;users&#39;</span><br><span class="line"></span><br><span class="line">    id &#x3D; Column(Integer, primary_key&#x3D;True)</span><br><span class="line">    name &#x3D; Column(String(32), index&#x3D;True, nullable&#x3D;False)</span><br><span class="line">    email &#x3D; Column(String(32), unique&#x3D;True)</span><br><span class="line">    ctime &#x3D; Column(DateTime, default&#x3D;datetime.datetime.now)</span><br><span class="line">    # extra &#x3D; Column(Text, nullable&#x3D;True)</span><br><span class="line"></span><br><span class="line">    __table_args__ &#x3D; (</span><br><span class="line">        # UniqueConstraint(&#39;id&#39;, &#39;name&#39;, name&#x3D;&#39;uix_id_name&#39;),   # 联合唯一索引</span><br><span class="line">        # Index(&#39;ix_id_name&#39;, &#39;name&#39;, &#39;email&#39;),                 # 联合索引</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def init_db():</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    根据类创建数据库表</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    engine &#x3D; create_engine(</span><br><span class="line">        &quot;mysql+pymysql:&#x2F;&#x2F;zff:zff123@127.0.0.1:3306&#x2F;zff?charset&#x3D;utf8&quot;,</span><br><span class="line">        max_overflow&#x3D;0,   # 超过连接池大小外最多创建的连接</span><br><span class="line">        pool_size&#x3D;5,      # 连接池大小</span><br><span class="line">        pool_timeout&#x3D;30,  # 池中没有线程最多等待的时间，否则报错</span><br><span class="line">        pool_recycle&#x3D;-1   # 多久之后对线程池中的线程进行一次连接的回收（重置）</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    Base.metadata.create_all(engine)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def drop_db():</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    根据类删除数据库表</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    engine &#x3D; create_engine(</span><br><span class="line">        &quot;mysql+pymysql:&#x2F;&#x2F;zff:zff123@127.0.0.1:3306&#x2F;zff?charset&#x3D;utf8&quot;,</span><br><span class="line">        max_overflow&#x3D;0,   # 超过连接池大小外最多创建的连接</span><br><span class="line">        pool_size&#x3D;5,      # 连接池大小</span><br><span class="line">        pool_timeout&#x3D;30,  # 池中没有线程最多等待的时间，否则报错</span><br><span class="line">        pool_recycle&#x3D;-1   # 多久之后对线程池中的线程进行一次连接的回收（重置）</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    Base.metadata.drop_all(engine)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    drop_db()</span><br><span class="line">    init_db()</span><br></pre></td></tr></table></figure></li>
<li><p>FK/M2M示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import datetime</span><br><span class="line">from sqlalchemy import create_engine</span><br><span class="line">from sqlalchemy.ext.declarative import declarative_base</span><br><span class="line">from sqlalchemy import Column, Integer, String, Text, ForeignKey, DateTime, UniqueConstraint, Index</span><br><span class="line">from sqlalchemy.orm import relationship</span><br><span class="line"></span><br><span class="line">Base &#x3D; declarative_base()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ##################### 单表示例 #########################</span><br><span class="line">class Users(Base):</span><br><span class="line">    __tablename__ &#x3D; &#39;users&#39;</span><br><span class="line"></span><br><span class="line">    id &#x3D; Column(Integer, primary_key&#x3D;True)</span><br><span class="line">    name &#x3D; Column(String(32), index&#x3D;True)</span><br><span class="line">    age &#x3D; Column(Integer, default&#x3D;18)</span><br><span class="line">    email &#x3D; Column(String(32), unique&#x3D;True)</span><br><span class="line">    ctime &#x3D; Column(DateTime, default&#x3D;datetime.datetime.now)</span><br><span class="line">    extra &#x3D; Column(Text, nullable&#x3D;True)</span><br><span class="line"></span><br><span class="line">    __table_args__ &#x3D; (</span><br><span class="line">        # UniqueConstraint(&#39;id&#39;, &#39;name&#39;, name&#x3D;&#39;uix_id_name&#39;),</span><br><span class="line">        # Index(&#39;ix_id_name&#39;, &#39;name&#39;, &#39;extra&#39;),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Hosts(Base):</span><br><span class="line">    __tablename__ &#x3D; &#39;hosts&#39;</span><br><span class="line"></span><br><span class="line">    id &#x3D; Column(Integer, primary_key&#x3D;True)</span><br><span class="line">    name &#x3D; Column(String(32), index&#x3D;True)</span><br><span class="line">    ctime &#x3D; Column(DateTime, default&#x3D;datetime.datetime.now)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ##################### 一对多示例 #########################</span><br><span class="line">class Hobby(Base):</span><br><span class="line">    __tablename__ &#x3D; &#39;hobby&#39;</span><br><span class="line">    id &#x3D; Column(Integer, primary_key&#x3D;True)</span><br><span class="line">    caption &#x3D; Column(String(50), default&#x3D;&#39;篮球&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Person(Base):</span><br><span class="line">    __tablename__ &#x3D; &#39;person&#39;</span><br><span class="line">    nid &#x3D; Column(Integer, primary_key&#x3D;True)</span><br><span class="line">    name &#x3D; Column(String(32), index&#x3D;True, nullable&#x3D;True)</span><br><span class="line">    hobby_id &#x3D; Column(Integer, ForeignKey(&quot;hobby.id&quot;))</span><br><span class="line"></span><br><span class="line">    # 与生成表结构无关，仅用于查询方便</span><br><span class="line">    hobby &#x3D; relationship(&quot;Hobby&quot;, backref&#x3D;&#39;pers&#39;)  # backref 反向查询</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ##################### 多对多示例 #########################</span><br><span class="line"></span><br><span class="line">class Server2Group(Base):</span><br><span class="line">    __tablename__ &#x3D; &#39;server2group&#39;</span><br><span class="line">    id &#x3D; Column(Integer, primary_key&#x3D;True, autoincrement&#x3D;True)  # 自增主键</span><br><span class="line">    server_id &#x3D; Column(Integer, ForeignKey(&#39;server.id&#39;))</span><br><span class="line">    group_id &#x3D; Column(Integer, ForeignKey(&#39;group.id&#39;))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Group(Base):</span><br><span class="line">    __tablename__ &#x3D; &#39;group&#39;</span><br><span class="line">    id &#x3D; Column(Integer, primary_key&#x3D;True)</span><br><span class="line">    name &#x3D; Column(String(64), unique&#x3D;True, nullable&#x3D;False)</span><br><span class="line"></span><br><span class="line">    # 与生成表结构无关，仅用于查询方便</span><br><span class="line">    servers &#x3D; relationship(&#39;Server&#39;, secondary&#x3D;&#39;server2group&#39;, backref&#x3D;&#39;groups&#39;)  # secondary: 指定关系表</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Server(Base):</span><br><span class="line">    __tablename__ &#x3D; &#39;server&#39;</span><br><span class="line"></span><br><span class="line">    id &#x3D; Column(Integer, primary_key&#x3D;True, autoincrement&#x3D;True)</span><br><span class="line">    hostname &#x3D; Column(String(64), unique&#x3D;True, nullable&#x3D;False)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def init_db():</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    根据类创建数据库表</span><br><span class="line">    :return: </span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    engine &#x3D; create_engine(</span><br><span class="line">        &quot;mysql+pymysql:&#x2F;&#x2F;zff:zff123@127.0.0.1:3306&#x2F;zff?charset&#x3D;utf8&quot;,</span><br><span class="line">        max_overflow&#x3D;0,  # 超过连接池大小外最多创建的连接</span><br><span class="line">        pool_size&#x3D;5,  # 连接池大小</span><br><span class="line">        pool_timeout&#x3D;30,  # 池中没有线程最多等待的时间，否则报错</span><br><span class="line">        pool_recycle&#x3D;-1  # 多久之后对线程池中的线程进行一次连接的回收（重置）</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    Base.metadata.create_all(engine)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def drop_db():</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    根据类删除数据库表</span><br><span class="line">    :return: </span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    engine &#x3D; create_engine(</span><br><span class="line">        &quot;mysql+pymysql:&#x2F;&#x2F;zff:zff123@127.0.0.1:3306&#x2F;zff?charset&#x3D;utf8&quot;,</span><br><span class="line">        max_overflow&#x3D;0,  # 超过连接池大小外最多创建的连接</span><br><span class="line">        pool_size&#x3D;5,  # 连接池大小</span><br><span class="line">        pool_timeout&#x3D;30,  # 池中没有线程最多等待的时间，否则报错</span><br><span class="line">        pool_recycle&#x3D;-1  # 多久之后对线程池中的线程进行一次连接的回收（重置）</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    Base.metadata.drop_all(engine)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    drop_db()</span><br><span class="line">    init_db()</span><br></pre></td></tr></table></figure>
<p>指定关联列: hobby = relationship(“Hobby”, backref=’pers’,foreign_keys=”Person.hobby_id”)</p>
<h4 id="6-1-ORM基本使用"><a href="#6-1-ORM基本使用" class="headerlink" title="6.1 ORM基本使用"></a>6.1 ORM基本使用</h4></li>
<li><p>初步使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># __author__ &#x3D; &quot;shuke&quot;</span><br><span class="line"># Date: 2018&#x2F;5&#x2F;14</span><br><span class="line"></span><br><span class="line">from sqlalchemy.orm import sessionmaker</span><br><span class="line">from sqlalchemy import create_engine</span><br><span class="line">from models import *</span><br><span class="line"></span><br><span class="line">engine &#x3D; create_engine(&quot;mysql+pymysql:&#x2F;&#x2F;zff:zff123@127.0.0.1:3306&#x2F;zff?charset&#x3D;utf8&quot;, max_overflow&#x3D;0, pool_size&#x3D;5)</span><br><span class="line">Session &#x3D; sessionmaker(bind&#x3D;engine)</span><br><span class="line"></span><br><span class="line"># 每次执行数据库操作时，都需要创建一个session</span><br><span class="line">session &#x3D; Session()</span><br><span class="line"></span><br><span class="line"># ############# 执行ORM操作 #############</span><br><span class="line">obj1 &#x3D; Users(name&#x3D;&quot;tome&quot;, age&#x3D;19, email&#x3D;&quot;tome163@163.com&quot;)</span><br><span class="line">session.add(obj1)</span><br><span class="line"></span><br><span class="line"># 提交事务</span><br><span class="line">session.commit()</span><br><span class="line"># 关闭session</span><br><span class="line">session.close()</span><br></pre></td></tr></table></figure></li>
<li><p>原生SQL</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from sqlalchemy.orm import sessionmaker</span><br><span class="line">from sqlalchemy import create_engine</span><br><span class="line">from sqlalchemy.sql import text</span><br><span class="line">from models import *</span><br><span class="line"></span><br><span class="line">engine &#x3D; create_engine(&quot;mysql+pymysql:&#x2F;&#x2F;zff:zff123@127.0.0.1:3306&#x2F;zff?charset&#x3D;utf8&quot;, max_overflow&#x3D;0, pool_size&#x3D;5)</span><br><span class="line">Session &#x3D; sessionmaker(bind&#x3D;engine)</span><br><span class="line"></span><br><span class="line">session &#x3D; Session()</span><br><span class="line"></span><br><span class="line"># 查询</span><br><span class="line"># cursor &#x3D; session.execute(&#39;select * from users&#39;)</span><br><span class="line"># result &#x3D; cursor.fetchall()</span><br><span class="line"></span><br><span class="line"># 添加</span><br><span class="line">with engine.connect() as con:</span><br><span class="line">    data &#x3D; (&#123;&#39;name&#39;: &#39;zhangsan&#39;, &#39;age&#39;: 20, &#39;value&#39;: &#39;zhangsan163@163.com&#39;&#125;,</span><br><span class="line">            &#123;&#39;name&#39;: &#39;lisi&#39;, &#39;age&#39;: 20, &#39;value&#39;: &#39;li163@163.com&#39;&#125;)</span><br><span class="line">    statement &#x3D; text(&quot;&quot;&quot;insert into users(name,age,email) values(:name,:age,:value)&quot;&quot;&quot;)</span><br><span class="line">    for line in data:</span><br><span class="line">        cursor &#x3D; con.execute(statement, **line)</span><br><span class="line"></span><br><span class="line">print(cursor.lastrowid)</span><br><span class="line">session.close()</span><br></pre></td></tr></table></figure></li>
<li><p>基本增删改查</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from sqlalchemy.orm import sessionmaker</span><br><span class="line">from sqlalchemy import create_engine</span><br><span class="line">from sqlalchemy.sql import text</span><br><span class="line">from models import *</span><br><span class="line"></span><br><span class="line">engine &#x3D; create_engine(&quot;mysql+pymysql:&#x2F;&#x2F;zff:zff123@127.0.0.1:3306&#x2F;zff?charset&#x3D;utf8&quot;, max_overflow&#x3D;0, pool_size&#x3D;5)</span><br><span class="line">Session &#x3D; sessionmaker(bind&#x3D;engine)</span><br><span class="line"></span><br><span class="line">session &#x3D; Session()</span><br><span class="line"></span><br><span class="line"># 1. ################ 添加 ################</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">obj1 &#x3D; Users(name&#x3D;&quot;jack&quot;, age&#x3D;19, email&#x3D;&quot;jak163@163.com&quot;)</span><br><span class="line">session.add(obj1)</span><br><span class="line"></span><br><span class="line">session.add_all([</span><br><span class="line">    Users(name&#x3D;&quot;wang&quot;, age&#x3D;19, email&#x3D;&quot;wang163@163.com&quot;),</span><br><span class="line">    Users(name&#x3D;&quot;lucy&quot;, age&#x3D;19, email&#x3D;&quot;lucy@163.com&quot;),</span><br><span class="line">    Hosts(name&#x3D;&quot;jav-pingtai03br-p002.gru1.blue.net&quot;),</span><br><span class="line">])</span><br><span class="line">session.commit()</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line"># 2. ################ 删除 ################</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">session.query(Users).filter(Users.id &gt; 2).delete()</span><br><span class="line">session.commit()</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"># 3. ################ 修改 ################</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">session.query(Users).filter(Users.id &gt; 0).update(&#123;&quot;name&quot; : &quot;shuke&quot;&#125;)</span><br><span class="line">session.query(Users).filter(Users.id &gt; 0).update(&#123;Users.name: Users.name + &quot;163&quot;&#125;, synchronize_session&#x3D;False)</span><br><span class="line">session.query(Users).filter(Users.id &gt; 0).update(&#123;&quot;age&quot;: Users.age + 1&#125;, synchronize_session&#x3D;&quot;evaluate&quot;)</span><br><span class="line">session.commit()</span><br><span class="line"></span><br><span class="line"># sqlalchemy 利用 session 执行 delete 时有一个 synchronize_session 参数用来说明 session 删除对象时需要执行的策略，共三个选项：</span><br><span class="line">1. False</span><br><span class="line">不同步 session，如果被删除的 objects 已经在 session 中存在，在 session commit 或者 expire_all 之前，这些被删除的对象都存在 session 中。</span><br><span class="line">不同步可能会导致获取被删除 objects 时出错。</span><br><span class="line"></span><br><span class="line"># 2. fetch</span><br><span class="line">删除之前从 db 中匹配被删除的对象并保存在 session 中，然后再从 session 中删除，这样做是为了让 session 的对象管理 identity_map 得知被删除的对象究竟是哪些以便更新引用关系。</span><br><span class="line"></span><br><span class="line"># 3. evaluate</span><br><span class="line"># 默认值。根据当前的 query criteria 扫描 session 中的 objects，如果不能正确执行则抛出错误，这句话也可以理解为，如果 session 中原本就没有这些被删除的 objects，扫描当然不会发生匹配，相当于匹配未正确执行。</span><br><span class="line">注意这里报错只会在特定 query criteria 时报错，比如 in 操作。</span><br><span class="line"></span><br><span class="line">session.query(Users).filter(Users.id.in_([1,2,3])).delete()</span><br><span class="line">sqlalchemy.exc.InvalidRequestError: Could not evaluate current criteria in Python. Specify &#39;fetch&#39; or False for the synchronize_session parameter.</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line"># 3. ################ 查询 ################</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">r1 &#x3D; session.query(Users).all()</span><br><span class="line">r2 &#x3D; session.query(Users.name.label(&#39;username&#39;), Users.age).all()   # 别名</span><br><span class="line">r3 &#x3D; session.query(Users).filter(Users.name &#x3D;&#x3D; &quot;shuke&quot;).all()</span><br><span class="line">r4 &#x3D; session.query(Users).filter_by(name&#x3D;&#39;shuke&#39;).all()</span><br><span class="line">r5 &#x3D; session.query(Users).filter_by(name&#x3D;&#39;shuke&#39;).first()</span><br><span class="line">r6 &#x3D; session.query(Users).filter(text(&quot;id&lt;:value and name&#x3D;:name&quot;)).params(value&#x3D;2, name&#x3D;&#39;shuke&#39;).order_by(Users.id).all()</span><br><span class="line">r7 &#x3D; session.query(Users).from_statement(text(&quot;SELECT * FROM users where name&#x3D;:name&quot;)).params(name&#x3D;&#39;shuke&#39;).all()</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line"># filter和filter_by的区别</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">filter_by用于简单的列名查询，如：</span><br><span class="line">db.users.filter_by(name&#x3D;&#39;Joe&#39;)</span><br><span class="line"></span><br><span class="line">filter对于上面的代码可以这样写：</span><br><span class="line">db.users.filter(db.users.name &#x3D;&#x3D; &#39;Joe&#39;)</span><br><span class="line"></span><br><span class="line">对于复杂的查询使用filter，如：</span><br><span class="line">db.users.filter(or_(db.users.name &#x3D;&#x3D; &#39;Ryan&#39;, db.users.country &#x3D;&#x3D; &#39;England&#39;))</span><br><span class="line"></span><br><span class="line">注意: filter_by使用的是赋值 &#x3D;, 而filter使用的是判断 &#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">另外：查询时使用like这样写： items &#x3D; session.query.filter(Users.name &#x3D;&#x3D; current_user, Users.title.like(&#39;%&#39; + keyword + &#39;%&#39;)).all()</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">session.close()</span><br></pre></td></tr></table></figure></li>
<li><p>常用操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 条件</span><br><span class="line">ret &#x3D; session.query(Users).filter_by(name&#x3D;&#39;shuke&#39;).all()</span><br><span class="line">ret &#x3D; session.query(Users).filter(Users.id &gt; 1, Users.name &#x3D;&#x3D; &#39;eric&#39;).all()</span><br><span class="line">ret &#x3D; session.query(Users).filter(Users.id.between(1, 3), Users.name &#x3D;&#x3D; &#39;eric&#39;).all()</span><br><span class="line">ret &#x3D; session.query(Users).filter(Users.id.in_([1, 3, 4])).all()</span><br><span class="line">ret &#x3D; session.query(Users).filter(~Users.id.in_([1, 3, 4])).all()</span><br><span class="line">ret &#x3D; session.query(Users).filter(Users.id.in_(session.query(Users.id).filter_by(name&#x3D;&#39;eric&#39;))).all()</span><br><span class="line"></span><br><span class="line"># 条件 AND &#x2F; OR</span><br><span class="line">from sqlalchemy import and_, or_</span><br><span class="line"></span><br><span class="line">ret &#x3D; session.query(Users).filter(and_(Users.id &gt; 3, Users.name &#x3D;&#x3D; &#39;eric&#39;)).all()</span><br><span class="line">ret &#x3D; session.query(Users).filter(or_(Users.id &lt; 3, Users.name &#x3D;&#x3D; &#39;shuke&#39;)).all()</span><br><span class="line">ret &#x3D; session.query(Users).filter(</span><br><span class="line">    or_(</span><br><span class="line">        Users.id &lt; 2,</span><br><span class="line">        and_(Users.name &#x3D;&#x3D; &#39;eric&#39;, Users.id &gt; 3),</span><br><span class="line">        Users.extra !&#x3D; &quot;&quot;</span><br><span class="line">    )).all()</span><br><span class="line"></span><br><span class="line"># 通配符</span><br><span class="line">ret &#x3D; session.query(Users).filter(Users.name.like(&#39;e%&#39;)).all()</span><br><span class="line">ret &#x3D; session.query(Users).filter(~Users.name.like(&#39;e%&#39;)).all()  # 取反</span><br><span class="line"></span><br><span class="line"># 限制</span><br><span class="line">ret &#x3D; session.query(Users)[1:2]  # limit</span><br><span class="line"></span><br><span class="line"># 排序</span><br><span class="line">ret &#x3D; session.query(Users).order_by(Users.name.desc()).all()  # 按降序排列</span><br><span class="line">ret &#x3D; session.query(Users).order_by(Users.name.desc(), Users.id.asc()).all()  # 根据name按降序排列，再根据id升序排列</span><br><span class="line"></span><br><span class="line"># 分组</span><br><span class="line">from sqlalchemy.sql import func</span><br><span class="line"></span><br><span class="line">ret &#x3D; session.query(Users).group_by(Users.extra).all()</span><br><span class="line">ret &#x3D; session.query(</span><br><span class="line">    func.max(Users.id),</span><br><span class="line">    func.sum(Users.id),</span><br><span class="line">    func.min(Users.id)).group_by(Users.name).all()</span><br><span class="line"></span><br><span class="line">ret &#x3D; session.query(</span><br><span class="line">    func.max(Users.id),</span><br><span class="line">    func.sum(Users.id),</span><br><span class="line">    func.min(Users.id)).group_by(Users.name).having(func.min(Users.id) &gt; 2).all()</span><br><span class="line"></span><br><span class="line"># 连表查询</span><br><span class="line">默认是innerjoin</span><br><span class="line"># 直接让两个表联合。这里join默认是innerjoin，这里没有写他们的对应关系，它们在内部自己找。</span><br><span class="line"># 它是怎么找的呢，在创建表的时候，有类型是foreignkey，是根据它来找的。</span><br><span class="line">ret &#x3D; session.query(Person).join(Favor).all()</span><br><span class="line">相当于sql语句,两个表通过on，来关联</span><br><span class="line"></span><br><span class="line">a.  查看sql</span><br><span class="line">sql &#x3D; session.query(Person).join(Favor)</span><br><span class="line">print(sql)</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">inner join打印sql，只打印person表所有字段信息，不打印favor表</span><br><span class="line">SELECT person.nid AS person_nid, person.name AS person_name, person.favor_id AS person_favor_id</span><br><span class="line">FROM person JOIN favor ON favor.nid &#x3D; person.favor_id</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line"></span><br><span class="line">b. isouter&#x3D;True即left join</span><br><span class="line">ret1 &#x3D; session.query(Person).join(Favor,isouter&#x3D;True).all()</span><br><span class="line">sql1 &#x3D; session.query(Person).join(Favor,isouter&#x3D;True)</span><br><span class="line">print(sql1)</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">打印sql，只打印person表所有字段的信息，但是没有打印favor表</span><br><span class="line">SELECT person.nid AS person_nid, person.name AS person_name, person.favor_id AS person_favor_id</span><br><span class="line">FROM person LEFT OUTER JOIN favor ON favor.nid &#x3D; person.favor_id</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line"></span><br><span class="line">c. 两张表的信息都打印出来</span><br><span class="line">ret2 &#x3D; session.query(Person, Favor).join(Favor, isouter&#x3D;True).all()</span><br><span class="line">print(ret2)</span><br><span class="line">sql2 &#x3D; session.query(Person, Favor).join(Favor, isouter&#x3D;True)</span><br><span class="line">print(sql2)</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">left join,打印结果：打印person和favor两张表的所有字段。</span><br><span class="line">[(&lt;__main__.Person object at 0x0000000003B34FD0&gt;, 1-white), (&lt;__main__.Person object at 0x0000000003B69BE0&gt;, 2-blue),</span><br><span class="line">(&lt;__main__.Person object at 0x0000000003B69C50&gt;, 2-blue)]</span><br><span class="line"></span><br><span class="line">left join,打印sql：打印person和favor两张表的所有字段。</span><br><span class="line">SELECT person.nid AS person_nid, person.name AS person_name, person.favor_id AS person_favor_id,</span><br><span class="line">favor.nid AS favor_nid, favor.caption AS favor_caption</span><br><span class="line">FROM person LEFT OUTER JOIN favor ON favor.nid &#x3D; person.favor_id</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line"></span><br><span class="line">d. 联表，只打印某些字段</span><br><span class="line">ret3 &#x3D; session.query(Person.name,Favor.caption).join(Favor,isouter&#x3D;True).all()</span><br><span class="line">print(ret3)</span><br><span class="line">sql3 &#x3D; session.query(Person.name,Favor.caption).join(Favor,isouter&#x3D;True)</span><br><span class="line">print(sql3)</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">left join,打印结果：某些指定字段值</span><br><span class="line">[(&#39;qiaomei0&#39;, &#39;white&#39;), (&#39;qiaomei1&#39;, &#39;blue&#39;), (&#39;qiaomei2&#39;, &#39;blue&#39;)]</span><br><span class="line">left join,打印sql：某些指定字段值</span><br><span class="line">SELECT person.name AS person_name, favor.caption AS favor_caption</span><br><span class="line">FROM person LEFT OUTER JOIN favor ON favor.nid &#x3D; person.favor_id</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line"></span><br><span class="line"># 关联子查询</span><br><span class="line">subqry &#x3D; session.query(func.count(Server.id).label(&quot;sid&quot;)).filter(Server.id &#x3D;&#x3D; Group.id).correlate(Group).as_scalar()</span><br><span class="line">result &#x3D; session.query(Group.name, subqry)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">SELECT &#96;group&#96;.name AS group_name, (SELECT count(server.id) AS sid </span><br><span class="line">FROM server </span><br><span class="line">WHERE server.id &#x3D; &#96;group&#96;.id) AS anon_1 </span><br><span class="line">FROM &#96;group&#96;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line"># 组合</span><br><span class="line">q1 &#x3D; session.query(Users.name).filter(Users.id &gt; 2)</span><br><span class="line">q2 &#x3D; session.query(Favor.caption).filter(Favor.nid &lt; 2)</span><br><span class="line">ret &#x3D; q1.union(q2).all()</span><br><span class="line"></span><br><span class="line">q1 &#x3D; session.query(Users.name).filter(Users.id &gt; 2)</span><br><span class="line">q2 &#x3D; session.query(Favor.caption).filter(Favor.nid &lt; 2)</span><br><span class="line">ret &#x3D; q1.union_all(q2).all()</span><br></pre></td></tr></table></figure>
</li>
<li><p>联表查询(一对多,基于relationship操作ForeignKey)</p>
</li>
</ul>
<ol>
<li>正向查询<br>多对一，多的那端开始查，也就是foreignkey写在哪里，从哪里查。<br>使用上面的方法非常麻烦，我们用更高效的方法。<br>只要在表里加上这一句话：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">favor &#x3D; relationship(&quot;Favor&quot;, backref&#x3D;&#39;pers&#39;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person(Base):</span><br><span class="line">    __tablename__ &#x3D; &#39;person&#39;</span><br><span class="line">    nid &#x3D; Column(Integer, primary_key&#x3D;True)</span><br><span class="line">    name &#x3D; Column(String(32), index&#x3D;True, nullable&#x3D;True)</span><br><span class="line">    favor_id &#x3D; Column(Integer, ForeignKey(&quot;favor.nid&quot;))</span><br><span class="line">    # 与生成表结构无关，仅用于查询方便</span><br><span class="line">    favor &#x3D; relationship(&quot;Favor&quot;, backref&#x3D;&#39;pers&#39;)</span><br><span class="line"> </span><br><span class="line">    # obj代指的是Person表的每一行数据</span><br><span class="line">    # obj.favor代指favor对象，obj.favor.nid就拿到了Person关联的favor对象的id。</span><br><span class="line">    # 所以你不用做联表，它内部帮你做联表。</span><br><span class="line">ret &#x3D; session.query(Person).all()</span><br><span class="line">for obj in ret:     # 每个obj就是一行数据。</span><br><span class="line"> </span><br><span class="line">    print(obj.nid,obj.name,obj.favor_id,obj.favor,obj.favor.nid,obj.favor.caption)</span><br></pre></td></tr></table></figure></li>
<li>反向查询<br>多对一，从一的那端开始查，也就是从没写foreignkey的表里反查。<br>多对一，从一的那端反查。<br>Person和Favor是多对一，假如查询喜欢蓝色的所有人。Favor的caption为blue的所有对应的Person</li>
</ol>
<p>传统方式，反向查询：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ret3 &#x3D; session.query(Person.name,Favor.caption).join(Favor,isouter&#x3D;True).filter(Favor.caption &#x3D;&#x3D; &#39;blue&#39;).all()</span><br></pre></td></tr></table></figure>
<p>Person表里，写了backref=’pers’,就相当于在favor表里加了个字段pers,实际是不存在的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">favor &#x3D; relationship(&quot;Favor&quot;, backref&#x3D;&#39;pers&#39;)</span><br></pre></td></tr></table></figure>
<p>如下: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person(Base):</span><br><span class="line">    __tablename__ &#x3D; &#39;person&#39;</span><br><span class="line">    nid &#x3D; Column(Integer, primary_key&#x3D;True)</span><br><span class="line">    name &#x3D; Column(String(32), index&#x3D;True, nullable&#x3D;True)</span><br><span class="line">    favor_id &#x3D; Column(Integer, ForeignKey(&quot;favor.nid&quot;))</span><br><span class="line">    # 与生成表结构无关，仅用于查询方便</span><br><span class="line">    favor &#x3D; relationship(&quot;Favor&quot;, backref&#x3D;&#39;pers&#39;)</span><br><span class="line"> </span><br><span class="line">class Favor(Base):</span><br><span class="line">    __tablename__ &#x3D; &#39;favor&#39;</span><br><span class="line">    nid &#x3D; Column(Integer, primary_key&#x3D;True)</span><br><span class="line">    caption &#x3D; Column(String(50), default&#x3D;&#39;red&#39;, unique&#x3D;True)</span><br><span class="line">    # Person表里写的：backref&#x3D;&#39;pers&#39;,相当于在这里加上字段pers。只是用于查询，不会修改表结构。</span><br><span class="line">    # pers &#x3D; 。。。。。。。。</span><br><span class="line">    def __repr__(self):</span><br><span class="line">        return &quot;%s-%s&quot; %(self.nid, self.caption)</span><br></pre></td></tr></table></figure>
<p>你可以直接通过Favor对象的pers字段找到跟这个颜色关联的所有person,在数据库里没有真实的字段对应的，只是帮你生成sql语句而已。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 新方式，反向查询</span><br><span class="line">obj &#x3D; session.query(Favor).filter(Favor.caption&#x3D;&#x3D;&#39;blue&#39;).first()    # 先找到caption为blue的Favor对象</span><br><span class="line">print(obj.nid)</span><br><span class="line">print(obj.caption)</span><br><span class="line">print(obj.pers)</span><br><span class="line"> </span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">打印结果：</span><br><span class="line">2</span><br><span class="line">blue</span><br><span class="line">[&lt;__main__.Person object at 0x0000000003B5BBE0&gt;, &lt;__main__.Person object at 0x0000000003B5BC50&gt;]</span><br><span class="line">&#39;&#39;&#39;</span><br></pre></td></tr></table></figure>
<p>Foreignkey(一对多总结)<br>Foreignkey和relationship要成对写在一个表里。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person(Base):</span><br><span class="line">    __tablename__ &#x3D; &#39;person&#39;</span><br><span class="line">    nid &#x3D; Column(Integer, primary_key&#x3D;True)</span><br><span class="line">    name &#x3D; Column(String(32), index&#x3D;True, nullable&#x3D;True)</span><br><span class="line">    favor_id &#x3D; Column(Integer, ForeignKey(&quot;favor.nid&quot;))</span><br><span class="line">    # 与生成表结构无关，仅用于查询方便</span><br><span class="line">    favor &#x3D; relationship(&quot;Favor&quot;, backref&#x3D;&#39;pers&#39;)</span><br><span class="line">&#96;&#96;&#96;    </span><br><span class="line">Person对Favor 是多对一的关系，foreignkey加在了多的那端(Person表)</span><br><span class="line">Person对象.favor.favor的字段：叫做正向查找</span><br><span class="line">Favor对象.pers.person的字段：反向查找</span><br><span class="line"></span><br><span class="line">- M2M(基于relationship的m2m关系)</span><br></pre></td></tr></table></figure>
<p>import time<br>import threading</p>
<p>from sqlalchemy.ext.declarative import declarative_base<br>from sqlalchemy import Column, Integer, String, ForeignKey, UniqueConstraint, Index<br>from sqlalchemy.orm import sessionmaker, relationship<br>from sqlalchemy import create_engine<br>from sqlalchemy.sql import text<br>from sqlalchemy.engine.result import ResultProxy<br>from db import Users, Hosts, Hobby, Person, Group, Server, Server2Group</p>
<p>engine = create_engine(“mysql+pymysql://root:<a href="mailto:123@127.0.0.1">123@127.0.0.1</a>:3306/s6?charset=utf8”, max_overflow=0, pool_size=5)<br>Session = sessionmaker(bind=engine)<br>session = Session()</p>
<h1 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h1><p>“””<br>session.add_all([<br>    Server(hostname=’c1.com’),<br>    Server(hostname=’c2.com’),<br>    Group(name=’A组’),<br>    Group(name=’B组’),<br>])<br>session.commit()</p>
<p>s2g = Server2Group(server_id=1, group_id=1)<br>session.add(s2g)<br>session.commit()</p>
<p>gp = Group(name=’C组’)<br>gp.servers = [Server(hostname=’c3.com’),Server(hostname=’c4.com’)]<br>session.add(gp)<br>session.commit()</p>
<p>ser = Server(hostname=’c6.com’)<br>ser.groups = [Group(name=’F组’),Group(name=’G组’)]<br>session.add(ser)<br>session.commit()<br>“””</p>
<h1 id="使用relationship正向查询"><a href="#使用relationship正向查询" class="headerlink" title="使用relationship正向查询"></a>使用relationship正向查询</h1><p>“””<br>v = session.query(Group).first()<br>print(v.name)<br>print(v.servers)<br>“””</p>
<h1 id="使用relationship反向查询"><a href="#使用relationship反向查询" class="headerlink" title="使用relationship反向查询"></a>使用relationship反向查询</h1><p>“””<br>v = session.query(Server).first()<br>print(v.hostname)<br>print(v.groups)<br>“””<br>session.close()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 多线程执行示例</span><br></pre></td></tr></table></figure>
<p>import time<br>import threading<br>from sqlalchemy.ext.declarative import declarative_base<br>from sqlalchemy import Column, Integer, String, ForeignKey, UniqueConstraint, Index<br>from sqlalchemy.orm import sessionmaker, relationship<br>from sqlalchemy import create_engine<br>from db import Users</p>
<p>engine = create_engine(“mysql+pymysql://root:<a href="mailto:123@127.0.0.1">123@127.0.0.1</a>:3306/s6”, max_overflow=0, pool_size=5)<br>Session = sessionmaker(bind=engine)</p>
<p>def task(arg):<br>    session = Session()<br>    obj1 = Users(name=”shuke”)<br>    session.add(obj1)<br>    session.commit()</p>
<p>for i in range(10):<br>    t = threading.Thread(target=task, args=(i,))<br>    t.start()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 基于scoped_session使得线程安全</span><br><span class="line">基于ThreadLocal实现</span><br></pre></td></tr></table></figure>
<p>from sqlalchemy.orm import sessionmaker<br>from sqlalchemy import create_engine<br>from sqlalchemy.orm import scoped_session<br>from models import Users</p>
<p>engine = create_engine(“mysql+pymysql://root:<a href="mailto:123@127.0.0.1">123@127.0.0.1</a>:3306/s6”, max_overflow=0, pool_size=5)<br>Session = sessionmaker(bind=engine)</p>
<p>“””</p>
<h1 id="线程安全，基于本地线程实现每个线程用同一个session"><a href="#线程安全，基于本地线程实现每个线程用同一个session" class="headerlink" title="线程安全，基于本地线程实现每个线程用同一个session"></a>线程安全，基于本地线程实现每个线程用同一个session</h1><h1 id="特殊的：scoped-session中有原来方法的Session中的一下方法："><a href="#特殊的：scoped-session中有原来方法的Session中的一下方法：" class="headerlink" title="特殊的：scoped_session中有原来方法的Session中的一下方法："></a>特殊的：scoped_session中有原来方法的Session中的一下方法：</h1><p>public_methods = (<br>    ‘<strong>contains</strong>‘, ‘<strong>iter</strong>‘, ‘add’, ‘add_all’, ‘begin’, ‘begin_nested’,<br>    ‘close’, ‘commit’, ‘connection’, ‘delete’, ‘execute’, ‘expire’,<br>    ‘expire_all’, ‘expunge’, ‘expunge_all’, ‘flush’, ‘get_bind’,<br>    ‘is_modified’, ‘bulk_save_objects’, ‘bulk_insert_mappings’,<br>    ‘bulk_update_mappings’,<br>    ‘merge’, ‘query’, ‘refresh’, ‘rollback’,<br>    ‘scalar’<br>)</p>
<p>“””<br>session = scoped_session(Session)</p>
<h1 id="执行ORM操作"><a href="#执行ORM操作" class="headerlink" title="############# 执行ORM操作"></a>############# 执行ORM操作</h1><p>obj1 = Users(name=”shuke”)<br>session.add(obj1)</p>
<h1 id="提交事务"><a href="#提交事务" class="headerlink" title="提交事务"></a>提交事务</h1><p>session.commit()</p>
<h1 id="关闭session"><a href="#关闭session" class="headerlink" title="关闭session"></a>关闭session</h1><p>session.close()</p>
<pre><code>

参考资料:
[Flask-SQLAlchemy-武沛齐-博客园](http://www.cnblogs.com/wupeiqi/articles/8259356.html)  
[mysql和SQLAlchemy-博客园](https://www.cnblogs.com/wangqiaomei/p/5721523.html)  
[使用flask-sqlalchemy玩转MySQL | Wing&apos;s Tech Space](https://wing324.github.io/2017/02/25/%E4%BD%BF%E7%94%A8flask-sqlalchemy%E7%8E%A9%E8%BD%ACMySQL/)  
[Flask-Migrate的使用 | Wing&apos;s Tech Space](https://wing324.github.io/2017/02/26/Flask-Migrate%E7%9A%84%E4%BD%BF%E7%94%A8/)





























</code></pre>]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>PYTHON</tag>
      </tags>
  </entry>
  <entry>
    <title>Web框架本质</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h2 id="Web框架本质"><a href="#Web框架本质" class="headerlink" title="Web框架本质"></a>Web框架本质</h2><p>众所周知，对于所有的Web应用，本质上其实就是一个socket服务端，用户的浏览器其实就是一个socket客户端。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># __author__ &#x3D; &quot;shuke&quot;</span><br><span class="line"># Date: 2018&#x2F;4&#x2F;22</span><br><span class="line"></span><br><span class="line">import socket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def handle_request(client):</span><br><span class="line">    # 获取客户端发送的数据</span><br><span class="line">    buf &#x3D; client.recv(1024)</span><br><span class="line">    # 回复客户端的请求</span><br><span class="line">    client.send(b&quot;HTTP&#x2F;1.1 200 OK\r\n\r\n&quot;)</span><br><span class="line">    client.send(b&quot;Hello, shuke&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    # 创建socket对象</span><br><span class="line">    sock &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    sock.bind((&#39;localhost&#39;, 9000))</span><br><span class="line">    sock.listen(5)</span><br><span class="line"></span><br><span class="line">    while True:</span><br><span class="line">        # 监听socket，等待请求的到来</span><br><span class="line">        connection, address &#x3D; sock.accept()</span><br><span class="line">        handle_request(connection)</span><br><span class="line">        # 关闭连接</span><br><span class="line">        connection.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    main()</span><br><span class="line"></span><br><span class="line"># 验证</span><br><span class="line">$ curl http:&#x2F;&#x2F;localhost:9000</span><br><span class="line">Hello, shuke</span><br></pre></td></tr></table></figure>
<p>上述通过socket来实现了其本质，而对于真实开发中的python web程序来说，一般会分为两部分：服务器程序和应用程序。服务器程序负责对socket服务器进行封装，并在请求到来时，对请求的各种数据进行整理。应用程序则负责具体的逻辑处理。为了方便应用程序的开发，就出现了众多的Web框架，例如：Django、Flask、web.py 等。不同的框架有不同的开发方式，但是无论如何，开发出的应用程序都要和服务器程序配合，才能为用户提供服务。这样，服务器程序就需要为不同的框架提供不同的支持。这样混乱的局面无论对于服务器还是框架，都是不好的。对服务器来说，需要支持各种不同框架，对框架来说，只有支持它的服务器才能被开发出的应用使用。这时候，标准化就变得尤为重要。我们可以设立一个标准，只要服务器程序支持这个标准，框架也支持这个标准，那么他们就可以配合使用。一旦标准确定，双方各自实现。这样，服务器可以支持更多支持标准的框架，框架也可以使用更多支持标准的服务器。</p>
<p>WSGI（Web Server Gateway Interface）是一种规范，它定义了使用python编写的web app与web server之间接口格式，实现web app与web server间的解耦。</p>
<p>python标准库提供的独立WSGI服务器称为wsgiref</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from wsgiref.simple_server import make_server</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def RunServer(environ, start_response):</span><br><span class="line">    start_response(&#39;200 OK&#39;, [(&#39;Content-Type&#39;, &#39;text&#x2F;html&#39;)])</span><br><span class="line">    return [bytes(&#39;&lt;h1&gt;Hello, web!&lt;&#x2F;h1&gt;&#39;, encoding&#x3D;&#39;utf-8&#39;), ]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    httpd &#x3D; make_server(&#39;&#39;, 8000, RunServer)</span><br><span class="line">    print(&quot;Serving HTTP on port 8000...&quot;)</span><br><span class="line">    httpd.serve_forever()</span><br></pre></td></tr></table></figure>
<h2 id="自定义框架"><a href="#自定义框架" class="headerlink" title="自定义框架"></a>自定义框架</h2><p>一. 框架<br>通过python标准库提供的wsgiref模块开发一个自己的Web框架</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line">#coding:utf-8</span><br><span class="line">from wsgiref.simple_server import make_server</span><br><span class="line"> </span><br><span class="line">def index():</span><br><span class="line">    return &#39;index&#39;</span><br><span class="line"> </span><br><span class="line">def login():</span><br><span class="line">    return &#39;login&#39;</span><br><span class="line"> </span><br><span class="line">def routers():</span><br><span class="line">     </span><br><span class="line">    urlpatterns &#x3D; (</span><br><span class="line">        (&#39;&#x2F;index&#x2F;&#39;,index),</span><br><span class="line">        (&#39;&#x2F;login&#x2F;&#39;,login),</span><br><span class="line">    )</span><br><span class="line">     </span><br><span class="line">    return urlpatterns</span><br><span class="line"> </span><br><span class="line">def RunServer(environ, start_response):</span><br><span class="line">    start_response(&#39;200 OK&#39;, [(&#39;Content-Type&#39;, &#39;text&#x2F;html&#39;)])</span><br><span class="line">    url &#x3D; environ[&#39;PATH_INFO&#39;]</span><br><span class="line">    urlpatterns &#x3D; routers()</span><br><span class="line">    func &#x3D; None</span><br><span class="line">    for item in urlpatterns:</span><br><span class="line">        if item[0] &#x3D;&#x3D; url:</span><br><span class="line">            func &#x3D; item[1]</span><br><span class="line">            break</span><br><span class="line">    if func:</span><br><span class="line">        return func()</span><br><span class="line">    else:</span><br><span class="line">        return &#39;404 not found&#39;</span><br><span class="line">     </span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    httpd &#x3D; make_server(&#39;&#39;, 8000, RunServer)</span><br><span class="line">    print &quot;Serving HTTP on port 8000...&quot;</span><br><span class="line">    httpd.serve_forever()</span><br><span class="line">&#96;&#96;&#96;    </span><br><span class="line">2、模板引擎</span><br><span class="line"></span><br><span class="line">在上一步骤中，对于所有的login、index均返回给用户浏览器一个简单的字符串，在现实的Web请求中一般会返回一个复杂的符合HTML规则的字符串，所以我们一般将要返回给用户的HTML写在指定文件中，然后再返回,如：</span><br></pre></td></tr></table></figure>
<h1 id="cat-index-html"><a href="#cat-index-html" class="headerlink" title="cat index.html"></a>cat index.html</h1><!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
    <h1>Index</h1>

</body>
</html>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;&#96;&#96;</span><br><span class="line"># cat login.html</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;text&quot; &#x2F;&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;text&quot; &#x2F;&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;submit&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;form&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"> </span><br><span class="line">from wsgiref.simple_server import make_server</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def index():</span><br><span class="line">    # return &#39;index&#39;</span><br><span class="line">    f &#x3D; open(&#39;index.html&#39;)</span><br><span class="line">    data &#x3D; f.read()</span><br><span class="line">    return data</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def login():</span><br><span class="line">    # return &#39;login&#39;</span><br><span class="line">    f &#x3D; open(&#39;login.html&#39;)</span><br><span class="line">    data &#x3D; f.read()</span><br><span class="line">    return data</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def routers():</span><br><span class="line"> </span><br><span class="line">    urlpatterns &#x3D; (</span><br><span class="line">        (&#39;&#x2F;index&#x2F;&#39;, index),</span><br><span class="line">        (&#39;&#x2F;login&#x2F;&#39;, login),</span><br><span class="line">    )</span><br><span class="line"> </span><br><span class="line">    return urlpatterns</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def run_server(environ, start_response):</span><br><span class="line">    start_response(&#39;200 OK&#39;, [(&#39;Content-Type&#39;, &#39;text&#x2F;html&#39;)])</span><br><span class="line">    url &#x3D; environ[&#39;PATH_INFO&#39;]</span><br><span class="line">    urlpatterns &#x3D; routers()</span><br><span class="line">    func &#x3D; None</span><br><span class="line">    for item in urlpatterns:</span><br><span class="line">        if item[0] &#x3D;&#x3D; url:</span><br><span class="line">            func &#x3D; item[1]</span><br><span class="line">            break</span><br><span class="line">    if func:</span><br><span class="line">        return func()</span><br><span class="line">    else:</span><br><span class="line">        return &#39;404 not found&#39;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    httpd &#x3D; make_server(&#39;&#39;, 8000, run_server)</span><br><span class="line">    print &quot;Serving HTTP on port 8000...&quot;</span><br><span class="line">    httpd.serve_forever()</span><br></pre></td></tr></table></figure>
对于上述代码，虽然可以返回给用户HTML的内容以现实复杂的页面，但是还是存在问题：如何给用户返回动态内容？
- 自定义一套特殊的语法，进行替换
- 使用开源工具jinja2，遵循其指定语法
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cat index.html</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;&#123;&#123;name&#125;&#125;&lt;&#x2F;h1&gt;</span><br><span class="line"></span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &#123;% for item in user_list %&#125;</span><br><span class="line">        &lt;li&gt;&#123;&#123;item&#125;&#125;&lt;&#x2F;li&gt;</span><br><span class="line">        &#123;% endfor %&#125;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"> </span><br><span class="line">from wsgiref.simple_server import make_server</span><br><span class="line">from jinja2 import Template</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def index():</span><br><span class="line">    # return &#39;index&#39;</span><br><span class="line"> </span><br><span class="line">    # template &#x3D; Template(&#39;Hello &#123;&#123; name &#125;&#125;!&#39;)</span><br><span class="line">    # result &#x3D; template.render(name&#x3D;&#39;John Doe&#39;)</span><br><span class="line"> </span><br><span class="line">    f &#x3D; open(&#39;index.html&#39;)</span><br><span class="line">    result &#x3D; f.read()</span><br><span class="line">    template &#x3D; Template(result)</span><br><span class="line">    data &#x3D; template.render(name&#x3D;&#39;John Doe&#39;, user_list&#x3D;[&#39;alex&#39;, &#39;eric&#39;])</span><br><span class="line">    return data.encode(&#39;utf-8&#39;)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def login():</span><br><span class="line">    # return &#39;login&#39;</span><br><span class="line">    f &#x3D; open(&#39;login.html&#39;)</span><br><span class="line">    data &#x3D; f.read()</span><br><span class="line">    return data</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def routers():</span><br><span class="line"> </span><br><span class="line">    urlpatterns &#x3D; (</span><br><span class="line">        (&#39;&#x2F;index&#x2F;&#39;, index),</span><br><span class="line">        (&#39;&#x2F;login&#x2F;&#39;, login),</span><br><span class="line">    )</span><br><span class="line"> </span><br><span class="line">    return urlpatterns</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def run_server(environ, start_response):</span><br><span class="line">    start_response(&#39;200 OK&#39;, [(&#39;Content-Type&#39;, &#39;text&#x2F;html&#39;)])</span><br><span class="line">    url &#x3D; environ[&#39;PATH_INFO&#39;]</span><br><span class="line">    urlpatterns &#x3D; routers()</span><br><span class="line">    func &#x3D; None</span><br><span class="line">    for item in urlpatterns:</span><br><span class="line">        if item[0] &#x3D;&#x3D; url:</span><br><span class="line">            func &#x3D; item[1]</span><br><span class="line">            break</span><br><span class="line">    if func:</span><br><span class="line">        return func()</span><br><span class="line">    else:</span><br><span class="line">        return &#39;404 not found&#39;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    httpd &#x3D; make_server(&#39;&#39;, 8000, run_server)</span><br><span class="line">    print &quot;Serving HTTP on port 8000...&quot;</span><br><span class="line">    httpd.serve_forever()</span><br></pre></td></tr></table></figure>
遵循jinja2的语法规则，其内部会对指定的语法进行相应的替换，从而达到动态的返回内容;
对于模板引擎的本质，参考: [白话tornado源码之褪去模板外衣的前戏](http://www.cnblogs.com/wupeiqi/p/4592637.html)


<p><a href="http://www.cnblogs.com/wupeiqi/articles/5237672.html" target="_blank" rel="noopener">原文</a></p>
]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>PYTHON</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx反向代理WebSocket</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h2 id="nginx反向代理WebSocket"><a href="#nginx反向代理WebSocket" class="headerlink" title="nginx反向代理WebSocket"></a>nginx反向代理WebSocket</h2><p>WebSocket协议相比较于HTTP协议成功握手后可以多次进行通讯，直到连接被关闭。但是WebSocket中的握手和HTTP中的握手兼容， 它使用HTTP中的Upgrade协议头将连接从HTTP升级到WebSocket。这使得WebSocket程序可以更容易的使用现已存在的基础设施。</p>
<p>WebSocket工作在HTTP的80和443端口并使用前缀ws://或者wss://进行协议标注，在建立连接时使用HTTP/1.1的101状态码进行协议切换， 当前标准不支持两个客户端之间不借助HTTP直接建立Websocket连接。</p>
<p>更多Websocket的介绍可参考我写的 <a href="https://www.xncoding.com/2017/05/03/web/websocket.html" target="_blank" rel="noopener">聊一聊WebSocket</a> 一文。</p>
<p>开发小程序的时候需要用到WebSocket长连接和推送技术，但是必须使用wss，并且必须通过域名访问。这时候就需要用到nginx反向代理了。</p>
<p>原理<br>一般我们开发的WebSocket服务程序使用ws协议，明文的。但是怎样让它安全的通过互联网传输呢？这时候可以通过nginx在客户端和服务端直接做一个转发了， 客户端通过wss访问，然后nginx和服务端通过ws协议通信。如下图所示：<br><img src="https://note.youdao.com/yws/api/personal/file/WEB872589b7edcbe0044ec1631cab0703d6?method=download&shareKey=efc98eab8e0f8a600ed7c82f9f474976" alt="WS">  </p>
<p>配置<br>前提条件是你有一个域名，并且申请好了证书。</p>
<p>新建nginx配置文件/etc/nginx/conf.d/websocket.conf，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">map $http_upgrade $connection_upgrade &#123;</span><br><span class="line">    default upgrade;</span><br><span class="line">    &#39;&#39; close;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">upstream websocket &#123;</span><br><span class="line">    server localhost:8282; # appserver_ip:ws_port</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">     server_name test.enzhico.net;</span><br><span class="line">     listen 443 ssl;</span><br><span class="line">     location &#x2F; &#123;</span><br><span class="line">         proxy_pass http:&#x2F;&#x2F;websocket;</span><br><span class="line">         proxy_read_timeout 300s;</span><br><span class="line">         proxy_send_timeout 300s;</span><br><span class="line">         </span><br><span class="line">         proxy_set_header Host $host;</span><br><span class="line">         proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">         proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">         </span><br><span class="line">         proxy_http_version 1.1;</span><br><span class="line">         proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">         proxy_set_header Connection $connection_upgrade;</span><br><span class="line">     &#125;</span><br><span class="line">    ssl_certificate &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;test.enzhico.net&#x2F;fullchain.pem;</span><br><span class="line">    ssl_certificate_key &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;test.enzhico.net&#x2F;privkey.pem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之类解释一下关键配置部分：</p>
<p>最重要的就是在反向代理的配置中增加了如下两行，其它的部分和普通的HTTP反向代理没有任何差别。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">proxy_set_header Connection $connection_upgrade;</span><br></pre></td></tr></table></figure>
<p>这里面的关键部分在于HTTP的请求中多了如下头部：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br></pre></td></tr></table></figure>
<p>这两个字段表示请求服务器升级协议为WebSocket。服务器处理完请求后，响应如下报文：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 状态码为101</span><br><span class="line">HTTP&#x2F;1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: upgrade</span><br></pre></td></tr></table></figure>
<p>告诉客户端已成功切换协议，升级为Websocket协议。握手成功之后，服务器端和客户端便角色对等，就像普通的Socket一样，能够双向通信。 不再进行HTTP的交互，而是开始WebSocket的数据帧协议实现数据交换。</p>
<p>这里使用map指令可以将变量组合成为新的变量，会根据客户端传来的连接中是否带有Upgrade头来决定是否给源站传递Connection头， 这样做的方法比直接全部传递upgrade更加优雅。</p>
<p>默认情况下，连接将会在无数据传输60秒后关闭，proxy_read_timeout参数可以延长这个时间。源站通过定期发送ping帧以保持连接并确认连接是否还在使用。</p>
<p>两个超时参数<br>proxy_read_timeout</p>
<p>语法 proxy_read_timeout time 默认值 60s 上下文 http server location 说明 该指令设置与代理服务器的读超时时间。它决定了nginx会等待多长时间来获得请求的响应。 这个时间不是获得整个response的时间，而是两次reading操作的时间。</p>
<p>proxy_send_timeout</p>
<p>语法 proxy_send_timeout time 默认值 60s 上下文 http server location 说明 这个指定设置了发送请求给upstream服务器的超时时间。超时设置不是为了整个发送期间，而是在两次write操作期间。 如果超时后，upstream没有收到新的数据，nginx会关闭连接</p>
<p>多次代理转发<br>工作中遇见过一种情况，就是某个域名在移动网络下面访问不了，这样的话我需要通过一个前段代理服务器做转发，这样就涉及到两次代理。</p>
<p>比如访问的websocket服务URL为：</p>
<p>wss://test.enzhico.net<br>这个在腾讯云公网IP上面，所有网络都能访问。另外一个域名board.xncoding.com解析到电信网络，部署在网关中心，这个域名腾讯云可以访问到。</p>
<p>在腾讯云主机上面：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">map $http_upgrade $connection_upgrade &#123;</span><br><span class="line">    default upgrade;</span><br><span class="line">    &#39;&#39; close;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">     server_name test.enzhico.net;</span><br><span class="line">     location &#x2F; &#123;</span><br><span class="line">         proxy_pass http:&#x2F;&#x2F;board.xncoding.com;</span><br><span class="line">         proxy_read_timeout 300s;</span><br><span class="line">         proxy_send_timeout 300s;</span><br><span class="line">         #proxy_set_header Host $host;</span><br><span class="line">         proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">         proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">         proxy_http_version 1.1;</span><br><span class="line">         proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">         proxy_set_header Connection $connection_upgrade;</span><br><span class="line">    &#125;</span><br><span class="line">    listen 443 ssl; # managed by Certbot</span><br><span class="line">    ssl_certificate &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;test.enzhico.net&#x2F;fullchain.pem; # managed by Certbot</span><br><span class="line">    ssl_certificate_key &#x2F;etc&#x2F;letsencrypt&#x2F;live&#x2F;test.enzhico.net&#x2F;privkey.pem; # managed by Certbot</span><br><span class="line">    include &#x2F;etc&#x2F;letsencrypt&#x2F;options-ssl-nginx.conf; # managed by Certbot</span><br><span class="line">    ssl_dhparam &#x2F;etc&#x2F;letsencrypt&#x2F;ssl-dhparams.pem; # managed by Certbot</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面唯一要注意的是，把proxy_set_header Host $host;这一行注释掉了。</p>
<p>而在网关中心主机上面：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">map $http_upgrade $connection_upgrade &#123;</span><br><span class="line">    default upgrade;</span><br><span class="line">    &#39;&#39; close;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">upstream websocket &#123;</span><br><span class="line">    server localhost:8282; # appserver_ip:ws_port</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name board.xncoding.com;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;websocket;</span><br><span class="line">        proxy_read_timeout 300s;</span><br><span class="line">        proxy_send_timeout 300s;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_http_version 1.1;</span><br><span class="line">        proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">        proxy_set_header Connection $connection_upgrade;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只需要最外层使用wss协议，里面的交互都使用ws协议，所以监听80端口即可。</p>
<p><a href="https://www.xncoding.com/2018/03/12/fullstack/nginx-websocket.html#more" target="_blank" rel="noopener">原文地址</a>  </p>
<p>参考<br><a href="http://pankajmalhotra.com/Websockets-SSL-TLS-Termination-Using-NGINX-Proxy" target="_blank" rel="noopener">Websockets SSL/TLS Termination Using NGINX Proxy</a><br><a href="https://www.hi-linux.com/posts/42176.html" target="_blank" rel="noopener">配置Nginx反向代理WebSocket</a></p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx配置http强制跳转https</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h2 id="nginx配置http强制跳转https"><a href="#nginx配置http强制跳转https" class="headerlink" title="nginx配置http强制跳转https"></a>nginx配置http强制跳转https</h2><blockquote>
<p>很多网站虽然支持 https, 但是直接在浏览器地址栏输入网址后, 默认仍是以 http 协议去访问的, http 强制跳转 https 的需求应运而生, 以下介绍三种实现的方式</p>
</blockquote>
<h3 id="rewrite-方法"><a href="#rewrite-方法" class="headerlink" title="rewrite 方法"></a>rewrite 方法</h3><p>这是最常用的实现方法, 将所有 http 请求通过 rewrite 重定向到 https 即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;  </span><br><span class="line">    listen  80;</span><br><span class="line">    server_name docs.lvrui.io</span><br><span class="line">      </span><br><span class="line">    rewrite ^(.*)$  https:&#x2F;&#x2F;$host$1 permanent; </span><br><span class="line">    # return 302 https:&#x2F;&#x2F;$host$request_uri;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name docs.lvrui.io;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line">    access_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;docs.log  main;</span><br><span class="line">    ssl on;</span><br><span class="line">    ssl_certificate &#x2F;etc&#x2F;ssl&#x2F;docs.20150509.cn.crt;</span><br><span class="line">    ssl_certificate_key  &#x2F;etc&#x2F;ssl&#x2F;docs.20150509.cn.key;</span><br><span class="line">    error_page 404 &#x2F;404.html;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">	    root &#x2F;var&#x2F;www&#x2F;html&#x2F;docs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>497 状态码<br>error code 497: normal request was sent to HTTPS</p>
<p>在一个站点只允许 https 访问时, 如果使用 http 访问会报出497错误码</p>
<p>利用497状态码重定向到 https</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name docs.lvrui.io</span><br><span class="line">    </span><br><span class="line">    error_page 497  https:&#x2F;&#x2F;$host$uri?$args;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name docs.lvrui.io;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line">    access_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;docs.log  main;</span><br><span class="line">    ssl on;</span><br><span class="line">    ssl_certificate &#x2F;etc&#x2F;ssl&#x2F;docs.20150509.cn.crt;</span><br><span class="line">    ssl_certificate_key  &#x2F;etc&#x2F;ssl&#x2F;docs.20150509.cn.key;</span><br><span class="line">    error_page 404 &#x2F;404.html;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">	    root &#x2F;var&#x2F;www&#x2F;html&#x2F;docs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="index-html-刷新网页"><a href="#index-html-刷新网页" class="headerlink" title="index.html 刷新网页"></a>index.html 刷新网页</h3><p>上面两种方法均会耗费服务器资源, 我们使用 curl 来看下百度是如何实现的 baidu.com 向 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 的跳转</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl baidu.com -vv </span><br><span class="line">* Rebuilt URL to: baidu.com&#x2F;</span><br><span class="line">*   Trying 220.181.57.217...</span><br><span class="line">* TCP_NODELAY set</span><br><span class="line">* Connected to baidu.com (220.181.57.217) port 80 (#0)</span><br><span class="line">&gt; GET &#x2F; HTTP&#x2F;1.1</span><br><span class="line">&gt; Host: baidu.com</span><br><span class="line">&gt; User-Agent: curl&#x2F;7.51.0</span><br><span class="line">&gt; Accept: *&#x2F;*</span><br><span class="line">&gt; </span><br><span class="line">&lt; HTTP&#x2F;1.1 200 OK</span><br><span class="line">&lt; Date: Sat, 01 Apr 2017 06:32:35 GMT</span><br><span class="line">&lt; Server: Apache</span><br><span class="line">&lt; Last-Modified: Tue, 12 Jan 2010 13:48:00 GMT</span><br><span class="line">&lt; ETag: &quot;51-47cf7e6ee8400&quot;</span><br><span class="line">&lt; Accept-Ranges: bytes</span><br><span class="line">&lt; Content-Length: 81</span><br><span class="line">&lt; Cache-Control: max-age&#x3D;86400</span><br><span class="line">&lt; Expires: Sun, 02 Apr 2017 06:32:35 GMT</span><br><span class="line">&lt; Connection: Keep-Alive</span><br><span class="line">&lt; Content-Type: text&#x2F;html</span><br><span class="line">&lt; </span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;meta http-equiv&#x3D;&quot;refresh&quot; content&#x3D;&quot;0;url&#x3D;http:&#x2F;&#x2F;www.baidu.com&#x2F;&quot;&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line">* Curl_http_done: called premature &#x3D;&#x3D; 0</span><br><span class="line">* Connection #0 to host baidu.com left intact</span><br></pre></td></tr></table></figure>
<p>可以看到百度很巧妙的利用meta的刷新作用，将baidu.com跳转到<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a><br>同理, 我们也可以用这个特性来实现http向https的跳转</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># index.html</span><br><span class="line">&lt;html&gt;  </span><br><span class="line">    &lt;meta http-equiv&#x3D;&quot;refresh&quot; content&#x3D;&quot;0;url&#x3D;https:&#x2F;&#x2F;docs.lvrui.io&#x2F;&quot;&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name docs.lvrui.io;</span><br><span class="line">    </span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        # 将 index.html 文件放到下面的目录下</span><br><span class="line">        root &#x2F;var&#x2F;www&#x2F;html&#x2F;refresh&#x2F;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name docs.lvrui.io;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line">    access_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;docs.log  main;</span><br><span class="line">    ssl on;</span><br><span class="line">    ssl_certificate &#x2F;etc&#x2F;ssl&#x2F;docs.20150509.cn.crt;</span><br><span class="line">    ssl_certificate_key  &#x2F;etc&#x2F;ssl&#x2F;docs.20150509.cn.key;</span><br><span class="line">    error_page 404 &#x2F;404.html;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">	    root &#x2F;var&#x2F;www&#x2F;html&#x2F;docs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>python 魔术方法</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h2 id="python-魔术方法"><a href="#python-魔术方法" class="headerlink" title="python 魔术方法"></a>python 魔术方法</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在做python开发的过程中,我们大家都会遇到在class(类)中使用双下划线的方法,这些都是我们经常所说的”魔法”方法.这些方法可以对类添加特殊的功能,使用恰当可以很大的提升我们在开发过程中的便捷性,方便的进行扩展.</p>
<h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p>目前我们常见的魔法方法大致可分为以下几类：</p>
<ul>
<li>构造与初始化</li>
<li>类的表示</li>
<li>访问控制</li>
<li>比较操作</li>
<li>容器类操作</li>
<li>可调用对象</li>
<li>Pickling序列化</li>
</ul>
<p>我们这次主要介绍这几类常用魔法方法:</p>
<h4 id="1-构造与初始化"><a href="#1-构造与初始化" class="headerlink" title="1.构造与初始化"></a>1.构造与初始化</h4><p>__init__<br>构造方法是我们使用频率最高的魔法方法了，几乎在我们定义类的时候，都会去定义构造方法，它的主要作用就是在初始化一个对象时，定义这个对象的初始值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person(object):</span><br><span class="line">    def __init__(self, name, age):</span><br><span class="line">        self.name &#x3D; name</span><br><span class="line">        self.age &#x3D; age</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p1 &#x3D; Person(&#39;Jack&#39;, 25)</span><br><span class="line">p2 &#x3D; Person(&#39;shuke&#39;, 20)</span><br></pre></td></tr></table></figure>
<p>__new__</p>
<ol>
<li>事实上，当我们理解了<strong>new</strong>方法后，我们还可以利用它来做一些其他有趣的事情，比如实现 设计模式中的 单例模式(singleton)</li>
<li>依照Python官方文档的说法，<strong>new</strong>方法主要是当你继承一些不可变的class时(比如int, str, tuple)， 提供给你一个自定义这些类的实例化过程的途径。还有就是实现自定义的metaclass</li>
<li>这个方法我们一般很少定义，不过我们在一些开源框架中偶尔会遇到定义这个方法的类。实际上，这才是”真正的构造方法”，它会在对象实例化时第一个被调用，然后再调用<strong>init</strong>，它们的区别主要如下：</li>
</ol>
<ul>
<li><strong>new</strong>的第一个参数是cls，而<strong>init</strong>的第一个参数是self</li>
<li><strong>new</strong>返回值是一个实例，而<strong>init</strong>没有任何返回值，只做初始化操作</li>
<li><strong>new</strong>由于是返回一个实例对象，所以它可以给所有实例进行统一的初始化操作</li>
</ul>
<ol start="4">
<li>由于<strong>new</strong>优先于<strong>init</strong>调用，且返回一个实例，所以我们可以利用这种特性，每次返回同一个实例来实现一个单例类：</li>
</ol>
<p>__new__的作用:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class PositiveInteger(int):</span><br><span class="line"></span><br><span class="line">  def __init__(self, value):</span><br><span class="line"></span><br><span class="line">    super(PositiveInteger, self).__init__(self, abs(value))</span><br><span class="line"></span><br><span class="line">i &#x3D; PositiveInteger(-3)</span><br><span class="line"></span><br><span class="line">print(i)</span><br></pre></td></tr></table></figure>
<p>但运行后会发现，结果根本不是我们想的那样，我们仍然得到了-3。这是因为对于int这种不可变的对象，我们只有重载它的<strong>new</strong>方法才能起到自定义的作用。<br>修改后的代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class PositiveInteger(int):</span><br><span class="line"></span><br><span class="line">  def __new__(cls, value):</span><br><span class="line"></span><br><span class="line">    return super(PositiveInteger, cls).__new__(cls, abs(value))</span><br><span class="line"></span><br><span class="line">i &#x3D; PositiveInteger(-3)</span><br><span class="line"></span><br><span class="line">print(i)</span><br></pre></td></tr></table></figure>
<p>通过重载<strong>new</strong>方法，我们实现了需要的功能.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class g(float):</span><br><span class="line">    &quot;&quot;&quot;千克转克&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def __new__(cls, kg):</span><br><span class="line">        return float.__new__(cls, kg * 2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 50千克转为克</span><br><span class="line">a &#x3D; g(50)</span><br><span class="line">print(a)  # 100.0</span><br><span class="line">print(a + 100)  # 200.0 由于继承了float，所以可以直接运算，非常方便！</span><br></pre></td></tr></table></figure>


<p>用<strong>new</strong>来实现单例<br>因为类每一次实例化后产生的过程都是通过<strong>new</strong>来控制的，所以通过重载<strong>new</strong>方法，我们 可以很简单的实现单例模式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 写法一</span><br><span class="line">class Singleton(object):</span><br><span class="line">    def __new__(cls):</span><br><span class="line">        # 关键在于这，每一次实例化的时候，我们都只会返回这同一个instance对象</span><br><span class="line"></span><br><span class="line">        if not hasattr(cls, &#39;instance&#39;):</span><br><span class="line">            cls.instance &#x3D; super(Singleton, cls).__new__(cls)</span><br><span class="line"></span><br><span class="line">        return cls.instance</span><br><span class="line"></span><br><span class="line">obj1 &#x3D; Singleton()</span><br><span class="line">obj2 &#x3D; Singleton()</span><br><span class="line">obj1.attr1 &#x3D; &#39;value1&#39;</span><br><span class="line">print(obj1.attr1, obj2.attr1)</span><br><span class="line">print(obj1 is obj2)</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">value1 value1</span><br><span class="line">True</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">可以看到obj1和obj2是同一个实例。</span><br><span class="line"></span><br><span class="line"># 写法二</span><br><span class="line">class Singleton(object):</span><br><span class="line">    &quot;&quot;&quot;单例&quot;&quot;&quot;</span><br><span class="line">    _instance &#x3D; None</span><br><span class="line"></span><br><span class="line">    def __new__(cls, *args, **kwargs):</span><br><span class="line">        if not cls._instance:</span><br><span class="line">            cls._instance &#x3D; super(Singleton, cls).__new__(cls, *args, **kwargs)</span><br><span class="line">        return cls._instance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MySingleton(Singleton):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a &#x3D; MySingleton()</span><br><span class="line">b &#x3D; MySingleton()</span><br><span class="line">print(a is b)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">True</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<h4 id="2-del析构方法"><a href="#2-del析构方法" class="headerlink" title="2. del析构方法"></a>2. <strong>del</strong>析构方法</h4><p>这个方法代表析构方法，也就是在对象被垃圾回收时被调用。但是请注意，执行del x不一定会执行此方法。</p>
<p>由于Python是通过引用计数来进行垃圾回收的，也就是说，如果这个实例还是有被引用到，即使执行del销毁这个对象，但其引用计数还是大于0，所以不会触发执行<strong>del</strong>。<br>例子:<br>此时我们没有对实例进行任何操作时，<strong>del</strong>在程序退出后被调用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person(object):</span><br><span class="line">    def __del__(self):</span><br><span class="line">        print(&#39;__del__&#39;)</span><br><span class="line"></span><br><span class="line">a &#x3D; Person()</span><br><span class="line">print(&#39;exit&#39;)</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">exit</span><br><span class="line">__del__</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>
<p>由于此实例没有被其他对象所引用，当我们手动销毁这个实例时，<strong>del</strong>被调用后程序正常退出。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person(object):</span><br><span class="line">    def __del__(self):</span><br><span class="line">        print(&#39;__del__&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a &#x3D; Person()</span><br><span class="line">b &#x3D; a  # b引用a</span><br><span class="line">del a  # 手动销毁,不触发__del__</span><br><span class="line">print(&#39;exit&#39;)</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">exit</span><br><span class="line">__del__</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>
<p>此时实例有被其他对象引用，尽管我们手动销毁这个实例，但依然不会触发<strong>del</strong>方法，而是在程序正常退出后被调用执行。<br>为了保险起见，当我们在对文件、socket进行操作时，要想安全地关闭和销毁这些对象，最好是在try异常块后的finally中进行关闭和释放操作！</p>
<h4 id="3-类的表示"><a href="#3-类的表示" class="headerlink" title="3. 类的表示"></a>3. 类的表示</h4><p><strong>str</strong>/<strong>repr</strong><br>这两个魔法方法一般会放到一起进行讲解，它们的主要差别为：</p>
<p><strong>str</strong>强调可读性，而<strong>repr</strong>强调准确性/标准性<br><strong>str</strong>的目标人群是用户，而<strong>repr</strong>的目标人群是机器，它的结果是可以被执行的<br>%s调用<strong>str</strong>方法，而%r调用<strong>repr</strong>方法<br>来看几个例子，了解内置类实现这2个方法的效果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; &#39;hello&#39;</span><br><span class="line">&gt;&gt;&gt; str(a)</span><br><span class="line">&#39;hello&#39;</span><br><span class="line">&gt;&gt;&gt; &#39;%s&#39; % a   # 调用__str__</span><br><span class="line">&#39;hello&#39;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; repr(a)     # 对象a的标准表示，也就是a是如何创建的</span><br><span class="line">&quot;&#39;hello&#39;&quot;</span><br><span class="line">&gt;&gt;&gt; &#39;%r&#39; % a    # 调用__repr__ </span><br><span class="line">&quot;&#39;hello&#39;&quot;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; import datetime</span><br><span class="line">&gt;&gt;&gt; b &#x3D; datetime.datetime.now()</span><br><span class="line">&gt;&gt;&gt; str(b)</span><br><span class="line">&#39;2018-05-03 19:08:45.921879&#39;</span><br><span class="line">&gt;&gt;&gt; print(b)     # 等同于print str(b)</span><br><span class="line">2018-05-03 19:08:45.921879</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; repr(b)     # 展示对象b的标准创建方式(如何创建的 </span><br><span class="line">&#39;datetime.datetime(2018, 5, 3, 19, 8, 45, 921879)&#39;</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">datetime.datetime(2018, 5, 3, 19, 8, 45, 921879)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; c &#x3D; eval(repr(b))</span><br><span class="line">&gt;&gt;&gt; c</span><br><span class="line">datetime.datetime(2018, 5, 3, 19, 8, 45, 921879)</span><br></pre></td></tr></table></figure>
<p>从上面的例子可以看出这两个方法的主要区别，在实际中我们定义类时，一般这样定义即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person(object):</span><br><span class="line">    def __init__(self, name, age):</span><br><span class="line">        self.name &#x3D; name</span><br><span class="line">        self.age &#x3D; age</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        # 格式化，友好对用户展示</span><br><span class="line">        return &#39;name: %s, age: %s&#39; % (self.name, self.age)</span><br><span class="line"></span><br><span class="line">    def __repr__(self):</span><br><span class="line">        # 标准化展示</span><br><span class="line">        return &quot;Person(&#39;%s&#39;, %s)&quot; % (self.name, self.age)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">person &#x3D; Person(&#39;zhangsan&#39;, 20)</span><br><span class="line">print(str(person))      # name: zhangsan, age: 20</span><br><span class="line">print(&#39;%s&#39; % person)    # name: zhangsan, age: 20</span><br><span class="line">print(repr(person))     # Person(&#39;zhangsan&#39;, 20)</span><br><span class="line">print(&#39;%r&#39; % person)    # Person(&#39;zhangsan&#39;, 20)</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">name: zhangsan, age: 20</span><br><span class="line">name: zhangsan, age: 20</span><br><span class="line">Person(&#39;zhangsan&#39;, 20)</span><br><span class="line">Person(&#39;zhangsan&#39;, 20)</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>
<p>这里值得注意的是，如果只定义了<strong>str</strong>或<strong>repr</strong>其中一个，那会是什么结果？</p>
<p>如果只定义了<em>str__，那么repr(person)输出&lt;<em>_main</em></em>.Person object at 0x10783b400&gt;<br>如果只定义了<strong>repr</strong>，那么str(person)与repr(person)结果是相同的<br>也就是说，<strong>repr</strong>在表示类时，是一级的，如果只定义它，那么<strong>str</strong> = <strong>repr</strong>。<br>而<strong>str</strong>展示类时是次级的，用户可自定义类的展示格式，如果没有定义<strong>repr</strong>，那么repr(person)将会展示缺省的定义。</p>
<h4 id="4-对象判断"><a href="#4-对象判断" class="headerlink" title="4. 对象判断"></a>4. 对象判断</h4><p><strong>hash</strong>/<strong>eq</strong><br><strong>hash</strong>方法返回一个整数，用来表示该对象的唯一标识，配合<strong>eq</strong>方法判断两个对象是否相等(==)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person(object):</span><br><span class="line">    def __init__(self, uid):</span><br><span class="line">        self.uid &#x3D; uid</span><br><span class="line"></span><br><span class="line">    def __repr__(self):</span><br><span class="line">        return &#39;Person(%s)&#39; % self.uid</span><br><span class="line"></span><br><span class="line">    def __hash__(self):</span><br><span class="line">        return self.uid</span><br><span class="line"></span><br><span class="line">    def __eq__(self, other):</span><br><span class="line">        return self.uid &#x3D;&#x3D; other.uid</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p1 &#x3D; Person(1)</span><br><span class="line">p2 &#x3D; Person(1)</span><br><span class="line">print(p1 &#x3D;&#x3D; p2)</span><br><span class="line">p3 &#x3D; Person(2)</span><br><span class="line">print(set([p1, p2, p3]))  # 根据唯一标识去重输出 set([Person(1), Person(2)])</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">True</span><br><span class="line">&#123;Person(1), Person(2)&#125;</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>
<p>如果我们需要判断两个对象是否相等，只要我们重写<strong>hash</strong>和<strong>eq</strong>方法就可以完成此功能。此外使用set存放这些对象时，会根据这两个方法进行去重操作。</p>
<h4 id="5-对象布尔判断"><a href="#5-对象布尔判断" class="headerlink" title="5. 对象布尔判断"></a>5. 对象布尔判断</h4><p><strong>bool</strong><br>当调用bool(obj)时，会调用<strong>bool</strong>方法，返回True/False。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person(object):</span><br><span class="line">    def __init__(self, uid):</span><br><span class="line">        self.uid &#x3D; uid</span><br><span class="line"></span><br><span class="line">    def __bool__(self):</span><br><span class="line">        return self.uid &gt; 10</span><br><span class="line"></span><br><span class="line">p1 &#x3D; Person(1)</span><br><span class="line">p2 &#x3D; Person(15)</span><br><span class="line">print(bool(p1))  # False</span><br><span class="line">print(bool(p2))  # True</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">False</span><br><span class="line">True</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>
<p>⚠️: 在Python3中，<strong>nonzero</strong>被重命名<strong>bool</strong></p>
<h4 id="6-访问控制"><a href="#6-访问控制" class="headerlink" title="6. 访问控制"></a>6. 访问控制</h4><p>访问控制相关的魔法方法，主要涉及以下几个：</p>
<p><strong>setattr</strong>：通过.设置属性或setattr(key, value)<br><strong>getattr</strong>：访问不存在的属性<br><strong>delattr</strong>：删除某个属性<br><strong>getattribute</strong>：访问任意属性或方法<br>来看一个完整的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class Person(object):</span><br><span class="line">    def __setattr__(self, key, value):</span><br><span class="line">        &quot;&quot;&quot;属性赋值&quot;&quot;&quot;</span><br><span class="line">        if key not in (&#39;name&#39;, &#39;age&#39;):</span><br><span class="line">            return</span><br><span class="line">        if key &#x3D;&#x3D; &#39;age&#39; and value &lt; 0:</span><br><span class="line">            raise ValueError()</span><br><span class="line">        super(Person, self).__setattr__(key, value)</span><br><span class="line"></span><br><span class="line">    def __getattr__(self, key):</span><br><span class="line">        &quot;&quot;&quot;访问某个不存在的属性&quot;&quot;&quot;</span><br><span class="line">        return &#39;unknown&#39;</span><br><span class="line"></span><br><span class="line">    def __delattr__(self, key):</span><br><span class="line">        &quot;&quot;&quot;删除某个属性&quot;&quot;&quot;</span><br><span class="line">        if key &#x3D;&#x3D; &#39;name&#39;:</span><br><span class="line">            raise AttributeError()</span><br><span class="line">        super(Person, self).__delattr__(key)</span><br><span class="line"></span><br><span class="line">    def __getattribute__(self, key):</span><br><span class="line">        &quot;&quot;&quot;所有属性&#x2F;方法调用都经过这里&quot;&quot;&quot;</span><br><span class="line">        if key &#x3D;&#x3D; &#39;money&#39;:</span><br><span class="line">            return 100</span><br><span class="line">        if key &#x3D;&#x3D; &#39;hello&#39;:</span><br><span class="line">            return self.say</span><br><span class="line">        return super(Person, self).__getattribute__(key)</span><br><span class="line"></span><br><span class="line">    def say(self):</span><br><span class="line">        return &#39;hello&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p1 &#x3D; Person()</span><br><span class="line">p1.name &#x3D; &#39;zhangsan&#39;  # 调用__setattr__</span><br><span class="line">p1.age &#x3D; 20  # 调用__setattr__</span><br><span class="line">print(p1.name)  # zhangsan</span><br><span class="line">print(p1.age)  # 20</span><br><span class="line">setattr(p1, &#39;name&#39;, &#39;lisi&#39;)  # 调用__setattr__</span><br><span class="line">setattr(p1, &#39;age&#39;, 30)  # 调用__setattr__</span><br><span class="line">print(p1.name)  # lisi</span><br><span class="line">print(p1.age)  # 30</span><br><span class="line"></span><br><span class="line">p1.gender &#x3D; &#39;male&#39;  # __setattr__中忽略对gender赋值</span><br><span class="line">print(p1.gender)  # gender不存在,调用__getattr__返回：unknown</span><br><span class="line">print(p1.money)  # money不存在,在__getattribute__中返回100</span><br><span class="line">print(p1.say())  # hello</span><br><span class="line">print(p1.hello())  # hello,调用__getattribute__，间接调用say方法</span><br><span class="line"></span><br><span class="line">del p1.name  # __delattr__中引发AttributeError</span><br><span class="line">p2 &#x3D; Person()</span><br><span class="line">p2.age &#x3D; -1  # __setattr__中引发ValueError</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>setattr</strong><br>通过此方法，对象可在在对属性进行赋值时进行控制，所有的属性赋值都会经过它。<br>一般常用于对某些属性赋值的检查校验逻辑，例如age不能小于0，否则认为是非法数据等等。</li>
<li><strong>getattr</strong><br>很多同学以为此方法是和<strong>setattr</strong>完全对立的，其实不然！<br>这个方法只有在访问某个不存在的属性时才会被调用，看上面的例子，由于gender属性在赋值时，忽略了此字段的赋值操作，所以此属性是没有被成功赋值给对象的。当访问这个属性时，<strong>getattr</strong>被调用，返回unknown。</li>
<li><strong>del</strong><br>删除对象的某个属性时，此方法被调用。一般常用于某个属性必须存在，否则无法进行后续的逻辑操作，会重写此方法，对删除属性逻辑进行检查和校验。</li>
<li><strong>getattribute</strong><br>这个方法我们很少用到，它与<strong>getattr</strong>很容易混淆。它与前者的区别在于：<br><strong>getattr</strong>访问某个不存在的属性被调用，<strong>getattribute</strong>访问任意属性被调用<br><strong>getattr</strong>只针对属性访问，<strong>getattribute</strong>不仅针对所有属性访问，还包括方法调用<br>越是强大的魔法方法，责任越大，如果你不能正确使用它，最好还是不用为好，否则在出现问题时很难排查!</li>
</ol>
<p><a href="http://kaito-kidd.com/2017/02/22/python-magic-methods/" target="_blank" rel="noopener">参考原文</a><br><a href="http://kaito-kidd.com/2017/02/23/python-magic-methods-2/" target="_blank" rel="noopener">魔术方法二</a><br><a href="http://pycoders-weekly-chinese.readthedocs.io/en/latest/issue6/a-guide-to-pythons-magic-methods.html" target="_blank" rel="noopener">延伸</a></p>
]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>PYTHON</tag>
      </tags>
  </entry>
  <entry>
    <title>python单例模式</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h2 id="python单例模式"><a href="#python单例模式" class="headerlink" title="python单例模式"></a>python单例模式</h2><h2 id="一-什么是单例模式"><a href="#一-什么是单例模式" class="headerlink" title="一. 什么是单例模式"></a>一. 什么是单例模式</h2><p>单例模式（Singleton Pattern）是一种常用的软件设计模式，该模式的主要目的是确保某一个类只有一个实例存在。当你希望在整个系统中，某个类只能出现一个实例时，单例对象就能派上用场。</p>
<p>比如，某个服务器程序的配置信息存放在一个文件中，客户端通过一个 AppConfig 的类来读取配置文件的信息。如果在程序运行期间，有很多地方都需要使用配置文件的内容，也就是说，很多地方都需要创建 AppConfig 对象的实例，这就导致系统中存在多个 AppConfig 的实例对象，而这样会严重浪费内存资源，尤其是在配置文件内容很多的情况下。事实上，类似 AppConfig 这样的类，我们希望在程序运行期间只存在一个实例对象。</p>
<h2 id="二-如何实现单例模式"><a href="#二-如何实现单例模式" class="headerlink" title="二. 如何实现单例模式"></a>二. 如何实现单例模式</h2><p>在 Python 中，我们可以用多种方法来实现单例模式：<br>使用模块<br>使用 <strong>new</strong><br>使用装饰器（decorator）<br>使用元类（metaclass)</p>
<h3 id="2-1-使用模块"><a href="#2-1-使用模块" class="headerlink" title="2.1 使用模块"></a>2.1 使用模块</h3><p>其实，Python 的模块就是天然的单例模式，因为模块在第一次导入时，会生成 .pyc 文件，当第二次导入时，就会直接加载 .pyc 文件，而不会再次执行模块代码。因此，我们只需把相关的函数和数据定义在一个模块中，就可以获得一个单例对象了。如果我们真的想要一个单例类，可以考虑这样做:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># mysingleton.py</span><br><span class="line">class My_Singleton(object):</span><br><span class="line">    def foo(self):</span><br><span class="line">        pass</span><br><span class="line">        </span><br><span class="line">my_singleton &#x3D; My_Singleton()</span><br></pre></td></tr></table></figure>
<p>将上面的代码保存在文件 mysingleton.py 中，然后这样使用:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from mysingleton import my_singleton</span><br><span class="line">my_singleton.foo()</span><br></pre></td></tr></table></figure>

<h3 id="2-2-使用new"><a href="#2-2-使用new" class="headerlink" title="2.2 使用new"></a>2.2 使用<strong>new</strong></h3><p><strong>new</strong>()在<strong>init</strong>()之前被调用，用于生成实例对象。利用这个方法和类的属性的特点可以实现设计模式的单例模式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Singeton(object):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    单例模式</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def __new__(cls, *args, **kwargs):</span><br><span class="line">        if not hasattr(cls, &#39;_instance&#39;):</span><br><span class="line">            # orig &#x3D; super(Singeton, cls)</span><br><span class="line">            cls._instance &#x3D; super(Singeton, cls).__new__(cls, *args, **kwargs)</span><br><span class="line">        return cls._instance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MyCLass(Singeton):</span><br><span class="line">    a &#x3D; 1</span><br><span class="line"></span><br><span class="line">one &#x3D; MyCLass()</span><br><span class="line">two &#x3D; MyCLass()</span><br><span class="line">print(one is two)</span><br><span class="line">print(one &#x3D;&#x3D; two)</span><br><span class="line">print(id(one), id(two))</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">输出:</span><br><span class="line">True</span><br><span class="line">True</span><br><span class="line">4436793720 4436793720</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们将类的实例和一个类变量 _instance 关联起来，如果 cls._instance 为 None 则创建实例，否则直接返回 cls._instance</p>
<h3 id="2-3-共享属性"><a href="#2-3-共享属性" class="headerlink" title="2.3 共享属性"></a>2.3 共享属性</h3><p>创建实例时把所有实例的<strong>dict</strong>指向同一个字典,这样它们具有相同的属性和方法.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Borg(object):</span><br><span class="line">    _state &#x3D; &#123;&#125;</span><br><span class="line">    def __new__(cls, *args, **kw):</span><br><span class="line">        ob &#x3D; super(Borg, cls).__new__(cls, *args, **kw)</span><br><span class="line">        ob.__dict__ &#x3D; cls._state</span><br><span class="line">        return ob</span><br><span class="line"></span><br><span class="line">class MyClass2(Borg):</span><br><span class="line">    a &#x3D; 1</span><br><span class="line">    </span><br><span class="line"># 没明白该方式如何实现单例</span><br></pre></td></tr></table></figure>

<h3 id="2-4-装饰器方式"><a href="#2-4-装饰器方式" class="headerlink" title="2.4 装饰器方式"></a>2.4 装饰器方式</h3><p>我们知道，装饰器（decorator）可以动态地修改一个类或函数的功能。这里，我们也可以使用装饰器来装饰某个类，使其只能生成一个实例，代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from functools import wraps</span><br><span class="line"></span><br><span class="line">def singleton(cls):</span><br><span class="line">    instances &#x3D; &#123;&#125;</span><br><span class="line"></span><br><span class="line">    @wraps(cls)</span><br><span class="line">    def getinstance(*args, **kw):</span><br><span class="line">        if cls not in instances:</span><br><span class="line">            instances[cls] &#x3D; cls(*args, **kw)</span><br><span class="line">        return instances[cls]</span><br><span class="line"></span><br><span class="line">    return getinstance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@singleton</span><br><span class="line">class MyClass(object):</span><br><span class="line">    a &#x3D; 1</span><br><span class="line"></span><br><span class="line">one &#x3D; MyClass()</span><br><span class="line">two &#x3D; MyClass()</span><br><span class="line">print(one is two)</span><br><span class="line">print(one &#x3D;&#x3D; two)</span><br><span class="line">print(id(one), id(two))</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">True</span><br><span class="line">True</span><br><span class="line">4492352536 4492352536</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>
<p>在上面，我们定义了一个装饰器singleton，它返回了一个内部函数 getinstance，该函数会判断某个类是否在字典 instances 中，如果不存在，则会将 cls 作为 key，cls(*args, **kw)作为 value存到instances中,否则,直接返回 instances[cls]。</p>
<h3 id="2-5-使用metaclass"><a href="#2-5-使用metaclass" class="headerlink" title="2.5 使用metaclass"></a>2.5 使用metaclass</h3><p>元类（metaclass）可以控制类的创建过程，它主要做三件事：</p>
<ul>
<li>拦截类的创建</li>
<li>修改类的定义</li>
<li>返回修改后的类<br>使用元类实现单例模式的代码如下:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Singleton(type):</span><br><span class="line">    _instances &#x3D; &#123;&#125;</span><br><span class="line"></span><br><span class="line">    def __call__(cls, *args, **kwargs):</span><br><span class="line">        if cls not in cls._instances:</span><br><span class="line">            cls._instances[cls] &#x3D; super(Singleton, cls).__call__(*args, **kwargs)</span><br><span class="line">        return cls._instances[cls]</span><br><span class="line"></span><br><span class="line"># Python2</span><br><span class="line">class MyClass(object):</span><br><span class="line">    __metaclass__ &#x3D; Singleton</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Python3</span><br><span class="line">class MyClass(metaclass&#x3D;Singleton):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>PYTHON</tag>
      </tags>
  </entry>
  <entry>
    <title>python操作zabbix API</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h2 id="python操作zabbix-API"><a href="#python操作zabbix-API" class="headerlink" title="python操作zabbix API"></a>python操作zabbix API</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">import json</span><br><span class="line">import urllib2</span><br><span class="line">import sys</span><br><span class="line">class zabbixtools:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.url &#x3D; &quot;http:&#x2F;&#x2F;192.168.1.1&#x2F;zabbix&#x2F;api_jsonrpc.php&quot;</span><br><span class="line">        self.header &#x3D; &#123;&quot;Content-Type&quot;: &quot;application&#x2F;json&quot;&#125;</span><br><span class="line">        self.authID &#x3D; self.user_login()</span><br><span class="line">    def user_login(self):</span><br><span class="line">        data &#x3D; json.dumps(</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;jsonrpc&quot;: &quot;2.0&quot;,</span><br><span class="line">                    &quot;method&quot;: &quot;user.login&quot;,</span><br><span class="line">                    &quot;params&quot;: &#123;</span><br><span class="line">                        &quot;user&quot;: &quot;Admin&quot;,</span><br><span class="line">                        &quot;password&quot;: &quot;admin&quot;</span><br><span class="line">                        &#125;,</span><br><span class="line">                    &quot;id&quot;: 0</span><br><span class="line">                    &#125;)</span><br><span class="line">        request &#x3D; urllib2.Request(self.url,data)</span><br><span class="line">        for key in self.header:</span><br><span class="line">            request.add_header(key,self.header[key])</span><br><span class="line">        try:</span><br><span class="line">            result &#x3D; urllib2.urlopen(request)</span><br><span class="line">        except URLError as e:</span><br><span class="line">            print &quot;Auth Failed, Please Check Your Name And Password:&quot;,e.code</span><br><span class="line">        else:</span><br><span class="line">            response &#x3D; json.loads(result.read())</span><br><span class="line">            result.close()</span><br><span class="line">            authID &#x3D; response[&#39;result&#39;]</span><br><span class="line">            return authID</span><br><span class="line">    def get_data(self,data,hostip&#x3D;&quot;&quot;):</span><br><span class="line">        request &#x3D; urllib2.Request(self.url,data)</span><br><span class="line">        for key in self.header:</span><br><span class="line">            request.add_header(key,self.header[key])</span><br><span class="line">        try:</span><br><span class="line">            result &#x3D; urllib2.urlopen(request)</span><br><span class="line">        except URLError as e:</span><br><span class="line">            if hasattr(e, &#39;reason&#39;):</span><br><span class="line">                print &#39;We failed to reach a server.&#39;</span><br><span class="line">                print &#39;Reason: &#39;, e.reason</span><br><span class="line">            elif hasattr(e, &#39;code&#39;):</span><br><span class="line">                print &#39;The server could not fulfill the request.&#39;</span><br><span class="line">                print &#39;Error code: &#39;, e.code</span><br><span class="line">            return 0</span><br><span class="line">        else:</span><br><span class="line">            response &#x3D; json.loads(result.read())</span><br><span class="line">            result.close()</span><br><span class="line">            return response</span><br><span class="line">    def host_get(self,hostip):</span><br><span class="line">        #hostip &#x3D; raw_input(&quot;\033[1;35;40m%s\033[0m&quot; % &#39;Enter Your Check Host:Host_ip :&#39;)</span><br><span class="line">        data &#x3D; json.dumps(</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;jsonrpc&quot;: &quot;2.0&quot;,</span><br><span class="line">                    &quot;method&quot;: &quot;host.get&quot;,</span><br><span class="line">                    &quot;params&quot;: &#123;</span><br><span class="line">                        &quot;output&quot;:[&quot;hostid&quot;,&quot;name&quot;,&quot;status&quot;,&quot;host&quot;],</span><br><span class="line">                        &quot;filter&quot;: &#123;&quot;host&quot;: [hostip]&#125;</span><br><span class="line">                        &#125;,</span><br><span class="line">                    &quot;auth&quot;: self.authID,</span><br><span class="line">                    &quot;id&quot;: 1</span><br><span class="line">                &#125;)</span><br><span class="line">        res &#x3D; self.get_data(data)[&#39;result&#39;]</span><br><span class="line">        if (res !&#x3D; 0) and (len(res) !&#x3D; 0):</span><br><span class="line">            #for host in res:</span><br><span class="line">            host &#x3D; res[0]</span><br><span class="line">            if host[&#39;status&#39;] &#x3D;&#x3D; &#39;1&#39;:</span><br><span class="line">                print &quot;\t&quot;,&quot;\033[1;31;40m%s\033[0m&quot; % &quot;Host_IP:&quot;,&quot;\033[1;31;40m%s\033[0m&quot; %host[&#39;host&#39;].ljust(15),&#39;\t&#39;,&quot;\033[1;31;40m%s\033[0m&quot; % &quot;Host_Name:&quot;,&quot;\033[1;31;40m%s\033[0m&quot;% host[&#39;name&#39;].encode(&#39;GBK&#39;),&#39;\t&#39;,&quot;\033[1;31;40m%s\033[0m&quot; % u&#39;monitor&#39;.encode(&#39;GBK&#39;)</span><br><span class="line">                return host[&#39;hostid&#39;]</span><br><span class="line">            elif host[&#39;status&#39;] &#x3D;&#x3D; &#39;0&#39;:</span><br><span class="line">                print &quot;\t&quot;,&quot;\033[1;32;40m%s\033[0m&quot; % &quot;Host_IP:&quot;,&quot;\033[1;32;40m%s\033[0m&quot; %host[&#39;host&#39;].ljust(15),&#39;\t&#39;,&quot;\033[1;32;40m%s\033[0m&quot; % &quot;Host_Name:&quot;,&quot;\033[1;32;40m%s\033[0m&quot;% host[&#39;name&#39;].encode(&#39;GBK&#39;),&#39;\t&#39;,&quot;\033[1;32;40m%s\033[0m&quot; % u&#39;unmonitor&#39;.encode(&#39;GBK&#39;)</span><br><span class="line">                return host[&#39;hostid&#39;]</span><br><span class="line">            print</span><br><span class="line">        else:</span><br><span class="line">            print &#39;\t&#39;,&quot;\033[1;31;40m%s\033[0m&quot; % &quot;Get Host Error or cannot find this host,please check !&quot;</span><br><span class="line">            return 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def get_grouphost(self):</span><br><span class="line">        groupid &#x3D; raw_input(&quot;\033[1;35;40m%s\033[0m&quot; % &#39;Enter Your groupid:&#39;)</span><br><span class="line">        data &#x3D; json.dumps(</span><br><span class="line">            &#123;</span><br><span class="line">               &quot;jsonrpc&quot;:&quot;2.0&quot;,</span><br><span class="line">               &quot;method&quot;:&quot;host.get&quot;,</span><br><span class="line">               &quot;params&quot;:&#123;</span><br><span class="line">                   &quot;output&quot;:[&quot;hostid&quot;,&quot;name&quot;,&quot;status&quot;,&quot;host&quot;],</span><br><span class="line">                   #&quot;output&quot;: &quot;extend&quot;,</span><br><span class="line">                   #&quot;filter&quot;: &#123;&quot;host&quot;: [&quot;42.62.121.16&quot;]&#125;</span><br><span class="line">                   &quot;groupids&quot;:groupid,</span><br><span class="line">               &#125;,</span><br><span class="line">               &quot;auth&quot;: self.authID, </span><br><span class="line">               &quot;id&quot;:1,</span><br><span class="line">            &#125;)</span><br><span class="line">        res &#x3D; self.get_data(data)</span><br><span class="line">        if &#39;result&#39; in res.keys():</span><br><span class="line">            res &#x3D; res[&#39;result&#39;]</span><br><span class="line">            if (res !&#x3D;0) or (len(res) !&#x3D; 0):</span><br><span class="line">                print &quot;\033[1;32;40m%s\033[0m&quot; % &quot;Number Of Hosts: &quot;,&quot;\033[1;31;40m%d\033[0m&quot; % len(res)</span><br><span class="line">                for host in res:</span><br><span class="line">                    print &quot;Host ID:&quot;,host[&#39;hostid&#39;],&quot;Visible name:&quot;,host[&#39;name&#39;],&quot;Host-status:&quot;,host[&#39;status&#39;],&quot;HostName:&quot;,host[&#39;host&#39;]</span><br><span class="line">        else:</span><br><span class="line">            print &quot;The groupid does not exist, please check!&quot;</span><br><span class="line">            return 0</span><br><span class="line"></span><br><span class="line">    def get_hostlist(self):</span><br><span class="line">        data &#x3D; json.dumps(</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;jsonrpc&quot;:&quot;2.0&quot;,</span><br><span class="line">                    &quot;method&quot;:&quot;host.get&quot;,</span><br><span class="line">                    &quot;params&quot;:&#123;</span><br><span class="line">                        &quot;output&quot;:[&quot;hostid&quot;,&quot;name&quot;],</span><br><span class="line">                        &quot;filter&quot;:&#123;&quot;host&quot;:&quot;&quot;&#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;auth&quot;:self.authID, </span><br><span class="line">                &quot;id&quot;:1,</span><br><span class="line">            &#125;)</span><br><span class="line">        res &#x3D; self.get_data(data)</span><br><span class="line">        if &#39;result&#39; in res.keys():</span><br><span class="line">            res &#x3D; res[&#39;result&#39;]</span><br><span class="line">            if (res !&#x3D;0) or (len(res) !&#x3D; 0):</span><br><span class="line">                print &quot;\033[1;32;40m%s\033[0m&quot; % &quot;Number Of Hosts: &quot;,&quot;\033[1;31;40m%d\033[0m&quot; % len(res)</span><br><span class="line">                for host in res:</span><br><span class="line">                    print &quot;Host ID:&quot;,host[&#39;hostid&#39;].encode(&#39;UTF-8&#39;),&quot;Host Name:&quot;,host[&#39;name&#39;].encode(&#39;UTF-8&#39;)</span><br><span class="line">        else:</span><br><span class="line">            print &#39;\t&#39;,&quot;\033[1;31;40m%s\033[0m&quot; % &quot;Get hostlist Error or cannot find this host,please check !&quot;</span><br><span class="line">        return 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def host_del(self):</span><br><span class="line">        hostip &#x3D; raw_input(&quot;\033[1;35;40m%s\033[0m&quot; % &#39;Enter Your Check Host:Host_ip :&#39;)</span><br><span class="line">        hostid &#x3D; self.host_get(hostip)</span><br><span class="line">    print hostid</span><br><span class="line">        if hostid &#x3D;&#x3D; 0:</span><br><span class="line">            print &#39;\t&#39;,&quot;\033[1;31;40m%s\033[0m&quot; % &quot;This host cannot find in zabbix,please check it !&quot;</span><br><span class="line">            sys.exit()</span><br><span class="line">        data &#x3D; json.dumps(</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;jsonrpc&quot;: &quot;2.0&quot;,</span><br><span class="line">                    &quot;method&quot;: &quot;host.delete&quot;,</span><br><span class="line">                    &quot;params&quot;: [hostid],</span><br><span class="line">                    &quot;auth&quot;: self.authID,</span><br><span class="line">                    &quot;id&quot;: 1</span><br><span class="line">                &#125;)</span><br><span class="line">        res &#x3D; self.get_data(data)[&#39;result&#39;]</span><br><span class="line">        if &#39;hostids&#39; in res.keys():</span><br><span class="line">            print &quot;\t&quot;,&quot;\033[1;32;40m%s\033[0m&quot; % &quot;Delet Host:%s success !&quot; % hostip</span><br><span class="line">        else:</span><br><span class="line">            print &quot;\t&quot;,&quot;\033[1;31;40m%s\033[0m&quot; % &quot;Delet Host:%s failure !&quot; % hostip</span><br><span class="line">    def hostgroup_get(self):</span><br><span class="line">        data &#x3D; json.dumps(</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;jsonrpc&quot;: &quot;2.0&quot;,</span><br><span class="line">                    &quot;method&quot;: &quot;hostgroup.get&quot;,</span><br><span class="line">                    &quot;params&quot;: &#123;</span><br><span class="line">                        &quot;output&quot;: &quot;extend&quot;,</span><br><span class="line">                        &#125;,</span><br><span class="line">                    &quot;auth&quot;: self.authID,</span><br><span class="line">                    &quot;id&quot;: 1,</span><br><span class="line">                    &#125;)</span><br><span class="line">        res &#x3D; self.get_data(data)</span><br><span class="line">        if &#39;result&#39; in res.keys():</span><br><span class="line">            res &#x3D; res[&#39;result&#39;]</span><br><span class="line">            if (res !&#x3D;0) or (len(res) !&#x3D; 0):</span><br><span class="line">                print &quot;\033[1;32;40m%s\033[0m&quot; % &quot;Number Of Group: &quot;,&quot;\033[1;31;40m%d\033[0m&quot; % len(res)</span><br><span class="line">                for host in res:</span><br><span class="line">                    print&quot;\t&quot;,&quot;HostGroup_id:&quot;,host[&#39;groupid&#39;],&quot;\t&quot;,&quot;HostGroup_Name:&quot;,host[&#39;name&#39;].encode(&#39;GBK&#39;)</span><br><span class="line">        else:</span><br><span class="line">            print &quot;Get HostGroup Error,please check !&quot;</span><br><span class="line">    def template_get(self):</span><br><span class="line">        data &#x3D; json.dumps(</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;jsonrpc&quot;: &quot;2.0&quot;,</span><br><span class="line">                    &quot;method&quot;: &quot;template.get&quot;,</span><br><span class="line">                    &quot;params&quot;: &#123;</span><br><span class="line">                        &quot;output&quot;: &quot;extend&quot;,</span><br><span class="line">                        &#125;,</span><br><span class="line">                    &quot;auth&quot;: self.authID,</span><br><span class="line">                    &quot;id&quot;: 1,</span><br><span class="line">                    &#125;)</span><br><span class="line">        res &#x3D; self.get_data(data)#[&#39;result&#39;]</span><br><span class="line">        if &#39;result&#39; in res.keys():</span><br><span class="line">            res &#x3D; res[&#39;result&#39;]</span><br><span class="line">            if (res !&#x3D;0) or (len(res) !&#x3D; 0):</span><br><span class="line">                print &quot;\033[1;32;40m%s\033[0m&quot; % &quot;Number Of Template: &quot;,&quot;\033[1;31;40m%d\033[0m&quot; % len(res)</span><br><span class="line">                for host in res:</span><br><span class="line">                    print&quot;\t&quot;,&quot;Template_id:&quot;,host[&#39;templateid&#39;],&quot;\t&quot;,&quot;Template_Name:&quot;,host[&#39;name&#39;].encode(&#39;GBK&#39;)</span><br><span class="line">                print</span><br><span class="line">        else:</span><br><span class="line">            print &quot;Get Template Error,please check !&quot;</span><br><span class="line">    def host_create(self):</span><br><span class="line">        hostip &#x3D; raw_input(&quot;\033[1;35;40m%s\033[0m&quot; % &#39;Enter your:Host_ip :&#39;)</span><br><span class="line">        #Visible_name &#x3D; raw_input(&quot;\033[1;35;40m%s\033[0m&quot; % &#39;Enter your:Visible name :&#39;)</span><br><span class="line">        groupid &#x3D; raw_input(&quot;\033[1;35;40m%s\033[0m&quot; % &#39;Enter your:Group_id :&#39;)</span><br><span class="line">        templateid &#x3D; raw_input(&quot;\033[1;35;40m%s\033[0m&quot; % &#39;Enter your:Tempate_id :&#39;)</span><br><span class="line">        g_list&#x3D;[]</span><br><span class="line">        t_list&#x3D;[]</span><br><span class="line">        for i in groupid.split(&#39;,&#39;):</span><br><span class="line">            var &#x3D; &#123;&#125;</span><br><span class="line">            var[&#39;groupid&#39;] &#x3D; i</span><br><span class="line">            g_list.append(var)</span><br><span class="line">        for i in templateid.split(&#39;,&#39;):</span><br><span class="line">            var &#x3D; &#123;&#125;</span><br><span class="line">            var[&#39;templateid&#39;] &#x3D; i</span><br><span class="line">            t_list.append(var)</span><br><span class="line">        if hostip and groupid and templateid:</span><br><span class="line">            data &#x3D; json.dumps(</span><br><span class="line">                    &#123;</span><br><span class="line">                        &quot;jsonrpc&quot;: &quot;2.0&quot;,</span><br><span class="line">                        &quot;method&quot;: &quot;host.create&quot;,</span><br><span class="line">                        &quot;params&quot;: &#123;</span><br><span class="line">                            &quot;host&quot;: hostip,</span><br><span class="line">                            &quot;interfaces&quot;: [</span><br><span class="line">                                &#123;</span><br><span class="line">                                    &quot;type&quot;: 1,</span><br><span class="line">                                    &quot;main&quot;: 1,</span><br><span class="line">                                    &quot;useip&quot;: 1,</span><br><span class="line">                                    &quot;ip&quot;: hostip,</span><br><span class="line">                                    &quot;dns&quot;: &quot;&quot;,</span><br><span class="line">                                    &quot;port&quot;: &quot;10050&quot;</span><br><span class="line">                                &#125;</span><br><span class="line">                            ],</span><br><span class="line">                            &quot;groups&quot;: g_list,</span><br><span class="line">                            &quot;templates&quot;: t_list,</span><br><span class="line">                    &#125;,</span><br><span class="line">                        &quot;auth&quot;: self.authID,</span><br><span class="line">                        &quot;id&quot;: 1,</span><br><span class="line">                        &#125;)</span><br><span class="line">            res &#x3D; self.get_data(data,hostip)</span><br><span class="line">            if &#39;result&#39; in res.keys():</span><br><span class="line">                res &#x3D; res[&#39;result&#39;]</span><br><span class="line">                if &#39;hostids&#39; in res.keys():</span><br><span class="line">                    print &quot;\033[1;32;40m%s\033[0m&quot; % &quot;Create host success&quot;</span><br><span class="line">            else:</span><br><span class="line">                print &quot;\033[1;31;40m%s\033[0m&quot; % &quot;Create host failure: %s&quot; % res[&#39;error&#39;][&#39;data&#39;]</span><br><span class="line">        else:</span><br><span class="line">            print &quot;\033[1;31;40m%s\033[0m&quot; % &quot;Enter Error: ip or groupid or tempateid is NULL,please check it !&quot;</span><br><span class="line">def main():</span><br><span class="line">    test &#x3D; zabbixtools()</span><br><span class="line">    #test.template_get()</span><br><span class="line">    #test.hostgroup_get()</span><br><span class="line">    #test.host_get()</span><br><span class="line">    #test.host_del()</span><br><span class="line">    #test.host_create()</span><br><span class="line">    #test.get_grouphost()</span><br><span class="line">    #test.get_hostlist()</span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>PYTHON</tag>
      </tags>
  </entry>
  <entry>
    <title>python操作Redis</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h2 id="python操作Redis"><a href="#python操作Redis" class="headerlink" title="python操作Redis"></a>python操作Redis</h2><h2 id="一-Redis是什么"><a href="#一-Redis是什么" class="headerlink" title="一. Redis是什么"></a>一. Redis是什么</h2><blockquote>
<p>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）<br><a href="https://github.com/CyC2018/Interview-Notebook/blob/master/notes/Redis.md" target="_blank" rel="noopener">Interview-Notebook/Redis.md-Notebook-GitHub</a><br><a href="http://www.redis.cn/" target="_blank" rel="noopener">redis.cn</a>   </p>
</blockquote>
<h2 id="二-Redis基本介绍"><a href="#二-Redis基本介绍" class="headerlink" title="二. Redis基本介绍"></a>二. Redis基本介绍</h2><blockquote>
<p>redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步</p>
</blockquote>
<h3 id="2-1-Redis的安装和基本使用"><a href="#2-1-Redis的安装和基本使用" class="headerlink" title="2.1 Redis的安装和基本使用"></a>2.1 Redis的安装和基本使用</h3><ul>
<li>安装<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-3.0.6.tar.gz</span><br><span class="line">tar xzf redis-3.0.6.tar.gz</span><br><span class="line">cd redis-3.0.6</span><br><span class="line">make</span><br></pre></td></tr></table></figure></li>
<li>启动服务端<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">src&#x2F;redis-server</span><br></pre></td></tr></table></figure></li>
<li>启动客户端<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">src&#x2F;redis-cli</span><br><span class="line">redis&gt; set foo bar</span><br><span class="line">OK</span><br><span class="line">redis&gt; get foo</span><br><span class="line">&quot;bar&quot;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-2-python操作redis"><a href="#2-2-python操作redis" class="headerlink" title="2.2 python操作redis"></a>2.2 python操作redis</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install redis</span><br><span class="line">or</span><br><span class="line">easy_install redis</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/WoLpH/redis-py" target="_blank" rel="noopener">GitHub - WoLpH/redis-py: Redis Python Client-源码安装</a></p>
<h2 id="三-API使用"><a href="#三-API使用" class="headerlink" title="三. API使用"></a>三. API使用</h2><p>redis-py 的API的使用可以分类为:</p>
<ul>
<li>连接方式<ul>
<li>直接连接</li>
<li>连接池</li>
</ul>
</li>
<li>操作<ul>
<li>String 操作</li>
<li>Hash 操作</li>
<li>List 操作</li>
<li>Set 操作</li>
<li>Sort Set 操作</li>
</ul>
</li>
<li>管道</li>
<li>发布订阅</li>
</ul>
<h2 id="四-连接方式"><a href="#四-连接方式" class="headerlink" title="四. 连接方式"></a>四. 连接方式</h2><h3 id="4-1-操作模式"><a href="#4-1-操作模式" class="headerlink" title="4.1 操作模式"></a>4.1 操作模式</h3><p>redis-py提供两个类Redis和StrictRedis用于实现Redis的命令，StrictRedis用于实现大部分官方的命令，并使用官方的语法和命令，Redis是StrictRedis的子类，用于向后兼容旧版本的redis-py</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"> </span><br><span class="line">import redis</span><br><span class="line"></span><br><span class="line">r &#x3D; redis.Redis(host&#x3D;&#39;127.0.0.1&#39;, port&#x3D;6379)</span><br><span class="line">r.set(&#39;foo&#39;, &#39;Bar&#39;)</span><br><span class="line">print(r.get(&#39;foo&#39;))</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">b&#39;Bar&#39;</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>
<p>连接redis，加上decode_responses=True,写入键值对中的value为str类型，不加这个参数写入的则为字节类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import redis</span><br><span class="line"></span><br><span class="line">r &#x3D; redis.Redis(host&#x3D;&#39;127.0.0.1&#39;, port&#x3D;6379, decode_responses&#x3D;True)</span><br><span class="line">r.set(&#39;name&#39;, &#39;shuke&#39;)</span><br><span class="line">print(r.get(&#39;name&#39;))</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">shuke</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-连接池"><a href="#4-2-连接池" class="headerlink" title="4.2 连接池"></a>4.2 连接池</h3><p>redis-py使用connection pool来管理对一个redis server的所有连接，避免每次建立、释放连接的开销。默认，每个Redis实例都会维护一个自己的连接池。可以直接建立一个连接池，然后作为参数Redis，这样就可以实现多个Redis实例共享一个连接池</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"> </span><br><span class="line">import redis</span><br><span class="line"></span><br><span class="line">pool &#x3D; redis.ConnectionPool(host&#x3D;&#39;127.0.0.1&#39;, port&#x3D;6379, decode_responses&#x3D;True)</span><br><span class="line"></span><br><span class="line">r &#x3D; redis.Redis(connection_pool&#x3D;pool)</span><br><span class="line">r.set(&#39;book&#39;, &#39;西游记&#39;)</span><br><span class="line">print(r.get(&#39;book&#39;))</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">西游记</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<h2 id="五-String-操作"><a href="#五-String-操作" class="headerlink" title="五. String 操作"></a>五. String 操作</h2><p>String操作，redis中的String在在内存中按照一个name对应一个value来存储<br>Key|–&gt;|Value|<br>—-|—-|—-<br>k1|–&gt;|v1<br>k2|–&gt;|v2<br>k3|–&gt;|v3</p>
<ul>
<li>set(name, value, ex=None, px=None, nx=False, xx=False)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在Redis中设置值，默认，不存在则创建，存在则修改</span><br><span class="line">参数：</span><br><span class="line">     ex，过期时间（秒）</span><br><span class="line">     px，过期时间（毫秒）</span><br><span class="line">     nx，如果设置为True，则只有name不存在时，当前set操作才执行</span><br><span class="line">     xx，如果设置为True，则只有name存在时，岗前set操作才执行</span><br></pre></td></tr></table></figure></li>
<li>setnx(name, value)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">设置值，只有name不存在时，执行设置操作(添加)</span><br></pre></td></tr></table></figure></li>
<li>setex(name, value, time)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 设置值</span><br><span class="line"># 参数：</span><br><span class="line">    # time，过期时间（数字秒 或 timedelta对象）</span><br><span class="line">&#96;&#96;&#96;&#96;    </span><br><span class="line">- psetex(name, time_ms, value)</span><br></pre></td></tr></table></figure>
<h1 id="设置值"><a href="#设置值" class="headerlink" title="设置值"></a>设置值</h1><h1 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h1><h1 id="time-ms，过期时间（数字毫秒-或-timedelta对象）"><a href="#time-ms，过期时间（数字毫秒-或-timedelta对象）" class="headerlink" title="time_ms，过期时间（数字毫秒 或 timedelta对象）"></a>time_ms，过期时间（数字毫秒 或 timedelta对象）</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- mset(args, *kwargs)</span><br></pre></td></tr></table></figure>
批量设置值<br>如：<br>  mset(k1=’v1’, k2=’v2’)<br>  或<br>  mset({‘k1’: ‘v1’, ‘k2’: ‘v2’})<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- get(name)</span><br></pre></td></tr></table></figure>
获取值<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- mget(keys, *args)</span><br></pre></td></tr></table></figure>
批量获取<br>如：<br>  mget(‘name’, ‘shuke’)<br>  或<br>  r.mget([‘name’, ‘shuke’])<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- getset(name, value)</span><br></pre></td></tr></table></figure>
设置新值并获取原来的值<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- getrange(key, start, end)</span><br></pre></td></tr></table></figure>
<h1 id="获取子序列（根据字节获取，非字符）"><a href="#获取子序列（根据字节获取，非字符）" class="headerlink" title="获取子序列（根据字节获取，非字符）"></a>获取子序列（根据字节获取，非字符）</h1><h1 id="参数：-1"><a href="#参数：-1" class="headerlink" title="参数："></a>参数：</h1><h1 id="name，Redis-的-name"><a href="#name，Redis-的-name" class="headerlink" title="name，Redis 的 name"></a>name，Redis 的 name</h1><h1 id="start，起始位置（字节）"><a href="#start，起始位置（字节）" class="headerlink" title="start，起始位置（字节）"></a>start，起始位置（字节）</h1><h1 id="end，结束位置（字节）"><a href="#end，结束位置（字节）" class="headerlink" title="end，结束位置（字节）"></a>end，结束位置（字节）</h1><h1 id="如：-“武大郎”-，0-3表示-“武”"><a href="#如：-“武大郎”-，0-3表示-“武”" class="headerlink" title="如： “武大郎” ，0-3表示 “武”"></a>如： “武大郎” ，0-3表示 “武”</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- setrange(name, offset, value)</span><br></pre></td></tr></table></figure>
<h1 id="修改字符串内容，从指定字符串索引开始向后替换（新值太长时，则向后添加）"><a href="#修改字符串内容，从指定字符串索引开始向后替换（新值太长时，则向后添加）" class="headerlink" title="修改字符串内容，从指定字符串索引开始向后替换（新值太长时，则向后添加）"></a>修改字符串内容，从指定字符串索引开始向后替换（新值太长时，则向后添加）</h1><h1 id="参数：-2"><a href="#参数：-2" class="headerlink" title="参数："></a>参数：</h1><h1 id="offset，字符串的索引，字节（一个汉字三个字节）"><a href="#offset，字符串的索引，字节（一个汉字三个字节）" class="headerlink" title="offset，字符串的索引，字节（一个汉字三个字节）"></a>offset，字符串的索引，字节（一个汉字三个字节）</h1><h1 id="value，要设置的值"><a href="#value，要设置的值" class="headerlink" title="value，要设置的值"></a>value，要设置的值</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- setbit(name, offset, value)</span><br></pre></td></tr></table></figure>
<h1 id="对name对应值的二进制表示的位进行操作"><a href="#对name对应值的二进制表示的位进行操作" class="headerlink" title="对name对应值的二进制表示的位进行操作"></a>对name对应值的二进制表示的位进行操作</h1></li>
</ul>
<h1 id="参数：-3"><a href="#参数：-3" class="headerlink" title="参数："></a>参数：</h1><pre><code># name，redis的name
# offset，位的索引（将值变换成二进制后再进行索引）
# value，值只能是 1 或 0</code></pre><h1 id="注：如果在Redis中有一个对应：-n1-“foo”，"><a href="#注：如果在Redis中有一个对应：-n1-“foo”，" class="headerlink" title="注：如果在Redis中有一个对应： n1 = “foo”，"></a>注：如果在Redis中有一个对应： n1 = “foo”，</h1><pre><code>    那么字符串foo的二进制表示为：01100110 01101111 01101111
所以，如果执行 setbit(&apos;n1&apos;, 7, 1)，则就会将第7位设置为1，
    那么最终二进制则变成 01100111 01101111 01101111，即：&quot;goo&quot;</code></pre><h1 id="扩展，转换二进制表示："><a href="#扩展，转换二进制表示：" class="headerlink" title="扩展，转换二进制表示："></a>扩展，转换二进制表示：</h1><pre><code># source = &quot;武沛齐&quot;
source = &quot;foo&quot;

for i in source:
    num = ord(i)
    print bin(num).replace(&apos;b&apos;,&apos;&apos;)

特别的，如果source是汉字 &quot;武沛齐&quot;怎么办？
答：对于utf-8，每一个汉字占 3 个字节，那么 &quot;武沛齐&quot; 则有 9个字节
   对于汉字，for循环时候会按照 字节 迭代，那么在迭代时，将每一个字节转换 十进制数，然后再将十进制数转换成二进制
    11100110 10101101 10100110 11100110 10110010 10011011 11101001 10111101 10010000
    -------------------------- ----------------------------- -----------------------------
                武                         沛                           齐</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- getbit(name, offset)</span><br></pre></td></tr></table></figure>
<h1 id="获取name对应的值的二进制表示中的某位的值-（0或1）"><a href="#获取name对应的值的二进制表示中的某位的值-（0或1）" class="headerlink" title="获取name对应的值的二进制表示中的某位的值 （0或1）"></a>获取name对应的值的二进制表示中的某位的值 （0或1）</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- bitcount(key, start&#x3D;None, end&#x3D;None)</span><br></pre></td></tr></table></figure>
<h1 id="获取name对应的值的二进制表示中-1-的个数"><a href="#获取name对应的值的二进制表示中-1-的个数" class="headerlink" title="获取name对应的值的二进制表示中 1 的个数"></a>获取name对应的值的二进制表示中 1 的个数</h1><h1 id="参数：-4"><a href="#参数：-4" class="headerlink" title="参数："></a>参数：</h1><pre><code># key，Redis的name
# start，位起始位置
# end，位结束位置</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- bitop(operation, dest, *keys)</span><br></pre></td></tr></table></figure>
<h1 id="获取多个值，并将值做位运算，将最后的结果保存至新的name对应的值"><a href="#获取多个值，并将值做位运算，将最后的结果保存至新的name对应的值" class="headerlink" title="获取多个值，并将值做位运算，将最后的结果保存至新的name对应的值"></a>获取多个值，并将值做位运算，将最后的结果保存至新的name对应的值</h1><h1 id="参数：-5"><a href="#参数：-5" class="headerlink" title="参数："></a>参数：</h1><pre><code># operation,AND（并） 、 OR（或） 、 NOT（非） 、 XOR（异或）
# dest, 新的Redis的name
# *keys,要查找的Redis的name</code></pre><h1 id="如："><a href="#如：" class="headerlink" title="如："></a>如：</h1><pre><code>bitop(&quot;AND&quot;, &apos;new_name&apos;, &apos;n1&apos;, &apos;n2&apos;, &apos;n3&apos;)
# 获取Redis中n1,n2,n3对应的值，然后讲所有的值做位运算（求并集），然后将结果保存 new_name 对应的值中</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- strlen(name)</span><br></pre></td></tr></table></figure>
<h1 id="返回name对应值的字节长度（一个汉字3个字节）"><a href="#返回name对应值的字节长度（一个汉字3个字节）" class="headerlink" title="返回name对应值的字节长度（一个汉字3个字节）"></a>返回name对应值的字节长度（一个汉字3个字节）</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- incr(self, name, amount&#x3D;1)</span><br></pre></td></tr></table></figure>
<h1 id="自增-name对应的值，当name不存在时，则创建name＝amount，否则，则自增。"><a href="#自增-name对应的值，当name不存在时，则创建name＝amount，否则，则自增。" class="headerlink" title="自增 name对应的值，当name不存在时，则创建name＝amount，否则，则自增。"></a>自增 name对应的值，当name不存在时，则创建name＝amount，否则，则自增。</h1><h1 id="参数：-6"><a href="#参数：-6" class="headerlink" title="参数："></a>参数：</h1><pre><code># name,Redis的name
# amount,自增数（必须是整数）</code></pre><h1 id="注：同incrby"><a href="#注：同incrby" class="headerlink" title="注：同incrby"></a>注：同incrby</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- incrbyfloat(self, name, amount&#x3D;1.0)</span><br></pre></td></tr></table></figure>
<h1 id="自增-name对应的值，当name不存在时，则创建name＝amount，否则，则自增。-1"><a href="#自增-name对应的值，当name不存在时，则创建name＝amount，否则，则自增。-1" class="headerlink" title="自增 name对应的值，当name不存在时，则创建name＝amount，否则，则自增。"></a>自增 name对应的值，当name不存在时，则创建name＝amount，否则，则自增。</h1><h1 id="参数：-7"><a href="#参数：-7" class="headerlink" title="参数："></a>参数：</h1><pre><code># name,Redis的name
# amount,自增数（浮点型)</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- decr(self, name, amount&#x3D;1)</span><br></pre></td></tr></table></figure>
<h1 id="自减-name对应的值，当name不存在时，则创建name＝amount，否则，则自减。"><a href="#自减-name对应的值，当name不存在时，则创建name＝amount，否则，则自减。" class="headerlink" title="自减 name对应的值，当name不存在时，则创建name＝amount，否则，则自减。"></a>自减 name对应的值，当name不存在时，则创建name＝amount，否则，则自减。</h1><h1 id="参数：-8"><a href="#参数：-8" class="headerlink" title="参数："></a>参数：</h1><pre><code># name,Redis的name
# amount,自减数（整数）</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- append(key, value)</span><br></pre></td></tr></table></figure>
<h1 id="在redis-name对应的值后面追加内容"><a href="#在redis-name对应的值后面追加内容" class="headerlink" title="在redis name对应的值后面追加内容"></a>在redis name对应的值后面追加内容</h1><h1 id="参数：-9"><a href="#参数：-9" class="headerlink" title="参数："></a>参数：</h1><pre><code>key, redis的name
value, 要追加的字符串</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 六. Hash 操作</span><br><span class="line">在redis中存储的结构为下表所示:</span><br><span class="line">Key|--&gt;|Value|</span><br><span class="line">----|----|----</span><br><span class="line">n1|--&gt;|k1-v1</span><br><span class="line">n2|--&gt;|k2-v2</span><br><span class="line">n3|--&gt;|k3-v3</span><br><span class="line"></span><br><span class="line">### 6.1 hset(name, key, value)</span><br></pre></td></tr></table></figure>
<h1 id="name对应的hash中设置一个键值对（不存在，则创建；否则，修改）"><a href="#name对应的hash中设置一个键值对（不存在，则创建；否则，修改）" class="headerlink" title="name对应的hash中设置一个键值对（不存在，则创建；否则，修改）"></a>name对应的hash中设置一个键值对（不存在，则创建；否则，修改）</h1><h1 id="参数：-10"><a href="#参数：-10" class="headerlink" title="参数："></a>参数：</h1><pre><code># name，redis的name
# key，name对应的hash中的key
# value，name对应的hash中的value</code></pre><h1 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h1><pre><code># hsetnx(name, key, value),当name对应的hash中不存在当前key时则创建（相当于添加）</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 6.2 hmset(name, mapping)</span><br></pre></td></tr></table></figure>
<h1 id="在name对应的hash中批量设置键值对"><a href="#在name对应的hash中批量设置键值对" class="headerlink" title="在name对应的hash中批量设置键值对"></a>在name对应的hash中批量设置键值对</h1><h1 id="参数：-11"><a href="#参数：-11" class="headerlink" title="参数："></a>参数：</h1><pre><code># name，redis的name
# mapping，字典，如：{&apos;k1&apos;:&apos;v1&apos;, &apos;k2&apos;: &apos;v2&apos;}</code></pre><h1 id="如：-1"><a href="#如：-1" class="headerlink" title="如："></a>如：</h1><pre><code># r.hmset(&apos;xx&apos;, {&apos;k1&apos;:&apos;v1&apos;, &apos;k2&apos;: &apos;v2&apos;})</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 6.3 hget(name,key)</span><br></pre></td></tr></table></figure>
<h1 id="在name对应的hash中获取根据key获取value"><a href="#在name对应的hash中获取根据key获取value" class="headerlink" title="在name对应的hash中获取根据key获取value"></a>在name对应的hash中获取根据key获取value</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 6.4 hmget(name, keys, *args)</span><br></pre></td></tr></table></figure>
<h1 id="在name对应的hash中获取多个key的值"><a href="#在name对应的hash中获取多个key的值" class="headerlink" title="在name对应的hash中获取多个key的值"></a>在name对应的hash中获取多个key的值</h1><h1 id="参数：-12"><a href="#参数：-12" class="headerlink" title="参数："></a>参数：</h1><pre><code># name，reids对应的name
# keys，要获取key集合，如：[&apos;k1&apos;, &apos;k2&apos;, &apos;k3&apos;]
# *args，要获取的key，如：k1,k2,k3</code></pre><h1 id="如：-2"><a href="#如：-2" class="headerlink" title="如："></a>如：</h1><pre><code># r.mget(&apos;xx&apos;, [&apos;k1&apos;, &apos;k2&apos;])
# 或
# print r.hmget(&apos;xx&apos;, &apos;k1&apos;, &apos;k2&apos;)</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 6.5 hgetall(name)</span><br></pre></td></tr></table></figure>
<p>获取name对应hash的所有键值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 6.6 hlen(name)</span><br></pre></td></tr></table></figure>
<h1 id="获取name对应的hash中键值对的个数"><a href="#获取name对应的hash中键值对的个数" class="headerlink" title="获取name对应的hash中键值对的个数"></a>获取name对应的hash中键值对的个数</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 6.7 hkeys(name)</span><br></pre></td></tr></table></figure>
<h1 id="获取name对应的hash中所有的key的值"><a href="#获取name对应的hash中所有的key的值" class="headerlink" title="获取name对应的hash中所有的key的值"></a>获取name对应的hash中所有的key的值</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 6.8 hvals(name)</span><br></pre></td></tr></table></figure>
<h1 id="获取name对应的hash中所有的value的值"><a href="#获取name对应的hash中所有的value的值" class="headerlink" title="获取name对应的hash中所有的value的值"></a>获取name对应的hash中所有的value的值</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 6.9 hexists(name, key)</span><br></pre></td></tr></table></figure>
<h1 id="检查name对应的hash是否存在当前传入的key"><a href="#检查name对应的hash是否存在当前传入的key" class="headerlink" title="检查name对应的hash是否存在当前传入的key"></a>检查name对应的hash是否存在当前传入的key</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 6.10 hdel(name,\*keys)</span><br></pre></td></tr></table></figure>
<h1 id="将name对应的hash中指定key的键值对删除"><a href="#将name对应的hash中指定key的键值对删除" class="headerlink" title="将name对应的hash中指定key的键值对删除"></a>将name对应的hash中指定key的键值对删除</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 6.11 hincrby(name, key, amount&#x3D;1)</span><br></pre></td></tr></table></figure>
<h1 id="自增name对应的hash中的指定key的值，不存在则创建key-amount"><a href="#自增name对应的hash中的指定key的值，不存在则创建key-amount" class="headerlink" title="自增name对应的hash中的指定key的值，不存在则创建key=amount"></a>自增name对应的hash中的指定key的值，不存在则创建key=amount</h1><h1 id="参数：-13"><a href="#参数：-13" class="headerlink" title="参数："></a>参数：</h1><pre><code># name，redis中的name
# key， hash对应的key
# amount，自增数（整数）</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 6.12 hincrbyfloat(name, key, amount&#x3D;1.0)</span><br></pre></td></tr></table></figure>
<h1 id="自增name对应的hash中的指定key的值，不存在则创建key-amount-1"><a href="#自增name对应的hash中的指定key的值，不存在则创建key-amount-1" class="headerlink" title="自增name对应的hash中的指定key的值，不存在则创建key=amount"></a>自增name对应的hash中的指定key的值，不存在则创建key=amount</h1><h1 id="参数：-14"><a href="#参数：-14" class="headerlink" title="参数："></a>参数：</h1><pre><code># name，redis中的name
# key， hash对应的key
# amount，自增数（浮点数）</code></pre><h1 id="自增name对应的hash中的指定key的值，不存在则创建key-amount-2"><a href="#自增name对应的hash中的指定key的值，不存在则创建key-amount-2" class="headerlink" title="自增name对应的hash中的指定key的值，不存在则创建key=amount"></a>自增name对应的hash中的指定key的值，不存在则创建key=amount</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 6.13 hscan(name, cursor&#x3D;0, match&#x3D;None, count&#x3D;None)</span><br></pre></td></tr></table></figure>
<h1 id="增量式迭代获取，对于数据大的数据非常有用，hscan可以实现分片的获取数据，并非一次性将数据全部获取完，从而放置内存被撑爆"><a href="#增量式迭代获取，对于数据大的数据非常有用，hscan可以实现分片的获取数据，并非一次性将数据全部获取完，从而放置内存被撑爆" class="headerlink" title="增量式迭代获取，对于数据大的数据非常有用，hscan可以实现分片的获取数据，并非一次性将数据全部获取完，从而放置内存被撑爆"></a>增量式迭代获取，对于数据大的数据非常有用，hscan可以实现分片的获取数据，并非一次性将数据全部获取完，从而放置内存被撑爆</h1><h1 id="参数：-15"><a href="#参数：-15" class="headerlink" title="参数："></a>参数：</h1><pre><code># name，redis的name
# cursor，游标（基于游标分批取获取数据）
# match，匹配指定key，默认None 表示所有的key
# count，每次分片最少获取个数，默认None表示采用Redis的默认分片个数</code></pre><h1 id="如：-3"><a href="#如：-3" class="headerlink" title="如："></a>如：</h1><pre><code># 第一次：cursor1, data1 = r.hscan(&apos;xx&apos;, cursor=0, match=None, count=None)
# 第二次：cursor2, data1 = r.hscan(&apos;xx&apos;, cursor=cursor1, match=None, count=None)
# ...
# 直到返回值cursor的值为0时，表示数据已经通过分片获取完毕</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 6.14 hscan_iter(name, match&#x3D;None, count&#x3D;None)</span><br></pre></td></tr></table></figure>
<h1 id="利用yield封装hscan创建生成器，实现分批去redis中获取数据"><a href="#利用yield封装hscan创建生成器，实现分批去redis中获取数据" class="headerlink" title="利用yield封装hscan创建生成器，实现分批去redis中获取数据"></a>利用yield封装hscan创建生成器，实现分批去redis中获取数据</h1><h1 id="参数：-16"><a href="#参数：-16" class="headerlink" title="参数："></a>参数：</h1><pre><code># match，匹配指定key，默认None 表示所有的key
# count，每次分片最少获取个数，默认None表示采用Redis的默认分片个数</code></pre><h1 id="如：-4"><a href="#如：-4" class="headerlink" title="如："></a>如：</h1><pre><code># for item in r.hscan_iter(&apos;xx&apos;):
#     print(item)</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 七. List 操作</span><br><span class="line">在redis中存储的结构为下表所示:</span><br><span class="line">Key|--&gt;|Value|</span><br><span class="line">----|----|----</span><br><span class="line">n1|--&gt;|v1,v2</span><br><span class="line">n2|--&gt;|v3,v4</span><br><span class="line">n3|--&gt;|v5,v6</span><br><span class="line"></span><br><span class="line">### 7.1 lpush(name,values)</span><br></pre></td></tr></table></figure>
<h1 id="在name对应的list中添加元素，每个新的元素都添加到列表的最左边"><a href="#在name对应的list中添加元素，每个新的元素都添加到列表的最左边" class="headerlink" title="在name对应的list中添加元素，每个新的元素都添加到列表的最左边"></a>在name对应的list中添加元素，每个新的元素都添加到列表的最左边</h1><h1 id="如：-5"><a href="#如：-5" class="headerlink" title="如："></a>如：</h1><pre><code># r.lpush(&apos;oo&apos;, 11,22,33)
# 保存顺序为: 33,22,11</code></pre><h1 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h1><pre><code># rpush(name, values) 表示从右向左操作</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 7.2 lpushx(name,value)</span><br></pre></td></tr></table></figure>
<h1 id="在name对应的list中添加元素，只有name已经存在时，值添加到列表的最左边"><a href="#在name对应的list中添加元素，只有name已经存在时，值添加到列表的最左边" class="headerlink" title="在name对应的list中添加元素，只有name已经存在时，值添加到列表的最左边"></a>在name对应的list中添加元素，只有name已经存在时，值添加到列表的最左边</h1><h1 id="更多："><a href="#更多：" class="headerlink" title="更多："></a>更多：</h1><pre><code># rpushx(name, value) 表示从右向左操作</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 7.3 llen(name)</span><br></pre></td></tr></table></figure>
<h1 id="name对应的list元素的个数"><a href="#name对应的list元素的个数" class="headerlink" title="name对应的list元素的个数"></a>name对应的list元素的个数</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 7.4 linsert(name, where, refvalue, value))</span><br></pre></td></tr></table></figure>
<h1 id="在name对应的列表的某一个值前或后插入一个新值"><a href="#在name对应的列表的某一个值前或后插入一个新值" class="headerlink" title="在name对应的列表的某一个值前或后插入一个新值"></a>在name对应的列表的某一个值前或后插入一个新值</h1><h1 id="参数：-17"><a href="#参数：-17" class="headerlink" title="参数："></a>参数：</h1><pre><code># name，redis的name
# where，BEFORE或AFTER
# refvalue，标杆值，即：在它前后插入数据
# value，要插入的数据</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 7.5 r.lset(name, index, value)</span><br></pre></td></tr></table></figure>
<h1 id="对name对应的list中的某一个索引位置重新赋值"><a href="#对name对应的list中的某一个索引位置重新赋值" class="headerlink" title="对name对应的list中的某一个索引位置重新赋值"></a>对name对应的list中的某一个索引位置重新赋值</h1><h1 id="参数：-18"><a href="#参数：-18" class="headerlink" title="参数："></a>参数：</h1><pre><code># name，redis的name
# index，list的索引位置
# value，要设置的值</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 7.6 r.lrem(name, value, num)</span><br></pre></td></tr></table></figure>
<h1 id="在name对应的list中删除指定的值"><a href="#在name对应的list中删除指定的值" class="headerlink" title="在name对应的list中删除指定的值"></a>在name对应的list中删除指定的值</h1><h1 id="参数：-19"><a href="#参数：-19" class="headerlink" title="参数："></a>参数：</h1><pre><code># name，redis的name
# value，要删除的值
# num，  num=0，删除列表中所有的指定值；
       # num=2,从前到后，删除2个；
       # num=-2,从后向前，删除2个</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 7.7 lpop(name)</span><br></pre></td></tr></table></figure>
<h1 id="在name对应的列表的左侧获取第一个元素并在列表中移除，返回值则是第一个元素"><a href="#在name对应的列表的左侧获取第一个元素并在列表中移除，返回值则是第一个元素" class="headerlink" title="在name对应的列表的左侧获取第一个元素并在列表中移除，返回值则是第一个元素"></a>在name对应的列表的左侧获取第一个元素并在列表中移除，返回值则是第一个元素</h1><h1 id="更多：-1"><a href="#更多：-1" class="headerlink" title="更多："></a>更多：</h1><pre><code># rpop(name) 表示从右向左操作</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 7.8 lindex(name, index)</span><br></pre></td></tr></table></figure>
<p>在name对应的列表中根据索引获取列表元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 7.9 lrange(name, start, end)</span><br></pre></td></tr></table></figure>
<h1 id="在name对应的列表分片获取数据"><a href="#在name对应的列表分片获取数据" class="headerlink" title="在name对应的列表分片获取数据"></a>在name对应的列表分片获取数据</h1><h1 id="参数：-20"><a href="#参数：-20" class="headerlink" title="参数："></a>参数：</h1><pre><code># name，redis的name
# start，索引的起始位置
# end，索引结束位置</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 7.10 ltrim(name, start, end)</span><br></pre></td></tr></table></figure>
<h1 id="在name对应的列表中移除没有在start-end索引之间的值"><a href="#在name对应的列表中移除没有在start-end索引之间的值" class="headerlink" title="在name对应的列表中移除没有在start-end索引之间的值"></a>在name对应的列表中移除没有在start-end索引之间的值</h1><h1 id="参数：-21"><a href="#参数：-21" class="headerlink" title="参数："></a>参数：</h1><pre><code># name，redis的name
# start，索引的起始位置
# end，索引结束位置</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 7.11 rpoplpush(src, dst)</span><br></pre></td></tr></table></figure>
<h1 id="从一个列表取出最右边的元素，同时将其添加至另一个列表的最左边"><a href="#从一个列表取出最右边的元素，同时将其添加至另一个列表的最左边" class="headerlink" title="从一个列表取出最右边的元素，同时将其添加至另一个列表的最左边"></a>从一个列表取出最右边的元素，同时将其添加至另一个列表的最左边</h1><h1 id="参数：-22"><a href="#参数：-22" class="headerlink" title="参数："></a>参数：</h1><pre><code># src，要取数据的列表的name
# dst，要添加数据的列表的name</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 7.12 blpop(keys, timeout)</span><br></pre></td></tr></table></figure>
<h1 id="将多个列表排列，按照从左到右去pop对应列表的元素"><a href="#将多个列表排列，按照从左到右去pop对应列表的元素" class="headerlink" title="将多个列表排列，按照从左到右去pop对应列表的元素"></a>将多个列表排列，按照从左到右去pop对应列表的元素</h1><h1 id="参数：-23"><a href="#参数：-23" class="headerlink" title="参数："></a>参数：</h1><pre><code># keys，redis的name的集合
# timeout，超时时间，当元素所有列表的元素获取完之后，阻塞等待列表内有数据的时间（秒）, 0 表示永远阻塞</code></pre><h1 id="更多：-2"><a href="#更多：-2" class="headerlink" title="更多："></a>更多：</h1><pre><code># r.brpop(keys, timeout)，从右向左获取数据</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 7.13 brpoplpush(src, dst, timeout&#x3D;0)</span><br></pre></td></tr></table></figure>
<h1 id="从一个列表的右侧移除一个元素并将其添加到另一个列表的左侧"><a href="#从一个列表的右侧移除一个元素并将其添加到另一个列表的左侧" class="headerlink" title="从一个列表的右侧移除一个元素并将其添加到另一个列表的左侧"></a>从一个列表的右侧移除一个元素并将其添加到另一个列表的左侧</h1><h1 id="参数：-24"><a href="#参数：-24" class="headerlink" title="参数："></a>参数：</h1><pre><code># src，取出并要移除元素的列表对应的name
# dst，要插入元素的列表对应的name
# timeout，当src对应的列表中没有数据时，阻塞等待其有数据的超时时间（秒），0 表示永远阻塞</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 7.14 自定义增量迭代(非常重要，原生的模块没有提供支持)(***)</span><br></pre></td></tr></table></figure>
<h1 id="由于redis类库中没有提供对列表元素的增量迭代，如果想要循环name对应的列表的所有元素，那么就需要："><a href="#由于redis类库中没有提供对列表元素的增量迭代，如果想要循环name对应的列表的所有元素，那么就需要：" class="headerlink" title="由于redis类库中没有提供对列表元素的增量迭代，如果想要循环name对应的列表的所有元素，那么就需要："></a>由于redis类库中没有提供对列表元素的增量迭代，如果想要循环name对应的列表的所有元素，那么就需要：</h1><pre><code># 1、获取name对应的所有列表
# 2、循环列表</code></pre><h1 id="但是，如果列表非常大，那么就有可能在第一步时就将程序的内容撑爆，所有有必要自定义一个增量迭代的功能："><a href="#但是，如果列表非常大，那么就有可能在第一步时就将程序的内容撑爆，所有有必要自定义一个增量迭代的功能：" class="headerlink" title="但是，如果列表非常大，那么就有可能在第一步时就将程序的内容撑爆，所有有必要自定义一个增量迭代的功能："></a>但是，如果列表非常大，那么就有可能在第一步时就将程序的内容撑爆，所有有必要自定义一个增量迭代的功能：</h1><p>def list_iter(name):<br>    “””<br>    自定义redis列表增量迭代<br>    :param name: redis中的name，即：迭代name对应的列表<br>    :return: yield 返回 列表元素<br>    “””<br>    list_count = r.llen(name)<br>    for index in range(list_count):<br>        yield r.lindex(name, index)</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>for item in list_iter(‘pp’):<br>    print(item)</p>
<h1 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h1><p>def list_scan_iter(name):<br>    start = 0<br>    while True:<br>        vals = conn.lrange(name, start, start+3)<br>        start = start + 4<br>        if not vals:<br>            return<br>        for val in vals:<br>            yield val</p>
<p>result = list_scan_iter(‘users’)<br>                for item in result:<br>                    print(item)      </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 八. Set操作</span><br><span class="line">Set操作，Set集合就是不允许重复的列表</span><br><span class="line"></span><br><span class="line">### 8.1 sadd(name,values)</span><br></pre></td></tr></table></figure>
<h1 id="name对应的集合中添加元素"><a href="#name对应的集合中添加元素" class="headerlink" title="name对应的集合中添加元素"></a>name对应的集合中添加元素</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 8.2 scard(name)</span><br></pre></td></tr></table></figure>
<p>获取name对应的集合中元素个数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 8.3 sdiff(keys, \*args)</span><br></pre></td></tr></table></figure>
<p>在第一个name对应的集合中且不在其他name对应的集合的元素集合</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 8.4 sdiffstore(dest, keys, \*args)</span><br></pre></td></tr></table></figure>
<h1 id="获取第一个name对应的集合中且不在其他name对应的集合，再将其新加入到dest对应的集合中"><a href="#获取第一个name对应的集合中且不在其他name对应的集合，再将其新加入到dest对应的集合中" class="headerlink" title="获取第一个name对应的集合中且不在其他name对应的集合，再将其新加入到dest对应的集合中"></a>获取第一个name对应的集合中且不在其他name对应的集合，再将其新加入到dest对应的集合中</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 8.5 sinter(keys, \*args)</span><br></pre></td></tr></table></figure>
<h1 id="获取多一个name对应集合的并集"><a href="#获取多一个name对应集合的并集" class="headerlink" title="获取多一个name对应集合的并集"></a>获取多一个name对应集合的并集</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 8.6 sinterstore(dest, keys, *args)</span><br></pre></td></tr></table></figure>
<h1 id="获取多一个name对应集合的并集，再讲其加入到dest对应的集合中"><a href="#获取多一个name对应集合的并集，再讲其加入到dest对应的集合中" class="headerlink" title="获取多一个name对应集合的并集，再讲其加入到dest对应的集合中"></a>获取多一个name对应集合的并集，再讲其加入到dest对应的集合中</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 8.7 sismember(name, value)</span><br></pre></td></tr></table></figure>
<h1 id="检查value是否是name对应的集合的成员"><a href="#检查value是否是name对应的集合的成员" class="headerlink" title="检查value是否是name对应的集合的成员"></a>检查value是否是name对应的集合的成员</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 8.8 smembers(name)</span><br></pre></td></tr></table></figure>
<h1 id="获取name对应的集合的所有成员"><a href="#获取name对应的集合的所有成员" class="headerlink" title="获取name对应的集合的所有成员"></a>获取name对应的集合的所有成员</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 8.9 smove(src, dst, value)</span><br></pre></td></tr></table></figure>
<h1 id="将某个成员从一个集合中移动到另外一个集合"><a href="#将某个成员从一个集合中移动到另外一个集合" class="headerlink" title="将某个成员从一个集合中移动到另外一个集合"></a>将某个成员从一个集合中移动到另外一个集合</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 8.10 spop(name)</span><br></pre></td></tr></table></figure>
<h1 id="从集合的右侧（尾部）移除一个成员，并将其返回"><a href="#从集合的右侧（尾部）移除一个成员，并将其返回" class="headerlink" title="从集合的右侧（尾部）移除一个成员，并将其返回"></a>从集合的右侧（尾部）移除一个成员，并将其返回</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 8.11 srandmember(name, numbers)</span><br></pre></td></tr></table></figure>
<h1 id="从name对应的集合中随机获取-numbers-个元素"><a href="#从name对应的集合中随机获取-numbers-个元素" class="headerlink" title="从name对应的集合中随机获取 numbers 个元素"></a>从name对应的集合中随机获取 numbers 个元素</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 8.12 srem(name, values)</span><br></pre></td></tr></table></figure>
<h1 id="在name对应的集合中删除某些值"><a href="#在name对应的集合中删除某些值" class="headerlink" title="在name对应的集合中删除某些值"></a>在name对应的集合中删除某些值</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 8.13 sunion(keys, \*args)</span><br></pre></td></tr></table></figure>
<h1 id="获取多一个name对应的集合的并集"><a href="#获取多一个name对应的集合的并集" class="headerlink" title="获取多一个name对应的集合的并集"></a>获取多一个name对应的集合的并集</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 8.14 sunionstore(dest,keys, *args)</span><br></pre></td></tr></table></figure>
<h1 id="获取多一个name对应的集合的并集，并将结果保存到dest对应的集合中"><a href="#获取多一个name对应的集合的并集，并将结果保存到dest对应的集合中" class="headerlink" title="获取多一个name对应的集合的并集，并将结果保存到dest对应的集合中"></a>获取多一个name对应的集合的并集，并将结果保存到dest对应的集合中</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 8.15 sscan(name, cursor&#x3D;0, match&#x3D;None, count&#x3D;None)</span><br><span class="line">sscan_iter(name, match&#x3D;None, count&#x3D;None)</span><br></pre></td></tr></table></figure>
<h1 id="同字符串的操作，用于增量迭代分批获取元素，避免内存消耗太大"><a href="#同字符串的操作，用于增量迭代分批获取元素，避免内存消耗太大" class="headerlink" title="同字符串的操作，用于增量迭代分批获取元素，避免内存消耗太大"></a>同字符串的操作，用于增量迭代分批获取元素，避免内存消耗太大</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 九. Sort Set 操作</span><br><span class="line">有序集合，在集合的基础上，为每元素排序；元素的排序需要根据另外一个值来进行比较，所以，对于有序集合，每一个元素有两个值，即: 值和分数，分数专门用来做排序</span><br><span class="line"></span><br><span class="line">### 9.1 zadd(name, args, \*kwargs)</span><br></pre></td></tr></table></figure>
<h1 id="在name对应的有序集合中添加元素"><a href="#在name对应的有序集合中添加元素" class="headerlink" title="在name对应的有序集合中添加元素"></a>在name对应的有序集合中添加元素</h1><h1 id="如：-6"><a href="#如：-6" class="headerlink" title="如："></a>如：</h1><pre><code># zadd(&apos;zz&apos;, &apos;n1&apos;, 1, &apos;n2&apos;, 2)
# 或
# zadd(&apos;zz&apos;, n1=11, n2=22)</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 9.2 zcard(name)</span><br></pre></td></tr></table></figure>
<h1 id="获取name对应的有序集合元素的数量"><a href="#获取name对应的有序集合元素的数量" class="headerlink" title="获取name对应的有序集合元素的数量"></a>获取name对应的有序集合元素的数量</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 9.3 zcount(name, min, max)</span><br></pre></td></tr></table></figure>
<h1 id="获取name对应的有序集合中分数-在-min-max-之间的个数"><a href="#获取name对应的有序集合中分数-在-min-max-之间的个数" class="headerlink" title="获取name对应的有序集合中分数 在 [min,max] 之间的个数"></a>获取name对应的有序集合中分数 在 [min,max] 之间的个数</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 9.4 zincrby(name, value, amount)</span><br></pre></td></tr></table></figure>
<h1 id="自增name对应的有序集合的-name-对应的分数"><a href="#自增name对应的有序集合的-name-对应的分数" class="headerlink" title="自增name对应的有序集合的 name 对应的分数"></a>自增name对应的有序集合的 name 对应的分数</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 9.5 r.zrange( name, start, end, desc&#x3D;False, withscores&#x3D;False, score_cast_func&#x3D;float)</span><br></pre></td></tr></table></figure>
<h1 id="按照索引范围获取name对应的有序集合的元素"><a href="#按照索引范围获取name对应的有序集合的元素" class="headerlink" title="按照索引范围获取name对应的有序集合的元素"></a>按照索引范围获取name对应的有序集合的元素</h1><h1 id="参数：-25"><a href="#参数：-25" class="headerlink" title="参数："></a>参数：</h1><pre><code># name，redis的name
# start，有序集合索引起始位置（非分数）
# end，有序集合索引结束位置（非分数）
# desc，排序规则，默认按照分数从小到大排序
# withscores，是否获取元素的分数，默认只获取元素的值
# score_cast_func，对分数进行数据转换的函数</code></pre><h1 id="更多：-3"><a href="#更多：-3" class="headerlink" title="更多："></a>更多：</h1><pre><code># 从大到小排序
# zrevrange(name, start, end, withscores=False, score_cast_func=float)

# 按照分数范围获取name对应的有序集合的元素
# zrangebyscore(name, min, max, start=None, num=None, withscores=False, score_cast_func=float)
# 从大到小排序
# zrevrangebyscore(name, max, min, start=None, num=None, withscores=False, score_cast_func=float)</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 9.6 zrank(name, value)</span><br></pre></td></tr></table></figure>
<h1 id="获取某个值在-name对应的有序集合中的排行（从-0-开始）"><a href="#获取某个值在-name对应的有序集合中的排行（从-0-开始）" class="headerlink" title="获取某个值在 name对应的有序集合中的排行（从 0 开始）"></a>获取某个值在 name对应的有序集合中的排行（从 0 开始）</h1><h1 id="更多：-4"><a href="#更多：-4" class="headerlink" title="更多："></a>更多：</h1><pre><code># zrevrank(name, value)，从大到小排序</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 9.7 zrangebylex(name, min, max, start&#x3D;None, num&#x3D;None)</span><br></pre></td></tr></table></figure>
<h1 id="当有序集合的所有成员都具有相同的分值时，有序集合的元素会根据成员的-值-（lexicographical-ordering）来进行排序，而这个命令则可以返回给定的有序集合键-key-中，-元素的值介于-min-和-max-之间的成员"><a href="#当有序集合的所有成员都具有相同的分值时，有序集合的元素会根据成员的-值-（lexicographical-ordering）来进行排序，而这个命令则可以返回给定的有序集合键-key-中，-元素的值介于-min-和-max-之间的成员" class="headerlink" title="当有序集合的所有成员都具有相同的分值时，有序集合的元素会根据成员的 值 （lexicographical ordering）来进行排序，而这个命令则可以返回给定的有序集合键 key 中， 元素的值介于 min 和 max 之间的成员"></a>当有序集合的所有成员都具有相同的分值时，有序集合的元素会根据成员的 值 （lexicographical ordering）来进行排序，而这个命令则可以返回给定的有序集合键 key 中， 元素的值介于 min 和 max 之间的成员</h1><h1 id="对集合中的每个成员进行逐个字节的对比（byte-by-byte-compare），-并按照从低到高的顺序，-返回排序后的集合成员。-如果两个字符串有一部分内容是相同的话，-那么命令会认为较长的字符串比较短的字符串要大"><a href="#对集合中的每个成员进行逐个字节的对比（byte-by-byte-compare），-并按照从低到高的顺序，-返回排序后的集合成员。-如果两个字符串有一部分内容是相同的话，-那么命令会认为较长的字符串比较短的字符串要大" class="headerlink" title="对集合中的每个成员进行逐个字节的对比（byte-by-byte compare）， 并按照从低到高的顺序， 返回排序后的集合成员。 如果两个字符串有一部分内容是相同的话， 那么命令会认为较长的字符串比较短的字符串要大"></a>对集合中的每个成员进行逐个字节的对比（byte-by-byte compare）， 并按照从低到高的顺序， 返回排序后的集合成员。 如果两个字符串有一部分内容是相同的话， 那么命令会认为较长的字符串比较短的字符串要大</h1><h1 id="参数：-26"><a href="#参数：-26" class="headerlink" title="参数："></a>参数：</h1><pre><code># name，redis的name
# min，左区间（值）。 + 表示正无限； - 表示负无限； ( 表示开区间； [ 则表示闭区间
# min，右区间（值）
# start，对结果进行分片处理，索引位置
# num，对结果进行分片处理，索引后面的num个元素</code></pre><h1 id="如：-7"><a href="#如：-7" class="headerlink" title="如："></a>如：</h1><pre><code># ZADD myzset 0 aa 0 ba 0 ca 0 da 0 ea 0 fa 0 ga
# r.zrangebylex(&apos;myzset&apos;, &quot;-&quot;, &quot;[ca&quot;) 结果为：[&apos;aa&apos;, &apos;ba&apos;, &apos;ca&apos;]</code></pre><h1 id="更多：-5"><a href="#更多：-5" class="headerlink" title="更多："></a>更多：</h1><pre><code># 从大到小排序
# zrevrangebylex(name, max, min, start=None, num=None)</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 9.8 zrem(name, values)</span><br></pre></td></tr></table></figure>
<h1 id="删除name对应的有序集合中值是values的成员"><a href="#删除name对应的有序集合中值是values的成员" class="headerlink" title="删除name对应的有序集合中值是values的成员"></a>删除name对应的有序集合中值是values的成员</h1><h1 id="如：zrem-‘zz’-‘s1’-‘s2’"><a href="#如：zrem-‘zz’-‘s1’-‘s2’" class="headerlink" title="如：zrem(‘zz’, [‘s1’, ‘s2’])"></a>如：zrem(‘zz’, [‘s1’, ‘s2’])</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 9.9 zremrangebyrank(name, min, max)</span><br></pre></td></tr></table></figure>
<h1 id="根据排行范围删除"><a href="#根据排行范围删除" class="headerlink" title="根据排行范围删除"></a>根据排行范围删除</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 9.10 zremrangebyscore(name, min, max)</span><br></pre></td></tr></table></figure>
<h1 id="根据分数范围删除"><a href="#根据分数范围删除" class="headerlink" title="根据分数范围删除"></a>根据分数范围删除</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 9.11 zremrangebylex(name, min, max)</span><br></pre></td></tr></table></figure>
<h1 id="根据值返回删除"><a href="#根据值返回删除" class="headerlink" title="根据值返回删除"></a>根据值返回删除</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zscore(name, value)</span><br></pre></td></tr></table></figure>
<h1 id="获取name对应有序集合中-value-对应的分数"><a href="#获取name对应有序集合中-value-对应的分数" class="headerlink" title="获取name对应有序集合中 value 对应的分数"></a>获取name对应有序集合中 value 对应的分数</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 9.12 zinterstore(dest, keys, aggregate&#x3D;None)</span><br></pre></td></tr></table></figure>
<h1 id="获取两个有序集合的交集，如果遇到相同值不同分数，则按照aggregate进行操作"><a href="#获取两个有序集合的交集，如果遇到相同值不同分数，则按照aggregate进行操作" class="headerlink" title="获取两个有序集合的交集，如果遇到相同值不同分数，则按照aggregate进行操作"></a>获取两个有序集合的交集，如果遇到相同值不同分数，则按照aggregate进行操作</h1><h1 id="aggregate的值为-SUM-MIN-MAX"><a href="#aggregate的值为-SUM-MIN-MAX" class="headerlink" title="aggregate的值为:  SUM  MIN  MAX"></a>aggregate的值为:  SUM  MIN  MAX</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 9.13 zunionstore(dest, keys, aggregate&#x3D;None)</span><br></pre></td></tr></table></figure>
<h1 id="获取两个有序集合的并集，如果遇到相同值不同分数，则按照aggregate进行操作"><a href="#获取两个有序集合的并集，如果遇到相同值不同分数，则按照aggregate进行操作" class="headerlink" title="获取两个有序集合的并集，如果遇到相同值不同分数，则按照aggregate进行操作"></a>获取两个有序集合的并集，如果遇到相同值不同分数，则按照aggregate进行操作</h1><h1 id="aggregate的值为-SUM-MIN-MAX-1"><a href="#aggregate的值为-SUM-MIN-MAX-1" class="headerlink" title="aggregate的值为:  SUM  MIN  MAX"></a>aggregate的值为:  SUM  MIN  MAX</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 9.14 zscan(name, cursor&#x3D;0, match&#x3D;None, count&#x3D;None, score_cast_func&#x3D;float)</span><br><span class="line">zscan_iter(name, match&#x3D;None, count&#x3D;None,score_cast_func&#x3D;float)</span><br></pre></td></tr></table></figure>
<h1 id="同字符串相似，相较于字符串新增score-cast-func，用来对分数进行操作"><a href="#同字符串相似，相较于字符串新增score-cast-func，用来对分数进行操作" class="headerlink" title="同字符串相似，相较于字符串新增score_cast_func，用来对分数进行操作"></a>同字符串相似，相较于字符串新增score_cast_func，用来对分数进行操作</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 十. 其他常用的操作</span><br><span class="line"></span><br><span class="line">### 10.1 delete(\*names)</span><br></pre></td></tr></table></figure>
<h1 id="根据删除redis中的任意数据类型"><a href="#根据删除redis中的任意数据类型" class="headerlink" title="根据删除redis中的任意数据类型"></a>根据删除redis中的任意数据类型</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 10.2 exists(name)</span><br></pre></td></tr></table></figure>
<h1 id="检测redis的name是否存在"><a href="#检测redis的name是否存在" class="headerlink" title="检测redis的name是否存在"></a>检测redis的name是否存在</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 10.3 keys(pattern&#x3D;’*’)</span><br></pre></td></tr></table></figure>
<h1 id="根据模型获取redis的name"><a href="#根据模型获取redis的name" class="headerlink" title="根据模型获取redis的name"></a>根据模型获取redis的name</h1><h1 id="更多：-6"><a href="#更多：-6" class="headerlink" title="更多："></a>更多：</h1><pre><code># KEYS * 匹配数据库中所有 key 。
# KEYS h?llo 匹配 hello ， hallo 和 hxllo 等。
# KEYS h*llo 匹配 hllo 和 heeeeello 等。
# KEYS h[ae]llo 匹配 hello 和 hallo ，但不匹配 hillo</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 10.4 expire(name ,time)</span><br></pre></td></tr></table></figure>
<h1 id="为某个redis的某个name设置超时时间"><a href="#为某个redis的某个name设置超时时间" class="headerlink" title="为某个redis的某个name设置超时时间"></a>为某个redis的某个name设置超时时间</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 10.5 rename(src, dst)</span><br></pre></td></tr></table></figure>
<h1 id="对redis的name重命名为"><a href="#对redis的name重命名为" class="headerlink" title="对redis的name重命名为"></a>对redis的name重命名为</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 10.6 move(name, db))</span><br></pre></td></tr></table></figure>
<h1 id="将redis的某个值移动到指定的db下"><a href="#将redis的某个值移动到指定的db下" class="headerlink" title="将redis的某个值移动到指定的db下"></a>将redis的某个值移动到指定的db下</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 10.7 randomkey()</span><br></pre></td></tr></table></figure>
<h1 id="随机获取一个redis的name（不删除）"><a href="#随机获取一个redis的name（不删除）" class="headerlink" title="随机获取一个redis的name（不删除）"></a>随机获取一个redis的name（不删除）</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 10.8 type(name)</span><br></pre></td></tr></table></figure>
<h1 id="获取name对应值的类型"><a href="#获取name对应值的类型" class="headerlink" title="获取name对应值的类型"></a>获取name对应值的类型</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 10.9 scan(cursor&#x3D;0, match&#x3D;None, count&#x3D;None)</span><br><span class="line">scan_iter(match&#x3D;None, count&#x3D;None)</span><br></pre></td></tr></table></figure>
<h1 id="同字符串操作，用于增量迭代获取key"><a href="#同字符串操作，用于增量迭代获取key" class="headerlink" title="同字符串操作，用于增量迭代获取key"></a>同字符串操作，用于增量迭代获取key</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 10.10 sentinel(哨兵)</span><br><span class="line">Redis中的sentinel主要用于在redis主从复制中，如果master故障，则自动将slave替换成master</span><br></pre></td></tr></table></figure>
<p>#!/usr/bin/env python</p>
<h1 id="coding-utf-8"><a href="#coding-utf-8" class="headerlink" title="-- coding:utf-8 --"></a>-<em>- coding:utf-8 -</em>-</h1><p>from redis.sentinel import Sentinel</p>
<h1 id="连接哨兵服务器-主机名也可以用域名"><a href="#连接哨兵服务器-主机名也可以用域名" class="headerlink" title="连接哨兵服务器(主机名也可以用域名)"></a>连接哨兵服务器(主机名也可以用域名)</h1><p>sentinel = Sentinel([(‘10.211.55.20’, 26379),<br>                     (‘10.211.55.20’, 26380),<br>                     ],<br>                    socket_timeout=0.5)</p>
<h1 id="获取主服务器地址"><a href="#获取主服务器地址" class="headerlink" title="# 获取主服务器地址"></a># 获取主服务器地址</h1><h1 id="master-sentinel-discover-master-‘mymaster’"><a href="#master-sentinel-discover-master-‘mymaster’" class="headerlink" title="master = sentinel.discover_master(‘mymaster’)"></a>master = sentinel.discover_master(‘mymaster’)</h1><h1 id="print-master"><a href="#print-master" class="headerlink" title="print(master)"></a>print(master)</h1><p>#</p>
<h1 id="获取从服务器地址"><a href="#获取从服务器地址" class="headerlink" title="# # 获取从服务器地址"></a># # 获取从服务器地址</h1><h1 id="slave-sentinel-discover-slaves-‘mymaster’"><a href="#slave-sentinel-discover-slaves-‘mymaster’" class="headerlink" title="slave = sentinel.discover_slaves(‘mymaster’)"></a>slave = sentinel.discover_slaves(‘mymaster’)</h1><h1 id="print-slave"><a href="#print-slave" class="headerlink" title="print(slave)"></a>print(slave)</h1><p>#<br>#</p>
<h1 id="获取主服务器进行写入"><a href="#获取主服务器进行写入" class="headerlink" title="# # 获取主服务器进行写入"></a># # 获取主服务器进行写入</h1><h1 id="master-sentinel-master-for-‘mymaster’"><a href="#master-sentinel-master-for-‘mymaster’" class="headerlink" title="master = sentinel.master_for(‘mymaster’)"></a>master = sentinel.master_for(‘mymaster’)</h1><h1 id="master-set-‘foo’-‘bar’"><a href="#master-set-‘foo’-‘bar’" class="headerlink" title="master.set(‘foo’, ‘bar’)"></a>master.set(‘foo’, ‘bar’)</h1><h1 id="获取从服务器进行读取（默认是round-roubin）"><a href="#获取从服务器进行读取（默认是round-roubin）" class="headerlink" title="# # # 获取从服务器进行读取（默认是round-roubin）"></a># # # 获取从服务器进行读取（默认是round-roubin）</h1><h1 id="slave-sentinel-slave-for-‘mymaster’-password-’redis-auth-pass’"><a href="#slave-sentinel-slave-for-‘mymaster’-password-’redis-auth-pass’" class="headerlink" title="slave = sentinel.slave_for(‘mymaster’, password=’redis_auth_pass’)"></a>slave = sentinel.slave_for(‘mymaster’, password=’redis_auth_pass’)</h1><h1 id="r-ret-slave-get-‘foo’"><a href="#r-ret-slave-get-‘foo’" class="headerlink" title="r_ret = slave.get(‘foo’)"></a>r_ret = slave.get(‘foo’)</h1><h1 id="print-r-ret"><a href="#print-r-ret" class="headerlink" title="print(r_ret)"></a>print(r_ret)</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 十一. 管道(pipline)</span><br><span class="line">redis-py默认在执行每次请求都会创建（连接池申请连接）和断开（归还连接池）一次连接操作，如果想要在一次请求中指定多个命令，则可以使用pipline实现一次请求指定多个命令，并且默认情况下一次pipline 是原子性操作</span><br></pre></td></tr></table></figure>
<p>#!/usr/bin/env python</p>
<h1 id="coding-utf-8-1"><a href="#coding-utf-8-1" class="headerlink" title="-- coding:utf-8 --"></a>-<em>- coding:utf-8 -</em>-</h1><p>import redis</p>
<p>pool = redis.ConnectionPool(host=’192.168.1.100’, port=6379)</p>
<p>r = redis.Redis(connection_pool=pool)</p>
<h1 id="pipe-r-pipeline-transaction-False"><a href="#pipe-r-pipeline-transaction-False" class="headerlink" title="pipe = r.pipeline(transaction=False)"></a>pipe = r.pipeline(transaction=False)</h1><p>pipe = r.pipeline(transaction=True)</p>
<p>r.set(‘name’, ‘shuke’)<br>r.set(‘role’, ‘DevOps’)<br>pipe.execute()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 十二. 发布订阅</span><br><span class="line">发布者: 服务器</span><br><span class="line">订阅者: Dashboad和数据处理</span><br><span class="line"></span><br><span class="line">工具类:</span><br></pre></td></tr></table></figure>
<p>#!/usr/bin/env python</p>
<h1 id="coding-utf-8-2"><a href="#coding-utf-8-2" class="headerlink" title="-- coding:utf-8 --"></a>-<em>- coding:utf-8 -</em>-</h1><p>import redis</p>
<p>class RedisHelper:</p>
<pre><code>def __init__(self):
    self.__conn = redis.Redis(host=&apos;192.168.1.100&apos;)
    self.chan_sub = &apos;fm104.5&apos;
    self.chan_pub = &apos;fm104.5&apos;

def public(self, msg):
    self.__conn.publish(self.chan_pub, msg)
    return True

def subscribe(self):
    pub = self.__conn.pubsub()
    pub.subscribe(self.chan_sub)
    pub.parse_response()
    return pub</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">订阅者:</span><br></pre></td></tr></table></figure>
<p>#!/usr/bin/env python</p>
<h1 id="coding-utf-8-3"><a href="#coding-utf-8-3" class="headerlink" title="-- coding:utf-8 --"></a>-<em>- coding:utf-8 -</em>-</h1><p>from monitor.RedisHelper import RedisHelper</p>
<p>obj = RedisHelper()<br>redis_sub = obj.subscribe()</p>
<p>while True:<br>    msg= redis_sub.parse_response()<br>    print msg</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">发布者:</span><br></pre></td></tr></table></figure>
<p>#!/usr/bin/env python</p>
<h1 id="coding-utf-8-4"><a href="#coding-utf-8-4" class="headerlink" title="-- coding:utf-8 --"></a>-<em>- coding:utf-8 -</em>-</h1><p>from monitor.RedisHelper import RedisHelper</p>
<p>obj = RedisHelper()<br>obj.public(‘hello’)</p>
<pre><code>
## 十三. Redis应用场景介绍

1. 使用Redis有哪些好处？
- 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)

- 支持丰富数据类型，支持string，list，set，sorted set，hash

- 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行

- 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除

2. redis相比memcached有哪些优势？

- memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型

- redis的速度比memcached快很多

- redis可以持久化其数据

3. redis常见性能问题和解决方案：

-  Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件

- 如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次

- 为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内

- 尽量避免在压力很大的主库上增加从库

- 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master &lt;- Slave1 &lt;- Slave2 &lt;- Slave3...

这样的结构方便解决单点故障问题，实现Slave对Master的替换。如果Master挂了，可以立刻启用Slave1做Master，其他不变。

4. MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据

相关知识：redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略,redis提供6种数据淘汰策略：

voltile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰

volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰

volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰

allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰

allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰

no-enviction（驱逐）：禁止驱逐数据

5. Memcache与Redis的区别都有哪些？

- 存储方式
Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。
Redis有部份存在硬盘上，这样能保证数据的持久性。

- 数据支持类型
Memcache对数据类型支持相对简单。
Redis有复杂的数据类型。

- value大小
redis最大可以达到1GB，而memcache只有1MB

6. Redis 常见的性能问题都有哪些？如何解决？

- Master写内存快照，save命令调度rdbSave函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以Master最好不要写内存快照。

- Master AOF持久化，如果不重写AOF文件，这个持久化方式对性能的影响是最小的，但是AOF文件会不断增大，AOF文件过大会影响Master重启的恢复速度。Master最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化,如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次。

- Master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。

- Redis主从复制的性能问题，为了主从复制的速度和连接的稳定性，Slave和Master最好在同一个局域网内

7. redis 最适合的场景

Redis最适合所有数据in-momory的场景，虽然Redis也提供持久化功能，但实际更多的是一个disk-backed的功能，跟传统意义上的持久化有比较大的差别，那么可能大家就会有疑问，似乎Redis更像一个加强版的Memcached，那么何时使用Memcached,何时使用Redis呢?

如果简单地比较Redis与Memcached的区别，大多数都会得到以下观点：
- Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。
- Redis支持数据的备份，即master-slave模式的数据备份。
- Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。

8. 会话缓存（Session Cache）

最常用的一种使用Redis的情景是会话缓存（session cache）。用Redis缓存会话比其他存储（如Memcached）的优势在于：Redis提供持久化。当维护一个不是严格要求一致性的缓存时，如果用户的购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？
幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用Redis来缓存会话的文档。甚至广为人知的商业平台Magento也提供Redis的插件。

9. 全页缓存（FPC）

除基本的会话token之外，Redis还提供很简便的FPC平台。回到一致性问题，即使重启了Redis实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似PHP本地FPC。
再次以Magento为例，Magento提供一个插件来使用Redis作为全页缓存后端。
此外，对WordPress的用户来说，Pantheon有一个非常好的插件  wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。

10. 队列
Reids在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得Redis能作为一个很好的消息队列平台来使用。Redis作为队列使用的操作，就类似于本地程序语言（如Python）对 list 的 push/pop 操作。
如果你快速的在Google中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项目的目的就是利用Redis创建非常好的后端工具，以满足各种队列需求。例如，Celery有一个后台就是使用Redis作为broker，你可以从这里去查看。

11. 排行榜/计数器
Redis在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis只是正好提供了这两种数据结构。所以，我们要从排序集合中获取到排名最靠前的10个用户–我们称之为“user_scores”，我们只需要像下面一样执行即可：
当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执行：
ZRANGE user_scores 0 10 WITHSCORES
Agora Games就是一个很好的例子，用Ruby实现的，它的排行榜就是使用Redis来存储数据的，你可以在这里看到。

12. 发布/订阅
最后（但肯定不是最不重要的）是Redis的发布/订阅功能。发布/订阅的使用场景确实非常多。我已看见人们在社交网络连接中使用，还可作为基于发布/订阅的脚本触发器，甚至用Redis的发布/订阅功能来建立聊天系统！(不，这是真的，你可以去核实)
Redis提供的所有特性中，我感觉这个是喜欢的人最少的一个，虽然它为用户提供如果此多功能。


参考文章:  
[Python操作redis详解 | Polar Snow Documentation](https://docs.lvrui.io/2016/07/24/Python%E6%93%8D%E4%BD%9Credis%E8%AF%A6%E8%A7%A3/)  
[使用python来操作redis用法详解 - 简书](https://www.jianshu.com/p/2639549bedc8)  
[Python操作 RabbitMQ、Redis、Memcache、SQLAlchemy](http://www.cnblogs.com/wupeiqi/articles/5132791.html)  
[GitHub - andymccurdy/redis-py: Redis Python Client](https://github.com/andymccurdy/redis-py/)  
</code></pre>]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>PYTHON</tag>
      </tags>
  </entry>
  <entry>
    <title>python一些不为人知的小技巧</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h2 id="python一些不为人知的小技巧"><a href="#python一些不为人知的小技巧" class="headerlink" title="python一些不为人知的小技巧"></a>python一些不为人知的小技巧</h2><h3 id="startswith-和endswith-参数可以是元组"><a href="#startswith-和endswith-参数可以是元组" class="headerlink" title="startswith()和endswith()参数可以是元组"></a>startswith()和endswith()参数可以是元组</h3><p>当检测字符串开头或结尾时，如果有多个检测值，可以用元组作为startswith()和endswith()参数:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># bad</span><br><span class="line">if image.endswith(&#39;.jpg&#39;) or image.endswith(&#39;.png&#39;) or image.endswith(&#39;.gif&#39;):</span><br><span class="line">    pass</span><br><span class="line"># good</span><br><span class="line">if image.endswith((&#39;.jpg&#39;, &#39;.png&#39;, &#39;.gif&#39;)):</span><br><span class="line">    pass</span><br><span class="line"># bad</span><br><span class="line">if url.startswith(&#39;http:&#39;) or url.startswith(&#39;https:&#39;) or url.startswith(&#39;ftp:&#39;):</span><br><span class="line">    pass</span><br><span class="line"># good</span><br><span class="line">if url.startswith((&#39;http:&#39;, &#39;https:&#39;, &#39;ftp:&#39;)):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>

<h3 id="enumerate-设置start参数做为索引起始值"><a href="#enumerate-设置start参数做为索引起始值" class="headerlink" title="enumerate()设置start参数做为索引起始值"></a>enumerate()设置start参数做为索引起始值</h3><p>当用enumerate()迭代同时要得到索引时，可以设置start参数作为索引起始值:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># bad</span><br><span class="line">for index, v in enumerate(data):</span><br><span class="line">    print(index+1, v)</span><br><span class="line"># good</span><br><span class="line">for index, v in enumerate(data, start&#x3D;1):</span><br><span class="line">    print(index, v)</span><br></pre></td></tr></table></figure>

<h3 id="对切片命名"><a href="#对切片命名" class="headerlink" title="对切片命名"></a>对切片命名</h3><p>当代码中到处都是硬编码的切片索引时，我们的代码将变得无法阅读。可以对切片命名解决此问题:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">record &#x3D; &#39;....................100.................513.25......&#39;</span><br><span class="line"># bad</span><br><span class="line">cost &#x3D; int(record[20:23]) * float(record[40:46])</span><br><span class="line"># good</span><br><span class="line">SHARES &#x3D; slice(20, 23)</span><br><span class="line">PRICE &#x3D; slice(40, 46)</span><br><span class="line">cost &#x3D; int(record[SHARES]) * float(record[PRICE])</span><br></pre></td></tr></table></figure>
<p>作为一条基本准则，代码中如果有很多硬编码的索引值，将导致可读性合可维护性都不佳。一般来说，内置的slice()函数会创建一个切片对象，可以用在任何允许进行切片操作的地方。例如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; items &#x3D; [0, 1, 2, 3, 4, 5, 6]</span><br><span class="line">&gt;&gt;&gt; a &#x3D; slice(2, 4)</span><br><span class="line">&gt;&gt;&gt; items[2:4]</span><br><span class="line">[2, 3]</span><br><span class="line">&gt;&gt;&gt; items[a]</span><br><span class="line">[2, 3]</span><br><span class="line">&gt;&gt;&gt; items[a] &#x3D; [-2, -3]</span><br><span class="line">&gt;&gt;&gt; items</span><br><span class="line">[0, 1, -2, -3, 4, 5, 6]</span><br><span class="line">&gt;&gt;&gt; del items[a]</span><br><span class="line">&gt;&gt;&gt; items</span><br><span class="line">[0, 1, 4, 5, 6]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="上下文管理器可以同时管理多个资源"><a href="#上下文管理器可以同时管理多个资源" class="headerlink" title="上下文管理器可以同时管理多个资源"></a>上下文管理器可以同时管理多个资源</h3><p>假设你要读取一个文件的内容，经过处理以后，写入到另一个文件。你能写出pythonic的代码，所以你使用了上下文管理器，满意地的写出了下面这样的代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with open(&#39;input.txt&#39;, &#39;r&#39;) as source:</span><br><span class="line">    with open(&#39;output.txt&#39;, &#39;w&#39;) as target:</span><br><span class="line">        target.write(source.read())</span><br></pre></td></tr></table></figure>
<p>你已经做的很好了，但是上下文管理器可以同时管理多个资源，上面这段代码还可以这样写:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with open(&#39;input.txt&#39;, &#39;r&#39;) as source, open(&#39;output.txt&#39;, &#39;w&#39;) as target:</span><br><span class="line">    target.write(source.read())</span><br></pre></td></tr></table></figure>

<h3 id="else子句"><a href="#else子句" class="headerlink" title="else子句"></a>else子句</h3><p>Python中的else子句不仅能在if语句中使用，还能在for、while、和try语句中使用。<br>在for循环或是while循环正常运行完毕时（而不是通过break语句或是return语句或是异常退出循环），才会运行else块。<br>举个例子:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; for i in range(3):</span><br><span class="line">...     print(i)</span><br><span class="line">... else:</span><br><span class="line">...     print(&#39;Iterated over everything&#39;)</span><br><span class="line">... </span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">Iterated over everything</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>如上，for循环正常结束，所以运行了后面的else块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; for i in range(3):</span><br><span class="line">...     if i &#x3D;&#x3D; 2:</span><br><span class="line">...         break</span><br><span class="line">...     print(i)</span><br><span class="line">... else:</span><br><span class="line">...     print(&#39;Iterated over everything&#39;)</span><br><span class="line">... </span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>由此可以看出，for循环如果没有正常运行完毕（如上面是break结束循环的），是不会运行后面的else块。<br>仅当try块中没有异常抛出时才运行else块。一开始，你可能觉得没必要在try/except块中使用else子句。<br>毕竟，在下述代码片段中，只有dangerous_call()不抛出异常，after_call()才会执行，对吧？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try：</span><br><span class="line">    dangerous_call()</span><br><span class="line">    after_call()</span><br><span class="line">except OSError:</span><br><span class="line">    log(&#39;OSError...&#39;)</span><br></pre></td></tr></table></figure>
<p>然而，after_call()不应该放在try块中。为了清晰明确，try块中应该只包括抛出预期异常的语句。因此,下面这种写法更优雅:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">    dangerous_call()</span><br><span class="line">except OSError:</span><br><span class="line">    log(&#39;OSError...&#39;)</span><br><span class="line">else:</span><br><span class="line">    after_call()</span><br></pre></td></tr></table></figure>
<p>现在很明确，try块防守的是dangerous_call()可能出现的错误，而不是after_call()。而且很明显，只有try块不抛出异常，才会执行after_call()。但要注意一点，else子句抛出的异常不会由前面的except子句处理，也就是说此时after_call()如果抛出异常，将不会被捕获到。</p>
<h3 id="脚本与命令行结合"><a href="#脚本与命令行结合" class="headerlink" title="脚本与命令行结合"></a>脚本与命令行结合</h3><p>可以使用下面方法运行一个Python脚本，在脚本运行结束后，直接进入Python命令行。这样做的好处是脚本的对象不会被清空，可以通过命令行直接调用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat hello.py</span><br><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># __author__ &#x3D; &quot;shuke&quot;</span><br><span class="line"># Date: 2018&#x2F;2&#x2F;7</span><br><span class="line"></span><br><span class="line">info &#x3D; &#123;&#39;name&#39;: &#39;shuke&#39;,&#39;age&#39;: 18&#125;</span><br><span class="line">li &#x3D; [1,2,3,4,&#39;A&#39;]</span><br><span class="line">const &#x3D; 1000</span><br><span class="line"># 结合命令行</span><br><span class="line">$ python -i hello.py</span><br><span class="line">&gt;&gt;&gt; info</span><br><span class="line">&#123;&#39;name&#39;: &#39;shuke&#39;, &#39;age&#39;: 18&#125;</span><br><span class="line">&gt;&gt;&gt; li</span><br><span class="line">[1, 2, 3, 4, &#39;A&#39;]</span><br><span class="line">&gt;&gt;&gt; const</span><br><span class="line">1000</span><br><span class="line">&gt;&gt;&gt; exit()</span><br></pre></td></tr></table></figure>

<h3 id="默认字典的简单树状表达"><a href="#默认字典的简单树状表达" class="headerlink" title="默认字典的简单树状表达"></a>默认字典的简单树状表达</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import json</span><br><span class="line">import collections</span><br><span class="line"></span><br><span class="line">tree &#x3D; lambda: collections.defaultdict(tree)</span><br><span class="line">root &#x3D; tree()</span><br><span class="line">root[&#39;menu&#39;][&#39;id&#39;] &#x3D; &#39;file&#39;</span><br><span class="line">root[&#39;menu&#39;][&#39;value&#39;] &#x3D; &#39;File&#39;</span><br><span class="line">root[&#39;menu&#39;][&#39;menuitems&#39;][&#39;new&#39;][&#39;value&#39;] &#x3D; &#39;New&#39;</span><br><span class="line">root[&#39;menu&#39;][&#39;menuitems&#39;][&#39;new&#39;][&#39;onclick&#39;] &#x3D; &#39;new();&#39;</span><br><span class="line">root[&#39;menu&#39;][&#39;menuitems&#39;][&#39;open&#39;][&#39;value&#39;] &#x3D; &#39;Open&#39;</span><br><span class="line">root[&#39;menu&#39;][&#39;menuitems&#39;][&#39;open&#39;][&#39;onclick&#39;] &#x3D; &#39;open();&#39;</span><br><span class="line">root[&#39;menu&#39;][&#39;menuitems&#39;][&#39;close&#39;][&#39;value&#39;] &#x3D; &#39;Close&#39;</span><br><span class="line">root[&#39;menu&#39;][&#39;menuitems&#39;][&#39;close&#39;][&#39;onclick&#39;] &#x3D; &#39;close();&#39;</span><br><span class="line">print(json.dumps(root, sort_keys&#x3D;True, indent&#x3D;4, separators&#x3D;(&#39;,&#39;, &#39;: &#39;)))</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">output: </span><br><span class="line">&#123;</span><br><span class="line">    &quot;menu&quot;: &#123;</span><br><span class="line">        &quot;id&quot;: &quot;file&quot;,</span><br><span class="line">        &quot;menuitems&quot;: &#123;</span><br><span class="line">            &quot;close&quot;: &#123;</span><br><span class="line">                &quot;onclick&quot;: &quot;close();&quot;,</span><br><span class="line">                &quot;value&quot;: &quot;Close&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;new&quot;: &#123;</span><br><span class="line">                &quot;onclick&quot;: &quot;new();&quot;,</span><br><span class="line">                &quot;value&quot;: &quot;New&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;open&quot;: &#123;</span><br><span class="line">                &quot;onclick&quot;: &quot;open();&quot;,</span><br><span class="line">                &quot;value&quot;: &quot;Open&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;value&quot;: &quot;File&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<h3 id="扩展拆箱-只兼容python3"><a href="#扩展拆箱-只兼容python3" class="headerlink" title="扩展拆箱(只兼容python3)"></a>扩展拆箱(只兼容python3)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a, *b, c &#x3D; [1, 2, 3, 4, 5]</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">[2, 3, 4]</span><br><span class="line">&gt;&gt;&gt; c</span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<h3 id="列表切割赋值"><a href="#列表切割赋值" class="headerlink" title="列表切割赋值"></a>列表切割赋值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; [1, 2, 3, 4, 5]</span><br><span class="line">&gt;&gt;&gt; a[2:3] &#x3D; [0, 0]</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[1, 2, 0, 0, 4, 5]</span><br><span class="line">&gt;&gt;&gt; a[1:1] &#x3D; [8, 9]</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[1, 8, 9, 2, 0, 0, 4, 5]</span><br><span class="line">&gt;&gt;&gt; a[1:-1] &#x3D; []</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">[1, 5]</span><br></pre></td></tr></table></figure>

<h3 id="命名列表切割方式"><a href="#命名列表切割方式" class="headerlink" title="命名列表切割方式"></a>命名列表切割方式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; [0, 1, 2, 3, 4, 5]</span><br><span class="line">&gt;&gt;&gt; LASTTHREE &#x3D; slice(-3, None)</span><br><span class="line">&gt;&gt;&gt; LASTTHREE</span><br><span class="line">slice(-3, None, None)</span><br><span class="line">&gt;&gt;&gt; a[LASTTHREE]</span><br><span class="line">[3, 4, 5]</span><br></pre></td></tr></table></figure>

<h3 id="列表以及迭代器的压缩和解压缩"><a href="#列表以及迭代器的压缩和解压缩" class="headerlink" title="列表以及迭代器的压缩和解压缩"></a>列表以及迭代器的压缩和解压缩</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; [1, 2, 3]</span><br><span class="line">b &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span><br><span class="line"></span><br><span class="line">z &#x3D; zip(a, b)</span><br><span class="line"></span><br><span class="line">for i in zip(a, b):</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line">for item in zip(*z):</span><br><span class="line">    print(item)</span><br></pre></td></tr></table></figure>

<h3 id="列表展开"><a href="#列表展开" class="headerlink" title="列表展开"></a>列表展开</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import itertools</span><br><span class="line">&gt;&gt;&gt; a &#x3D; [[1, 2], [3, 4], [5, 6]]</span><br><span class="line">&gt;&gt;&gt; list(itertools.chain.from_iterable(a))</span><br><span class="line">[1, 2, 3, 4, 5, 6]</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; sum(a, [])</span><br><span class="line">[1, 2, 3, 4, 5, 6]</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; [x for l in a for x in l]</span><br><span class="line">[1, 2, 3, 4, 5, 6]</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; a &#x3D; [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]</span><br><span class="line">&gt;&gt;&gt; [x for l1 in a for l2 in l1 for x in l2]</span><br><span class="line">[1, 2, 3, 4, 5, 6, 7, 8]</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt; a &#x3D; [1, 2, [3, 4], [[5, 6], [7, 8]]]</span><br><span class="line">&gt;&gt;&gt; flatten &#x3D; lambda x: [y for l in x for y in flatten(l)] if type(x) is list else [x]</span><br><span class="line">&gt;&gt;&gt; flatten(a)</span><br><span class="line">[1, 2, 3, 4, 5, 6, 7, 8]</span><br></pre></td></tr></table></figure>

<h3 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; g &#x3D; (x ** 2 for x in range(5))</span><br><span class="line">&gt;&gt;&gt; next(g)</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; next(g)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; next(g)</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; next(g)</span><br><span class="line">9</span><br><span class="line">&gt;&gt;&gt; next(g)</span><br><span class="line">16</span><br><span class="line">&gt;&gt;&gt; next(g)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">StopIteration</span><br><span class="line">&gt;&gt;&gt; sum(x ** 3 for x in range(10))</span><br><span class="line">2025</span><br><span class="line">&gt;&gt;&gt; sum(x ** 3 for x in range(10) if x % 3 &#x3D;&#x3D; 1)</span><br><span class="line">408</span><br><span class="line"># 迭代器中没有可迭代对象的时候会引发StopIteration错误</span><br></pre></td></tr></table></figure>

<h3 id="字典setdefault"><a href="#字典setdefault" class="headerlink" title="字典setdefault"></a>字典setdefault</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; request &#x3D; &#123;&#125;</span><br><span class="line">&gt;&gt;&gt; request.setdefault(None,[]).append(123)</span><br><span class="line">&gt;&gt;&gt; print(request)</span><br><span class="line">&#123;None: [123]&#125;</span><br><span class="line">&gt;&gt;&gt; request.setdefault(None,[]).append(456)</span><br><span class="line">&gt;&gt;&gt; print(request)</span><br><span class="line">&#123;None: [123, 456]&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字典推导"><a href="#字典推导" class="headerlink" title="字典推导"></a>字典推导</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; m &#x3D; &#123;x: x ** 2 for x in range(5)&#125;</span><br><span class="line">&gt;&gt;&gt; m</span><br><span class="line">&#123;0: 0, 1: 1, 2: 4, 3: 9, 4: 16&#125;</span><br><span class="line">&gt;&gt;&gt; m &#x3D; &#123;x: &#39;A&#39; + str(x) for x in range(10)&#125;</span><br><span class="line">&gt;&gt;&gt; m</span><br><span class="line">&#123;0: &#39;A0&#39;, 1: &#39;A1&#39;, 2: &#39;A2&#39;, 3: &#39;A3&#39;, 4: &#39;A4&#39;, 5: &#39;A5&#39;, 6: &#39;A6&#39;, 7: &#39;A7&#39;, 8: &#39;A8&#39;, 9: &#39;A9&#39;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字典推导反转字典"><a href="#字典推导反转字典" class="headerlink" title="字典推导反转字典"></a>字典推导反转字典</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; m &#x3D; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4&#125;</span><br><span class="line">&gt;&gt;&gt; m</span><br><span class="line">&#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4&#125;</span><br><span class="line">&gt;&gt;&gt; &#123;v: k for k, v in m.items()&#125;</span><br><span class="line">&#123;1: &#39;a&#39;, 2: &#39;b&#39;, 3: &#39;c&#39;, 4: &#39;d&#39;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="命名元组"><a href="#命名元组" class="headerlink" title="命名元组"></a>命名元组</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; Point &#x3D; collections.namedtuple(&#39;Point&#39;, [&#39;x&#39;, &#39;y&#39;])</span><br><span class="line">&gt;&gt;&gt; p &#x3D; Point(x&#x3D;1.0, y&#x3D;2.0)</span><br><span class="line">&gt;&gt;&gt; p</span><br><span class="line">Point(x&#x3D;1.0, y&#x3D;2.0)</span><br><span class="line">&gt;&gt;&gt; p.x</span><br><span class="line">1.0</span><br><span class="line">&gt;&gt;&gt; p.y</span><br><span class="line">2.0</span><br></pre></td></tr></table></figure>

<h3 id="继承命名元组"><a href="#继承命名元组" class="headerlink" title="继承命名元组"></a>继承命名元组</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import collections</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Point(collections.namedtuple(&#39;PointBase&#39;, [&#39;x&#39;, &#39;y&#39;])):</span><br><span class="line">    __slots__ &#x3D; ()</span><br><span class="line"></span><br><span class="line">    def __add__(self, other):</span><br><span class="line">        return Point(x&#x3D;self.x + other.x, y&#x3D;self.y + other.y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p &#x3D; Point(x&#x3D;1.0, y&#x3D;2.0)</span><br><span class="line">q &#x3D; Point(x&#x3D;2.0, y&#x3D;3.0)</span><br><span class="line">print(p + q)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">Point(x&#x3D;3.0, y&#x3D;5.0)</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<h3 id="统计在可迭代器中最常出现的元素"><a href="#统计在可迭代器中最常出现的元素" class="headerlink" title="统计在可迭代器中最常出现的元素"></a>统计在可迭代器中最常出现的元素</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; A &#x3D; collections.Counter([1, 1, 2, 2, 3, 3, 3, 3, 4, 5, 6, 7])</span><br><span class="line">&gt;&gt;&gt; A</span><br><span class="line">Counter(&#123;3: 4, 1: 2, 2: 2, 4: 1, 5: 1, 6: 1, 7: 1&#125;)</span><br><span class="line">&gt;&gt;&gt; A.most_common(1)</span><br><span class="line">[(3, 4)]</span><br><span class="line">&gt;&gt;&gt; A.most_common(3)</span><br><span class="line">[(3, 4), (1, 2), (2, 2)]</span><br></pre></td></tr></table></figure>

<h3 id="两端都可以操作的队列"><a href="#两端都可以操作的队列" class="headerlink" title="两端都可以操作的队列"></a>两端都可以操作的队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; Q &#x3D; collections.deque()</span><br><span class="line">&gt;&gt;&gt; Q.append(1)</span><br><span class="line">&gt;&gt;&gt; Q.appendleft(2)</span><br><span class="line">&gt;&gt;&gt; Q.extend([3, 4])</span><br><span class="line">&gt;&gt;&gt; Q.extendleft([5, 6])</span><br><span class="line">&gt;&gt;&gt; Q</span><br><span class="line">deque([6, 5, 2, 1, 3, 4])</span><br><span class="line">&gt;&gt;&gt; Q.pop()</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; Q.popleft()</span><br><span class="line">6</span><br><span class="line">&gt;&gt;&gt; Q</span><br><span class="line">deque([5, 2, 1, 3])</span><br><span class="line">&gt;&gt;&gt; Q.rotate(3)</span><br><span class="line">&gt;&gt;&gt; Q</span><br><span class="line">deque([2, 1, 3, 5])</span><br><span class="line">&gt;&gt;&gt; Q.rotate(-3)</span><br><span class="line">&gt;&gt;&gt; Q</span><br><span class="line">deque([5, 2, 1, 3])</span><br></pre></td></tr></table></figure>

<h3 id="有最大长度的双端队列"><a href="#有最大长度的双端队列" class="headerlink" title="有最大长度的双端队列"></a>有最大长度的双端队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; last_three &#x3D; collections.deque(maxlen&#x3D;3)</span><br><span class="line">&gt;&gt;&gt; for i in range(10):</span><br><span class="line">...     last_three.append(i)</span><br><span class="line">...     print(&#39;,&#39;.join(str(x) for x in last_three))</span><br><span class="line">...</span><br><span class="line">0</span><br><span class="line">0,1</span><br><span class="line">0,1,2</span><br><span class="line">1,2,3</span><br><span class="line">2,3,4</span><br><span class="line">3,4,5</span><br><span class="line">4,5,6</span><br><span class="line">5,6,7</span><br><span class="line">6,7,8</span><br><span class="line">7,8,9</span><br></pre></td></tr></table></figure>

<h3 id="最大和最小的几个列表元素"><a href="#最大和最小的几个列表元素" class="headerlink" title="最大和最小的几个列表元素"></a>最大和最小的几个列表元素</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import random</span><br><span class="line">&gt;&gt;&gt; import heapq</span><br><span class="line">&gt;&gt;&gt; a &#x3D; [random.randint(0, 100) for __ in range(100)]</span><br><span class="line">&gt;&gt;&gt;  heapq.nsmallest(5, a)</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1</span><br><span class="line">    heapq.nsmallest(5, a)</span><br><span class="line">    ^</span><br><span class="line">IndentationError: unexpected indent</span><br><span class="line">&gt;&gt;&gt; heapq.nsmallest(5, a)</span><br><span class="line">[0, 1, 3, 4, 4]</span><br><span class="line">&gt;&gt;&gt; heapq.nlargest(5, a)</span><br><span class="line">[100, 99, 98, 97, 96]</span><br></pre></td></tr></table></figure>

<h3 id="两个列表的笛卡尔积"><a href="#两个列表的笛卡尔积" class="headerlink" title="两个列表的笛卡尔积"></a>两个列表的笛卡尔积</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import itertools</span><br><span class="line">&gt;&gt;&gt; for p in itertools.product([1, 2, 3], [4, 5]):</span><br><span class="line">...     print(p)</span><br><span class="line">...</span><br><span class="line">(1, 4)</span><br><span class="line">(1, 5)</span><br><span class="line">(2, 4)</span><br><span class="line">(2, 5)</span><br><span class="line">(3, 4)</span><br><span class="line">(3, 5)</span><br><span class="line">&gt;&gt;&gt; for p in itertools.product([0, 1], repeat&#x3D;4):</span><br><span class="line">...     print(&#39;&#39;.join(str(x) for x in p))</span><br><span class="line">...</span><br><span class="line">0000</span><br><span class="line">0001</span><br><span class="line">0010</span><br><span class="line">0011</span><br><span class="line">0100</span><br><span class="line">0101</span><br><span class="line">0110</span><br><span class="line">0111</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1110</span><br><span class="line">1111</span><br></pre></td></tr></table></figure>

<h3 id="列表组合和列表元素替代组合"><a href="#列表组合和列表元素替代组合" class="headerlink" title="列表组合和列表元素替代组合"></a>列表组合和列表元素替代组合</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; for c in itertools.combinations([1, 2, 3, 4, 5], 3):</span><br><span class="line">...     print(&#39;&#39;.join(str(x) for x in c))</span><br><span class="line">...</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">145</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">245</span><br><span class="line">345</span><br><span class="line">&gt;&gt;&gt; for c in itertools.combinations_with_replacement([1, 2, 3], 2):</span><br><span class="line">...     print(&#39;&#39;.join(str(x) for x in c))</span><br><span class="line">...</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">33</span><br></pre></td></tr></table></figure>

<h3 id="列表元素排列组合"><a href="#列表元素排列组合" class="headerlink" title="列表元素排列组合"></a>列表元素排列组合</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; for p in itertools.permutations([1, 2, 3, 4]):</span><br><span class="line">...      print(&#39;&#39;.join(str(x) for x in p))</span><br><span class="line">...</span><br><span class="line">1234</span><br><span class="line">1243</span><br><span class="line">1324</span><br><span class="line">1342</span><br><span class="line">1423</span><br><span class="line">1432</span><br><span class="line">2134</span><br><span class="line">2143</span><br><span class="line">2314</span><br><span class="line">2341</span><br><span class="line">2413</span><br><span class="line">2431</span><br><span class="line">3124</span><br><span class="line">3142</span><br><span class="line">3214</span><br><span class="line">3241</span><br><span class="line">3412</span><br><span class="line">3421</span><br><span class="line">4123</span><br><span class="line">4132</span><br><span class="line">4213</span><br><span class="line">4231</span><br><span class="line">4312</span><br><span class="line">4321</span><br></pre></td></tr></table></figure>

<h3 id="可链接迭代器"><a href="#可链接迭代器" class="headerlink" title="可链接迭代器"></a>可链接迭代器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; [1, 2, 3, 4]</span><br><span class="line">&gt;&gt;&gt; for p in itertools.chain(itertools.combinations(a, 2), itertools.combinations(a, 3)):</span><br><span class="line">...     print(p)</span><br><span class="line">...</span><br><span class="line">(1, 2)</span><br><span class="line">(1, 3)</span><br><span class="line">(1, 4)</span><br><span class="line">(2, 3)</span><br><span class="line">(2, 4)</span><br><span class="line">(3, 4)</span><br><span class="line">(1, 2, 3)</span><br><span class="line">(1, 2, 4)</span><br><span class="line">(1, 3, 4)</span><br><span class="line">(2, 3, 4)</span><br><span class="line">&gt;&gt;&gt; for subset in itertools.chain.from_iterable(itertools.combinations(a, n) for n in range(len(a) + 1)):</span><br><span class="line">...      print(subset)</span><br><span class="line">...</span><br><span class="line">()</span><br><span class="line">(1,)</span><br><span class="line">(2,)</span><br><span class="line">(3,)</span><br><span class="line">(4,)</span><br><span class="line">(1, 2)</span><br><span class="line">(1, 3)</span><br><span class="line">(1, 4)</span><br><span class="line">(2, 3)</span><br><span class="line">(2, 4)</span><br><span class="line">(3, 4)</span><br><span class="line">(1, 2, 3)</span><br><span class="line">(1, 2, 4)</span><br><span class="line">(1, 3, 4)</span><br><span class="line">(2, 3, 4)</span><br><span class="line">(1, 2, 3, 4)</span><br></pre></td></tr></table></figure>

<h3 id="根据文件指定列类聚"><a href="#根据文件指定列类聚" class="headerlink" title="根据文件指定列类聚"></a>根据文件指定列类聚</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import itertools</span><br><span class="line">&gt;&gt;&gt; with open(&#39;contactlenses.csv&#39;, &#39;r&#39;) as infile:</span><br><span class="line">...     data &#x3D; [line.strip().split(&#39;,&#39;) for line in infile]</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; data &#x3D; data[1:]</span><br><span class="line">&gt;&gt;&gt; def print_data(rows):</span><br><span class="line">...     print &#39;\n&#39;.join(&#39;\t&#39;.join(&#39;&#123;: &lt;16&#125;&#39;.format(s) for s in row) for row in rows)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; print_data(data)</span><br><span class="line">young               myope                   no                      reduced                 none</span><br><span class="line">young               myope                   no                      normal                  soft</span><br><span class="line">young               myope                   yes                     reduced                 none</span><br><span class="line">young               myope                   yes                     normal                  hard</span><br><span class="line">young               hypermetrope            no                      reduced                 none</span><br><span class="line">young               hypermetrope            no                      normal                  soft</span><br><span class="line">young               hypermetrope            yes                     reduced                 none</span><br><span class="line">young               hypermetrope            yes                     normal                  hard</span><br><span class="line">pre-presbyopic      myope                   no                      reduced                 none</span><br><span class="line">pre-presbyopic      myope                   no                      normal                  soft</span><br><span class="line">pre-presbyopic      myope                   yes                     reduced                 none</span><br><span class="line">pre-presbyopic      myope                   yes                     normal                  hard</span><br><span class="line">pre-presbyopic      hypermetrope            no                      reduced                 none</span><br><span class="line">pre-presbyopic      hypermetrope            no                      normal                  soft</span><br><span class="line">pre-presbyopic      hypermetrope            yes                     reduced                 none</span><br><span class="line">pre-presbyopic      hypermetrope            yes                     normal                  none</span><br><span class="line">presbyopic          myope                   no                      reduced                 none</span><br><span class="line">presbyopic          myope                   no                      normal                  none</span><br><span class="line">presbyopic          myope                   yes                     reduced                 none</span><br><span class="line">presbyopic          myope                   yes                     normal                  hard</span><br><span class="line">presbyopic          hypermetrope            no                      reduced                 none</span><br><span class="line">presbyopic          hypermetrope            no                      normal                  soft</span><br><span class="line">presbyopic          hypermetrope            yes                     reduced                 none</span><br><span class="line">presbyopic          hypermetrope            yes                     normal                  none</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; data.sort(key&#x3D;lambda r: r[-1])</span><br><span class="line">&gt;&gt;&gt; for value, group in itertools.groupby(data, lambda r: r[-1]):</span><br><span class="line">...     print &#39;-----------&#39;</span><br><span class="line">...     print &#39;Group: &#39; + value</span><br><span class="line">...     print_data(group)</span><br><span class="line">...</span><br><span class="line">-----------</span><br><span class="line">Group: hard</span><br><span class="line">young               myope                   yes                     normal                  hard</span><br><span class="line">young               hypermetrope            yes                     normal                  hard</span><br><span class="line">pre-presbyopic      myope                   yes                     normal                  hard</span><br><span class="line">presbyopic          myope                   yes                     normal                  hard</span><br><span class="line">-----------</span><br><span class="line">Group: none</span><br><span class="line">young               myope                   no                      reduced                 none</span><br><span class="line">young               myope                   yes                     reduced                 none</span><br><span class="line">young               hypermetrope            no                      reduced                 none</span><br><span class="line">young               hypermetrope            yes                     reduced                 none</span><br><span class="line">pre-presbyopic      myope                   no                      reduced                 none</span><br><span class="line">pre-presbyopic      myope                   yes                     reduced                 none</span><br><span class="line">pre-presbyopic      hypermetrope            no                      reduced                 none</span><br><span class="line">pre-presbyopic      hypermetrope            yes                     reduced                 none</span><br><span class="line">pre-presbyopic      hypermetrope            yes                     normal                  none</span><br><span class="line">presbyopic          myope                   no                      reduced                 none</span><br><span class="line">presbyopic          myope                   no                      normal                  none</span><br><span class="line">presbyopic          myope                   yes                     reduced                 none</span><br><span class="line">presbyopic          hypermetrope            no                      reduced                 none</span><br><span class="line">presbyopic          hypermetrope            yes                     reduced                 none</span><br><span class="line">presbyopic          hypermetrope            yes                     normal                  none</span><br><span class="line">-----------</span><br><span class="line">Group: soft</span><br><span class="line">young               myope                   no                      normal                  soft</span><br><span class="line">young               hypermetrope            no                      normal                  soft</span><br><span class="line">pre-presbyopic      myope                   no                      normal                  soft</span><br><span class="line">pre-presbyopic      hypermetrope            no                      normal                  soft</span><br><span class="line">presbyopic          hypermetrope            no                      normal                  soft</span><br></pre></td></tr></table></figure>

<h3 id="按单词反转字符串"><a href="#按单词反转字符串" class="headerlink" title="按单词反转字符串"></a>按单词反转字符串</h3><p>按单词反转字符串是一道很常见的面试题。在Python中实现起来非常简单</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def reverse_string_by_word(s):</span><br><span class="line">    lst &#x3D; s.split()  # split by blank space by default</span><br><span class="line">    return &#39; &#39;.join(lst[::-1])</span><br><span class="line"></span><br><span class="line">s &#x3D; &#39;Power of Love&#39;</span><br><span class="line">print reverse_string_by_word(s)</span><br><span class="line"># Love of Power</span><br><span class="line"></span><br><span class="line">s &#x3D; &#39;Hello    World!&#39;</span><br><span class="line">print reverse_string_by_word(s)</span><br><span class="line"># World! Hello</span><br></pre></td></tr></table></figure>

<p>上面的实现其实已经能满足大多数情况，但是并不完美。比如第二个字符串中的感叹号并没有被翻转，而且原字符串中的空格数量也没有保留。（在上面的例子里其实Hello和World之间不止一个空格）</p>
<p>我们期望的结果应该是这样子的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print reverse_string_by_word(s)</span><br><span class="line"># Expected: !World  Hello</span><br></pre></td></tr></table></figure>
<p>要改进上面的方案还不把问题复杂化，推荐使用re模块。你可以查阅re.split() 的官方文档。我们看一下具体例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import re</span><br><span class="line">&gt;&gt;&gt; s &#x3D; &#39;Hello  World!&#39;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; re.split(r&#39;\s+&#39;, s)    # will discard blank spaces</span><br><span class="line">[&#39;Hello&#39;, &#39;World!&#39;]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; re.split(r&#39;(\s+)&#39;, s)  # will keep spaces as a group</span><br><span class="line">[&#39;Hello&#39;, &#39;  &#39;, &#39;World!&#39;]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; s &#x3D; &#39;&lt; Welcome to EF.COM! &gt;&#39;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; re.split(r&#39;\s+&#39;, s)  # split by spaces</span><br><span class="line">[&#39;&lt;&#39;, &#39;Welcome&#39;, &#39;to&#39;, &#39;EF.COM!&#39;, &#39;&gt;&#39;]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; re.split(r&#39;(\w+)&#39;, s)  # exactly split by word</span><br><span class="line">[&#39;&lt; &#39;, &#39;Welcome&#39;, &#39; &#39;, &#39;to&#39;, &#39; &#39;, &#39;EF&#39;, &#39;.&#39;, &#39;COM&#39;, &#39;! &gt;&#39;]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; re.split(r&#39;(\s+|\w+)&#39;, s)  # split by space and word</span><br><span class="line">[&#39;&lt;&#39;, &#39; &#39;, &#39;&#39;, &#39;Welcome&#39;, &#39;&#39;, &#39; &#39;, &#39;&#39;, &#39;to&#39;, &#39;&#39;, &#39; &#39;, &#39;&#39;, &#39;EF&#39;, &#39;.&#39;, &#39;COM&#39;, &#39;!&#39;, &#39; &#39;, &#39;&gt;&#39;]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; &#39;&#39;.join(re.split(r&#39;(\s+|\w+)&#39;, s)[::-1])</span><br><span class="line">&#39;&gt; !COM.EF to Welcome &lt;&#39;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; &#39;&#39;.join(re.split(r&#39;(\s+)&#39;, s)[::-1])</span><br><span class="line">&#39;&gt; EF.COM! to Welcome &lt;&#39;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; &#39;&#39;.join(re.split(r&#39;(\w+)&#39;, s)[::-1])</span><br><span class="line">&#39;! &gt;COM.EF to Welcome&lt; &#39;</span><br></pre></td></tr></table></figure>
<p>如果你觉得用切片将序列倒序可读性不高，那么其实也可以这样写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; &#39;&#39;.join(reversed(re.split(r&#39;(\s+|\w+)&#39;, s)))</span><br><span class="line">&#39;&gt; !COM.EF to Welcome &lt;</span><br></pre></td></tr></table></figure>


<p><a href="http://blog.jobbole.com/63320/" target="_blank" rel="noopener">30个有关Python的小技巧</a><br><a href="http://www.revotu.com/most-common-learn-python-questions.html" target="_blank" rel="noopener">Python学习之路上的几个经典问题|大师兄</a></p>
]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>PYTHON</tag>
      </tags>
  </entry>
  <entry>
    <title>一些有趣的python技巧</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h2 id="一些有趣的python技巧"><a href="#一些有趣的python技巧" class="headerlink" title="一些有趣的python技巧"></a>一些有趣的python技巧</h2><p>python有时候简单起来连我自己都怕，有时候其他语言需要几十写出来的python几行搞定。 这里经常收集一些有趣的东西还是很好玩的。</p>
<h3 id="简单的HTTP服务器"><a href="#简单的HTTP服务器" class="headerlink" title="简单的HTTP服务器"></a>简单的HTTP服务器</h3><p>你想快速简单的分享目录下的文件吗？可以这样做:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd $HOME&#x2F;work&#x2F;</span><br><span class="line"></span><br><span class="line"># Python2</span><br><span class="line">python -m SimpleHTTPServer</span><br><span class="line"></span><br><span class="line"># Python 3</span><br><span class="line">python3 -m http.server 8000</span><br></pre></td></tr></table></figure>
<p>然后别人就可以打开<a href="http://ip:8000" target="_blank" rel="noopener">http://ip:8000</a> 来访问这个简单的Web服务器了,如果该文件夹里面有个index.html就显示它，如果没有就显示文件和目录列表。 这样就能给别人快速分享文件或展示你的网站。</p>
<h3 id="简单的FTP服务器"><a href="#简单的FTP服务器" class="headerlink" title="简单的FTP服务器"></a>简单的FTP服务器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install pyftpdlib</span><br><span class="line">python -m pyftpdlib -p 21</span><br></pre></td></tr></table></figure>
<p>可选参数</p>
<ul>
<li>-i 指定IP地址（默认为本机的IP地址）</li>
<li>-p 指定端口（默认为2121）</li>
<li>-w 写权限（默认为只读）</li>
<li>-d 指定目录 （默认为当前目录）</li>
<li>-u 指定用户名登录</li>
<li>-P 设置登录密码</li>
</ul>
<h3 id="优雅的打印"><a href="#优雅的打印" class="headerlink" title="优雅的打印"></a>优雅的打印</h3><p>下面的方式可以用优雅的方式打印字典和列表:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pprint import pprint</span><br><span class="line">pprint(my_dict)</span><br></pre></td></tr></table></figure>
<p>这用于字段打印是非常高效的,如果你想从文件中快速优雅的打印json格式的数据,可以这样做:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat file.json | python -m json.tool</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>PYTHON</tag>
      </tags>
  </entry>
  <entry>
    <title>Python小技巧和有趣的内置函数</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h2 id="Python小技巧和有趣的内置函数"><a href="#Python小技巧和有趣的内置函数" class="headerlink" title="Python小技巧和有趣的内置函数"></a>Python小技巧和有趣的内置函数</h2><blockquote>
<p>一个python小技巧的集合和一些很有用的Python内置函数,这些函数简直是屌爆了，我认为每个 Pythoner 都应该知道这些函数。</p>
</blockquote>
<h3 id="1-1-拆箱"><a href="#1-1-拆箱" class="headerlink" title="1.1 拆箱"></a>1.1 拆箱</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a, b, c &#x3D; 1, 2, 3  </span><br><span class="line">&gt;&gt;&gt; a, b, c  </span><br><span class="line">(1, 2, 3)  </span><br><span class="line">&gt;&gt;&gt; a, b, c &#x3D; [1, 2, 3]  </span><br><span class="line">&gt;&gt;&gt; a, b, c  </span><br><span class="line">(1, 2, 3)  </span><br><span class="line">&gt;&gt;&gt; a, b, c &#x3D; (2 * i + 1  for i in range(3))  </span><br><span class="line">&gt;&gt;&gt; a, b, c  </span><br><span class="line">(1, 3, 5)  </span><br><span class="line">&gt;&gt;&gt; a, (b, c), d &#x3D; [1, (2, 3), 4]  </span><br><span class="line">&gt;&gt;&gt; a  </span><br><span class="line">1  </span><br><span class="line">&gt;&gt;&gt; b  </span><br><span class="line">2  </span><br><span class="line">&gt;&gt;&gt; c  </span><br><span class="line">3  </span><br><span class="line">&gt;&gt;&gt; d  </span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<h3 id="1-2-拆箱变量交换"><a href="#1-2-拆箱变量交换" class="headerlink" title="1.2 拆箱变量交换"></a>1.2 拆箱变量交换</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a, b &#x3D; 1, 2  </span><br><span class="line">&gt;&gt;&gt; a, b &#x3D; b, a  </span><br><span class="line">&gt;&gt;&gt; a, b  </span><br><span class="line">(2, 1)</span><br></pre></td></tr></table></figure>
<h3 id="1-3-扩展拆箱-只兼容python3"><a href="#1-3-扩展拆箱-只兼容python3" class="headerlink" title="1.3 扩展拆箱(只兼容python3)"></a>1.3 扩展拆箱(只兼容python3)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a, *b, c &#x3D; [1, 2, 3, 4, 5]  </span><br><span class="line">&gt;&gt;&gt; a  </span><br><span class="line">1  </span><br><span class="line">&gt;&gt;&gt; b  </span><br><span class="line">[2, 3, 4]  </span><br><span class="line">&gt;&gt;&gt; c  </span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<h3 id="1-4-负数索引"><a href="#1-4-负数索引" class="headerlink" title="1.4 负数索引"></a>1.4 负数索引</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]  </span><br><span class="line">&gt;&gt;&gt; a[-1]  </span><br><span class="line">10  </span><br><span class="line">&gt;&gt;&gt; a[-3]  </span><br><span class="line">8</span><br></pre></td></tr></table></figure>
<h3 id="1-5-切割列表"><a href="#1-5-切割列表" class="headerlink" title="1.5 切割列表"></a>1.5 切割列表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]  </span><br><span class="line">&gt;&gt;&gt; a &#x3D; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]  </span><br><span class="line">&gt;&gt;&gt; a[2:8]  </span><br><span class="line">[2, 3, 4, 5, 6, 7]</span><br></pre></td></tr></table></figure>
<h3 id="1-6-负数索引切割列表"><a href="#1-6-负数索引切割列表" class="headerlink" title="1.6 负数索引切割列表"></a>1.6 负数索引切割列表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]  </span><br><span class="line">&gt;&gt;&gt; a[-4:-2]  </span><br><span class="line">[7, 8]</span><br></pre></td></tr></table></figure>
<h3 id="1-7指定步长切割列表"><a href="#1-7指定步长切割列表" class="headerlink" title="1.7指定步长切割列表"></a>1.7指定步长切割列表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]  </span><br><span class="line">&gt;&gt;&gt; a[::2]  </span><br><span class="line">[0, 2, 4, 6, 8, 10]  </span><br><span class="line">&gt;&gt;&gt; a[::3]  </span><br><span class="line">[0, 3, 6, 9]  </span><br><span class="line">&gt;&gt;&gt; a[2:8:2]  </span><br><span class="line">[2, 4, 6]</span><br></pre></td></tr></table></figure>
<h3 id="1-8-负数步长切割列表"><a href="#1-8-负数步长切割列表" class="headerlink" title="1.8 负数步长切割列表"></a>1.8 负数步长切割列表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]  </span><br><span class="line">&gt;&gt;&gt; a[::-1]  </span><br><span class="line">[10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]  </span><br><span class="line">&gt;&gt;&gt; a[::-2]  </span><br><span class="line">[10, 8, 6, 4, 2, 0]</span><br></pre></td></tr></table></figure>
<h3 id="1-9-列表切割赋值"><a href="#1-9-列表切割赋值" class="headerlink" title="1.9 列表切割赋值"></a>1.9 列表切割赋值</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; [1, 2, 3, 4, 5]  </span><br><span class="line">&gt;&gt;&gt; a[2:3] &#x3D; [0, 0]  </span><br><span class="line">&gt;&gt;&gt; a  </span><br><span class="line">[1, 2, 0, 0, 4, 5]  </span><br><span class="line">&gt;&gt;&gt; a[1:1] &#x3D; [8, 9]  </span><br><span class="line">&gt;&gt;&gt; a  </span><br><span class="line">[1, 8, 9, 2, 0, 0, 4, 5]  </span><br><span class="line">&gt;&gt;&gt; a[1:-1] &#x3D; []  </span><br><span class="line">&gt;&gt;&gt; a  </span><br><span class="line">[1, 5]</span><br></pre></td></tr></table></figure>
<h3 id="1-10-命名列表切割方式"><a href="#1-10-命名列表切割方式" class="headerlink" title="1.10 命名列表切割方式"></a>1.10 命名列表切割方式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; [0, 1, 2, 3, 4, 5]  </span><br><span class="line">&gt;&gt;&gt; LASTTHREE &#x3D; slice(-3, None)  </span><br><span class="line">&gt;&gt;&gt; LASTTHREE  </span><br><span class="line">slice(-3, None, None)  </span><br><span class="line">&gt;&gt;&gt; a[LASTTHREE]  </span><br><span class="line">[3, 4, 5]</span><br></pre></td></tr></table></figure>
<h3 id="1-11-列表以及迭代器的压缩和解压缩"><a href="#1-11-列表以及迭代器的压缩和解压缩" class="headerlink" title="1.11 列表以及迭代器的压缩和解压缩"></a>1.11 列表以及迭代器的压缩和解压缩</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; [1, 2, 3]  </span><br><span class="line">&gt;&gt;&gt; b &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]  </span><br><span class="line">&gt;&gt;&gt; z &#x3D; zip(a, b)  </span><br><span class="line">&gt;&gt;&gt; z  </span><br><span class="line">[(1, &#39;a&#39;), (2, &#39;b&#39;), (3, &#39;c&#39;)]  </span><br><span class="line">&gt;&gt;&gt; zip(*z)  </span><br><span class="line">[(1, 2, 3), (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)]</span><br></pre></td></tr></table></figure>
<h3 id="1-12-列表相邻元素压缩器"><a href="#1-12-列表相邻元素压缩器" class="headerlink" title="1.12 列表相邻元素压缩器"></a>1.12 列表相邻元素压缩器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; [1, 2, 3, 4, 5, 6]  </span><br><span class="line">&gt;&gt;&gt; zip(*([iter(a)] * 2))  </span><br><span class="line">[(1, 2), (3, 4), (5, 6)]  </span><br><span class="line">&gt;&gt;&gt; group_adjacent &#x3D; lambda a, k: zip(*([iter(a)] * k))  </span><br><span class="line">&gt;&gt;&gt; group_adjacent(a, 3)  </span><br><span class="line">[(1, 2, 3), (4, 5, 6)]  </span><br><span class="line">&gt;&gt;&gt; group_adjacent(a, 2)  </span><br><span class="line">[(1, 2), (3, 4), (5, 6)]  </span><br><span class="line">&gt;&gt;&gt; group_adjacent(a, 1)  </span><br><span class="line">[(1,), (2,), (3,), (4,), (5,), (6,)]  </span><br><span class="line">  </span><br><span class="line">&gt;&gt;&gt; zip(a[::2], a[1::2])  </span><br><span class="line">[(1, 2), (3, 4), (5, 6)]  </span><br><span class="line">  </span><br><span class="line">&gt;&gt;&gt; zip(a[::3], a[1::3], a[2::3])  </span><br><span class="line">[(1, 2, 3), (4, 5, 6)]  </span><br><span class="line">  </span><br><span class="line">&gt;&gt;&gt; group_adjacent &#x3D; lambda a, k: zip(*(a[i::k] for i in range(k)))  </span><br><span class="line">&gt;&gt;&gt; group_adjacent(a, 3)  </span><br><span class="line">[(1, 2, 3), (4, 5, 6)]  </span><br><span class="line">&gt;&gt;&gt; group_adjacent(a, 2)  </span><br><span class="line">[(1, 2), (3, 4), (5, 6)]  </span><br><span class="line">&gt;&gt;&gt; group_adjacent(a, 1)  </span><br><span class="line">[(1,), (2,), (3,), (4,), (5,), (6,)]</span><br></pre></td></tr></table></figure>
<h3 id="1-13-在列表中用压缩器和迭代器滑动取值窗口"><a href="#1-13-在列表中用压缩器和迭代器滑动取值窗口" class="headerlink" title="1.13 在列表中用压缩器和迭代器滑动取值窗口"></a>1.13 在列表中用压缩器和迭代器滑动取值窗口</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; def n_grams(a, n):  </span><br><span class="line">... z &#x3D; [iter(a[i:]) for i in range(n)]  </span><br><span class="line">... return zip(*z)  </span><br><span class="line">...  </span><br><span class="line">&gt;&gt;&gt; a &#x3D; [1, 2, 3, 4, 5, 6]  </span><br><span class="line">&gt;&gt;&gt; n_grams(a, 3)  </span><br><span class="line">[(1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 5, 6)]  </span><br><span class="line">&gt;&gt;&gt; n_grams(a, 2)  </span><br><span class="line">[(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]  </span><br><span class="line">&gt;&gt;&gt; n_grams(a, 4)  </span><br><span class="line">[(1, 2, 3, 4), (2, 3, 4, 5), (3, 4, 5, 6)]</span><br></pre></td></tr></table></figure>
<h3 id="用压缩器反转字典"><a href="#用压缩器反转字典" class="headerlink" title="用压缩器反转字典"></a>用压缩器反转字典</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; m &#x3D; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4&#125;  </span><br><span class="line">&gt;&gt;&gt; m.items()  </span><br><span class="line">[(&#39;a&#39;, 1), (&#39;c&#39;, 3), (&#39;b&#39;, 2), (&#39;d&#39;, 4)]  </span><br><span class="line">&gt;&gt;&gt; zip(m.values(), m.keys())  </span><br><span class="line">[(1, &#39;a&#39;), (3, &#39;c&#39;), (2, &#39;b&#39;), (4, &#39;d&#39;)]  </span><br><span class="line">&gt;&gt;&gt; mi &#x3D; dict(zip(m.values(), m.keys()))  </span><br><span class="line">&gt;&gt;&gt; mi  </span><br><span class="line">&#123;1: &#39;a&#39;, 2: &#39;b&#39;, 3: &#39;c&#39;, 4: &#39;d&#39;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-15-列表展开"><a href="#1-15-列表展开" class="headerlink" title="1.15 列表展开"></a>1.15 列表展开</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; [[1, 2], [3, 4], [5, 6]]  </span><br><span class="line">&gt;&gt;&gt; list(itertools.chain.from_iterable(a))  </span><br><span class="line">[1, 2, 3, 4, 5, 6]  </span><br><span class="line">  </span><br><span class="line">&gt;&gt;&gt; sum(a, [])  </span><br><span class="line">[1, 2, 3, 4, 5, 6]  </span><br><span class="line">  </span><br><span class="line">&gt;&gt;&gt; [x for l in a for x in l]  </span><br><span class="line">[1, 2, 3, 4, 5, 6]  </span><br><span class="line">  </span><br><span class="line">&gt;&gt;&gt; a &#x3D; [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]  </span><br><span class="line">&gt;&gt;&gt; [x for l1 in a for l2 in l1 for x in l2]  </span><br><span class="line">[1, 2, 3, 4, 5, 6, 7, 8]  </span><br><span class="line">  </span><br><span class="line">&gt;&gt;&gt; a &#x3D; [1, 2, [3, 4], [[5, 6], [7, 8]]]  </span><br><span class="line">&gt;&gt;&gt; flatten &#x3D; lambda x: [y for l in x for y in flatten(l)] if type(x) is list else [x]  </span><br><span class="line">&gt;&gt;&gt; flatten(a)  </span><br><span class="line">[1, 2, 3, 4, 5, 6, 7, 8]</span><br></pre></td></tr></table></figure>
<h3 id="1-16-生成器表达式"><a href="#1-16-生成器表达式" class="headerlink" title="1.16 生成器表达式"></a>1.16 生成器表达式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; g &#x3D; (x ** 2  for x in xrange(10))  </span><br><span class="line">&gt;&gt;&gt; next(g)  </span><br><span class="line">0  </span><br><span class="line">&gt;&gt;&gt; next(g)  </span><br><span class="line">1  </span><br><span class="line">&gt;&gt;&gt; next(g)  </span><br><span class="line">4  </span><br><span class="line">&gt;&gt;&gt; next(g)  </span><br><span class="line">9  </span><br><span class="line">&gt;&gt;&gt; sum(x ** 3  for x in xrange(10))  </span><br><span class="line">2025  </span><br><span class="line">&gt;&gt;&gt; sum(x ** 3  for x in xrange(10) if x % 3 &#x3D;&#x3D; 1)  </span><br><span class="line">408</span><br></pre></td></tr></table></figure>
<h3 id="1-17-字典推导"><a href="#1-17-字典推导" class="headerlink" title="1.17 字典推导"></a>1.17 字典推导</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; m &#x3D; &#123;x: x ** 2  for x in range(5)&#125;  </span><br><span class="line">&gt;&gt;&gt; m  </span><br><span class="line">&#123;0: 0, 1: 1, 2: 4, 3: 9, 4: 16&#125;  </span><br><span class="line">  </span><br><span class="line">&gt;&gt;&gt; m &#x3D; &#123;x: &#39;A&#39; + str(x) for x in range(10)&#125;  </span><br><span class="line">&gt;&gt;&gt; m  </span><br><span class="line">&#123;0: &#39;A0&#39;, 1: &#39;A1&#39;, 2: &#39;A2&#39;, 3: &#39;A3&#39;, 4: &#39;A4&#39;, 5: &#39;A5&#39;, 6: &#39;A6&#39;, 7: &#39;A7&#39;, 8: &#39;A8&#39;, 9: &#39;A9&#39;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-18-用字典推导反转字典"><a href="#1-18-用字典推导反转字典" class="headerlink" title="1.18 用字典推导反转字典"></a>1.18 用字典推导反转字典</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; m &#x3D; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4&#125;  </span><br><span class="line">&gt;&gt;&gt; m  </span><br><span class="line">&#123;&#39;d&#39;: 4, &#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3&#125;  </span><br><span class="line">&gt;&gt;&gt; &#123;v: k for k, v in m.items()&#125;  </span><br><span class="line">&#123;1: &#39;a&#39;, 2: &#39;b&#39;, 3: &#39;c&#39;, 4: &#39;d&#39;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-19-命名元组"><a href="#1-19-命名元组" class="headerlink" title="1.19 命名元组"></a>1.19 命名元组</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; Point &#x3D; collections.namedtuple(&#39;Point&#39;, [&#39;x&#39;, &#39;y&#39;])  </span><br><span class="line">&gt;&gt;&gt; p &#x3D; Point(x&#x3D;1.0, y&#x3D;2.0)  </span><br><span class="line">&gt;&gt;&gt; p  </span><br><span class="line">Point(x&#x3D;1.0, y&#x3D;2.0)  </span><br><span class="line">&gt;&gt;&gt; p.x  </span><br><span class="line">1.0  </span><br><span class="line">&gt;&gt;&gt; p.y  </span><br><span class="line">2.0</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="http://python.jobbole.com/63320/" target="_blank" rel="noopener">更多请查看原文</a>  </p>
</blockquote>
<h3 id="函数部分"><a href="#函数部分" class="headerlink" title="函数部分"></a>函数部分</h3><h3 id="all-iterable"><a href="#all-iterable" class="headerlink" title="all(iterable)"></a>all(iterable)</h3><p>如果可迭代的对象(数组，字符串，列表等，下同)中的元素都是true(或者为空)的话返回True</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_all &#x3D; True  </span><br><span class="line">for item in iterable:  </span><br><span class="line">if  not item:  </span><br><span class="line">_all &#x3D; False  </span><br><span class="line">break  </span><br><span class="line">if _all:  </span><br><span class="line"># do stuff</span><br></pre></td></tr></table></figure>
<p>更简便的写法是:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if all(iterable):  </span><br><span class="line"># do stuff</span><br></pre></td></tr></table></figure>

<h3 id="any-iterable"><a href="#any-iterable" class="headerlink" title="any(iterable)"></a>any(iterable)</h3><p>如果可迭代的对象中任何一个元素为true的话返回True,如果可迭代的对象为空则返回False</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_any &#x3D; False  </span><br><span class="line">for item in iterable:  </span><br><span class="line">if item:  </span><br><span class="line">_any &#x3D; True  </span><br><span class="line">break  </span><br><span class="line">if _any:  </span><br><span class="line"># do stuff</span><br></pre></td></tr></table></figure>
<p>更简便的写法是:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if any(iterable):  </span><br><span class="line"># do stuff</span><br></pre></td></tr></table></figure>
<h3 id="cmp-x-y"><a href="#cmp-x-y" class="headerlink" title="cmp(x, y)"></a>cmp(x, y)</h3><p>比较两个对象 x 和 y , x &lt; y 的时候返回负数， x ==y 的时候返回 0， x &gt; y 的时候返回正数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def compare(x,y):  </span><br><span class="line">if x &lt; y:  </span><br><span class="line">return -1  </span><br><span class="line">elif x &#x3D;&#x3D; y:  </span><br><span class="line">return  0  </span><br><span class="line">else:  </span><br><span class="line">return  1</span><br></pre></td></tr></table></figure>
<p>你完全可以使用一句 cmp(x, y) 来替代。</p>
<h3 id="dict-arg"><a href="#dict-arg" class="headerlink" title="dict([arg])"></a>dict([arg])</h3><p>使用 arg 提供的条目生成一个新的字典。<br>arg 通常是未知的，但是它很方便！比如说，如果我们想把一个含两个元组的列表转换成一个字典，我们可以这么做。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l &#x3D; [(&#39;Knights&#39;, &#39;Ni&#39;), (&#39;Monty&#39;, &#39;Python&#39;), (&#39;SPAM&#39;, &#39;SPAAAM&#39;)]  </span><br><span class="line">d &#x3D; dict()  </span><br><span class="line">for tuple in l:  </span><br><span class="line">   d[tuple[0]] &#x3D; tuple[1]  </span><br><span class="line"># &#123;&#39;Knights&#39;: &#39;Ni&#39;, &#39;Monty&#39;: &#39;Python&#39;, &#39;SPAM&#39;: &#39;SPAAAM&#39;&#125;</span><br></pre></td></tr></table></figure>
<p>或者这样:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l &#x3D; [(&#39;Knights&#39;, &#39;Ni&#39;), (&#39;Monty&#39;, &#39;Python&#39;), (&#39;SPAM&#39;, &#39;SPAAAM&#39;)]  </span><br><span class="line">d &#x3D; dict(l) # &#123;&#39;Knights&#39;: &#39;Ni&#39;, &#39;Monty&#39;: &#39;Python&#39;, &#39;SPAM&#39;: &#39;SPAAAM&#39;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="enumerate-iterable-start-0"><a href="#enumerate-iterable-start-0" class="headerlink" title="enumerate(iterable [,start=0])"></a>enumerate(iterable [,start=0])</h3><p>我真的是超级喜欢这个!如果你以前写过C语言，那么你可能会这么写:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for i in range(len(list)):  </span><br><span class="line"># do stuff with list[i], for example, print it  </span><br><span class="line">print i, list[i]</span><br></pre></td></tr></table></figure>
<p>噢,不用那么麻烦!你可以使用enumerate()来提高可读性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for i, item in enumerate(list):  </span><br><span class="line"># so stuff with item, for example print it  </span><br><span class="line">print i, item</span><br></pre></td></tr></table></figure>
<h3 id="isinstance-object-classinfo"><a href="#isinstance-object-classinfo" class="headerlink" title="isinstance(object, classinfo)"></a>isinstance(object, classinfo)</h3><p>如果 object 参数是 classinfo 参数的一个实例或者子类(直接或者间接)的话返回 True<br>当你想检验一个对象的类型的时候,第一个想到的应该是使用type()函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if type(obj) &#x3D;&#x3D; type(dict):  </span><br><span class="line"># do stuff  </span><br><span class="line">elif type(obj) &#x3D;&#x3D; type(list):  </span><br><span class="line"># do other stuff  </span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>或者你可以这么写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if isinstance(obj, dict):  </span><br><span class="line"># do stuff  </span><br><span class="line">elif isinstance(obj, list):  </span><br><span class="line"># do other stuff  </span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="pow-x-y-z"><a href="#pow-x-y-z" class="headerlink" title="pow(x, y [,z])"></a>pow(x, y [,z])</h3><p>返回 x 的 y 次幂(如果 z 存在的话则以 z 为模)。<br>如果你想计算 x 的 y 次方，以 z 为模，那么你可以这么写:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mod &#x3D; (x ** y) % z</span><br></pre></td></tr></table></figure>
<p>但是当 x=1234567， y=4567676， z=56 的时候我的电脑足足跑了 64 秒！<br>不要用 ** 和 % 了，使用 pow(x, y, z) 吧！这个例子可以写成 pow(1234567, 4567676, 56) ，只用了 0.034 秒就出了结果！</p>
<h3 id="zip-iterable"><a href="#zip-iterable" class="headerlink" title="zip([iterable, ])"></a>zip([iterable, ])</h3><p>这个函数返回一个含元组的列表，具体请看例子:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l1 &#x3D; (&#39;You gotta&#39;, &#39;the&#39;)  </span><br><span class="line">l2 &#x3D; (&#39;love&#39;, &#39;built-in&#39;)  </span><br><span class="line">out &#x3D; []  </span><br><span class="line">if len(l1) &#x3D;&#x3D; len(l2):  </span><br><span class="line">for i in range(len(l1)):  </span><br><span class="line">       out.append((l1[i], l2[i]))  </span><br><span class="line"># out &#x3D; [(&#39;You gotta&#39;, &#39;love&#39;), (&#39;the&#39;, &#39;built-in)]</span><br></pre></td></tr></table></figure>
<p>或者这么写:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l1 &#x3D; [&#39;You gotta&#39;, &#39;the&#39;]  </span><br><span class="line">l2 &#x3D; [&#39;love&#39;, &#39;built-in&#39;]  </span><br><span class="line">out &#x3D; zip(l1, l2) # [(&#39;You gotta&#39;, &#39;love&#39;), (&#39;the&#39;, &#39;built-in)]</span><br></pre></td></tr></table></figure>
<p>如果你想得到倒序的话加上 * 操作符就可以了:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print zip(*out)  </span><br><span class="line"># [(&#39;You gotta&#39;, &#39;the&#39;), (&#39;love&#39;, &#39;built-in&#39;)]</span><br></pre></td></tr></table></figure>

<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>Python 内置函数很方便，它们很快并且经过了优化，所以它们可能效率更高。<br>我真心认为每个 Python 开发者都应该好好看看内置函数的文档(引言部分)。<br>忘了说了，在 itertools 模块中有很多很不错的函数。</p>
]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>PYTHON</tag>
      </tags>
  </entry>
  <entry>
    <title>python的logging模块实现json格式的日志输出</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h2 id="python的logging模块实现json格式的日志输出"><a href="#python的logging模块实现json格式的日志输出" class="headerlink" title="python的logging模块实现json格式的日志输出"></a>python的logging模块实现json格式的日志输出</h2><blockquote>
<p>想要让开发过程或者是上线后的bug无处可藏，最好的方式便是在程序运行过程中，不断收集重要的日志，以供分析使用。Python中内置的log收集模块是logging，该模块使用起来比较方便，但是美中不足的地方就是日志的格式转成json比较麻烦。于是我结合logging和另一个模块python-json-logger(pip install python-json-logger), 实现json格式的日志输出。</p>
</blockquote>
<p>以下代码可以做成模块，直接导入使用</p>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;user&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import logging, logging.config, os</span><br><span class="line">import structlog</span><br><span class="line">import traceback</span><br><span class="line">from structlog import configure, processors, stdlib, threadlocal</span><br><span class="line">from pythonjsonlogger import jsonlogger</span><br><span class="line">BASE_DIR &#x3D; BASE_DIR &#x3D; os.path.dirname(os.path.abspath(__file__))</span><br><span class="line">DEBUG &#x3D; True  # 标记是否在开发环境</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 给过滤器使用的判断</span><br><span class="line">class RequireDebugTrue(logging.Filter):</span><br><span class="line">    # 实现filter方法</span><br><span class="line">    def filter(self, record):</span><br><span class="line">        return DEBUG</span><br><span class="line"></span><br><span class="line">def get_logger():</span><br><span class="line">    LOGGING &#x3D; &#123;</span><br><span class="line">    # 基本设置</span><br><span class="line">        &#39;version&#39;: 1,  # 日志级别</span><br><span class="line">        &#39;disable_existing_loggers&#39;: False,  # 是否禁用现有的记录器</span><br><span class="line"></span><br><span class="line">    # 日志格式集合</span><br><span class="line">        &#39;formatters&#39;: &#123;</span><br><span class="line">        # 标准输出格式</span><br><span class="line">            &#39;json&#39;: &#123;</span><br><span class="line">            # [具体时间][线程名:线程ID][日志名字:日志级别名称(日志级别ID)] [输出的模块:输出的函数]:日志内容</span><br><span class="line">                &#39;format&#39;: &#39;[%(asctime)s][%(threadName)s:%(thread)d][%(name)s:%(levelname)s(%(lineno)d)]\n[%(module)s:%(funcName)s]:%(message)s&#39;,</span><br><span class="line">                &#39;class&#39;: &#39;pythonjsonlogger.jsonlogger.JsonFormatter&#39;,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    # 过滤器</span><br><span class="line">        &#39;filters&#39;: &#123;</span><br><span class="line">            &#39;require_debug_true&#39;: &#123;</span><br><span class="line">                &#39;()&#39;: RequireDebugTrue,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    # 处理器集合</span><br><span class="line">        &#39;handlers&#39;: &#123;</span><br><span class="line">        # 输出到控制台</span><br><span class="line">        # 输出到文件</span><br><span class="line">            &#39;TimeChecklog&#39;: &#123;</span><br><span class="line">                &#39;level&#39;: &#39;DEBUG&#39;,</span><br><span class="line">                &#39;class&#39;: &#39;logging.handlers.RotatingFileHandler&#39;,</span><br><span class="line">                &#39;formatter&#39;: &#39;json&#39;,</span><br><span class="line">                &#39;filename&#39;: os.path.join(&quot;.&#x2F;&quot;, &#39;TimeoutCheck.log&#39;),  # 输出位置</span><br><span class="line">                &#39;maxBytes&#39;: 1024 * 1024 * 5,  # 文件大小 5M</span><br><span class="line">                &#39;backupCount&#39;: 5,  # 备份份数</span><br><span class="line">                &#39;encoding&#39;: &#39;utf8&#39;,  # 文件编码</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    # 日志管理器集合</span><br><span class="line">        &#39;loggers&#39;: &#123;</span><br><span class="line">        # 管理器</span><br><span class="line">            &#39;proxyCheck&#39;: &#123;</span><br><span class="line">                &#39;handlers&#39;: [&#39;TimeChecklog&#39;],</span><br><span class="line">                &#39;level&#39;: &#39;DEBUG&#39;,</span><br><span class="line">                &#39;propagate&#39;: True,  # 是否传递给父记录器</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    logging.config.dictConfig(LOGGING)</span><br><span class="line">    logger &#x3D; logging.getLogger(&quot;proxyCheck&quot;)</span><br><span class="line">    return logger</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 测试用例，你可以把get_logger()封装成一个模块，from xxx import get_logger()</span><br><span class="line">logger1 &#x3D; get_logger()</span><br><span class="line">def test():</span><br><span class="line">    try:</span><br><span class="line">        a &#x3D; 1 &#x2F; 0</span><br><span class="line">    except Exception as e:</span><br><span class="line">        logger1.error(&quot;This is a error info&quot;,exc_info&#x3D;True)  # 写入错误日志</span><br><span class="line">        #如果需要添加额外的信息，使用extra关键字即可</span><br><span class="line">        logger1.error(str(traceback.format_exc()), extra&#x3D;&#123;&quot;key1&quot;: &quot;value1&quot;, &quot;key2&quot;:&quot;value2&quot;&#125;)</span><br><span class="line">        # 其他错误处理代码</span><br><span class="line">        pass</span><br><span class="line">test()</span><br></pre></td></tr></table></figure>
<h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><p>测试的结果，可以在./TimeoutCheck.log文件中看到输出的日志</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat TimeoutCheck.log</span><br><span class="line">&#123;&quot;asctime&quot;: &quot;2019-01-31 11:29:16,818&quot;, &quot;threadName&quot;: &quot;MainThread&quot;, &quot;thread&quot;: 140735830963008, &quot;name&quot;: &quot;proxyCheck&quot;, &quot;levelname&quot;: &quot;ERROR&quot;, &quot;%(lineno&quot;: null, &quot;module&quot;: &quot;log&quot;, &quot;funcName&quot;: &quot;test&quot;, &quot;message&quot;: &quot;This is a error info&quot;, &quot;exc_info&quot;: &quot;Traceback (most recent call last):\n  File \&quot;log.py\&quot;, line 74, in test\n    a &#x3D; 1 &#x2F; 0\nZeroDivisionError: division by zero&quot;&#125;</span><br><span class="line">&#123;&quot;asctime&quot;: &quot;2019-01-31 11:29:16,819&quot;, &quot;threadName&quot;: &quot;MainThread&quot;, &quot;thread&quot;: 140735830963008, &quot;name&quot;: &quot;proxyCheck&quot;, &quot;levelname&quot;: &quot;ERROR&quot;, &quot;%(lineno&quot;: null, &quot;module&quot;: &quot;log&quot;, &quot;funcName&quot;: &quot;test&quot;, &quot;message&quot;: &quot;Traceback (most recent call last):\n  File \&quot;log.py\&quot;, line 74, in test\n    a &#x3D; 1 &#x2F; 0\nZeroDivisionError: division by zero\n&quot;, &quot;key1&quot;: &quot;value1&quot;, &quot;key2&quot;: &quot;value2&quot;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="版本二"><a href="#版本二" class="headerlink" title="版本二"></a>版本二</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import json</span><br><span class="line">import datetime</span><br><span class="line">import logging</span><br><span class="line">import logging.config</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">class LogstashFormatter(logging.Formatter):</span><br><span class="line">    def __init__(self, task_name&#x3D;None):</span><br><span class="line">        self.task_name &#x3D; task_name</span><br><span class="line"></span><br><span class="line">        super(LogstashFormatter, self).__init__()</span><br><span class="line"></span><br><span class="line">    def format(self, record):</span><br><span class="line">        data &#x3D; &#123;&#39;@message&#39;: record.msg,</span><br><span class="line">                &#39;@timestamp&#39;: datetime.datetime.utcnow().strftime(&#39;%Y-%m-%dT%H:%M:%S.%fZ&#39;),</span><br><span class="line">                &#39;@type&#39;: &#39;Add log extra test&#39;&#125;</span><br><span class="line"></span><br><span class="line">        if self.task_name:</span><br><span class="line">            data[&#39;@task_name&#39;] &#x3D; self.task_name</span><br><span class="line"></span><br><span class="line">        for key, value in record.args.items():</span><br><span class="line">            data[key] &#x3D; value</span><br><span class="line"></span><br><span class="line">        return json.dumps(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">logger &#x3D; logging.getLogger(__name__)</span><br><span class="line"></span><br><span class="line">logging.config.dictConfig(&#123;</span><br><span class="line">    &#39;version&#39;: 1,</span><br><span class="line">    &#39;disable_existing_loggers&#39;: False,  # this fixes the problem</span><br><span class="line">    &#39;formatters&#39;: &#123;</span><br><span class="line">        &#39;json&#39;: &#123;</span><br><span class="line">            &#39;()&#39;: LogstashFormatter,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#39;handlers&#39;: &#123;</span><br><span class="line">        &#39;console&#39;: &#123;</span><br><span class="line">            &#39;level&#39;: &#39;DEBUG&#39;,</span><br><span class="line">            &#39;class&#39;: &#39;logging.StreamHandler&#39;,</span><br><span class="line">            &#39;formatter&#39;: &#39;json&#39;,</span><br><span class="line">            &#39;stream&#39;: sys.stdout</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#39;loggers&#39;: &#123;</span><br><span class="line">        &#39;&#39;: &#123;</span><br><span class="line">            &#39;handlers&#39;: [&#39;console&#39;],</span><br><span class="line">            &#39;level&#39;: &#39;INFO&#39;,</span><br><span class="line">            &#39;propagate&#39;: True,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">logger.info(&#39;It works!&#39;, &#123;&#39;aaa&#39;:&#39;bbbb&#39;,&#39;cccc&#39;:&#39;dddd&#39;&#125;)</span><br><span class="line"></span><br><span class="line"># output:</span><br><span class="line">&#123;&quot;@message&quot;: &quot;It works!&quot;, &quot;@timestamp&quot;: &quot;2019-01-31T02:52:24.786570Z&quot;, &quot;@type&quot;: &quot;Add log extra test&quot;, &quot;aaa&quot;: &quot;bbbb&quot;, &quot;cccc&quot;: &quot;dddd&quot;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="版本三"><a href="#版本三" class="headerlink" title="版本三"></a>版本三</h3><blockquote>
<p>此版本为优化版本,继承pythonjsonlogger.jsonlogger库中的JsonFormatter类,重写format方法</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">@author: shuke</span><br><span class="line">@file: jsonlog.py </span><br><span class="line">@time: 2019&#x2F;01&#x2F;20 15:36</span><br><span class="line">@contact: shu_ke163@163.com</span><br><span class="line">@software:  shuke-logging</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line">import time</span><br><span class="line">import json</span><br><span class="line">import socket</span><br><span class="line">import datetime</span><br><span class="line">import logging</span><br><span class="line">import traceback</span><br><span class="line">import logging.config</span><br><span class="line">from pythonjsonlogger.jsonlogger import JsonFormatter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class JsonFormatter(JsonFormatter):</span><br><span class="line">    def __init__(self, *args, **kwargs):</span><br><span class="line">        self.host &#x3D; socket.getfqdn()</span><br><span class="line">        self.message_type &#x3D; &quot;json&quot;</span><br><span class="line">        self.version &#x3D; &quot;v1.0&quot;</span><br><span class="line">        super(JsonFormatter, self).__init__(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    def get_extra_fields(self, record):</span><br><span class="line">        # The list contains all the attributes listed in</span><br><span class="line">        # http:&#x2F;&#x2F;docs.python.org&#x2F;library&#x2F;logging.html#logrecord-attributes</span><br><span class="line">        builtin_attr_list &#x3D; [</span><br><span class="line">            &#39;args&#39;, &#39;asctime&#39;, &#39;created&#39;, &#39;exc_info&#39;, &#39;exc_text&#39;, &#39;filename&#39;, &#39;id&#39;, &#39;levelname&#39;, &#39;levelno&#39;, &#39;module&#39;,</span><br><span class="line">            &#39;msecs&#39;, &#39;msecs&#39;, &#39;message&#39;, &#39;msg&#39;, &#39;name&#39;, &#39;pathname&#39;, &#39;relativeCreated&#39;, &#39;extra&#39;]</span><br><span class="line"></span><br><span class="line">        fields &#x3D; &#123;&#125;</span><br><span class="line"></span><br><span class="line">        for key, value in record.__dict__.items():</span><br><span class="line">            if key not in builtin_attr_list:</span><br><span class="line">                fields[key] &#x3D; repr(value)</span><br><span class="line"></span><br><span class="line">        fields[&quot;project&quot;] &#x3D; &quot;WEHOST&quot;</span><br><span class="line">        fields[&quot;team&quot;] &#x3D; &quot;OPS&quot;</span><br><span class="line">        fields[&quot;department&quot;] &#x3D; &quot;IT&quot;</span><br><span class="line">        fields[&quot;log_debug&quot;] &#x3D; True</span><br><span class="line"></span><br><span class="line">        return fields</span><br><span class="line"></span><br><span class="line">    def format_timestamp(self, time):</span><br><span class="line">        return datetime.datetime.now().strftime(&#39;%Y-%m-%d %H:%M:%S %f&#39;)</span><br><span class="line"></span><br><span class="line">    def format(self, record):</span><br><span class="line">        message &#x3D; &#123;</span><br><span class="line">            &#39;@timestamp&#39;: self.format_timestamp(record.created),</span><br><span class="line">            &#39;@version&#39;: &#39;v1.0&#39;,</span><br><span class="line">            &#39;name&#39;: record.name,</span><br><span class="line">            &#39;host&#39;: self.host,</span><br><span class="line">            &#39;pathname&#39;: record.pathname,</span><br><span class="line">            &#39;levelno&#39;: record.levelno,</span><br><span class="line">            &#39;filename&#39;: record.filename,</span><br><span class="line">            &#39;module&#39;: record.module,</span><br><span class="line">            &#39;exc_info&#39;: &#39;&#39;.join(traceback.format_exception(*record.exc_info)),</span><br><span class="line">            &#39;exc_text&#39;: record.exc_text,</span><br><span class="line">            &#39;stack_info&#39;: record.stack_info,</span><br><span class="line">            &#39;created&#39;: time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time.localtime(record.created)),</span><br><span class="line">            &#39;msecs&#39;: record.msecs,</span><br><span class="line">            &#39;relativeCreated&#39;: record.relativeCreated,</span><br><span class="line">            &#39;type&#39;: self.message_type,</span><br><span class="line">            &#39;level&#39;: record.levelname,</span><br><span class="line">            &#39;message&#39;: record.getMessage(),</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        # Add extra fields</span><br><span class="line">        message.update(self.get_extra_fields(record))</span><br><span class="line"></span><br><span class="line">        return json.dumps(message, indent&#x3D;4)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_logger():</span><br><span class="line">    LOGGING &#x3D; &#123;</span><br><span class="line">        # 基本设置</span><br><span class="line">        &#39;version&#39;: 1,  # 日志级别</span><br><span class="line">        &#39;disable_existing_loggers&#39;: False,  # 是否禁用现有的记录器</span><br><span class="line"></span><br><span class="line">        # 日志格式集合</span><br><span class="line">        &#39;formatters&#39;: &#123;</span><br><span class="line">            # 标准输出格式</span><br><span class="line">            &#39;json&#39;: &#123;</span><br><span class="line">                # [具体时间][线程名:线程ID][日志名字:日志级别名称(日志级别ID)] [输出的模块:输出的函数]:日志内容</span><br><span class="line">                # &#39;format&#39;: &#39;[%(asctime)s][%(threadName)s:%(thread)d][%(name)s:%(levelname)s(%(lineno)d)]\n[%(module)s:%(funcName)s]:%(message)s&#39;,</span><br><span class="line">                # &#39;format&#39;: &#39;[%(asctime)s][%(threadName)s:%(thread)d][%(created)s:%(process)d:%(processName)s][%(relativeCreated)s:%(msecs)s][%(pathname)s:%(filename)s][%(name)s:%(levelname)s:%(lineno)d)][%(module)s:%(funcName)s]:%(message)s&#39;,</span><br><span class="line">                # &#39;()&#39;: JsonFormatter.format,</span><br><span class="line">                # &#39;class&#39;: &#39;pythonjsonlogger.jsonlogger.JsonFormatter&#39;,</span><br><span class="line">                &#39;()&#39;: JsonFormatter,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        # 处理器集合</span><br><span class="line">        &#39;handlers&#39;: &#123;</span><br><span class="line">            # 输出到控制台</span><br><span class="line">            &#39;console&#39;: &#123;</span><br><span class="line">                &#39;level&#39;: &#39;DEBUG&#39;,</span><br><span class="line">                &#39;class&#39;: &#39;logging.StreamHandler&#39;,</span><br><span class="line">                &#39;formatter&#39;: &#39;json&#39;,</span><br><span class="line">                &#39;stream&#39;: sys.stdout</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        # 日志管理器集合</span><br><span class="line">        &#39;loggers&#39;: &#123;</span><br><span class="line">            # 管理器</span><br><span class="line">            &#39;mylog&#39;: &#123;</span><br><span class="line">                &#39;handlers&#39;: [&#39;console&#39;],</span><br><span class="line">                &#39;level&#39;: &#39;DEBUG&#39;,</span><br><span class="line">                &#39;propagate&#39;: True,  # 是否传递给父记录器</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    logging.config.dictConfig(LOGGING)</span><br><span class="line">    logger &#x3D; logging.getLogger(&quot;mylog&quot;)</span><br><span class="line">    return logger</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 测试用例，你可以把get_logger()封装成一个模块，from xxx import get_logger()</span><br><span class="line">logger &#x3D; get_logger()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    try:</span><br><span class="line">        a &#x3D; 1 &#x2F; 0</span><br><span class="line">    except Exception as e:</span><br><span class="line">        # 如果需要添加额外的信息，使用extra关键字即可</span><br><span class="line">        logger.info(&quot;This is a info message&quot;, extra&#x3D;&#123;&quot;type&quot;: &quot;json&quot;, &quot;department&quot;: &quot;IT&quot;, &quot;bussiness&quot;: &quot;game&quot;&#125;,</span><br><span class="line">                    exc_info&#x3D;True)</span><br><span class="line">        logger.info(&quot;Hello World&quot;, extra&#x3D;&#123;&quot;key1&quot;: &quot;value1&quot;, &quot;key2&quot;: &quot;value2&quot;&#125;, exc_info&#x3D;True)</span><br><span class="line">        # 其他错误处理代码</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    main()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># output:</span><br><span class="line">&#123;</span><br><span class="line">    &quot;@timestamp&quot;: &quot;2019-01-31 18:53:39 581892&quot;,</span><br><span class="line">    &quot;@version&quot;: &quot;v1.0&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;mylog&quot;,</span><br><span class="line">    &quot;host&quot;: &quot;MacBooKPro&quot;,</span><br><span class="line">    &quot;pathname&quot;: &quot;jsonlog.py&quot;,</span><br><span class="line">    &quot;levelno&quot;: 20,</span><br><span class="line">    &quot;filename&quot;: &quot;jsonlog.py&quot;,</span><br><span class="line">    &quot;module&quot;: &quot;jsonlog&quot;,</span><br><span class="line">    &quot;exc_info&quot;: &quot;Traceback (most recent call last):\n  File \&quot;jsonlog.py\&quot;, line 129, in test\n    a &#x3D; 1 &#x2F; 0\nZeroDivisionError: division by zero\n&quot;,</span><br><span class="line">    &quot;exc_text&quot;: null,</span><br><span class="line">    &quot;stack_info&quot;: &quot;None&quot;,</span><br><span class="line">    &quot;created&quot;: &quot;2019-01-31 18:53:39&quot;,</span><br><span class="line">    &quot;msecs&quot;: 581.8040370941162,</span><br><span class="line">    &quot;relativeCreated&quot;: 47.5161075592041,</span><br><span class="line">    &quot;type&quot;: &quot;&#39;json&#39;&quot;,</span><br><span class="line">    &quot;level&quot;: &quot;INFO&quot;,</span><br><span class="line">    &quot;message&quot;: &quot;This is a info message&quot;,</span><br><span class="line">    &quot;lineno&quot;: &quot;133&quot;,</span><br><span class="line">    &quot;funcName&quot;: &quot;&#39;test&#39;&quot;,</span><br><span class="line">    &quot;thread&quot;: &quot;140735830963008&quot;,</span><br><span class="line">    &quot;threadName&quot;: &quot;&#39;MainThread&#39;&quot;,</span><br><span class="line">    &quot;processName&quot;: &quot;&#39;MainProcess&#39;&quot;,</span><br><span class="line">    &quot;process&quot;: &quot;83309&quot;,</span><br><span class="line">    &quot;department&quot;: &quot;IT&quot;,</span><br><span class="line">    &quot;bussiness&quot;: &quot;&#39;game&#39;&quot;,</span><br><span class="line">    &quot;project&quot;: &quot;WEHOST&quot;,</span><br><span class="line">    &quot;team&quot;: &quot;OPS&quot;,</span><br><span class="line">    &quot;log_debug&quot;: true</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;@timestamp&quot;: &quot;2019-01-31 18:53:39 582770&quot;,</span><br><span class="line">    &quot;@version&quot;: &quot;v1.0&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;mylog&quot;,</span><br><span class="line">    &quot;host&quot;: &quot;MacBooKPro&quot;,</span><br><span class="line">    &quot;pathname&quot;: &quot;jsonlog.py&quot;,</span><br><span class="line">    &quot;levelno&quot;: 20,</span><br><span class="line">    &quot;filename&quot;: &quot;jsonlog.py&quot;,</span><br><span class="line">    &quot;module&quot;: &quot;jsonlog&quot;,</span><br><span class="line">    &quot;exc_info&quot;: &quot;Traceback (most recent call last):\n  File \&quot;jsonlog.py\&quot;, line 129, in test\n    a &#x3D; 1 &#x2F; 0\nZeroDivisionError: division by zero\n&quot;,</span><br><span class="line">    &quot;exc_text&quot;: null,</span><br><span class="line">    &quot;stack_info&quot;: &quot;None&quot;,</span><br><span class="line">    &quot;created&quot;: &quot;2019-01-31 18:53:39&quot;,</span><br><span class="line">    &quot;msecs&quot;: 582.7357769012451,</span><br><span class="line">    &quot;relativeCreated&quot;: 48.44784736633301,</span><br><span class="line">    &quot;type&quot;: &quot;json&quot;,</span><br><span class="line">    &quot;level&quot;: &quot;INFO&quot;,</span><br><span class="line">    &quot;message&quot;: &quot;Hello World&quot;,</span><br><span class="line">    &quot;lineno&quot;: &quot;134&quot;,</span><br><span class="line">    &quot;funcName&quot;: &quot;&#39;test&#39;&quot;,</span><br><span class="line">    &quot;thread&quot;: &quot;140735830963008&quot;,</span><br><span class="line">    &quot;threadName&quot;: &quot;&#39;MainThread&#39;&quot;,</span><br><span class="line">    &quot;processName&quot;: &quot;&#39;MainProcess&#39;&quot;,</span><br><span class="line">    &quot;process&quot;: &quot;83309&quot;,</span><br><span class="line">    &quot;key1&quot;: &quot;&#39;value1&#39;&quot;,</span><br><span class="line">    &quot;key2&quot;: &quot;&#39;value2&#39;&quot;,</span><br><span class="line">    &quot;project&quot;: &quot;WEHOST&quot;,</span><br><span class="line">    &quot;team&quot;: &quot;OPS&quot;,</span><br><span class="line">    &quot;department&quot;: &quot;IT&quot;,</span><br><span class="line">    &quot;log_debug&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到日志是json格式，这样你就可以很方便的使用grafna和kafka-&gt;logstash-&gt;es的方式进行日志收集展示了.如果需要将日志直接打到kafka中,需要使用kafka-python库,同时定义handlers进行处理.</p>
]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>PYTHON</tag>
      </tags>
  </entry>
  <entry>
    <title>世界上最小的Django项目示例</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h2 id="一-世界上最小的Django项目示例"><a href="#一-世界上最小的Django项目示例" class="headerlink" title="一. 世界上最小的Django项目示例"></a>一. 世界上最小的Django项目示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># hello.py</span><br><span class="line">import os</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">from django.conf import settings</span><br><span class="line"></span><br><span class="line">DEBUG &#x3D; os.environ.get(&quot;DEBUG&quot;,&quot;on&quot;) &#x3D;&#x3D; &quot;on&quot;</span><br><span class="line">SECRET_KEY &#x3D; os.environ.get(&quot;SECRET_KEY&quot;,&quot;&#123;&#123; secret_key &#125;&#125;&quot;)</span><br><span class="line">ALLOWED_HOSTS &#x3D; os.environ.get(&quot;ALLOWED_HOST&quot;,&quot;localhost&quot;).split(&quot;,&quot;)</span><br><span class="line"></span><br><span class="line">settings.configure(</span><br><span class="line">    DEBUG&#x3D;DEBUG,</span><br><span class="line">    SECRET_KEY&#x3D;SECRET_KEY,</span><br><span class="line">    ALLOWED_HOSTS&#x3D;ALLOWED_HOSTS,</span><br><span class="line">    ROOT_URLCONF&#x3D;__name__,</span><br><span class="line">    MIDDLEWARE_CLASSES&#x3D;(</span><br><span class="line">        &#39;django.middleware.common.CommonMiddleware&#39;,</span><br><span class="line">        &#39;django.middleware.csrf.CsrfViewMiddleware&#39;,</span><br><span class="line">        &#39;django.middleware.clickjacking.XFrameOptionsMiddleware&#39;,</span><br><span class="line">    ),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">from django.conf.urls import url</span><br><span class="line">from django.http import HttpResponse</span><br><span class="line"></span><br><span class="line">def index(request):</span><br><span class="line">    return HttpResponse(&#39;Heello World&#39;)</span><br><span class="line">    </span><br><span class="line">urlpatters &#x3D; (</span><br><span class="line">    url(r&#39;^$&#39;,index),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">if __name &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    from django.core.management import execute_from_command_line</span><br><span class="line">    execute_from_command_line(sys.argv)</span><br></pre></td></tr></table></figure>

<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ python hello.py runserver</span><br></pre></td></tr></table></figure>


<h2 id="二-使用gunincorn运行python服务"><a href="#二-使用gunincorn运行python服务" class="headerlink" title="二. 使用gunincorn运行python服务"></a>二. 使用gunincorn运行python服务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cat hello.py</span><br><span class="line">from django.conf.urls import url</span><br><span class="line">from django.core.wsgi import get_wsgi_application</span><br><span class="line">from django.http import Httpresponse</span><br><span class="line"></span><br><span class="line">application &#x3D; get_wsgi_application()</span><br><span class="line"></span><br><span class="line">if __name &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">   from django.core.management import execute_from_command_line</span><br><span class="line">   execute_from_command_line(sys.argv)</span><br></pre></td></tr></table></figure>
<h3 id="安装gunicorn并运行"><a href="#安装gunicorn并运行" class="headerlink" title="安装gunicorn并运行"></a>安装gunicorn并运行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># pip install gunicorn</span><br><span class="line"># gunicorn hello --log-file&#x3D;-</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>利用P2P软件(Murder)大规模分发大文件</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h2 id="利用P2P软件-Murder-大规模分发大文件"><a href="#利用P2P软件-Murder-大规模分发大文件" class="headerlink" title="利用P2P软件(Murder)大规模分发大文件"></a>利用P2P软件(Murder)大规模分发大文件</h2><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>当服务器多时，为了管理方便和提升效率，就会用到自动化管理工具（如Ansible）来自动部署和批量分发文件。</p>
<blockquote>
<p>场景描述：目前有50+台服务器，已部署Ansible用于自动化部署和批量分发文件。批量分发文件时，一般把文件传到 Ansible 所在的服务器并通过 copy或者synchronize 模块传输，文件小于100M时，分发正常。当传输大文件时（100M+），受单节点及其带宽的影响，整个分发过程变得非常缓慢，甚至出现Ansible卡死。</p>
</blockquote>
<p>使用 Ansible 来分发小文件速度很快，但对于大文件，文件分发就是一个很大的问题。在使用单一分布点和固定出口带宽的情况下，经常存在带宽拥堵、耗费时间长的问题。</p>
<p>对于大文件分发，首先想到的是 BitTorrent ，利用 P2P 协议实现快速分发，节省带宽，提高效率。</p>
<h2 id="P2P软件介绍"><a href="#P2P软件介绍" class="headerlink" title="P2P软件介绍"></a>P2P软件介绍</h2><p>为了解决上面的问题，这里我们使用 Murder </p>
<p><a href="https://github.com/lg/murder" target="_blank" rel="noopener">Murder</a>是 Twitter 的开源项目，很适合大文件分发。（该项目还能用，但官方已经不再继续维护）</p>
<p>项目介绍中有这么一段话：Large scale server deploys using BitTorrent and the BitTornado library</p>
<p>根据 Murder 开发者的博客，可以知道这个项目的来龙去脉：</p>
<blockquote>
<p>Twitter 在早期便依赖 Capistrano 来进行应用程序的部署，每当有新版本需要发布时，Capistrano 会根据预设好的各种设置和流程到 Twitter 所有的服务器上进行更新的操作。<br>在过去服务器还不多的情況下一切都很美好，但随着 Twitter 服务器数量的增长，到了几百台服务器时，事情已经不再像过去一样美好，甚至到后来拥有数千台服务器时，更新的操作会耗费 40 分钟。<br>Twitter 针对这个问题，认为问题的关键在于：使用集中式的系统，也就是所有的服务器要轮流排队到同一台版本控制系统上进行代码更新。</p>
</blockquote>
<p>Twitter 最初的想法是将版本控制系统也做出分散式的架构，服务器的代码更新就可以分散到不同的机器来压缩部署时间，但事实上版本控制系统即使分散在多台服务器上，这些服务器要更新文件也同样需要时间。<br>因此 Twitter 发现或许需要一个完全去中心化、最好是像 BitTorrent 这样的，利用 P2P 的特点让所有的节点都可以协助进行程序代码的更新。</p>
<p>从结果来看，在采用了 BitTorrent 的方式来更新代码，部署的时间从 40 分钟大幅减少到只要 12 秒！实在是非常惊人的改善，数千台服务器的代码更新居然只要短短 12 秒就能完成。</p>
<p>集中式架构和Murder架构对比:</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEBb17ecf2d648c399a8e681511fbeb8997?method=download&shareKey=7c1ea1579628222596f0e3e3f2d106ce" alt="image"></p>
<p><img src="https://note.youdao.com/yws/api/personal/file/WEB7aa1edd58d4910b55f320ba6f7c19327?method=download&shareKey=357ea31cc3b84346b9f99004fb033aef" alt="image"></p>
<h2 id="部署Murder"><a href="#部署Murder" class="headerlink" title="部署Murder"></a>部署Murder</h2><h3 id="Murder-组件介绍"><a href="#Murder-组件介绍" class="headerlink" title="Murder 组件介绍"></a>Murder 组件介绍</h3><p>Murder 是基于 BitTornado 来实现的。有以下几个主要组件：</p>
<ol>
<li>torrent tracker: tracker 使用 murder_tracker.py 运行，tracker 实际上是运行中一台服务器上的单个服务，其他任何成员都要依赖它。Murder为了保持简单，并没有实现tracker-less distribution（DHT）功能。tracker 实际上是个迷你的 httpd 服务，存放着BitTorrent客户端需要更新状态的路径。</li>
<li>seeder ：sender 是存放要分发到其他主机的文件的服务器。这些文件存放在 seeder 的一个目录中，Murder 会将这个目录打包成 tgz 格式并创建一个 .torrent 文件（非常小的文件，包含有关这个tgz文件的基本hash信息）。这个 .torrent 文件让各个 peer 节点知道他们下载的是什么文件。同时，tracker 会保持跟踪有哪些 .torrent 文件正在被分发。一旦 Murder 开始传输文件，seeder 服务器将是各个 peer 节点获取种子的地方。</li>
<li>peers ：peer 是成百上千需要接收文件的服务器，并且它们之间可以相互传输文件（下载、上传）。一旦一个peer节点下载完整个 tgz 文件，还将继续 seeding 一段时间，防止蜜罐效应。</li>
</ol>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>在 tracker 服务器下载并安装 Murder，写成脚本运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">cd &#x2F;usr&#x2F;local&#x2F;src</span><br><span class="line">wget https:&#x2F;&#x2F;codeload.github.com&#x2F;lg&#x2F;murder&#x2F;zip&#x2F;master</span><br><span class="line">mv master murder.zip</span><br><span class="line">unzip murder.zip</span><br><span class="line">mv murder-master &#x2F;usr&#x2F;local&#x2F;murder</span><br></pre></td></tr></table></figure>
<p>配置好 ansible 服务，连通各个 peer 节点。</p>
<p>通过 ansible 将tracker服务器下的 master.zip 分发到各个 peer 节点的家目录下，并解压安装 Murder ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ansible all -m copy -a &quot;src&#x3D;&#x2F;usr&#x2F;local&#x2F;src&#x2F;murder.zip dest&#x3D;~&quot;</span><br><span class="line"># ansible all -m shell -a &quot;unzip murder.zip ; mv murder-master murder&quot;</span><br></pre></td></tr></table></figure>
<p>各个节点ip和环境说明：</p>
<ul>
<li>tracker : 192.168.1.100</li>
<li>seeder : 192.168.1.100</li>
<li>peers : 192.168.1.101-111</li>
<li>服务器都在同一个机房</li>
<li>都是 CentOS 6.5 系统</li>
</ul>
<h2 id="启动-tracker-服务"><a href="#启动-tracker-服务" class="headerlink" title="启动 tracker 服务"></a>启动 tracker 服务</h2><p>在 Tracker 服务器，启动 tracker 服务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># python &#x2F;usr&#x2F;local&#x2F;murder&#x2F;dist&#x2F;murder_tracker.py &gt; &#x2F;var&#x2F;log&#x2F;murder_tracker.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>
<p>检查端口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># netstat -tnlp|grep 8998</span><br></pre></td></tr></table></figure>
<p>实时查看日志输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># tailf &#x2F;var&#x2F;log&#x2F;murder_tracker.log</span><br></pre></td></tr></table></figure>
<p>配置防火墙（如果防火墙是关闭的，则不用此操作）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># iptables -I INPUT -s 192.168.100.0&#x2F;24 -p tcp --dport 8998 -j ACCEPT</span><br></pre></td></tr></table></figure>
<p>murder_tracker.py 实际上是调用 BitTornado/BT1/track.py 这个文件。 track.py 有很多参数，如果需要添加参数，可以修改 murder_tracker.py。</p>
<p>几个重要参数：</p>
<ul>
<li>port ：tracker 监听的端口，默认 8998</li>
<li>dfile ：存储近期下载信息的文件</li>
<li>logfile ：tracker 日志文件，默认是标准输出</li>
</ul>
<h2 id="在-seeder-服务器上准备要分发的文件并创建种子"><a href="#在-seeder-服务器上准备要分发的文件并创建种子" class="headerlink" title="在 seeder 服务器上准备要分发的文件并创建种子"></a>在 seeder 服务器上准备要分发的文件并创建种子</h2><p>这里将 seeder 和 tracker 服务 放在同一台服务器。<br>准备分发文件，并放在 /home/data/murder/ 目录下。</p>
<p>生成种子文件的脚本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"># 定义变量</span><br><span class="line">deploy_file&#x3D;&#x2F;home&#x2F;data&#x2F;murder&#x2F;deploy.test.tar.gz</span><br><span class="line"># 因所有peer节点已经打通内网，这里用seeder服务器的内网地址</span><br><span class="line">Seeder_IP&#x3D;192.168.1.100</span><br><span class="line">make_torrent_command&#x3D;&#x2F;usr&#x2F;local&#x2F;murder&#x2F;dist&#x2F;murder_make_torrent.py</span><br><span class="line"># 生成种子</span><br><span class="line">python $&#123;make_torrent_command&#125; $&#123;deploy_file&#125; $&#123;Seeder_IP&#125;:8998 $&#123;deploy_file&#125;.torrent</span><br></pre></td></tr></table></figure>

<h2 id="分发种子文件给所有的peer节点"><a href="#分发种子文件给所有的peer节点" class="headerlink" title="分发种子文件给所有的peer节点"></a>分发种子文件给所有的peer节点</h2><p>利用 ansible 分发seeder服务器上的种子文件给所有的 peer 节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ansible all -m synchronize -a &quot;src&#x3D;&#x2F;home&#x2F;data&#x2F;murder&#x2F;deploy.test.tar.gz.torrent dest&#x3D;~&quot;</span><br></pre></td></tr></table></figure>
<h2 id="启动-seeder-服务"><a href="#启动-seeder-服务" class="headerlink" title="启动 seeder 服务"></a>启动 seeder 服务</h2><p>启动 seeder 服务的脚本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"># 定义变量</span><br><span class="line">deploy_file&#x3D;&#x2F;home&#x2F;data&#x2F;murder&#x2F;deploy.test.tar.gz</span><br><span class="line">start_ip&#x3D;192.168.1.100</span><br><span class="line">make_torrent_command&#x3D;&#x2F;usr&#x2F;local&#x2F;murder&#x2F;dist&#x2F;murder_client.py</span><br><span class="line"></span><br><span class="line"># 启动 seeder，放到后台运行</span><br><span class="line">python $&#123;make_torrent_command&#125; seed $&#123;deploy_file&#125;.torrent $&#123;deploy_file&#125; $&#123;start_ip&#125; &amp;</span><br></pre></td></tr></table></figure>
<p>要确保 seeder 服务在启动状态，否则 peer 节点下载时连接不到。</p>
<p>在各个peer节点执行下载任务<br>编写下载脚本 peer_download.sh ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"># 用于各个 peer 节点根据种子文件信息，执行下载任务</span><br><span class="line"># 定义变量</span><br><span class="line">torrent_file&#x3D;~&#x2F;deploy.test.tar.gz.torrent</span><br><span class="line">download_file&#x3D;~&#x2F;download&#x2F;deploy.test.tar.gz</span><br><span class="line"># 这里获取各个 peer 节点自己的内网IP</span><br><span class="line">local_ip&#x3D;$(hostname -I|awk &#39;&#123;print $2&#125;&#39;)</span><br><span class="line">murder_client_bin&#x3D;~&#x2F;murder&#x2F;dist&#x2F;murder_client.py</span><br><span class="line"># 在各个 peer 节点执行 P2P 下载命令</span><br><span class="line">python  $murder_client_bin peer $torrent_file $download_file $local_ip</span><br></pre></td></tr></table></figure>
<p>利用ansible远程操控，在每个peer节点都执行下载脚本。使用ansible的 script 模块，在本地写一个脚本，然后在远程服务器执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ansible all -m script -a &quot;peer_download.sh&quot;</span><br></pre></td></tr></table></figure>
<h2 id="下载速度分析"><a href="#下载速度分析" class="headerlink" title="下载速度分析"></a>下载速度分析</h2><p>Murder 默认是服务器都存于一个数据中心的彼此相互信任的内网，并且每台服务器都是关闭防火墙的。</p>
<p>Murder 封装的是 BitTornado，在 BitTornado/download_bt1.py 代码中默认是启动一个 10000-60000 范围的随机端口，每个 peer 在下载的同时向其他 peer 提供下载服务也是通过这个随机端口。</p>
<p>对于端口的配置，把防火墙关了当然好，当然为了安全，还是开放端口更好。然而开放这个大的端口范围，肯定是不行的，这里选择开放 10000-10500 500个端口，只允许内网IP访问。</p>
<p>在各个 peer 节点中配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># iptables -I INPUT -s 192.168.1.0&#x2F;24 -p tcp --dport 10000:10500 -j ACCEPT</span><br></pre></td></tr></table></figure>
<p>并且在 dist/BitTornado/download_bt1.py 中修改代码的端口范围：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(&#39;minport&#39;, 10000, &#39;minimum port to listen on, counts up if unavailable&#39;),</span><br><span class="line">(&#39;maxport&#39;, 10500, &#39;maximum port to listen on&#39;),</span><br><span class="line">(&#39;random_port&#39;, 1, &#39;whether to choose randomly inside the port range &#39; + &#39;instead of counting up linearly&#39;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这一步最好在把Murder代码分发到各个peer节点前做，如果已经做了，只能重新分发覆盖了。</p>
</blockquote>
<p>分发测试的机器有11台，都是内网IP，千兆路由器，但防火墙开启，测试文件有 560 M 大小。</p>
<ul>
<li>第一次分发：没有配好防火墙，用时 5m 分发完成。</li>
<li>第二次分发：配好了防火墙，用时 2m30s 分发完成。</li>
<li>第三次分发：不用Murder，用 ansible 直接分发，用时 36s 分发完成。<br>这里测试的服务器还是太少，服务器越多时，P2P方式分发文件速度越快。服务器不超过50+时，还是用 ansible 直接分发更快。</li>
</ul>
<p>文件都下载完后，关闭 seeder 服务器进程<br>kill 掉 seeder 的进程PID，避免它一直做种子和提升安全性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># pgrep -f seed|xargs kill -9</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.51cto.com/john88wang/1793080" target="_blank" rel="noopener">结合P2P软件使用Ansible分发大文件</a><br><a href="http://jaminzhang.github.io/p2p/use-Murder-to-distribute-big-software-package-in-production-environment/" target="_blank" rel="noopener">Murder 在生产环境中分发大软件包的应用</a><br><a href="https://wuyanteng.github.io/2017/10/12/%E5%9C%A8%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%ADP2P%E5%88%86%E5%8F%91%E5%A4%A7%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%9A%84%E5%BA%94%E7%94%A8-Murder/" target="_blank" rel="noopener">在生产环境中-P2P分发大软件包的应用-Murder</a>  </p>
]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>PYTHON</tag>
      </tags>
  </entry>
  <entry>
    <title>值得看的7本书</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h2 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h2><ol>
<li>穷爸爸富爸爸</li>
<li>见识</li>
<li>被讨厌的勇气</li>
<li>情绪勒索</li>
<li>苏菲的世界</li>
<li>秘密</li>
<li>就这样，我睡了全世界的沙发</li>
</ol>
]]></content>
      <categories>
        <category>Book</category>
      </categories>
      <tags>
        <tag>Book</tag>
      </tags>
  </entry>
  <entry>
    <title>操作excel</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h2 id="读取excel"><a href="#读取excel" class="headerlink" title="读取excel"></a>读取excel</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">import xlrd</span><br><span class="line">from xlrd.book import Book</span><br><span class="line">from xlrd.sheet import Sheet</span><br><span class="line">from xlrd.sheet import Cell</span><br><span class="line"></span><br><span class="line">workbook &#x3D; xlrd.open_workbook(&#39;基础课程大纲.xlsx&#39;)</span><br><span class="line"></span><br><span class="line">sheet_names &#x3D; workbook.sheet_names()</span><br><span class="line"></span><br><span class="line"># sheet &#x3D; workbook.sheet_by_name(&#39;工作表1&#39;)</span><br><span class="line">sheet &#x3D; workbook.sheet_by_index(1)</span><br><span class="line"></span><br><span class="line"># 循环Excel文件的所有行</span><br><span class="line">for row in sheet.get_rows():</span><br><span class="line">    # 循环一行的所有列</span><br><span class="line">    for col in row:</span><br><span class="line">        # 获取一个单元格中的值</span><br><span class="line">        print(col.value)</span><br></pre></td></tr></table></figure>
<h2 id="写excel"><a href="#写excel" class="headerlink" title="写excel"></a>写excel</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">import xlwt</span><br><span class="line"></span><br><span class="line">wb &#x3D; xlwt.Workbook()</span><br><span class="line">sheet &#x3D; wb.add_sheet(&#39;sheet1&#39;)</span><br><span class="line"></span><br><span class="line">for row in range(10):</span><br><span class="line">    for col in range(5):</span><br><span class="line">        sheet.write(row, col, &#39;第&#123;0&#125;行第&#123;1&#125;列&#39;.format(row, col))</span><br><span class="line"></span><br><span class="line">wb.save(&#39;xxx.xls&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 更多示例：https:&#x2F;&#x2F;github.com&#x2F;python-excel&#x2F;xlwt&#x2F;tree&#x2F;master&#x2F;examples</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>PYTHON</tag>
      </tags>
  </entry>
  <entry>
    <title>常用Git命令清单-v0.1</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h2 id="常用Git命令清单"><a href="#常用Git命令清单" class="headerlink" title="常用Git命令清单"></a>常用Git命令清单</h2><blockquote>
<p>一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。</p>
</blockquote>
<h3 id="名次解释"><a href="#名次解释" class="headerlink" title="名次解释"></a>名次解释</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEB392fff8491cd94960a8296d7607e51b4?method=download&shareKey=e5b3ec746227b33cc6120efe14ca3fde" alt="image"><br>下面是我整理的常用 Git 命令清单。几个专用名词的译名如下:<br>Workspace：工作区<br>Index / Stage：暂存区<br>Repository：仓库区（或本地仓库）<br>Remote：远程仓库</p>
<h3 id="一-新建代码库"><a href="#一-新建代码库" class="headerlink" title="一. 新建代码库"></a>一. 新建代码库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在当前目录新建一个Git代码库</span><br><span class="line">$ git init</span><br><span class="line"></span><br><span class="line"># 新建一个目录，将其初始化为Git代码库</span><br><span class="line">$ git init [project-name]</span><br><span class="line"></span><br><span class="line"># 下载一个项目和它的整个代码历史</span><br><span class="line">$ git clone [url]</span><br></pre></td></tr></table></figure>

<h3 id="二-配置"><a href="#二-配置" class="headerlink" title="二.配置"></a>二.配置</h3><p>Git的设置文件为.gitconfig，它可以在用户主目录下(全局配置)，也可以在项目目录下(项目配置)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 显示当前的Git配置</span><br><span class="line">$ git config --list</span><br><span class="line"></span><br><span class="line"># 编辑Git配置文件</span><br><span class="line">$ git config -e [--global]</span><br><span class="line"></span><br><span class="line"># 设置提交代码时的用户信息</span><br><span class="line">$ git config [--global] user.name &quot;[name]&quot;</span><br><span class="line">$ git config [--global] user.email &quot;[email address]&quot;</span><br><span class="line"></span><br><span class="line"># 颜色设置</span><br><span class="line">git config --global color.ui true                         # git status等命令自动着色</span><br><span class="line">git config --global color.status auto</span><br><span class="line">git config --global color.diff auto</span><br><span class="line">git config --global color.branch auto</span><br><span class="line">git config --global color.interactive auto</span><br><span class="line">git config --global --unset http.proxy                    # remove  proxy configuration on git</span><br></pre></td></tr></table></figure>

<h3 id="三-增加-删除文件"><a href="#三-增加-删除文件" class="headerlink" title="三. 增加/删除文件"></a>三. 增加/删除文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 添加指定文件到暂存区</span><br><span class="line">$ git add [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"># 添加指定目录到暂存区，包括子目录</span><br><span class="line">$ git add [dir]</span><br><span class="line"></span><br><span class="line"># 添加当前目录的所有文件到暂存区</span><br><span class="line">$ git add .</span><br><span class="line"></span><br><span class="line"># 添加每个变化前，都会要求确认</span><br><span class="line"># 对于同一个文件的多处变化，可以实现分次提交</span><br><span class="line">$ git add -p</span><br><span class="line"></span><br><span class="line"># 删除工作区文件，并且将这次删除放入暂存区</span><br><span class="line">$ git rm [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"># 停止追踪指定文件，但该文件会保留在工作区</span><br><span class="line">$ git rm --cached [file]</span><br><span class="line"></span><br><span class="line"># 改名文件，并且将这个改名放入暂存区</span><br><span class="line">$ git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure>

<h3 id="四-代码提交"><a href="#四-代码提交" class="headerlink" title="四. 代码提交"></a>四. 代码提交</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 提交暂存区到仓库区</span><br><span class="line">$ git commit -m [message]</span><br><span class="line"></span><br><span class="line"># 提交暂存区的指定文件到仓库区</span><br><span class="line">$ git commit [file1] [file2] ... -m [message]</span><br><span class="line"></span><br><span class="line"># 提交工作区自上次commit之后的变化，直接到仓库区</span><br><span class="line">$ git commit -a</span><br><span class="line"></span><br><span class="line"># 提交时显示所有diff信息</span><br><span class="line">$ git commit -v</span><br><span class="line"></span><br><span class="line"># 将add和commit合为一步</span><br><span class="line">$ git commit -am &#39;message&#39;</span><br><span class="line"></span><br><span class="line"># 使用一次新的commit，替代上一次提交</span><br><span class="line"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span><br><span class="line">$ git commit --amend -m [message]</span><br><span class="line"></span><br><span class="line"># 重做上一次commit，并包括指定文件的新变化</span><br><span class="line">$ git commit --amend [file1] [file2] ...</span><br></pre></td></tr></table></figure>

<h3 id="五-分支"><a href="#五-分支" class="headerlink" title="五. 分支"></a>五. 分支</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 列出所有本地分支</span><br><span class="line">$ git branch</span><br><span class="line"></span><br><span class="line"># 列出所有远程分支</span><br><span class="line">$ git branch -r</span><br><span class="line"></span><br><span class="line"># 列出所有本地分支和远程分支</span><br><span class="line">$ git branch -a</span><br><span class="line"></span><br><span class="line"># 新建一个分支，但依然停留在当前分支</span><br><span class="line">$ git branch [branch-name]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，并切换到该分支</span><br><span class="line">$ git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，指向指定commit</span><br><span class="line">$ git branch [branch] [commit]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，与指定的远程分支建立追踪关系</span><br><span class="line">$ git branch --track [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"># 切换到指定分支，并更新工作区</span><br><span class="line">$ git checkout [branch-name]</span><br><span class="line"></span><br><span class="line"># 切换到上一个分支</span><br><span class="line">$ git checkout -</span><br><span class="line"></span><br><span class="line"># 建立追踪关系，在现有分支与指定的远程分支之间</span><br><span class="line">$ git branch --set-upstream [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"># 合并指定分支到当前分支</span><br><span class="line">$ git merge [branch]</span><br><span class="line"></span><br><span class="line"># 选择一个commit，合并进当前分支</span><br><span class="line">$ git cherry-pick [commit]</span><br><span class="line"></span><br><span class="line"># 删除分支</span><br><span class="line">$ git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line"># 删除远程分支</span><br><span class="line">$ git push origin --delete [branch-name]</span><br><span class="line">$ git branch -dr [remote&#x2F;branch]</span><br><span class="line"></span><br><span class="line"># 检出版本v2.0</span><br><span class="line">$ git checkout v2.0</span><br><span class="line"></span><br><span class="line"># 从远程分支develop创建新本地分支devel并检出</span><br><span class="line">$ git checkout -b devel origin&#x2F;develop</span><br><span class="line"></span><br><span class="line"># 检出head版本的README文件（可用于修改错误回退）</span><br><span class="line">git checkout -- README</span><br></pre></td></tr></table></figure>

<h3 id="六-标签"><a href="#六-标签" class="headerlink" title="六. 标签"></a>六. 标签</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 列出所有tag</span><br><span class="line">$ git tag</span><br><span class="line"></span><br><span class="line"># 新建一个tag在当前commit</span><br><span class="line">$ git tag [tag]</span><br><span class="line"></span><br><span class="line"># 新建一个tag在指定commit</span><br><span class="line">$ git tag [tag] [commit]</span><br><span class="line"></span><br><span class="line"># 删除本地tag</span><br><span class="line">$ git tag -d [tag]</span><br><span class="line"></span><br><span class="line"># 删除远程tag</span><br><span class="line">$ git push origin :refs&#x2F;tags&#x2F;[tagName]</span><br><span class="line"></span><br><span class="line"># 查看tag信息</span><br><span class="line">$ git show [tag]</span><br><span class="line"></span><br><span class="line"># 提交指定tag</span><br><span class="line">$ git push [remote] [tag]</span><br><span class="line"></span><br><span class="line"># 提交所有tag</span><br><span class="line">$ git push [remote] --tags</span><br><span class="line"></span><br><span class="line"># 新建一个分支，指向某个tag</span><br><span class="line">$ git checkout -b [branch] [tag]</span><br></pre></td></tr></table></figure>

<h3 id="七-查看信息"><a href="#七-查看信息" class="headerlink" title="七. 查看信息"></a>七. 查看信息</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 显示有变更的文件</span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"># 显示当前分支的版本历史</span><br><span class="line">$ git log</span><br><span class="line"></span><br><span class="line"># 显示commit历史，以及每次commit发生变更的文件</span><br><span class="line">$ git log --stat</span><br><span class="line"></span><br><span class="line"># 搜索提交历史，根据关键词</span><br><span class="line">$ git log -S [keyword]</span><br><span class="line"></span><br><span class="line"># 显示某个commit之后的所有变动，每个commit占据一行</span><br><span class="line">$ git log [tag] HEAD --pretty&#x3D;format:%s</span><br><span class="line"></span><br><span class="line"># 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件</span><br><span class="line">$ git log [tag] HEAD --grep feature</span><br><span class="line"></span><br><span class="line"># 显示某个文件的版本历史，包括文件改名</span><br><span class="line">$ git log --follow [file]</span><br><span class="line">$ git whatchanged [file]</span><br><span class="line"></span><br><span class="line"># 显示指定文件相关的每一次diff</span><br><span class="line">$ git log -p [file]</span><br><span class="line"></span><br><span class="line"># 显示过去5次提交</span><br><span class="line">$ git log -5 --pretty --oneline</span><br><span class="line"></span><br><span class="line"># 显示所有提交过的用户，按提交次数排序</span><br><span class="line">$ git shortlog -sn</span><br><span class="line"></span><br><span class="line"># 显示指定文件是什么人在什么时间修改过</span><br><span class="line">$ git blame [file]</span><br><span class="line"></span><br><span class="line"># 显示暂存区和工作区的差异</span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line"># 显示暂存区和上一个commit的差异</span><br><span class="line">$ git diff --cached [file]</span><br><span class="line"></span><br><span class="line"># 显示工作区与当前分支最新commit之间的差异</span><br><span class="line">$ git diff HEAD</span><br><span class="line"></span><br><span class="line"># 显示两次提交之间的差异</span><br><span class="line">$ git diff [first-branch]...[second-branch]</span><br><span class="line"></span><br><span class="line"># 显示今天你写了多少行代码</span><br><span class="line">$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;</span><br><span class="line"></span><br><span class="line"># 显示某次提交的元数据和内容变化</span><br><span class="line">$ git show [commit]</span><br><span class="line"></span><br><span class="line"># 显示某次提交发生变化的文件</span><br><span class="line">$ git show --name-only [commit]</span><br><span class="line"></span><br><span class="line"># 显示某次提交时，某个文件的内容</span><br><span class="line">$ git show [commit]:[filename]</span><br><span class="line"></span><br><span class="line"># 显示当前分支的最近几次提交</span><br><span class="line">$ git reflog</span><br></pre></td></tr></table></figure>

<h3 id="八-远程同步"><a href="#八-远程同步" class="headerlink" title="八. 远程同步"></a>八. 远程同步</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 下载远程仓库的所有变动</span><br><span class="line">$ git fetch [remote]</span><br><span class="line"></span><br><span class="line"># 显示所有远程仓库</span><br><span class="line">$ git remote -v</span><br><span class="line"></span><br><span class="line"># 显示某个远程仓库的信息</span><br><span class="line">$ git remote show [remote]</span><br><span class="line"></span><br><span class="line"># 增加一个新的远程仓库，并命名</span><br><span class="line">$ git remote add [shortname] [url]</span><br><span class="line"></span><br><span class="line"># 取回远程仓库的变化，并与本地分支合并</span><br><span class="line">$ git pull [remote] [branch]</span><br><span class="line"></span><br><span class="line"># 上传本地指定分支到远程仓库</span><br><span class="line">$ git push [remote] [branch]</span><br><span class="line"></span><br><span class="line"># 强行推送当前分支到远程仓库，即使有冲突</span><br><span class="line">$ git push [remote] --force</span><br><span class="line"></span><br><span class="line"># 推送所有分支到远程仓库</span><br><span class="line">$ git push [remote] --all</span><br></pre></td></tr></table></figure>

<h3 id="九-撤销"><a href="#九-撤销" class="headerlink" title="九. 撤销"></a>九. 撤销</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 恢复暂存区的指定文件到工作区</span><br><span class="line">$ git checkout [file]</span><br><span class="line"></span><br><span class="line"># 恢复某个commit的指定文件到暂存区和工作区</span><br><span class="line">$ git checkout [commit] [file]</span><br><span class="line"></span><br><span class="line"># 恢复暂存区的所有文件到工作区</span><br><span class="line">$ git checkout .</span><br><span class="line"></span><br><span class="line"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span><br><span class="line">$ git reset [file]</span><br><span class="line"></span><br><span class="line"># 重置暂存区与工作区，与上一次commit保持一致</span><br><span class="line">$ git reset --hard</span><br><span class="line"></span><br><span class="line"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br><span class="line">$ git reset [commit]</span><br><span class="line"></span><br><span class="line"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br><span class="line">$ git reset --hard [commit]</span><br><span class="line"></span><br><span class="line"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span><br><span class="line">$ git reset --keep [commit]</span><br><span class="line"></span><br><span class="line"># 新建一个commit，用来撤销指定commit</span><br><span class="line"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span><br><span class="line">$ git revert [commit]</span><br><span class="line"></span><br><span class="line"># 暂时将未提交的变化移除，稍后再移入</span><br><span class="line">$ git stash</span><br><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure>

<h3 id="十-其他"><a href="#十-其他" class="headerlink" title="十. 其他"></a>十. 其他</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git init                                                  # 初始化本地git仓库（创建新仓库）</span><br><span class="line">git config --global user.name &quot;xxx&quot;                       # 配置用户名</span><br><span class="line">git config --global user.email &quot;xxx@xxx.com&quot;              # 配置邮件</span><br><span class="line">git config --global color.ui true                         # git status等命令自动着色</span><br><span class="line">git config --global color.status auto</span><br><span class="line">git config --global color.diff auto</span><br><span class="line">git config --global color.branch auto</span><br><span class="line">git config --global color.interactive auto</span><br><span class="line">git config --global --unset http.proxy                    # remove  proxy configuration on git</span><br><span class="line">git clone git+ssh:&#x2F;&#x2F;git@192.168.53.168&#x2F;VT.git             # clone远程仓库</span><br><span class="line">git status                                                # 查看当前版本状态（是否修改）</span><br><span class="line">git add xyz                                               # 添加xyz文件至index</span><br><span class="line">git add .                                                 # 增加当前子目录下所有更改过的文件至index</span><br><span class="line">git commit -m &#39;xxx&#39;                                       # 提交</span><br><span class="line">git commit --amend -m &#39;xxx&#39;                               # 合并上一次提交（用于反复修改）</span><br><span class="line">git commit -am &#39;xxx&#39;                                      # 将add和commit合为一步</span><br><span class="line">git rm xxx                                                # 删除index中的文件</span><br><span class="line">git rm -r *                                               # 递归删除</span><br><span class="line">git log                                                   # 显示提交日志</span><br><span class="line">git log -1                                                # 显示1行日志 -n为n行</span><br><span class="line">git log -5</span><br><span class="line">git log --stat                                            # 显示提交日志及相关变动文件</span><br><span class="line">git log -p -m</span><br><span class="line">git show dfb02e6e4f2f7b573337763e5c0013802e392818         # 显示某个提交的详细内容</span><br><span class="line">git show dfb02                                            # 可只用commitid的前几位</span><br><span class="line">git show HEAD                                             # 显示HEAD提交日志</span><br><span class="line">git show HEAD^                                            # 显示HEAD的父（上一个版本）的提交日志 ^^为上两个版本 ^5为上5个版本</span><br><span class="line">git tag                                                   # 显示已存在的tag</span><br><span class="line">git tag -a v2.0 -m &#39;xxx&#39;                                  # 增加v2.0的tag</span><br><span class="line">git show v2.0                                             # 显示v2.0的日志及详细内容</span><br><span class="line">git log v2.0                                              # 显示v2.0的日志</span><br><span class="line">git diff                                                  # 显示所有未添加至index的变更</span><br><span class="line">git diff --cached                                         # 显示所有已添加index但还未commit的变更</span><br><span class="line">git diff HEAD^                                            # 比较与上一个版本的差异</span><br><span class="line">git diff HEAD -- .&#x2F;lib                                    # 比较与HEAD版本lib目录的差异</span><br><span class="line">git diff origin&#x2F;master..master                            # 比较远程分支master上有本地分支master上没有的</span><br><span class="line">git diff origin&#x2F;master..master --stat                     # 只显示差异的文件，不显示具体内容</span><br><span class="line">git remote add origin git+ssh:&#x2F;&#x2F;git@192.168.53.168&#x2F;VT.git # 增加远程定义（用于push&#x2F;pull&#x2F;fetch）</span><br><span class="line">git branch                                                # 显示本地分支</span><br><span class="line">git branch --contains 50089                               # 显示包含提交50089的分支</span><br><span class="line">git branch -a                                             # 显示所有分支</span><br><span class="line">git branch -r                                             # 显示所有原创分支</span><br><span class="line">git branch --merged                                       # 显示所有已合并到当前分支的分支</span><br><span class="line">git branch --no-merged                                    # 显示所有未合并到当前分支的分支</span><br><span class="line">git branch -m master master_copy                          # 本地分支改名</span><br><span class="line">git checkout -b master_copy                               # 从当前分支创建新分支master_copy并检出</span><br><span class="line">git checkout -b master master_copy                        # 上面的完整版</span><br><span class="line">git checkout features&#x2F;performance                         # 检出已存在的features&#x2F;performance分支</span><br><span class="line">git checkout --track hotfixes&#x2F;BJVEP933                    # 检出远程分支hotfixes&#x2F;BJVEP933并创建本地跟踪分支</span><br><span class="line">git checkout v2.0                                         # 检出版本v2.0</span><br><span class="line">git checkout -b devel origin&#x2F;develop                      # 从远程分支develop创建新本地分支devel并检出</span><br><span class="line">git checkout -- README                                    # 检出head版本的README文件（可用于修改错误回退）</span><br><span class="line">git merge origin&#x2F;master                                   # 合并远程master分支至当前分支</span><br><span class="line">git cherry-pick ff44785404a8e                             # 合并提交ff44785404a8e的修改</span><br><span class="line">git push origin master                                    # 将当前分支push到远程master分支</span><br><span class="line">git push origin :hotfixes&#x2F;BJVEP933                        # 删除远程仓库的hotfixes&#x2F;BJVEP933分支</span><br><span class="line">git push --tags                                           # 把所有tag推送到远程仓库</span><br><span class="line">git fetch                                                 # 获取所有远程分支（不更新本地分支，另需merge）</span><br><span class="line">git fetch --prune                                         # 获取所有原创分支并清除服务器上已删掉的分支</span><br><span class="line">git pull origin master                                    # 获取远程分支master并merge到当前分支</span><br><span class="line">git mv README README2                                     # 重命名文件README为README2</span><br><span class="line">git reset --hard HEAD                                     # 将当前版本重置为HEAD（通常用于merge失败回退）</span><br><span class="line">git rebase</span><br><span class="line">git branch -d hotfixes&#x2F;BJVEP933                           # 删除分支hotfixes&#x2F;BJVEP933（本分支修改已合并到其他分支）</span><br><span class="line">git branch -D hotfixes&#x2F;BJVEP933                           # 强制删除分支hotfixes&#x2F;BJVEP933</span><br><span class="line">git ls-files                                              # 列出git index包含的文件</span><br><span class="line">git show-branch                                           # 图示当前分支历史</span><br><span class="line">git show-branch --all                                     # 图示所有分支历史</span><br><span class="line">git whatchanged                                           # 显示提交历史对应的文件修改</span><br><span class="line">git revert dfb02e6e4f2f7b573337763e5c0013802e392818       # 撤销提交dfb02e6e4f2f7b573337763e5c0013802e392818</span><br><span class="line">git ls-tree HEAD                                          # 内部命令：显示某个git对象</span><br><span class="line">git rev-parse v2.0                                        # 内部命令：显示某个ref对于的SHA1 HASH</span><br><span class="line">git reflog                                                # 显示所有提交，包括孤立节点</span><br><span class="line">git show HEAD@&#123;5&#125;</span><br><span class="line">git show master@&#123;yesterday&#125;                               # 显示master分支昨天的状态</span><br><span class="line">git log --pretty&#x3D;format:&#39;%h %s&#39; --graph                   # 图示提交日志</span><br><span class="line">git show HEAD~3</span><br><span class="line">git show -s --pretty&#x3D;raw 2be7fcb476</span><br><span class="line">git stash                                                 # 暂存当前修改，将所有至为HEAD状态</span><br><span class="line">git stash list                                            # 查看所有暂存</span><br><span class="line">git stash show -p stash@&#123;0&#125;                               # 参考第一次暂存</span><br><span class="line">git stash apply stash@&#123;0&#125;                                 # 应用第一次暂存</span><br><span class="line">git grep &quot;delete from&quot;                                    # 文件中搜索文本“delete from”</span><br><span class="line">git grep -e &#39;#define&#39; --and -e SORT_DIRENT</span><br><span class="line">git gc</span><br><span class="line">git fsck</span><br><span class="line"># 生成一个可供发布的压缩包</span><br><span class="line">$ git archive</span><br></pre></td></tr></table></figure>

<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="noopener">常用 Git 命令清单 - 阮一峰的网络日志</a><br><a href="http://www.cnblogs.com/wupeiqi/p/7295372.html" target="_blank" rel="noopener">老铁，这年头不会点Git真不行</a><br><a href="https://gist.github.com/guweigang/9848271" target="_blank" rel="noopener">一些命令-github</a><br><a href="https://github.com/geeeeeeeeek/git-recipes/wiki" target="_blank" rel="noopener">Home-geeeeeeeeek/git-recipes Wiki-GitHub</a>  </p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>改善Python程序的91个建议</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h2 id="改善Python程序的91个建议"><a href="#改善Python程序的91个建议" class="headerlink" title="改善Python程序的91个建议"></a>改善Python程序的91个建议</h2><h3 id="1：引论"><a href="#1：引论" class="headerlink" title="1：引论"></a>1：引论</h3><p>建议1、理解Pythonic概念—-详见Python中的《Python之禅》</p>
<p>建议2、编写Pythonic代码</p>
<p>（1）避免不规范代码，比如只用大小写区分变量、使用容易混淆的变量名、害怕过长变量名等。有时候长的变量名会使代码更加具有可读性。</p>
<p>（2）深入学习Python相关知识，比如语言特性、库特性等，比如Python演变过程等。深入学习一两个业内公认的Pythonic的代码库，比如Flask等。</p>
<p>建议3：理解Python与C的不同之处，比如缩进与{}，单引号双引号，三元操作符？，Switch-Case语句等。</p>
<p>建议4：在代码中适当添加注释</p>
<p>建议5：适当添加空行使代码布局更加合理</p>
<p>建议6：编写函数的4个原则</p>
<p>（1）函数设计要尽量短小，嵌套层次不宜过深</p>
<p>（2）函数声明应该做到合理、简单、易用</p>
<p>（3）函数参数设计应该考虑向下兼容</p>
<p>（4）一个函数只做一件事，尽量保证函数粒度的一致性</p>
<p>建议7：将常量集中在一个文件，且常量名尽量使用全大写字母</p>
<h3 id="2：编程惯用法"><a href="#2：编程惯用法" class="headerlink" title="2：编程惯用法"></a>2：编程惯用法</h3><p>建议8：利用assert语句来发现问题，但要注意，断言assert会影响效率</p>
<p>建议9：数据交换值时不推荐使用临时变量，而是直接a, b = b, a</p>
<p>建议10：充分利用惰性计算（Lazy evaluation）的特性，从而避免不必要的计算</p>
<p>建议11：理解枚举替代实现的缺陷（最新版Python中已经加入了枚举特性）</p>
<p>建议12：不推荐使用type来进行类型检查，因为有些时候type的结果并不一定可靠。如果有需求，建议使用isinstance函数来代替</p>
<p>建议13：尽量将变量转化为浮点类型后再做除法（Python3以后不用考虑）</p>
<p>建议14：警惕eval()函数的安全漏洞，有点类似于SQL注入</p>
<p>建议15：使用enumerate()同时获取序列迭代的索引和值</p>
<p>建议16：分清==和is的适用场景，特别是在比较字符串等不可变类型变量时（详见评论）</p>
<p>建议17：尽量使用Unicode。在Python2中编码是很让人头痛的一件事，但Python3就不用过多考虑了</p>
<p>建议18：构建合理的包层次来管理Module</p>
<h3 id="3：基础用法"><a href="#3：基础用法" class="headerlink" title="3：基础用法"></a>3：基础用法</h3><p>建议19：有节制的使用from…import语句，防止污染命名空间</p>
<p>建议20：优先使用absolute import来导入模块（Python3中已经移除了relative import）</p>
<p>建议21：i+=1不等于++i，在Python中，++i前边的加号仅表示正，不表示操作</p>
<p>建议22：习惯使用with自动关闭资源，特别是在文件读写中</p>
<p>建议23：使用else子句简化循环（异常处理）</p>
<p>建议24：遵循异常处理的几点基本原则</p>
<p>（1）注意异常的粒度，try块中尽量少写代码</p>
<p>（2）谨慎使用单独的except语句，或except Exception语句，而是定位到具体异常</p>
<p>（3）注意异常捕获的顺序，在合适的层次处理异常</p>
<p>（4）使用更加友好的异常信息，遵守异常参数的规范</p>
<p>建议25：避免finally中可能发生的陷阱</p>
<p>建议26：深入理解None，正确判断对象是否为空。Python中下列数据会判断为空：<br><img src="https://mmbiz.qpic.cn/mmbiz_jpg/iciaMJDiaNTbG52ZVEtvvWrJdfxjeHnC0h2nJcvp2sZwpqMdESQCm3pUhzcPcBsOyWfj6NJ0vIT3D6AVHMzZLCjmA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="空值判断"><br>建议27：连接字符串应优先使用join函数，而不是+操作</p>
<p>建议28：格式化字符串时尽量使用.format函数，而不是%形式</p>
<p>建议29：区别对待可变对象和不可变对象，特别是作为函数参数时</p>
<p>建议30：[], {}和()：一致的容器初始化形式。使用列表解析可以使代码更清晰，同时效率更高</p>
<p>建议31：函数传参数，既不是传值也不是传引用，而是传对象或者说对象的引用</p>
<p>建议32：警惕默认参数潜在的问题，特别是当默认参数为可变对象时</p>
<p>建议33：函数中慎用变长参数args和*kargs</p>
<p>（1）这种使用太灵活，从而使得函数签名不够清晰，可读性较差</p>
<p>（2）如果因为函数参数过多而是用变长参数简化函数定义，那么一般该函数可以重构</p>
<p>建议34：深入理解str()和repr()的区别</p>
<p>（1）两者之间的目标不同：str主要面向客户，其目的是可读性，返回形式为用户友好性和可读性都比较高的字符串形式；而repr是面向Python解释器或者说Python开发人员，其目的是准确性，其返回值表示Python解释器内部的定义</p>
<p>（2）在解释器中直接输入变量，默认调用repr函数，而print(var)默认调用str函数</p>
<p>（3）repr函数的返回值一般可以用eval函数来还原对象</p>
<p>（4）两者分别调用对象的内建函数str__()和__repr()</p>
<p>建议35：分清静态方法staticmethod和类方法classmethod的使用场景</p>
<h3 id="4：库"><a href="#4：库" class="headerlink" title="4：库"></a>4：库</h3><p>建议36：掌握字符串的基本用法</p>
<p>建议37：按需选择sort()和sorted()函数</p>
<p>》sort()是列表在就地进行排序，所以不能排序元组等不可变类型。</p>
<p>》sorted()可以排序任意的可迭代类型，同时不改变原变量本身。</p>
<p>建议38：使用copy模块深拷贝对象，区分浅拷贝（shallow copy）和深拷贝（deep copy）</p>
<p>建议39：使用Counter进行计数统计，Counter是字典类的子类，在collections模块中</p>
<p>建议40：深入掌握ConfigParser</p>
<p>建议41：使用argparse模块处理命令行参数</p>
<p>建议42：使用pandas处理大型CSV文件</p>
<p>》Python本身提供一个CSV文件处理模块，并提供reader、writer等函数。</p>
<p>》Pandas可提供分块、合并处理等，适用于数据量大的情况，且对二维数据操作更方便。</p>
<p>建议43：使用ElementTree解析XML</p>
<p>建议44：理解模块pickle的优劣</p>
<p>》优势：接口简单、各平台通用、支持的数据类型广泛、扩展性强</p>
<p>》劣势：不保证数据操作的原子性、存在安全问题、不同语言之间不兼容</p>
<p>建议45：序列化的另一个选择JSON模块：load和dump操作</p>
<p>建议46：使用traceback获取栈信息</p>
<p>建议47：使用logging记录日志信息</p>
<p>建议48：使用threading模块编写多线程程序</p>
<p>建议49：使用Queue模块使多线程编程更安全</p>
<h3 id="5：设计模式"><a href="#5：设计模式" class="headerlink" title="5：设计模式"></a>5：设计模式</h3><p>建议50：利用模块实现单例模式</p>
<p>建议51：用mixin模式让程序更加灵活</p>
<p>建议52：用发布-订阅模式实现松耦合</p>
<p>建议53：用状态模式美化代码</p>
<h3 id="6：内部机制"><a href="#6：内部机制" class="headerlink" title="6：内部机制"></a>6：内部机制</h3><p>建议54：理解build-in对象</p>
<p>建议55：init__()不是构造方法，理解__new()与它之间的区别</p>
<p>建议56：理解变量的查找机制，即作用域</p>
<p>》局部作用域</p>
<p>》全局作用域</p>
<p>》嵌套作用域</p>
<p>》内置作用域</p>
<p>建议57：为什么需要self参数</p>
<p>建议58：理解MRO（方法解析顺序）与多继承</p>
<p>建议59：理解描述符机制</p>
<p>建议60：区别getattr__()与__getattribute()方法之间的区别</p>
<p>建议61：使用更安全的property</p>
<p>建议62：掌握元类metaclass</p>
<p>建议63：熟悉Python对象协议<br><img src="https://mmbiz.qpic.cn/mmbiz_jpg/iciaMJDiaNTbG52ZVEtvvWrJdfxjeHnC0h2mTYUZQBgtMVG5BQzVEnnkMDu5U9MzPJp99DzicxZ6hUjT03ib6wicwalw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="内置方法"><br>建议64：利用操作符重载实现中缀语法</p>
<p>建议65：熟悉Python的迭代器协议</p>
<p>建议66：熟悉Python的生成器</p>
<p>建议67：基于生成器的协程和greenlet，理解协程、多线程、多进程之间的区别</p>
<p>建议68：理解GIL的局限性</p>
<p>建议69：对象的管理和垃圾回收</p>
<h3 id="7：使用工具辅助项目开发"><a href="#7：使用工具辅助项目开发" class="headerlink" title="7：使用工具辅助项目开发"></a>7：使用工具辅助项目开发</h3><p>建议70：从PyPI安装第三方包</p>
<p>建议71：使用pip和yolk安装、管理包</p>
<p>建议72：做paster创建包</p>
<p>建议73：理解单元测试的概念</p>
<p>建议74：为包编写单元测试</p>
<p>建议75：利用测试驱动开发（TDD）提高代码的可测性</p>
<p>建议76：使用Pylint检查代码风格</p>
<p>》代码风格审查</p>
<p>》代码错误检查</p>
<p>》发现重复以及不合理的代码，方便重构</p>
<p>》高度的可配置化和可定制化</p>
<p>》支持各种IDE和编辑器的集成</p>
<p>》能够基于Python代码生成UML图</p>
<p>》能够与Jenkins等持续集成工具相结合，支持自动代码审查</p>
<p>建议77：进行高效的代码审查</p>
<p>建议78：将包发布到PyPI</p>
<h3 id="8：性能剖析与优化"><a href="#8：性能剖析与优化" class="headerlink" title="8：性能剖析与优化"></a>8：性能剖析与优化</h3><p>建议79：了解代码优化的基本原则</p>
<p>建议80：借助性能优化工具</p>
<p>建议81：利用cProfile定位性能瓶颈</p>
<p>建议82：使用memory_profiler和objgraph剖析内存使用</p>
<p>建议83：努力降低算法复杂度</p>
<p>建议84：掌握循环优化的基本技巧</p>
<p>》减少循环内部的计算</p>
<p>》将显式循环改为隐式循环，当然这会牺牲代码的可读性</p>
<p>》在循环中尽量引用局部变量</p>
<p>》关注内层嵌套循环</p>
<p>建议85：使用生成器提高效率</p>
<p>建议86：使用不同的数据结构优化性能</p>
<p>建议87：充分利用set的优势</p>
<p>建议88：使用multiprocessing模块克服GIL缺陷</p>
<p>建议89：使用线程池提高效率</p>
<p>建议90：使用C/C++模块扩展提高性能</p>
<p>建议91：使用Cythonb编写扩展模块</p>
]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>PYTHON</tag>
      </tags>
  </entry>
  <entry>
    <title>如何禁用自动命名的Django迁移</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h2 id="如何禁用自动命名的Django迁移"><a href="#如何禁用自动命名的Django迁移" class="headerlink" title="如何禁用自动命名的Django迁移"></a>如何禁用自动命名的Django迁移</h2><blockquote>
<p>本文主要介绍如何在<code>Django</code>执行<code>makemigrations</code>时完成文件的命名</p>
</blockquote>
<p>当你运行Django的manage.py makemigrations时，它将根据迁移的内容为迁移生成一个名称。例如，如果你是在添加单个字段，它会将迁移命名为0002_mymodel_myfield.py。但是，当你的迁移中包含不止一步操作时，它将使用一个简单的‘auto’和当前日期+时间进行命名，例如，0002_auto_20200113_1837.py。你可以为makemigrations提供-n/–name参数，但是开发人员经常会忘记这一点。</p>
<p>命名是编程中一个众所周知的难题。管理这些具有自动名称的迁移会很困难: 如果不打开它们，你就无法分辨哪个是哪个，而且如果它们是在同一天生成的，它们就会有相同的名称，那你就可能会混淆它们。</p>
<p>这在以下情况中会非常令人头疼:</p>
<ul>
<li>变基分支</li>
<li>挖掘历史记录</li>
<li>部署到生产环境</li>
</ul>
<p>在最坏的情况下，运行错误的迁移可能会导致数据丢失!<br>我们还很容易忘记修改迁移名称和提交，因为Django不会提示你输入一个更好的名称。我们可以通过一些自动化措施来防范这种情况!</p>
<p>让我们来看看实现这一点的三种技术。</p>
<ol>
<li><strong>重写makemigrations以要求提供 -n/–name</strong><br>这个方法使用了重写内置管理命令的技术，这与我在文章《让Django测试总是重新构建数据库(如果它存在的话)》中使用的技术相同。</li>
</ol>
<p>在你的项目的“核心”应用程序中添加一个新的makemigrations命令(例如:myapp/management/commands/makemigrations.py)，内容如下:</p>
]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>最常用的正则表达式大全</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h3 id="一-校验数字的表达式"><a href="#一-校验数字的表达式" class="headerlink" title="一. 校验数字的表达式"></a>一. 校验数字的表达式</h3><ol>
<li><p>数字：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^\[0-9\]*$</span><br></pre></td></tr></table></figure>
</li>
<li><p>n位的数字：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^\\d&#123;n&#125;$</span><br></pre></td></tr></table></figure></li>
<li><p>至少n位的数字：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^\\d&#123;n,&#125;$</span><br></pre></td></tr></table></figure></li>
<li><p>m-n位的数字：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^\\d&#123;m,n&#125;$</span><br></pre></td></tr></table></figure></li>
<li><p>零和非零开头的数字：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^(0|\[1-9\]\[0-9\]*)$</span><br></pre></td></tr></table></figure></li>
<li><p>非零开头的最多带两位小数的数字：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^(\[1-9\]\[0-9\]*)+(.\[0-9\]&#123;1,2&#125;)?$</span><br></pre></td></tr></table></figure></li>
<li><p>带1-2位小数的正数或负数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^(\\-)?\\d+(\\.\\d&#123;1,2&#125;)?$</span><br></pre></td></tr></table></figure></li>
<li><p>正数、负数、和小数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^(\\-|\\+)?\\d+(\\.\\d+)?$</span><br></pre></td></tr></table></figure></li>
<li><p>有两位小数的正实数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^\[0-9\]+(.\[0-9\]&#123;2&#125;)?$</span><br></pre></td></tr></table></figure></li>
<li><p>有1~3位小数的正实数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^\[0-9\]+(.\[0-9\]&#123;1,3&#125;)?$</span><br></pre></td></tr></table></figure></li>
<li><p>非零的正整数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^\[1-9\]\\d*$ 或 ^(\[1-9\]\[0-9\]*)&#123;1,3&#125;$ 或 ^\\+?\[1-9\]\[0-9\]*$</span><br></pre></td></tr></table></figure></li>
<li><p>非零的负整数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^\\-\[1-9\]\[\]0-9&quot;*$ 或 ^-\[1-9\]\\d*$</span><br></pre></td></tr></table></figure></li>
<li><p>非负整数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^\\d+$ 或 ^\[1-9\]\\d*|0$</span><br></pre></td></tr></table></figure></li>
<li><p>非正整数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^-\[1-9\]\\d*|0$ 或 ^((-\\d+)|(0+))$</span><br></pre></td></tr></table></figure></li>
<li><p>非负浮点数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^\\d+(\\.\\d+)?$ 或 ^\[1-9\]\\d*\\.\\d*|0\\.\\d*\[1-9\]\\d*|0?\\.0+|0$</span><br></pre></td></tr></table></figure></li>
<li><p>非正浮点数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ 或 ^(-(\[1-9\]\\d*\\.\\d*|0\\.\\d*\[1-9\]\\d*))|0?\\.0+|0$</span><br></pre></td></tr></table></figure></li>
<li><p>正浮点数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^\[1-9\]\\d*\\.\\d*|0\\.\\d*\[1-9\]\\d*$ 或 ^((\[0-9\]+\\.\[0-9\]*\[1-9\]\[0-9\]*)|(\[0-9\]*\[1-9\]\[0-9\]*\\.\[0-9\]+)|(\[0-9\]*\[1-9\]\[0-9\]*))$</span><br></pre></td></tr></table></figure></li>
<li><p>负浮点数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^-(\[1-9\]\\d*\\.\\d*|0\\.\\d*\[1-9\]\\d*)$ 或 ^(-((\[0-9\]+\\.\[0-9\]*\[1-9\]\[0-9\]*)|(\[0-9\]*\[1-9\]\[0-9\]*\\.\[0-9\]+)|(\[0-9\]*\[1-9\]\[0-9\]*)))$</span><br></pre></td></tr></table></figure></li>
<li><p>浮点数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^(-?\\d+)(\\.\\d+)?$ 或 ^-?(\[1-9\]\\d*\\.\\d*|0\\.\\d*\[1-9\]\\d*|0?\\.0+|0)$</span><br></pre></td></tr></table></figure>
<h3 id="二-校验字符的表达式"><a href="#二-校验字符的表达式" class="headerlink" title="二. 校验字符的表达式"></a>二. 校验字符的表达式</h3></li>
<li><p>汉字：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^\[\\u4e00-\\u9fa5\]&#123;0,&#125;$</span><br></pre></td></tr></table></figure></li>
<li><p>英文和数字：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^\[A-Za-z0-9\]+$ 或 ^\[A-Za-z0-9\]&#123;4,40&#125;$</span><br></pre></td></tr></table></figure></li>
<li><p>长度为3-20的所有字符：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^.&#123;3,20&#125;$</span><br></pre></td></tr></table></figure></li>
<li><p>由26个英文字母组成的字符串：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^\[A-Za-z\]+$</span><br></pre></td></tr></table></figure></li>
<li><p>由26个大写英文字母组成的字符串：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^\[A-Z\]+$</span><br></pre></td></tr></table></figure></li>
<li><p>由26个小写英文字母组成的字符串：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^\[a-z\]+$</span><br></pre></td></tr></table></figure></li>
<li><p>由数字和26个英文字母组成的字符串：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^\[A-Za-z0-9\]+$</span><br></pre></td></tr></table></figure></li>
<li><p>由数字、26个英文字母或者下划线组成的字符串：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^\\w+$ 或 ^\\w&#123;3,20&#125;$</span><br></pre></td></tr></table></figure></li>
<li><p>中文、英文、数字包括下划线：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^\[\\u4E00-\\u9FA5A-Za-z0-9_\]+$</span><br></pre></td></tr></table></figure></li>
<li><p>中文、英文、数字但不包括下划线等符号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^\[\\u4E00-\\u9FA5A-Za-z0-9\]+$ 或 ^\[\\u4E00-\\u9FA5A-Za-z0-9\]&#123;2,20&#125;$</span><br></pre></td></tr></table></figure></li>
<li><p>可以输入含有^%&amp;’,;=?$\“等字符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">：\[^%&amp;&#39;,;&#x3D;?$\\x22\]+</span><br></pre></td></tr></table></figure></li>
<li><p>禁止输入含有~的字符：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\[^~\\x22\]+</span><br></pre></td></tr></table></figure>
<h3 id="三-特殊需求表达式"><a href="#三-特殊需求表达式" class="headerlink" title="三. 特殊需求表达式"></a>三. 特殊需求表达式</h3></li>
<li><p>Email地址：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^\\w+(\[-+.\]\\w+)*@\\w+(\[-.\]\\w+)*\\.\\w+(\[-.\]\\w+)*$</span><br></pre></td></tr></table></figure></li>
<li><p>域名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\[a-zA-Z0-9\]\[-a-zA-Z0-9\]&#123;0,62&#125;(&#x2F;.\[a-zA-Z0-9\]\[-a-zA-Z0-9\]&#123;0,62&#125;)+&#x2F;.?</span><br></pre></td></tr></table></figure></li>
<li><p>InternetURL：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\[a-zA-z\]+:&#x2F;&#x2F;\[^\\s\]* 或 ^http:&#x2F;&#x2F;(\[\\w-\]+\\.)+\[\\w-\]+(&#x2F;\[\\w-.&#x2F;?%&amp;&#x3D;\]*)?$</span><br></pre></td></tr></table></figure></li>
<li><p>手机号码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^(13\[0-9\]|14\[5|7\]|15\[0|1|2|3|5|6|7|8|9\]|18\[0|1|2|3|5|6|7|8|9\])\\d&#123;8&#125;$</span><br></pre></td></tr></table></figure></li>
<li><p>电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^(\\(\\d&#123;3,4&#125;-)|\\d&#123;3.4&#125;-)?\\d&#123;7,8&#125;$</span><br></pre></td></tr></table></figure></li>
<li><p>国内电话号码(0511-4405222、021-87888822)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\\d&#123;3&#125;-\\d&#123;8&#125;|\\d&#123;4&#125;-\\d&#123;7&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>身份证号(15位、18位数字)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^\\d&#123;15&#125;|\\d&#123;18&#125;$</span><br></pre></td></tr></table></figure></li>
<li><p>短身份证号码(数字、字母x结尾)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^(\[0-9\])&#123;7,18&#125;(x|X)?$ 或 ^\\d&#123;8,18&#125;|\[0-9x\]&#123;8,18&#125;|\[0-9X\]&#123;8,18&#125;?$</span><br></pre></td></tr></table></figure></li>
<li><p>帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^\[a-zA-Z\]\[a-zA-Z0-9_\]&#123;4,15&#125;$</span><br></pre></td></tr></table></figure></li>
<li><p>密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^\[a-zA-Z\]\\w&#123;5,17&#125;$</span><br></pre></td></tr></table></figure></li>
<li><p>强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^(?&#x3D;.*\\d)(?&#x3D;.*\[a-z\])(?&#x3D;.*\[A-Z\]).&#123;8,10&#125;$</span><br></pre></td></tr></table></figure></li>
<li><p>日期格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>一年的12个月(01～09和1～12)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^(0?\[1-9\]|1\[0-2\])$</span><br></pre></td></tr></table></figure></li>
<li><p>一个月的31天(01～09和1～31)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^((0?\[1-9\])|((1|2)\[0-9\])|30|31)$</span><br></pre></td></tr></table></figure></li>
<li><p>钱的输入格式：</p>
</li>
<li><p>有四种钱的表示形式我们可以接受:”10000.00″ 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：^[1-9][0-9]*$</p>
</li>
<li><p>这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0″不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$</p>
</li>
<li><p>一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$</p>
</li>
<li><p>这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$</p>
</li>
<li><p>必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：^[0-9]+(.[0-9]{2})?$</p>
</li>
<li><p>这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$</p>
</li>
<li><p>这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$</p>
</li>
<li><p>1到3个数字,后面跟着任意个逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})<em>)(.[0-9]{1,2})?$<br>备注：这就是最终结果了,别忘了”+”可以用”</em>”替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里</p>
</li>
<li><p>xml文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^(\[a-zA-Z\]+-?)+\[a-zA-Z0-9\]+\\\.\[x|X\]\[m|M\]\[l|L\]$</span><br></pre></td></tr></table></figure></li>
<li><p>中文字符的正则表达式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\[\\u4e00-\\u9fa5\]</span><br></pre></td></tr></table></figure></li>
<li><p>双字节字符：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\[^\\x00-\\xff\] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))</span><br></pre></td></tr></table></figure></li>
<li><p>空白行的正则表达式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\\n\\s*\\r (可以用来删除空白行)</span><br></pre></td></tr></table></figure></li>
<li><p>HTML标记的正则表达式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;(\\S*?)\[^&gt;\]*&gt;.*?|&lt;.*? &#x2F;&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)</span><br></pre></td></tr></table></figure></li>
<li><p>首尾空白字符的正则表达式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^\\s*|\\s*$ 或 (^\\s*)|(\\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)</span><br></pre></td></tr></table></figure></li>
<li><p>腾讯QQ号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\[1-9\]\[0-9\]&#123;4,&#125; (腾讯QQ号从10000开始)</span><br></pre></td></tr></table></figure></li>
<li><p>中国邮政编码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\[1-9\]\\d&#123;5&#125;(?!\\d) (中国邮政编码为6位数字)</span><br></pre></td></tr></table></figure></li>
<li><p>IP地址：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\\d+\\.\\d+\\.\\d+\\.\\d+ (提取IP地址时有用)</span><br></pre></td></tr></table></figure></li>
<li><p>IP地址：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">((?:(?:25\[0-5\]|2\[0-4\]\\\d|\[01\]?\\\d?\\\d)\\\.)&#123;3&#125;(?:25\[0-5\]|2\[0-4\]\\\d|\[01\]?\\\d?\\\d))</span><br></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3></li>
</ol>
<ul>
<li><a href="http://www.aikaiyuan.com/9609.html" target="_blank" rel="noopener">检测IP地址的正则表达式</a></li>
<li><a href="http://www.aikaiyuan.com/6836.html" target="_blank" rel="noopener">Python下的正则表达式原理和优化笔记</a></li>
<li><a href="http://www.aikaiyuan.com/7981.html" target="_blank" rel="noopener">正则表达式 内部培训 PPT</a></li>
<li><a href="http://www.aikaiyuan.com/10014.html" target="_blank" rel="noopener">grep 命令中正则表达式的用法</a></li>
<li><a href="http://www.aikaiyuan.com/8975.html" target="_blank" rel="noopener">优酷真实视频地址解析</a></li>
<li><a href="http://www.aikaiyuan.com/7764.html" target="_blank" rel="noopener">Nginx重写规则 rewrite 指南</a></li>
</ul>
<p>转载请注明：<a href="http://www.aikaiyuan.com" target="_blank" rel="noopener">爱开源</a> » <a href="http://www.aikaiyuan.com/10924.html" target="_blank" rel="noopener">最全面的常用正则表达式大全</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>日期格式转换</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h2 id="日期格式转换"><a href="#日期格式转换" class="headerlink" title="日期格式转换"></a>日期格式转换</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># __author__ &#x3D; &quot;shuke&quot;</span><br><span class="line"># Date: 2017&#x2F;9&#x2F;11</span><br><span class="line"></span><br><span class="line">import json</span><br><span class="line">from datetime import date</span><br><span class="line">from datetime import datetime</span><br><span class="line"></span><br><span class="line">class JsonCustomEncoder(json.JSONEncoder):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    处理datetime格式数据</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def default(self, field):</span><br><span class="line">        if isinstance(field, datetime):</span><br><span class="line">            return field.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;)</span><br><span class="line">        elif isinstance(field, date):</span><br><span class="line">            return field.strftime(&#39;%Y-%m-%d&#39;)</span><br><span class="line">        else:</span><br><span class="line">            return json.JSONEncoder.default(self, field)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>PYTHON</tag>
      </tags>
  </entry>
  <entry>
    <title>生产配置示例</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h2 id="生产配置示例"><a href="#生产配置示例" class="headerlink" title="生产配置示例"></a>生产配置示例</h2><h4 id="1-nginx-conf"><a href="#1-nginx-conf" class="headerlink" title="1. nginx.conf"></a>1. nginx.conf</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">user  www-data;</span><br><span class="line"></span><br><span class="line">worker_processes  auto;</span><br><span class="line">worker_rlimit_nofile 65535;</span><br><span class="line"></span><br><span class="line">error_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log warn;</span><br><span class="line">pid        &#x2F;var&#x2F;run&#x2F;nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  4096;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       &#x2F;etc&#x2F;nginx&#x2F;mime.types;</span><br><span class="line">    default_type  application&#x2F;octet-stream;</span><br><span class="line"></span><br><span class="line">    #log_format  main  &#39;$http_x_forwarded_for - $remote_addr - $remote_user &#39;</span><br><span class="line">    #                  &#39;[$time_local] &quot;$request&quot; $status $body_bytes_sent &#39;</span><br><span class="line">    #                  &#39;&quot;$http_referer&quot; &quot;$http_user_agent&quot;&#39;</span><br><span class="line">    #                  &#39;&quot;$http_x_forwarded_for&quot; $request_time&#39;;</span><br><span class="line"></span><br><span class="line">    #access_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log  main;</span><br><span class="line">    ## LOG ##</span><br><span class="line">    log_format  main  &#39;$upstream_response_time $remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;</span><br><span class="line">                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;</span><br><span class="line">                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot; &quot;$request_time&quot;&#39;;</span><br><span class="line"></span><br><span class="line">    log_format json &#39;&#123;&quot;@timestamp&quot;:&quot;$time_iso8601&quot;,&#39;</span><br><span class="line">                     &#39;&quot;department&quot;:&quot;devops&quot;,&#39;</span><br><span class="line">                     &#39;&quot;type&quot;:&quot;prod_america_nginx&quot;,&#39;</span><br><span class="line">                     &#39;&quot;@version&quot;:&quot;1&quot;,&#39;</span><br><span class="line">                     &#39;&quot;host&quot;:&quot;$server_addr&quot;,&#39;</span><br><span class="line">                     &#39;&quot;client&quot;:&quot;$remote_addr&quot;,&#39;</span><br><span class="line">                     &#39;&quot;real-client&quot;:&quot;$http_x_forwarded_for&quot;,&#39;</span><br><span class="line">                     &#39;&quot;auth_user&quot;:&quot;$remote_user&quot;,&#39;</span><br><span class="line">                     &#39;&quot;request&quot;:&quot;$request&quot;,&#39;</span><br><span class="line">                     &#39;&quot;method&quot;:&quot;$request_method&quot;,&#39;</span><br><span class="line">                     &#39;&quot;port&quot;:&quot;$server_port&quot;,&#39;</span><br><span class="line">                     &#39;&quot;size&quot;:$body_bytes_sent,&#39;</span><br><span class="line">                     &#39;&quot;responsetime&quot;:$request_time,&#39;</span><br><span class="line">                     &#39;&quot;domain&quot;:&quot;$host&quot;,&#39;</span><br><span class="line">                     &#39;&quot;UserAgent&quot;:&quot;$http_user_agent&quot;,&#39;</span><br><span class="line">                     &#39;&quot;url&quot;:&quot;$uri&quot;,&#39;</span><br><span class="line">                     &#39;&quot;status&quot;:&quot;$status&quot;&#125;&#39;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &lt;!--log_format logstash_json &#39;&#123; &quot;@timestamp&quot;: &quot;$time_iso8601&quot;, &#39;--&gt;</span><br><span class="line">        &lt;!--&#39;&quot;remote_addr&quot;: &quot;$remote_addr&quot;, &#39;--&gt;</span><br><span class="line">        &lt;!--&#39;&quot;referer&quot;: &quot;$http_referer&quot;, &#39;--&gt;</span><br><span class="line">        &lt;!--&#39;&quot;request&quot;: &quot;$request&quot;, &#39;--&gt;</span><br><span class="line">        &lt;!--&#39;&quot;status&quot;: $status, &#39;--&gt;</span><br><span class="line">        &lt;!--&#39;&quot;bytes&quot;:$body_bytes_sent, &#39;--&gt;</span><br><span class="line">        &lt;!--&#39;&quot;agent&quot;: &quot;$http_user_agent&quot;, &#39;--&gt;</span><br><span class="line">        &lt;!--&#39;&quot;x_forwarded&quot;: &quot;$http_x_forwarded_for&quot;, &#39;--&gt;</span><br><span class="line">        &lt;!--&#39;&quot;upstr_addr&quot;: &quot;$upstream_addr&quot;,&#39;--&gt;</span><br><span class="line">        &lt;!--&#39;&quot;upstr_host&quot;: &quot;$upstream_http_host&quot;,&#39;--&gt;</span><br><span class="line">        &lt;!--&#39;&quot;ups_resp_time&quot;: &quot;$upstream_response_time&quot; &#125;&#39;;--&gt;</span><br><span class="line"></span><br><span class="line">    access_log   &#x2F;data&#x2F;logs&#x2F;nginx&#x2F;access_json.log   json;</span><br><span class="line">    error_log    &#x2F;data&#x2F;logs&#x2F;nginx&#x2F;error.log   warn;</span><br><span class="line"></span><br><span class="line">    ssi on;</span><br><span class="line">    ssi_silent_errors off;</span><br><span class="line"></span><br><span class="line">    server_tokens   off;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    tcp_nopush      on;</span><br><span class="line">    tcp_nodelay     on;</span><br><span class="line"></span><br><span class="line">    client_max_body_size 8M;</span><br><span class="line">    client_body_buffer_size 128k;</span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    gzip on;</span><br><span class="line">    gzip_min_length 10k;</span><br><span class="line">    gzip_comp_level 3;</span><br><span class="line">    gzip_types text&#x2F;plain text&#x2F;css application&#x2F;javascript application&#x2F;json</span><br><span class="line">               application&#x2F;xml application&#x2F;xhtml+xml text&#x2F;csv;</span><br><span class="line"></span><br><span class="line">    include &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;*.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-redirect-all-to-https-conf"><a href="#2-redirect-all-to-https-conf" class="headerlink" title="2. redirect-all-to-https.conf"></a>2. redirect-all-to-https.conf</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80  default_server;</span><br><span class="line">    listen 443 default_server;</span><br><span class="line">    server_name _;</span><br><span class="line"></span><br><span class="line">    access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;redirect-all-to-https.access.log main;</span><br><span class="line">    error_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;redirect-all-to-https.error.log warn;</span><br><span class="line"></span><br><span class="line">    return 302 https:&#x2F;&#x2F;$host$request_uri;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-upstream"><a href="#3-upstream" class="headerlink" title="3. upstream"></a>3. upstream</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">####################</span><br><span class="line">#  数据挖掘</span><br><span class="line">####################</span><br><span class="line">upstream wecash_mining_apis &#123;</span><br><span class="line">    server 10.40.58.116:8080 max_fails&#x3D;2 fail_timeout&#x3D;30s;</span><br><span class="line">&#125;</span><br><span class="line">upstream wecash_mining_router &#123;</span><br><span class="line">    server 10.40.58.114:8080 max_fails&#x3D;2 fail_timeout&#x3D;30s;</span><br><span class="line">&#125;</span><br><span class="line">upstream wecash_restful_apis &#123;</span><br><span class="line">    server 10.40.58.115:8081 max_fails&#x3D;2 fail_timeout&#x3D;30s;</span><br><span class="line">    server 10.40.61.93:8081  max_fails&#x3D;2 fail_timeout&#x3D;30s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-Server段"><a href="#4-Server段" class="headerlink" title="4. Server段"></a>4. Server段</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       8081;</span><br><span class="line">    server_name  10.40.61.75;</span><br><span class="line">    aio threads&#x3D;default;</span><br><span class="line">    client_max_body_size    2048m;</span><br><span class="line">    access_log  logs&#x2F;wecash_mining.access.log main;</span><br><span class="line">    error_log  logs&#x2F;wecash_mining.error.log  error;</span><br><span class="line">    location ~ ^&#x2F;v1&#x2F;(sms|employer) &#123;</span><br><span class="line">       proxy_next_upstream error timeout http_503 http_502 http_504;</span><br><span class="line">       proxy_pass http:&#x2F;&#x2F;wecash_mining_apis;</span><br><span class="line">       proxy_set_header X-Forwarded-For $http_x_forwarded_for;</span><br><span class="line">       proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">       proxy_set_header Host $http_host;</span><br><span class="line">    &#125;</span><br><span class="line">    location ~ ^&#x2F;api&#x2F;v1&#x2F;dispatch &#123;</span><br><span class="line">        proxy_next_upstream error timeout http_503 http_502 http_504;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;wecash_mining_router;</span><br><span class="line">        proxy_set_header X-Forwarded-For $http_x_forwarded_for;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header Host $http_host;</span><br><span class="line">    &#125;</span><br><span class="line">    location ~ ^&#x2F;api&#x2F;v1&#x2F;(phone_book|segmentation|apply_info|lastest_company|fund|credit_report|social_security|simple_operator|phone_tag) &#123;</span><br><span class="line">        proxy_next_upstream error timeout http_503 http_502 http_504;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;wecash_restful_apis;</span><br><span class="line">        proxy_set_header X-Forwarded-For $http_x_forwarded_for;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header Host $http_host;</span><br><span class="line">    &#125;</span><br><span class="line">    error_page   500 502 503 504  &#x2F;50x.html;</span><br><span class="line">    location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">        root   html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>简洁的Bash Programming技巧(一)</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h2 id="简洁的Bash-Programming技巧-二"><a href="#简洁的Bash-Programming技巧-二" class="headerlink" title="简洁的Bash Programming技巧(二)"></a>简洁的Bash Programming技巧(二)</h2><h3 id="1-检查命令执行是否成功"><a href="#1-检查命令执行是否成功" class="headerlink" title="1. 检查命令执行是否成功"></a>1. 检查命令执行是否成功</h3><p>第一种写法，比较常见：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo abcdee | grep -q abcd</span><br><span class="line"></span><br><span class="line">if [ $? -eq 0 ]; then</span><br><span class="line">    echo &quot;Found&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;Not found&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>简洁的写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if echo abcdee | grep -q abc; then</span><br><span class="line">    echo &quot;Found&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;Not found&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>当然你也可以不要if/else,不过这样可读性比较差:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ echo abcdee | grep -q abc &amp;&amp; echo &quot;Found&quot; || echo &quot;Not found&quot;</span><br><span class="line">Found</span><br></pre></td></tr></table></figure>
<h3 id="2-将标准输出与标准错误输出重定向到-dev-null"><a href="#2-将标准输出与标准错误输出重定向到-dev-null" class="headerlink" title="2. 将标准输出与标准错误输出重定向到/dev/null"></a>2. 将标准输出与标准错误输出重定向到/dev/null</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 第一种写法，比较常见：</span><br><span class="line">grep &quot;abc&quot; test.txt 1&gt;&#x2F;dev&#x2F;null 2&gt;&amp;1</span><br><span class="line">2. 常见的错误写法：</span><br><span class="line">grep &quot;abc&quot; test.txt 2&gt;&amp;1 1&gt;&#x2F;dev&#x2F;null</span><br><span class="line">3. 简洁的写法：</span><br><span class="line">grep &quot;abc&quot; test.txt &amp;&gt; &#x2F;dev&#x2F;null</span><br></pre></td></tr></table></figure>
<h3 id="3-awk的使用"><a href="#3-awk的使用" class="headerlink" title="3. awk的使用"></a>3. awk的使用</h3><p>举一个实际的例子，获取Xen DomU的id。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 常见的写法：</span><br><span class="line">sudo xm li | grep vm_name | awk &#39;&#123;print $2&#125;&#39;</span><br><span class="line">2. 简洁的写法：</span><br><span class="line">sudo xm li | awk &#39;&#x2F;vm_name&#x2F;&#123;print $2&#125;&#39;</span><br></pre></td></tr></table></figure>
<h3 id="4-将一个文本的所有行用逗号连接起来"><a href="#4-将一个文本的所有行用逗号连接起来" class="headerlink" title="4. 将一个文本的所有行用逗号连接起来"></a>4. 将一个文本的所有行用逗号连接起来</h3><p>假设文件内容如下所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat &#x2F;tmp&#x2F;ip.txt </span><br><span class="line">192.168.1.100</span><br><span class="line">192.168.1.101</span><br><span class="line">192.168.1.102</span><br></pre></td></tr></table></figure>
<p>使用Sed命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sed &#39;:a;$!N;s&#x2F;\n&#x2F;,&#x2F;;ta&#39; &#x2F;tmp&#x2F;ip.txt</span><br><span class="line">192.168.1.100,192.168.1.101,192.168.1.102</span><br></pre></td></tr></table></figure>
<p>简洁的写法(一)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ paste -sd, &#x2F;tmp&#x2F;ip.txt</span><br><span class="line">192.168.1.100,192.168.1.101,192.168.1.102</span><br></pre></td></tr></table></figure>
<p>简洁的写法(二)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat &#x2F;tmp&#x2F;ip.txt | tr &quot;\n&quot; &quot;,&quot;</span><br><span class="line">192.168.1.100,192.168.1.101,192.168.1.102,</span><br><span class="line">⚠️ 结尾的换行符也会被替换为逗号</span><br></pre></td></tr></table></figure>
<h3 id="5-过滤重复行"><a href="#5-过滤重复行" class="headerlink" title="5. 过滤重复行"></a>5. 过滤重复行</h3><p>假设文件内容如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># sort &#x2F;tmp&#x2F;ip.txt</span><br><span class="line">192.168.1.100</span><br><span class="line">192.168.1.100</span><br><span class="line">192.168.1.101</span><br><span class="line">192.168.1.101</span><br><span class="line">192.168.1.102</span><br></pre></td></tr></table></figure>
<p>常用的方法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># sort &#x2F;tmp&#x2F;ip.txt | uniq</span><br><span class="line">192.168.1.100</span><br><span class="line">192.168.1.101</span><br><span class="line">192.168.1.102</span><br></pre></td></tr></table></figure>
<p>简单的写法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># sort -u &#x2F;tmp&#x2F;ip.txt</span><br><span class="line">192.168.1.100</span><br><span class="line">192.168.1.101</span><br><span class="line">192.168.1.102</span><br></pre></td></tr></table></figure>
<h3 id="6-grep查找单词"><a href="#6-grep查找单词" class="headerlink" title="6. grep查找单词"></a>6. grep查找单词</h3><p>假设一个文本的每一行是一个ip地址，例如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cat &#x2F;tmp&#x2F;ip.txt</span><br><span class="line">192.168.1.100</span><br><span class="line">192.168.1.101</span><br><span class="line">192.168.1.102</span><br><span class="line">192.168.1.100</span><br><span class="line">192.168.1.101</span><br></pre></td></tr></table></figure>
<p>使用grep查找是否包括192.168.1.102这个ip地址。常见的写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># grep &#39;192.168.1.102\&gt;&#39; &#x2F;tmp&#x2F;ip.txt</span><br><span class="line">192.168.1.102</span><br></pre></td></tr></table></figure>
<p>简单的方法（其实这方法不见得简单，只是为了说明-w这个参数还是很有用的)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># grep -w &#39;192.168.1.102&#39; &#x2F;tmp&#x2F;ip.txt</span><br><span class="line">192.168.1.102</span><br></pre></td></tr></table></figure>
<p>注⚠️: grep的-n/-H/-v/-f/-c这几参数都很有用.</p>
<h3 id="7-临时设置环境变量"><a href="#7-临时设置环境变量" class="headerlink" title="7. 临时设置环境变量"></a>7. 临时设置环境变量</h3><p>常见的写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ export LC_ALL&#x3D;zh_CN.UTF-8 </span><br><span class="line"></span><br><span class="line">$ date</span><br><span class="line">2012年 11月 03日 星期六 22:26:55 CST</span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line">简洁的写法:</span><br></pre></td></tr></table></figure>
<p>$ unset LC_ALL<br>$ LC_ALL=zh_CN.UTF-8 date<br>2012年 11月 03日 星期六 22:27:43 CST</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在命令之前加上环境变更的设置，只是临时改变当前执行命令的环境。</span><br><span class="line">### 8. \$1,\$2...等位置参数的使用</span><br><span class="line">假设只想使用$2,$3..这几个参数，常见的做法是:</span><br></pre></td></tr></table></figure>
<p>shift<br>echo “$@”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">为什么不这样写呢？</span><br></pre></td></tr></table></figure>
<p>echo “${@:2}”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 9. 退而求其次的写法</span><br><span class="line">相信大家会有这种需求，当一个参数值没有提供时，可以使用默认值。常见的写法是：</span><br></pre></td></tr></table></figure>
<p>arg=$1<br>if [ -z “$arg” ]; then<br>   arg=0<br>fi</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简洁的写法是这样的:</span><br></pre></td></tr></table></figure>
<p>arg=${1:-0}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 10. bash特殊参数--的用法</span><br><span class="line">假设要用grep查找字符串中是否包含-i，我们会这样尝试：</span><br></pre></td></tr></table></figure>
<h1 id="echo-‘abc-i’-grep-“-i”"><a href="#echo-‘abc-i’-grep-“-i”" class="headerlink" title="echo ‘abc-i’ | grep “-i”"></a>echo ‘abc-i’ | grep “-i”</h1><p>Usage: grep [OPTION]… PATTERN [FILE]…<br>Try ‘grep –help’ for more information.</p>
<h1 id="echo-‘abc-i’-grep-“-i”-1"><a href="#echo-‘abc-i’-grep-“-i”-1" class="headerlink" title="echo ‘abc-i’ | grep “-i”"></a>echo ‘abc-i’ | grep “-i”</h1><p>abc-i</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简洁的方法是：</span><br></pre></td></tr></table></figure>
<h1 id="echo-‘abc-i’-grep-–-i"><a href="#echo-‘abc-i’-grep-–-i" class="headerlink" title="echo ‘abc-i’ | grep – -i"></a>echo ‘abc-i’ | grep – -i</h1><p>abc-i</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">注⚠️:bash中--后面的参数不会被当作选项解析。</span><br><span class="line">### 11. 函数的返回值默认是最后一行语句的返回值</span><br></pre></td></tr></table></figure>
<h1 id="Check-whether-an-item-is-a-function"><a href="#Check-whether-an-item-is-a-function" class="headerlink" title="Check whether an item is a function"></a>Check whether an item is a function</h1><h1 id="1-the-function-name"><a href="#1-the-function-name" class="headerlink" title="$1: the function name"></a>$1: the function name</h1><h1 id="Return-0-yes-or-1-no"><a href="#Return-0-yes-or-1-no" class="headerlink" title="Return: 0(yes) or 1(no)"></a>Return: 0(yes) or 1(no)</h1><p>function is_function()<br>{<br>    local func_name=$1<br>    test “<code>type -t $1 2&gt;/dev/null</code>“ = “function”<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">不要画蛇添足再在后面加一行return $?了。</span><br><span class="line">### 12. 将printf格式化的结果赋值给变量</span><br><span class="line">例如将数字转换成其十六进制形式，常见的写法是：</span><br></pre></td></tr></table></figure>
<p>$ var=$(printf ‘%%%02x’ 111)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简单的写法是：</span><br></pre></td></tr></table></figure>
<p>$ printf -v var ‘%%%02x’ 111 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">printf的help：</span><br></pre></td></tr></table></figure>
<h1 id="help-printf-grep-A-1-B-1-–-v"><a href="#help-printf-grep-A-1-B-1-–-v" class="headerlink" title="help printf | grep -A 1 -B 1 – -v"></a>help printf | grep -A 1 -B 1 – -v</h1><p>printf: printf [-v var] format [arguments]<br>    Formats and prints ARGUMENTS under control of the FORMAT.<br>–<br>    Options:<br>      -v var    assign the output to shell variable VAR rather than<br>            display it on the standard output</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 13. 打印文件行</span><br><span class="line">打印文件的第一行：</span><br></pre></td></tr></table></figure>
<p>head -1 test.txt</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">打印文件的第2行：</span><br></pre></td></tr></table></figure>
<p>sed -n ‘2p’ test.txt</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">打印文件的第2到5行：</span><br></pre></td></tr></table></figure>
<p>sed -n ‘2,5p’ test.txt</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">打印文件的第2行始（包括第2行在内）5行的内容：</span><br></pre></td></tr></table></figure>
<p>sed -n ‘2,+4p’ test.txt</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">打印倒数第二行：</span><br></pre></td></tr></table></figure>
<p>$ tail -2 test.txt | head -1<br>$ tac test.txt | sed -n ‘2p’</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 14.善用let或者(())命令做算术运算</span><br><span class="line">如何对一个数字做++运算，可能你会这样用：</span><br></pre></td></tr></table></figure>
<p>a=1<br>a=<code>expr a + 1</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">为何不用你熟悉的:</span><br></pre></td></tr></table></figure>
<p>a=1<br>let a++<br>let a+=2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 15. 获取软连接指定的真实文件名</span><br><span class="line">如果你不知道，你可能会这样获取：</span><br></pre></td></tr></table></figure>
<p>$ ls -l /usr/bin/python | awk -F’-&gt;’ ‘{print $2}’ | tr -d ‘ ‘<br>/usr/bin/python2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果你知道有一个叫readlink的命令，那么：</span><br></pre></td></tr></table></figure>
<p>$ readlink /usr/bin/python<br>/usr/bin/python2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 16. 获取一个字符的ASCII码</span><br></pre></td></tr></table></figure>
<p>$ printf ‘%02x’ “‘+”<br>2b<br>$ echo -n ‘+’ | od -tx1 -An | tr -d ‘ ‘<br>2b</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 17. 清空一个文件</span><br><span class="line">常见的用法:</span><br></pre></td></tr></table></figure>
<p>echo “” &gt; test.txt</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简单的写法：</span><br></pre></td></tr></table></figure>
<blockquote>
<p>test.txt</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 18 不要忘记有here document</span><br><span class="line">下面一段代码：</span><br></pre></td></tr></table></figure>
<p>grep -v 1 /tmp/test.txt | while read line; do<br>    let a++<br>    echo –$line–<br>done<br>echo a:$a</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">执行后有什么问题吗？</span><br></pre></td></tr></table></figure>
<p>$ sh test.sh<br>–2–<br>–3–<br>a:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">问题: 发现a这个变量没有被赋值，为什么呢？因为管道后面的代码是在在一个子shell中执行的，所做的任何更改都不会对当前shell有影响，自然a这个变量就不会有赋值了。</span><br><span class="line"></span><br><span class="line">换一种思路，可以这样做：</span><br></pre></td></tr></table></figure>
<p>grep -v 1 /tmp/test.txt &gt; /tmp/test.tmp</p>
<p>while read line; do<br>    let a++<br>    echo –$line–<br>done &lt; /tmp/test.tmp</p>
<p>echo a:$a<br>rm -f /tmp/test.tmp</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">不过多了一个临时文件，最后还要删除。这里其实可以用到here document：</span><br></pre></td></tr></table></figure>
<p>while read line2; do<br>    let b++<br>    echo ??$line2??<br>done &lt;&lt; EOF<br><code>grep -v 1 /tmp/test.txt</code><br>EOF<br>echo b: $b</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">here document往往用于需要输出一大段文本的地方，例如脚本的help函数</span><br><span class="line"></span><br><span class="line">### 19.删除字符串中的第一个或者最后一个字符</span><br><span class="line">假设字符串为：</span><br></pre></td></tr></table></figure>
<p>$ str=”aremoveb”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">可能你第一个想法是通过sed或者其它命令来完成这个功能，但是其实有很简单的方法,此处利用shell的数组进行处理：</span><br></pre></td></tr></table></figure>
<p>$ echo “${str#?}”<br>removeb<br>$ echo “${str%?}”<br>aremove</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">类似地，你也可以删除2个、3个、4个……</span><br><span class="line"></span><br><span class="line">有没有一次性删除第一个和最后一个字符的方法呢？答案当然是肯定的：</span><br></pre></td></tr></table></figure>
<p>$ echo “${str:1:-1}”<br>remove</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">关于这些变量替换的内容在bash的man手册中都有说明。</span><br><span class="line">### 20. 使用逗号join数组元素</span><br><span class="line">假设数组元素没有空格，可以用这种方法：</span><br></pre></td></tr></table></figure>
<p>$ a=(1 2 3)<br>$ b=”${a[*]}”</p>
<p>$ echo ${b// /,}<br>1,2,3</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">注⚠️：当该数组的长度非常长时，使用这种替换的时间开销很高，性能很差，推荐用sed。</span><br><span class="line">假设数组元素包含有空格，可以借用printf命令来达到：</span><br></pre></td></tr></table></figure>
<p>$ a=(1 “2 3” 4)<br>$ printf “,%s” “${a[@]}” | cut -c2-<br>1,2 3,4</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 21. Shell中的多进程</span><br><span class="line">在命令行下，我们会在命令行后面加上&amp;符号来让该命令在后台执行，在shell脚本中，使用&quot;(cmd)&quot;可以让fork一个子shell来执行该命令。利用这两点，可以实现shell的多线程：</span><br></pre></td></tr></table></figure>
<p>job_num=10</p>
<p>function do_work()<br>{<br>    echo “Do work..”<br>}</p>
<p>for ((i=0; i &lt; job_num ;i++)); do<br>    echo “Fork job $i”<br>    (do_work) &amp;<br>done</p>
<p>wait   # wait for all job done<br>echo “All job have been done!”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">注⚠️: 最后的wait命令，作用是等待所有子进程结束。</span><br><span class="line">附几则小技巧：</span><br></pre></td></tr></table></figure>
<p>1）sudo iptables -L -n | vim -<br>2）grep -v xxx | vim -<br>3）echo $’&#39;‘<br>4）set – 1 2 3; echo “$@”<br>5）搜索stackoverflow/superuser等站点<br>6）VIM编辑远程文件 vim scp://xxx//etc/vimrc<br>7）远程执行脚本 ssh xxx bash &lt; xxx.sh</p>
<pre><code>
[原文地址](https://yq.aliyun.com/articles/68541?spm=a2c4e.11153959.blogcont72014.7.6f252cb3xPFFVx)

</code></pre>]]></content>
      <categories>
        <category>SHELL</category>
      </categories>
      <tags>
        <tag>SHELL</tag>
      </tags>
  </entry>
  <entry>
    <title>维护JAVA服务脚本示例</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h3 id="维护JAVA服务脚本示例"><a href="#维护JAVA服务脚本示例" class="headerlink" title="维护JAVA服务脚本示例"></a>维护JAVA服务脚本示例</h3><p>start_env.sh</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">CURRENT_PATH&#x3D;$(cd &#96;dirname $0&#96;; pwd)</span><br><span class="line">PARENT_PATH&#x3D;$(cd &#96;dirname $0&#96;; cd ..; pwd)</span><br><span class="line">CURRENT_SERVICE_NAME&#x3D;$(echo $&#123;CURRENT_PATH&#125; | awk -F &#39;&#x2F;&#39; &#39;&#123;print $(NF)&#125;&#39;)</span><br><span class="line"></span><br><span class="line"># USE THOSE VARIABLE</span><br><span class="line">GC_LOG_PATH&#x3D;$&#123;CURRENT_PATH&#125;&#x2F;logs&#x2F;$&#123;CURRENT_SERVICE_NAME&#125;-gcdetail.log</span><br><span class="line">COMMON_CONFIG_PATH&#x3D;$&#123;PARENT_PATH&#125;</span><br><span class="line">CONFIG_PATH&#x3D;$&#123;CURRENT_PATH&#125;&#x2F;config</span><br><span class="line">JAR_PATH&#x3D;$&#123;CURRENT_PATH&#125;&#x2F;jar</span><br><span class="line">LOG_PATH&#x3D;$&#123;CURRENT_PATH&#125;&#x2F;logs</span><br><span class="line"></span><br><span class="line">## MODIFY FOLLOWING LINES</span><br><span class="line">EXECUT_JAR&#x3D;&quot;america-business-auth-impl-1.0-SNAPSHOT-all.jar&quot;</span><br><span class="line">DUBBO_PARAMETER&#x3D;&quot;</span><br><span class="line">-Dapp.id&#x3D;america-business-auth</span><br><span class="line">-Xdebug</span><br><span class="line">-server</span><br><span class="line">-Xmx512m</span><br><span class="line">-Xms512m</span><br><span class="line">-Xnoagent</span><br><span class="line">-XX:+PrintGCDateStamps</span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-XX:NewRatio&#x3D;2</span><br><span class="line">-XX:SurvivorRatio&#x3D;8</span><br><span class="line">-XX:MetaspaceSize&#x3D;128m</span><br><span class="line">-XX:MaxMetaspaceSize&#x3D;128m</span><br><span class="line">-Xloggc:$&#123;GC_LOG_PATH&#125;</span><br><span class="line">-Ddubbo.registry.file&#x3D;$&#123;JAR_PATH&#125;&#x2F;dubbo.cache</span><br><span class="line">-Dconfig.path&#x3D;file:$&#123;COMMON_CONFIG_PATH&#125;&#x2F;common.properties;file:$&#123;CONFIG_PATH&#125;&#x2F;config.properties</span><br><span class="line">$&#123;JAR_PATH&#125;&#x2F;$&#123;EXECUT_JAR&#125;</span><br><span class="line">&quot;</span><br><span class="line">## STOP MODIFY</span><br><span class="line"></span><br><span class="line">java -jar $&#123;DUBBO_PARAMETER&#125; | &#x2F;usr&#x2F;bin&#x2F;cronolog $LOG_PATH&#x2F;out.%Y%m%d.nohup &gt;&gt; &#x2F;dev&#x2F;null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>
<p>service_control.sh</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">#set -x</span><br><span class="line"></span><br><span class="line">source &#x2F;etc&#x2F;profile</span><br><span class="line"></span><br><span class="line"># USE THOSE VARIABLE</span><br><span class="line">CURRENT_PATH&#x3D;$(cd &#96;dirname $0&#96;; pwd)</span><br><span class="line">PARENT_PATH&#x3D;$(cd &#96;dirname $0&#96;; cd ..; pwd)</span><br><span class="line">CURRENT_SERVICE_NAME&#x3D;$(echo $&#123;CURRENT_PATH&#125; | awk -F &#39;&#x2F;&#39; &#39;&#123;print $(NF)&#125;&#39;)</span><br><span class="line">STOP_WAIT_TIME&#x3D;10</span><br><span class="line">CURRENT_TIME&#x3D;&#96;date +%Y%m%d-%H%M%S&#96;</span><br><span class="line"></span><br><span class="line">DUMP_PATH&#x3D;$&#123;CURRENT_PATH&#125;&#x2F;dump</span><br><span class="line">LOG_PATH&#x3D;$&#123;CURRENT_PATH&#125;&#x2F;logs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">log() &#123;</span><br><span class="line">    echo &quot;$(date +&quot;%Y-%m-%d %H:%M:%S&quot;): $1&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exit_status() &#123;</span><br><span class="line">    if [ $? &#x3D;&#x3D; 0 ]</span><br><span class="line">    then</span><br><span class="line">        echo -e &quot;\\033[1;32m[OK]\\033[0;39m&quot;</span><br><span class="line">    else</span><br><span class="line">        echo -e &quot;\\033[1;31m[Failed]\\033[0;39m&quot;</span><br><span class="line">        log &quot;Error&quot;</span><br><span class="line">        exit 1</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">check_user() &#123;</span><br><span class="line">    if [ &#96;whoami&#96; !&#x3D; &quot;app&quot; || &#96;whoami&#96; !&#x3D; &quot;root&quot; ]; then</span><br><span class="line">        log &quot;Please use app user to run this command.&quot;</span><br><span class="line">        false</span><br><span class="line">        exit_status</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stop_service() &#123;</span><br><span class="line"></span><br><span class="line">    log &quot;Stop Service Service: $&#123;CURRENT_SERVICE_NAME&#125;&quot;</span><br><span class="line">    Service_NUM&#x3D;&#96;ps -ef|grep $&#123;CURRENT_SERVICE_NAME&#125;&#x2F;jar&#x2F;|grep -v grep|grep -v cronolog|grep -v $0|awk &#39;&#123;print $2&#125;&#39;|wc -l&#96;</span><br><span class="line">    if [ $((Service_NUM)) -gt 1 ]</span><br><span class="line">    then</span><br><span class="line">        log &quot;Service: $&#123;CURRENT_SERVICE_NAME&#125; run more than one process&quot;</span><br><span class="line">        false</span><br><span class="line">        exit_status</span><br><span class="line">    fi</span><br><span class="line">    Service_PID&#x3D;&#96;ps -ef|grep $&#123;CURRENT_SERVICE_NAME&#125;&#x2F;jar&#x2F;|grep -v grep|grep -v cronolog|grep -v $0|awk &#39;&#123;print $2&#125;&#39;&#96;</span><br><span class="line">    if [ x$Service_PID &#x3D;&#x3D; x ];then</span><br><span class="line">        log &quot;Service: $&#123;CURRENT_SERVICE_NAME&#125; process is NOT exist&quot;</span><br><span class="line">        exit_status</span><br><span class="line">    else</span><br><span class="line">        log &quot;KILL Service Service: $&#123;CURRENT_SERVICE_NAME&#125;&quot;</span><br><span class="line">        kill  $Service_PID</span><br><span class="line">        exit_status</span><br><span class="line">    fi</span><br><span class="line">    echo &quot;&quot;</span><br><span class="line">    log &quot;Search Service Process ...&quot;</span><br><span class="line">    Check&#x3D;N</span><br><span class="line">    N&#x3D;0</span><br><span class="line">    while [ $Check &#x3D;&#x3D; &quot;N&quot; ]</span><br><span class="line">    do</span><br><span class="line">        N&#x3D;$(($N+1))</span><br><span class="line">        Service_PID&#x3D;&#96;ps -ef|grep $&#123;CURRENT_SERVICE_NAME&#125;&#x2F;jar&#x2F;|grep -v grep|grep -v cronolog|grep -v $0|awk &#39;&#123;print $2&#125;&#39;&#96;</span><br><span class="line"></span><br><span class="line">        if [ &quot;$Service_PID&quot; &#x3D; &quot;&quot; ]</span><br><span class="line">        then</span><br><span class="line">            log &quot;Not found Service PID alive&quot;</span><br><span class="line">            break</span><br><span class="line">        else</span><br><span class="line">            log &quot;$N: Check Service PID:$Service_PID, Sleep 1 Sec Wait Service Exit ...&quot;</span><br><span class="line">        fi</span><br><span class="line"></span><br><span class="line">        if [ $((N)) -gt $STOP_WAIT_TIME ]</span><br><span class="line">        then</span><br><span class="line">            log &quot;Force KILL Service: $&#123;CURRENT_SERVICE_NAME&#125;&quot;</span><br><span class="line">            #jstack $Service_PID &gt;&gt; &#x2F;var&#x2F;log&#x2F;jstack.log</span><br><span class="line">            #skill -9 $Service_PID</span><br><span class="line">            kill -9 $Service_PID</span><br><span class="line">            exit_status</span><br><span class="line">            break</span><br><span class="line">        fi</span><br><span class="line">        sleep 1</span><br><span class="line">    done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">start_service() &#123;</span><br><span class="line"></span><br><span class="line">    log &quot;Start Service Service: $&#123;CURRENT_SERVICE_NAME&#125;&quot;</span><br><span class="line">    Service_NUM&#x3D;&#96;ps -ef|grep $&#123;CURRENT_SERVICE_NAME&#125;&#x2F;jar&#x2F; | grep -v grep |grep -v $0|awk &#39;&#123;print $2&#125;&#39;|wc -l&#96;</span><br><span class="line">    if [ $((Service_NUM)) -gt 0 ]</span><br><span class="line">    then</span><br><span class="line">        log &quot;Service: $&#123;CURRENT_SERVICE_NAME&#125; already running&quot;</span><br><span class="line">        false</span><br><span class="line">        exit_status</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    if [ ! -d $LOG_PATH ]; then</span><br><span class="line">        mkdir -p $LOG_PATH</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    nohup &#x2F;bin&#x2F;bash $CURRENT_PATH&#x2F;start_env.sh &amp;&gt;&gt; &#x2F;dev&#x2F;null &amp;</span><br><span class="line"></span><br><span class="line">    #exit_status</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status() &#123;</span><br><span class="line"></span><br><span class="line">    Service_NUM&#x3D;&#96;ps -ef|grep $&#123;CURRENT_SERVICE_NAME&#125;&#x2F;jar&#x2F;|grep -v grep|grep -v cronolog|grep -v $0|awk &#39;&#123;print $2&#125;&#39;|wc -l&#96;</span><br><span class="line">    if [ $((Service_NUM)) -gt 1 ]</span><br><span class="line">    then</span><br><span class="line">        echo &quot;Service run more than one process,please check&quot;</span><br><span class="line">        false</span><br><span class="line">        exit_status</span><br><span class="line">    fi</span><br><span class="line">    Service_PID&#x3D;&#96;ps -ef|grep $&#123;CURRENT_SERVICE_NAME&#125;&#x2F;jar&#x2F;|grep -v grep|grep -v cronolog|grep -v $0|awk &#39;&#123;print $2&#125;&#39;&#96;</span><br><span class="line">    if [ x$Service_PID &#x3D;&#x3D; x ];then</span><br><span class="line">        echo &quot;Service: $&#123;CURRENT_SERVICE_NAME&#125; process is NOT exist&quot;</span><br><span class="line">        false</span><br><span class="line">        exit_status</span><br><span class="line">    else</span><br><span class="line">        Service_startTime&#x3D;&#96;ps -p $&#123;Service_PID&#125; -o lstart|grep -v &quot;START&quot;&#96;</span><br><span class="line">        echo -e &quot;service: $&#123;CURRENT_SERVICE_NAME&#125; started,\npid: $&#123;Service_PID&#125;,\nstartTime: $&#123;Service_startTime&#125;,\nlogPath: $&#123;LOG_PATH&#125;&#x2F;out.&#96;date +%Y%m%d&#96;.nohup&quot;</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dump() &#123;</span><br><span class="line">    if [ ! -d $DUMP_PATH ]; then</span><br><span class="line">        mkdir -p $DUMP_PATH</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    echo -e &quot;Dumping the $&#123;CURRENT_SERVICE_NAME&#125; ...\c&quot;</span><br><span class="line">    sudo &#x2F;usr&#x2F;local&#x2F;jdk&#x2F;bin&#x2F;jstack $Service_PID &gt; $DUMP_PATH&#x2F;jstack-$Service_PID.$&#123;CURRENT_TIME&#125;.dump 2&gt;&amp;1</span><br><span class="line">    echo -e &quot;.\c&quot;</span><br><span class="line">    sudo &#x2F;usr&#x2F;local&#x2F;jdk&#x2F;bin&#x2F;jinfo $Service_PID &gt; $DUMP_PATH&#x2F;jinfo-$Service_PID.$&#123;CURRENT_TIME&#125;.dump 2&gt;&amp;1</span><br><span class="line">    echo -e &quot;.\c&quot;</span><br><span class="line">    sudo &#x2F;usr&#x2F;local&#x2F;jdk&#x2F;bin&#x2F;jstat -gcutil $Service_PID &gt; $DUMP_PATH&#x2F;jstat-gcutil-$Service_PID.$&#123;CURRENT_TIME&#125;.dump 2&gt;&amp;1</span><br><span class="line">    echo -e &quot;.\c&quot;</span><br><span class="line">    sudo &#x2F;usr&#x2F;local&#x2F;jdk&#x2F;bin&#x2F;jstat -gccapacity $Service_PID &gt; $DUMP_PATH&#x2F;jstat-gccapacity-$Service_PID.$&#123;CURRENT_TIME&#125;.dump 2&gt;&amp;1</span><br><span class="line">    echo -e &quot;.\c&quot;</span><br><span class="line">    sudo &#x2F;usr&#x2F;local&#x2F;jdk&#x2F;bin&#x2F;jmap $Service_PID &gt; $DUMP_PATH&#x2F;jmap-$Service_PID.$&#123;CURRENT_TIME&#125;.dump 2&gt;&amp;1</span><br><span class="line">    echo -e &quot;.\c&quot;</span><br><span class="line">    sudo &#x2F;usr&#x2F;local&#x2F;jdk&#x2F;bin&#x2F;jmap -heap $Service_PID &gt; $DUMP_PATH&#x2F;jmap-heap-$Service_PID.$&#123;CURRENT_TIME&#125;.dump 2&gt;&amp;1</span><br><span class="line">    echo -e &quot;.\c&quot;</span><br><span class="line">    sudo &#x2F;usr&#x2F;local&#x2F;jdk&#x2F;bin&#x2F;jmap -histo $Service_PID &gt; $DUMP_PATH&#x2F;jmap-histo-$Service_PID.$&#123;CURRENT_TIME&#125;.dump 2&gt;&amp;1</span><br><span class="line">    echo -e &quot;.\c&quot;</span><br><span class="line">    if [ -r &#x2F;usr&#x2F;sbin&#x2F;lsof ]; then</span><br><span class="line">    &#x2F;usr&#x2F;sbin&#x2F;lsof -p $Service_PID &gt; $DUMP_PATH&#x2F;lsof-$Service_PID.$&#123;CURRENT_TIME&#125;.dump</span><br><span class="line">    echo -e &quot;.\c&quot;</span><br><span class="line">    fi</span><br><span class="line">    echo -e &quot;\nDump Complete, files in $&#123;DUMP_PATH&#125;\n&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tail_log() &#123;</span><br><span class="line">    if [ ! -n &quot;$1&quot; ] ; then</span><br><span class="line">        tail_num&#x3D;10</span><br><span class="line">    else</span><br><span class="line">        tail_num&#x3D;$1</span><br><span class="line">    fi</span><br><span class="line">    tail -$&#123;tail_num&#125;f $&#123;LOG_PATH&#125;&#x2F;out.&#96;date +%Y%m%d&#96;.nohup</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">help() &#123;</span><br><span class="line">    echo &quot;USAGE: $0 &#123;stop|start|restart|status|dump|log [tail line of numbers:200]|help&#125;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if [ $# -gt 0 ] ; then</span><br><span class="line"></span><br><span class="line">    case $1 in</span><br><span class="line">    start)</span><br><span class="line">        log &quot;Will Start Service ...&quot;</span><br><span class="line">        start_service</span><br><span class="line">        log &quot;Sleep 3 Sec for Status ...&quot;</span><br><span class="line">        sleep 3</span><br><span class="line">        status</span><br><span class="line">        ;;</span><br><span class="line">    stop)</span><br><span class="line">        log &quot;Will Stop Service ...&quot;</span><br><span class="line">        stop_service</span><br><span class="line">        ;;</span><br><span class="line">    restart)</span><br><span class="line">        log &quot;Will Restart Service ...&quot;</span><br><span class="line"></span><br><span class="line">        stop_service</span><br><span class="line">        log &quot;Sleep 3 Sec&quot;</span><br><span class="line">        sleep 3</span><br><span class="line"></span><br><span class="line">        start_service</span><br><span class="line">        log &quot;Sleep 3 Sec for Status ...&quot;</span><br><span class="line">        sleep 3</span><br><span class="line">        status</span><br><span class="line">        ;;</span><br><span class="line">    status)</span><br><span class="line">        status</span><br><span class="line">        ;;</span><br><span class="line">    dump)</span><br><span class="line">        check_user</span><br><span class="line">        status</span><br><span class="line">        if [ $? &#x3D;&#x3D; 0 ]</span><br><span class="line">        then</span><br><span class="line">            dump</span><br><span class="line">        else</span><br><span class="line">            exit 1</span><br><span class="line">        fi</span><br><span class="line"></span><br><span class="line">        ;;</span><br><span class="line">    log)</span><br><span class="line">        tail_log $2</span><br><span class="line">        ;;</span><br><span class="line">    help)</span><br><span class="line">        help</span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">        echo &quot;Bad Parameter: $1&quot;</span><br><span class="line">        help</span><br><span class="line">        exit 1</span><br><span class="line">        ;;</span><br><span class="line">    esac</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line">    help</span><br><span class="line">    exit 1;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SHELL</category>
      </categories>
      <tags>
        <tag>SHELL</tag>
      </tags>
  </entry>
  <entry>
    <title>简洁的Bash Programming技巧(二)</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h2 id="简洁的Bash-Programming技巧-三"><a href="#简洁的Bash-Programming技巧-三" class="headerlink" title="简洁的Bash Programming技巧(三)"></a>简洁的Bash Programming技巧(三)</h2><p>这一系列的文章专门介绍 Bash 编程中一些简洁的技巧，帮助大家提高平时 Bash 编程的效率。</p>
<h3 id="1-替换语法-parameter-pattern-string-的妙用"><a href="#1-替换语法-parameter-pattern-string-的妙用" class="headerlink" title="1. 替换语法${parameter/pattern/string}的妙用"></a>1. 替换语法${parameter/pattern/string}的妙用</h3><p>${parameter/pattern/string}将parameter中匹配pattern的部分替换成string，例如下面的例子将字符串中的e替换成x：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ str&#x3D;&quot;three&quot;</span><br><span class="line">$ echo &quot;$&#123;str&#x2F;e&#x2F;x&#125;&quot;</span><br><span class="line">thrxe</span><br></pre></td></tr></table></figure>
<p>如果pattern部分以/开头，表示替换parameter中所有匹配的内容，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ str&#x3D;&quot;three&quot;</span><br><span class="line">$ echo &quot;$&#123;str&#x2F;&#x2F;e&#x2F;x&#125;&quot;  # thrxx</span><br></pre></td></tr></table></figure>
<p>如果pattern部分以#开头，表示仅当parameter开始处匹配pattern的时候替换，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str&#x3D;&quot;three&quot;</span><br><span class="line">$ echo &quot;$&#123;str&#x2F;#e&#x2F;x&#125;&quot; # three</span><br><span class="line">$ echo &quot;$&#123;str&#x2F;#t&#x2F;x&#125;&quot; # xhree</span><br></pre></td></tr></table></figure>
<p>与此对应地是，如果pattern部分以%开头，表示仅当parameter结尾处匹配pattern的时候替换，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ str&#x3D;&quot;three&quot;</span><br><span class="line">$ echo &quot;$&#123;str&#x2F;%e&#x2F;x&#125;&quot; # threx</span><br></pre></td></tr></table></figure>
<p>如果string部分为空，匹配pattern的部分被删除（替换为空），例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ str&#x3D;&quot;three&quot;</span><br><span class="line">$ echo &quot;$&#123;str&#x2F;h&#x2F;&#125;&quot;  # tree</span><br></pre></td></tr></table></figure>
<p>这个时候第二个斜杠可以删除，即：echo “${str/h}” 如果parameter是一个数组会怎么样呢？有兴趣的可以看看Bash的man手册说明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">man -P &#39;less -p &quot;\\$\&#123;parameter&#x2F;pattern&#x2F;string&#125;&quot;&#39; bash</span><br></pre></td></tr></table></figure>
<h3 id="2-运算符"><a href="#2-运算符" class="headerlink" title="2. +=运算符"></a>2. +=运算符</h3><p>有一天，我看到这样一个用法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ arr&#x3D;(1 2 3)</span><br><span class="line">$ arr+&#x3D;(4 5)</span><br></pre></td></tr></table></figure>
<p>原来数组还可以这样相加，后来我看了下Bash的手册，确实有一段这么说明的，这里未引用这段文字，有兴趣的可以查看<a href="http://www.gnu.org/software/bash/manual/bashref.html?spm=a2c4e.11153959.blogcont68524.12.4dbf3d2foIG0jZ#Shell-Parameters" target="_blank" rel="noopener">Bash Reference Manual</a> 自然地我们会想到如果一个变量是数字，是否也可以用+=作运算呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ i&#x3D;1</span><br><span class="line">$ i+&#x3D;1</span><br></pre></td></tr></table></figure>
<p>但是，运行后你会发现i的结果并不为2，而是11，这里bash并不认为i是一个整数，而是作为字符串。 这时可以通过declare声明一个变量为整数，上面的问题就解决了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ declare -i int&#x3D;1</span><br><span class="line">$ int+&#x3D;1</span><br><span class="line">$ echo $int</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<h3 id="3-Here-document不为人知的用法"><a href="#3-Here-document不为人知的用法" class="headerlink" title="3. Here document不为人知的用法"></a>3. Here document不为人知的用法</h3><p>Shell学得越多，越会发现一些神奇的用法，每天都觉得自己实在是一个刚入门的菜鸟。</p>
<ol>
<li>Here Document 是在Linux Shell 中的一种特殊的重定向方式，它的基本的形式如下<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmd &lt;&lt; delimiter</span><br><span class="line">  Here Document Content</span><br><span class="line">delimiter</span><br></pre></td></tr></table></figure>
它的作用就是将两个 delimiter 之间的内容(Here Document Content 部分) 传递给cmd 作为输入参数。</li>
<li>比如在终端中输入cat &lt;&lt; EOF ，系统会提示继续进行输入，输入多行信息再输入EOF，中间输入的信息将会显示在屏幕上。如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat &lt;&lt; EOF</span><br><span class="line">&gt;  First Line</span><br><span class="line">&gt; Second Line</span><br><span class="line">&gt; Third Line EOF</span><br><span class="line">&gt; EOF</span><br><span class="line"> First Line</span><br><span class="line">Second Line</span><br><span class="line">Third Line EOF</span><br></pre></td></tr></table></figure>
注⚠️： &gt;这个符号是终端产生的提示输入信息的标识符<br>这里要注意几点</li>
<li>EOF 只是一个标识而已，可以替换成任意的合法字符</li>
<li>作为结尾的delimiter一定要顶格写，前面不能有任何字符</li>
<li>作为结尾的delimiter后面也不能有任何的字符（包括空格）</li>
<li>作为起始的delimiter前后的空格会被省略掉<br>Here Document 不仅可以在终端上使用，在shell 文件中也可以使用，例如下面的here.sh 文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt; EOF &gt; output.sh</span><br><span class="line">echo &quot;hello&quot;</span><br><span class="line">echo &quot;world&quot;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
使用 bash here.sh 运行这个脚本文件，会得到output.sh 这个新文件，里面的内容如下<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;hello&quot;</span><br><span class="line">echo &quot;world&quot;</span><br></pre></td></tr></table></figure></li>
<li>delimiter 与变量<br>在Here Document 的内容中，不仅可以包括普通的字符，还可以在里面使用变量,例如将上面的here.sh改为<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat here.sh</span><br><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">cat &lt;&lt; EOF &gt; output.sh  #没有引号</span><br><span class="line">echo &quot;hello, $USER&quot;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">$ bash here.sh</span><br><span class="line">$ cat output.sh</span><br><span class="line">echo &quot;hello, shuke&quot;</span><br></pre></td></tr></table></figure>
使用bash here.sh HereDocument 运行脚本得到output.sh的内容<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat output.sh</span><br><span class="line">echo &quot;hello $USER&quot;</span><br></pre></td></tr></table></figure>
在这里 $1 被展开成为了脚本的参数 HereDocument<br>但是有时候不想展开这个变量怎么办呢，可以通过在起始的 delimiter的前后添加 “ 来实现,将EOF有引号括起来就可以：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat here.sh</span><br><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">cat &lt;&lt; &quot;EOF&quot;     #注意引号</span><br><span class="line">echo &quot;hello, $USER&quot;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">$ bash here.sh</span><br><span class="line">echo &quot;hello, $USER&quot;</span><br></pre></td></tr></table></figure>
<h3 id="4-«-变为-«"><a href="#4-«-变为-«" class="headerlink" title="4. « 变为 «-"></a>4. « 变为 «-</h3>Here Document 还有一个用法就是将 ‘«’ 变为 ‘«-‘。 使用 &lt;&lt;- 的唯一变化就是Here Document 的内容部分每行前面的 tab (制表符)将会被删除掉，这种用法是为了编写Here Document的时候可以将内容部分进行缩进，方便阅读代码.<br>如果你有强迫症，有时候使用here document的时候会很不爽，因为here document里面每行首部的空格都会被保留，而如果要顶格写，在缩进的地方又会有点打乱结构，例如：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat b.sh</span><br><span class="line"># part 1</span><br><span class="line">if :; then</span><br><span class="line">    cat &lt;&lt; EOF</span><br><span class="line">    hello, $USER    </span><br><span class="line">EOF</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># part 2</span><br><span class="line">if :; then</span><br><span class="line">    if :; then</span><br><span class="line">        cat &lt;&lt; EOF</span><br><span class="line">hello, $USER    </span><br><span class="line">EOF</span><br><span class="line">    fi</span><br></pre></td></tr></table></figure>
上面的脚本执行的结果为：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sh b.sh </span><br><span class="line">    hello, kodango   # part 1 result</span><br><span class="line">hello, kodango       # part 2 result</span><br></pre></td></tr></table></figure>
有没有办法既兼顾到缩进又能不保留行首空格呢？</li>
</ol>
<p>答案也是肯定的，只不过语法又要稍稍变一下，现在在&lt;&lt;的后面加一个短横，这个用法下，行首的Tab字符都会被忽略:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat b.sh </span><br><span class="line">if :; then</span><br><span class="line">    cat &lt;&lt;- EOF</span><br><span class="line">    hello, $USER    </span><br><span class="line">EOF</span><br><span class="line">fi</span><br><span class="line">$ sh b.sh </span><br><span class="line">hello, shuke</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>一定要是Tab键哦，空格也是不可以的，在vim里面还要注意如果设置了smarttab选项，行首插入的Tab键会替换成相应个数的空格(这里可以按ctrl+v tab插入实际的空格)</p>
<h3 id="5-使用内置命令declare显示脚本中定义的函数"><a href="#5-使用内置命令declare显示脚本中定义的函数" class="headerlink" title="5. 使用内置命令declare显示脚本中定义的函数"></a>5. 使用内置命令declare显示脚本中定义的函数</h3><p>declare的-F选项可以列出脚本中定义的函数名称：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat fun.sh</span><br><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function one()</span><br><span class="line">&#123;</span><br><span class="line">    :</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function two()</span><br><span class="line">&#123;</span><br><span class="line">    :</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">declare -F | sed &#39;s&#x2F;declare -f &#x2F;&#x2F;&#39;</span><br><span class="line">shuke@MacBooKPro:&#x2F;tmp</span><br><span class="line">$ bash fun.sh</span><br><span class="line">one</span><br><span class="line">two</span><br></pre></td></tr></table></figure>
<h3 id="6-嵌套函数还可以这么用"><a href="#6-嵌套函数还可以这么用" class="headerlink" title="6. 嵌套函数还可以这么用"></a>6. 嵌套函数还可以这么用</h3><p>Bash中可以嵌套函数定义，即在一个函数中定义另外一个函数，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat fun.sh</span><br><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">function out()</span><br><span class="line">&#123;</span><br><span class="line">    echo &quot;out&quot;</span><br><span class="line"></span><br><span class="line">    function inner() &#123;</span><br><span class="line">        echo &quot;inner&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">inner</span><br><span class="line">out</span><br><span class="line">inner</span><br></pre></td></tr></table></figure>
<p>这里out函数里面定义了inner函数，形成嵌套函数。但是，执行上面的例子会出错（nest.sh: line 12: inner: command not found），这是因为这是后inner函数还没定义。一旦out函数执行之后，inner函数就被定义了。整个例子的执行结果是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ bash fun.sh</span><br><span class="line">fun.sh: line 13: inner: command not found</span><br><span class="line">out</span><br><span class="line">inner</span><br></pre></td></tr></table></figure>
<p>看到这里，你可能会想嵌套函数有什么用？事实上，在大多数情况下，我们基本不会用到嵌套函数。但是它并非一无是处，比如下面的例子就向我们展示了嵌套函数的神奇用法。</p>
<p>假设，我们要定义一个调试函数，同时需要一个开关控制该函数是否输出调试日志，最简单的写法是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function log()</span><br><span class="line">&#123;</span><br><span class="line">    if [ &quot;$verbose&quot; &#x3D; &quot;1&quot; ]; then</span><br><span class="line">        echo &quot;$@&quot;</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它可以完成任务，但是唯一美中不足的是，每次调用该函数都要判断verbose的值是否为1。这时候可以使用嵌套函数来弥补这个不足：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat fun.sh</span><br><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">verbose&#x3D;$&#123;1:-1&#125;</span><br><span class="line"></span><br><span class="line">function log()</span><br><span class="line">&#123;</span><br><span class="line">    if [ $verbose -eq 1 ]; then</span><br><span class="line">        function log() &#123;</span><br><span class="line">            echo &quot;$@&quot;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        echo &quot;$@&quot;</span><br><span class="line">    else</span><br><span class="line">        function log() &#123;</span><br><span class="line">            :</span><br><span class="line">        &#125;</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log what is your name</span><br><span class="line">log my name is shuke</span><br><span class="line"></span><br><span class="line">$ bash fun.sh</span><br><span class="line">what is your name</span><br><span class="line">my name is shuke</span><br></pre></td></tr></table></figure>
<p>上面的例子中，根据verbose的值定义了两个同名的log函数来覆盖之前的旧函数，以后调用的函数就都是后定义的函数了。</p>
<h3 id="7-删除ps-auxf-grep-python结果中的grep进程"><a href="#7-删除ps-auxf-grep-python结果中的grep进程" class="headerlink" title="7. 删除ps auxf | grep python结果中的grep进程"></a>7. 删除ps auxf | grep python结果中的grep进程</h3><p>在shell脚本中，经常需要利用ps和grep命令一起在查找进程相关的信息，尤其是针对python/java/shell等脚本进程，因为pidof本身不大支持查找脚本进程对应的pid。</p>
<p>在用ps auxf | grep python的时候，一个很恼人的事情是，经常会出现多余的grep进程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ps aux | grep python</span><br><span class="line">shuke            76718   0.1  0.5  4341192  42404 s001  S+   12:52下午   0:01.32 &#x2F;Users&#x2F;zhao&#x2F;anaconda3&#x2F;envs&#x2F;sloth&#x2F;bin&#x2F;python manage.py runserver 8000</span><br><span class="line">shuke            76732   0.0  0.0  4284136    884 s003  S+   12:53下午   0:00.00 grep python</span><br><span class="line">shuke            76716   0.0  0.4  4329332  32936 s001  S+   12:52下午   0:00.68 python manage.py runserver 8000</span><br></pre></td></tr></table></figure>
<p>所以我们需要再加一个grep -v grep来排除它。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ps aux | grep python | grep -v grep</span><br><span class="line">shuke            76718   0.1  0.5  4341192  42404 s001  R+   12:52下午   0:02.13 &#x2F;Users&#x2F;zhao&#x2F;anaconda3&#x2F;envs&#x2F;sloth&#x2F;bin&#x2F;python manage.py runserver 8000</span><br><span class="line">shuke            76716   0.0  0.4  4329332  32936 s001  S+   12:52下午   0:00.68 python manage.py runserver 8000</span><br></pre></td></tr></table></figure>
<p>还有一个解决方法是巧用正则表达式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ps aux | grep [p]ython</span><br><span class="line">shuke            76718   0.5  0.5  4341192  42412 s001  S+   12:52下午   0:03.58 &#x2F;Users&#x2F;zhao&#x2F;anaconda3&#x2F;envs&#x2F;sloth&#x2F;bin&#x2F;python manage.py runserver 8000</span><br><span class="line">shuke            76716   0.0  0.4  4329332  32936 s001  S+   12:52下午   0:00.68 python manage.py runserver 8000</span><br></pre></td></tr></table></figure>

<p> 一个很好的解释: shell在执行以上命令的时候，其实创建了一个管道，并且fork了两个子进程：ps auxf与grep python，并且将管道读的这一端绑定到grep的标准输入，管道写的这一段绑定到ps的标准输出。ps将自己的输出写到管道，grep从管道中读取输入。可能在这个时候，ps与grep是同时执行的，所以ps的结果中也会包含grep进程的信息。</p>
<h3 id="8-Shell如何实现timeout功能"><a href="#8-Shell如何实现timeout功能" class="headerlink" title="8. Shell如何实现timeout功能"></a>8. Shell如何实现timeout功能</h3><p> 有时候我们不希望某个命令执行太久，所以如果在给定的时间内没有完成，能够杀掉这个命令对应的进程，这就是timeout功能，可惜bash没有提供该功能。所以就得我们自己来实现。</p>
<p>实现代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function timeout()</span><br><span class="line">&#123;</span><br><span class="line">    local time cmd pid</span><br><span class="line"></span><br><span class="line">    if echo &quot;$1&quot; | grep -Eq &#39;^[0-9]+&#39;; then</span><br><span class="line">        time&#x3D;$1</span><br><span class="line">        shift &amp;&amp; cmd&#x3D;&quot;$@&quot;</span><br><span class="line">    else</span><br><span class="line">        time&#x3D;5</span><br><span class="line">        cmd&#x3D;&quot;$@&quot;</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    $cmd &amp;</span><br><span class="line">    pid&#x3D;$!</span><br><span class="line"></span><br><span class="line">    while kill -0 $pid &amp;&gt;&#x2F;dev&#x2F;null; do</span><br><span class="line">        sleep 1</span><br><span class="line">        let time-&#x3D;1</span><br><span class="line"></span><br><span class="line">        if [ &quot;$time&quot; &#x3D; &quot;0&quot; ]; then</span><br><span class="line">            kill -9 $pid &amp;&gt;&#x2F;dev&#x2F;null</span><br><span class="line">            wait $pid &amp;&gt;&#x2F;dev&#x2F;null</span><br><span class="line">        fi</span><br><span class="line">    done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设有一个测试脚本,内容如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat sleep.sh</span><br><span class="line">echo &quot;sleep $1 seconds&quot;</span><br><span class="line">sleep $1</span><br><span class="line">echo &quot;awake from sleep&quot;</span><br></pre></td></tr></table></figure>
<p>现在利用我们写的timeout函数来达到超时kill功能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ time bash timeout.sh 2 &#39;sh sleep.sh 100&#39;</span><br><span class="line">sleep 100 seconds</span><br><span class="line"></span><br><span class="line">real    0m2.005s</span><br><span class="line">user    0m0.002s</span><br><span class="line">sys    0m0.001s</span><br></pre></td></tr></table></figure>
<p>看最终执行的时间，差不多就是2秒钟。<br>上面timeout函数实现的代码中，利用了两个技巧：</p>
<ol>
<li>kill -0 $pid：发送信号0给进程，可以检查进程是否存活，如果进程不存在或者没有权限，则返回错误，错误码为1；</li>
<li>wait $pid &amp;&gt;/dev/null：等待某个进程退出返回，这样相对比较优雅，同时将错误重定向到黑洞，从而隐藏后台进程被kill的错误输出；<h3 id="9-利用-etc-inittab实现watchdog"><a href="#9-利用-etc-inittab实现watchdog" class="headerlink" title="9. 利用/etc/inittab实现watchdog"></a>9. 利用/etc/inittab实现watchdog</h3>还在为实现watch dog而头疼吗，其实inittab中已经包含了该功能。可以将自己的脚本或者程序写到inittab文件中：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tt:2345:respawn:&#x2F;home&#x2F;kodango&#x2F;sleep.sh 100</span><br></pre></td></tr></table></figure>
然后执行telinit q使其生效，ps看下该脚本是否已经在运行了，尝试kill后，又会被起起来。</li>
</ol>
<h3 id="10-慎用波浪号展开"><a href="#10-慎用波浪号展开" class="headerlink" title="10. 慎用波浪号展开"></a>10. 慎用波浪号展开</h3><p>在shell中对比下面两种用法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ home1&#x3D;~shuke</span><br><span class="line">$ home2&#x3D;&quot;~shuke&quot;</span><br><span class="line">$ echo -e &quot;$home1\n$home2&quot;</span><br><span class="line">&#x2F;Users&#x2F;zhao</span><br><span class="line">~shuke</span><br></pre></td></tr></table></figure>
<p>第一个变量赋值，波浪号正确展开，所以我们得到了kodango用户的家目录地址；第二个变量，我们使用了双引号，这个时候波波浪号并没有展开。这是一个比较容易出错的地方。</p>
<p>还有一点要注意的地方是，波浪号展开只在:或者=号后面才会执行。所以：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ path&#x3D;1~shuke</span><br><span class="line">$ echo &quot;$path&quot;</span><br><span class="line">1~shuke</span><br><span class="line"></span><br><span class="line">$ path&#x3D;1:~shuke</span><br><span class="line">$ echo &quot;$path&quot;</span><br><span class="line">1:&#x2F;Users&#x2F;shuke</span><br></pre></td></tr></table></figure>
<p>为什么要在:后面也可以展开呢？想想PATH的定义吧。</p>
<h3 id="11-pushd-popd"><a href="#11-pushd-popd" class="headerlink" title="11. pushd/popd"></a>11. pushd/popd</h3><p>这个在脚本中非常好用，特别是在循环中<br>如下所示，假设你正在写一个进入退出文件夹的for循环：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for d1 in $(ls -d *&#x2F;)</span><br><span class="line">do</span><br><span class="line"> # Store original working directory.</span><br><span class="line"> original_wd&#x3D;&quot;$(pwd)&quot;</span><br><span class="line"> cd &quot;$d1&quot;</span><br><span class="line"> for d2 in $(ls -d *&#x2F;)</span><br><span class="line"> do</span><br><span class="line">   pushd &quot;$d2&quot;</span><br><span class="line">   # Do something</span><br><span class="line">   popd</span><br><span class="line"> done</span><br><span class="line"> # Return to original working directory</span><br><span class="line"> cd &quot;$&#123;original_wd&#125;&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>


<p>你可以像这样使用pushd栈来重写上方代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for d1 in $(ls -d *)</span><br><span class="line">do</span><br><span class="line"> pushd &quot;$d1&quot;</span><br><span class="line"> for d2 in $(ls  -d *&#x2F;)</span><br><span class="line"> do</span><br><span class="line">   pushd &quot;$d2&quot;</span><br><span class="line">   # Do something</span><br><span class="line">   popd</span><br><span class="line"> done</span><br><span class="line"> popd</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>它可以追踪记录你切换的目录并进行入栈或出栈<br>注意，当使用pushd出现错误时，可能会丢失栈的记录并且popd多次。因此你可能会想要在脚本中使用set -e（见上一篇文章）</p>
<p>当然也可以用cd -，但是它不会使用栈——仅仅返回前一个目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~</span><br><span class="line">cd &#x2F;tmp</span><br><span class="line">cd blah</span><br><span class="line">cd - # Back to &#x2F;tmp</span><br><span class="line">cd - # Back to &#39;blah&#39;</span><br><span class="line">cd - # Back to &#x2F;tmp</span><br><span class="line">cd - # Back to &#39;blah&#39; ...</span><br></pre></td></tr></table></figure>

<h3 id="12-shopt-vs-set"><a href="#12-shopt-vs-set" class="headerlink" title="12.shopt vs set"></a>12.shopt vs set</h3><p>这两个命令困扰了我一阵子。<br>两者之间有什么不同呢？<br>set在之前的文章已经介绍过了，而shopt看起来与之相似。只输入shopt会显示一系列选项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ shopt</span><br><span class="line">cdable_vars    off</span><br><span class="line">cdspell        on</span><br><span class="line">checkhash      off</span><br><span class="line">checkwinsize   on</span><br><span class="line">cmdhist        on</span><br><span class="line">compat31       off</span><br><span class="line">dotglob        off</span><br></pre></td></tr></table></figure>
<p>从根本上说，似乎有一系列的bash（和其他shells）建立在sh之上，而添加shopt命令则为设置额外的shell选项提供了一种方式</p>
<h3 id="13-Here-Docs-与-Here-Strings"><a href="#13-Here-Docs-与-Here-Strings" class="headerlink" title="13. Here Docs 与 Here Strings"></a>13. Here Docs 与 Here Strings</h3><p>“Here Docs”是在shell中用一些语句创建的文件。</p>
<p>“诀窍”很简单。定义一个用于结束的单词，则在这个单词单独出现在一行之前的所有输入行将构成文件。</p>
<p>像这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat &gt; afile &lt;&lt; SOMEENDSTRING</span><br><span class="line">&gt; here is a doc</span><br><span class="line">&gt; it has three lines</span><br><span class="line">&gt; SOMEENDSTRING alone on a line will save the doc</span><br><span class="line">&gt; SOMEENDSTRING</span><br><span class="line">$ cat afile</span><br><span class="line">here is a doc</span><br><span class="line">it has three lines</span><br><span class="line">SOMEENDSTRING alone on a line will save the doc</span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>如果结束单词不是“单独”出现在一行中，那它可以构成文件</li>
<li>SOMEENDSTRING通常是END，但这仅仅只是习惯<br>更鲜为人知的是”here string”:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat &gt; asd &lt;&lt;&lt; &#39;This file has one line&#39;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="14-字符串变量的操作"><a href="#14-字符串变量的操作" class="headerlink" title="14. 字符串变量的操作"></a>14. 字符串变量的操作</h3><p>以前你可能是像下面展示的那样写代码，用sed一类的工具来操作字符串：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ VAR&#x3D;&#39;HEADERMy voice is my passwordFOOTER&#39;</span><br><span class="line">$ PASS&#x3D;&quot;$(echo $VAR | sed &#39;s&#x2F;^HEADER(.*)FOOTER&#x2F;1&#x2F;&#39;)&quot;</span><br><span class="line">$ echo $PASS</span><br></pre></td></tr></table></figure>
<p>但是你可能不知道bash本身也是可以的。<br>这意味着你可以省去大量的sed和awk。<br>一种重写上述代码的方式如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ VAR&#x3D;&#39;HEADERMy voice is my passwordFOOTER&#39;</span><br><span class="line">$ PASS&#x3D;&quot;$&#123;VAR#HEADER&#125;&quot;</span><br><span class="line">$ PASS&#x3D;&quot;$&#123;PASS%FOOTER&#125;&quot;</span><br><span class="line">$ echo $PASS</span><br></pre></td></tr></table></figure>
<ul>
<li>#表示”从字符串开头开始匹配并删除所给的模式串”</li>
<li>%表示”从字符串结尾开始匹配并删除所给的模式串”</li>
</ul>
<p>在我的电脑上，后一种方法比前一种快两倍。并且(令我吃惊的是),他的速度跟类似功能的python脚本速度大致相当<br>如果你想使用通配符（见前文）模式串并采用贪婪模式，你需要双写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ VAR&#x3D;&#39;HEADERMy voice is my passwordFOOTER&#39;</span><br><span class="line">$ echo $&#123;VAR##HEADER*&#125;</span><br><span class="line">$ echo $&#123;VAR%%*FOOTER&#125;</span><br></pre></td></tr></table></figure>

<h3 id="15-变量的默认值"><a href="#15-变量的默认值" class="headerlink" title="15.变量的默认值"></a>15.变量的默认值</h3><p>这些对写脚本来说非常好用。<br>如果你有一个没有赋值的变量，你可以像这样给它“赋默认值”<br>创建一个default.sh文件，写入如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">FIRST_ARG&#x3D;&quot;$&#123;1:-no_first_arg&#125;&quot;</span><br><span class="line">SECOND_ARG&#x3D;&quot;$&#123;2:-no_second_arg&#125;&quot;</span><br><span class="line">THIRD_ARG&#x3D;&quot;$&#123;3:-no_third_arg&#125;&quot;</span><br><span class="line">echo $&#123;FIRST_ARG&#125;</span><br><span class="line">echo $&#123;SECOND_ARG&#125;</span><br><span class="line">echo $&#123;THIRD_ARG&#125;</span><br></pre></td></tr></table></figure>

<p>现在执行chmod +x default.sh并用./default.sh first second来运行脚本：<br>观察第三个参数的默认值是如何被分配的，而不是前两个。<br>你也可以直接用${VAR:=defaultval}(等号，不是破折号)，但是注意这不适用于脚本或函数中的位置变量。尝试修改上面的脚本来看它是如何失败的。</p>
<h3 id="16-Traps"><a href="#16-Traps" class="headerlink" title="16. Traps"></a>16. Traps</h3><p>当一个信号被送到脚本时，内建的trap可以用于“捕获”<br>下面是我用在自己的chepci脚本中的一个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function cleanup() &#123;</span><br><span class="line">   rm -rf &quot;$&#123;BUILD_DIR&#125;&quot;</span><br><span class="line">   rm -f &quot;$&#123;LOCK_FILE&#125;&quot;</span><br><span class="line">   # get rid of &#x2F;tmp detritus, leaving anything accessed 2 days ago+</span><br><span class="line">   find &quot;$&#123;BUILD_DIR_BASE&#125;&quot;&#x2F;* -type d -atime +1 | rm -rf</span><br><span class="line">   echo &quot;cleanup done&quot;                                                     &#125;</span><br><span class="line">trap cleanup TERM INT QUIT</span><br></pre></td></tr></table></figure>
<p>任何使用TERM信号的CTRL-C,CTRL-或终止程序的操作将会首先调用cleanup<br>⚠️ 注意：</p>
<ul>
<li>trap的逻辑可能非常棘手（例如处理信号竞争条件）</li>
<li>KILL信号不能以这种方式捕获<br>但是大多数情况下，我会把它用于类似上述的‘cleanup’中，来达成函数的目的。</li>
</ul>
<h3 id="17-Shell变量"><a href="#17-Shell变量" class="headerlink" title="17. Shell变量"></a>17. Shell变量</h3><p>了解可用的标准shell变量是非常值得的。这些是我最喜欢的。<br>RANDOM<br>不要依赖这个来加密堆栈，但你可以生成随机数字，例如在脚本中创建临时文件时：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ echo $&#123;RANDOM&#125;</span><br><span class="line">16313</span><br><span class="line">$ # Not enough digits?</span><br><span class="line">$ echo $&#123;RANDOM&#125;$&#123;RANDOM&#125;</span><br><span class="line">113610703</span><br><span class="line">$ NEWFILE&#x3D;&#x2F;tmp&#x2F;newfile_$&#123;RANDOM&#125;</span><br><span class="line">$ touch $NEWFILE</span><br></pre></td></tr></table></figure>

<p>REPLY<br>不在需要给read一个变量名称</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ read</span><br><span class="line">my input</span><br><span class="line">$ echo $&#123;REPLY&#125;</span><br></pre></td></tr></table></figure>

<p>LINENO 与 SECONDS<br>方便调试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ echo $&#123;LINENO&#125;</span><br><span class="line">115</span><br><span class="line">$ echo $&#123;SECONDS&#125;; sleep 1; echo $&#123;SECONDS&#125;; echo $LINENO</span><br><span class="line">174380</span><br><span class="line">174381</span><br><span class="line">116</span><br></pre></td></tr></table></figure>
<p>注意，即便使用;来隔开命令，上面的代码也要分两行</p>
<p>TMOUT<br>可以用来超时读取，在一些脚本中真的很好用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">TMOUT&#x3D;5</span><br><span class="line">echo You have 5 seconds to respond...</span><br><span class="line">read</span><br><span class="line">echo $&#123;REPLY:-noreply&#125;</span><br></pre></td></tr></table></figure>

<p>Extglobs</p>
<p>如果你真的沉迷bash不能自拔，那么你可能想要增强你的通配功能。你可以通过设置shell中的extglob选项。这是设置方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shopt -s extglob</span><br><span class="line">A&#x3D;&quot;12345678901234567890&quot;</span><br><span class="line">B&#x3D;&quot;  $&#123;A&#125;  &quot;</span><br></pre></td></tr></table></figure>

<p>现在来看看你是否能指出以下这些语句各自的功能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;B      |$&#123;B&#125;|&quot;</span><br><span class="line">echo &quot;B#+( ) |$&#123;B#+( )&#125;|&quot;</span><br><span class="line">echo &quot;B#?( ) |$&#123;B#?( )&#125;|&quot;</span><br><span class="line">echo &quot;B#*( ) |$&#123;B#*( )&#125;|&quot;</span><br><span class="line">echo &quot;B##+( )|$&#123;B##+( )&#125;|&quot;</span><br><span class="line">echo &quot;B##*( )|$&#123;B##*( )&#125;|&quot;</span><br><span class="line">echo &quot;B##?( )|$&#123;B##?( )&#125;|&quot;</span><br></pre></td></tr></table></figure>
<p>虽然它可能很有用，但是很难想象出一种你必须要用这种方式的情况。通常你会使用一些更适合相应任务的工具（像sed）或者直接放弃bash去使用一些像python那样的“合适的”编程语言。</p>
<h3 id="18-关联数组"><a href="#18-关联数组" class="headerlink" title="18.关联数组"></a>18.关联数组</h3><p>谈到移植到其他语言，一条重要的规则是，如果我需要用到数组，那么我会放弃bash，使用python（为此我甚至创建了一个Docker Container来运行一个专门的工具）</p>
<p>知道读到它我才知道，在bash中有关联数组</p>
<p>以下是演示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ declare -A MYAA&#x3D;([one]&#x3D;1 [two]&#x3D;2 [three]&#x3D;3)</span><br><span class="line">$ MYAA[one]&#x3D;&quot;1&quot;</span><br><span class="line">$ MYAA[two]&#x3D;&quot;2&quot;</span><br><span class="line">$ echo $MYAA</span><br><span class="line">$ echo $&#123;MYAA[one]&#125;</span><br><span class="line">$ MYAA[one]&#x3D;&quot;1&quot;</span><br><span class="line">$ WANT&#x3D;two</span><br><span class="line">$ echo $&#123;MYAA[$WANT]&#125;</span><br></pre></td></tr></table></figure>
<p>注意仅适用于bash4.x+版本</p>
<h3 id="19-实用的shell文章"><a href="#19-实用的shell文章" class="headerlink" title="19. 实用的shell文章"></a>19. 实用的shell文章</h3><p><a href="http://mywiki.wooledge.org/BashPitfalls?spm=a2c4e.11153959.blogcont68524.18.4dbf3d2foIG0jZ" target="_blank" rel="noopener">BashPitfalls - Greg’s Wiki</a><br><a href="http://mywiki.wooledge.org/ProcessManagement?spm=a2c4e.11153959.blogcont68524.19.4dbf3d2foIG0jZ" target="_blank" rel="noopener">ProcessManagement - Greg’s Wiki</a><br><a href="http://mywiki.wooledge.org/BashGuide?spm=a2c4e.11153959.blogcont68524.20.4dbf3d2foIG0jZ" target="_blank" rel="noopener">BashGuide - Greg’s Wiki</a><br><a href="http://mywiki.wooledge.org/BashFAQ?spm=a2c4e.11153959.blogcont68524.21.4dbf3d2foIG0jZ" target="_blank" rel="noopener">BashFAQ - Greg’s Wiki</a></p>
<p><a href="https://yq.aliyun.com/articles/68524?spm=a2c4e.11153959.teamhomeleft.136.7e4c8bc1kg1JeI" target="_blank" rel="noopener">原文参考地址</a></p>
<p><a href="https://yq.aliyun.com/articles/72012?spm=a2c4e.11153959.teamhomeleft.10.7e4c8bc1kg1JeI" target="_blank" rel="noopener">Sed&amp;awk笔记系列-博客</a></p>
]]></content>
      <categories>
        <category>SHELL</category>
      </categories>
      <tags>
        <tag>SHELL</tag>
      </tags>
  </entry>
  <entry>
    <title>简洁的Bash Programming技巧(三)</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h2 id="简洁的Bash-Programming技巧-一"><a href="#简洁的Bash-Programming技巧-一" class="headerlink" title="简洁的Bash Programming技巧(一)"></a>简洁的Bash Programming技巧(一)</h2><h3 id="1-bash中alias的使用"><a href="#1-bash中alias的使用" class="headerlink" title="1. bash中alias的使用"></a>1. bash中alias的使用</h3><p>alias其实是给常用的命令定一个别名，比如很多人会定义一下的一个别名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alias ll&#x3D;&#39;ls -l&#39;</span><br></pre></td></tr></table></figure>
<p>以后就可以使用ll，实际展开后执行的是ls -l。现在很多发行版都会带几个默认的别名，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alias grep&#x3D;&#39;grep --color&#x3D;auto&#39;  # 带颜色显示</span><br><span class="line">alias ls&#x3D;&#39;ls --color&#x3D;auto&#39; # 同上</span><br><span class="line">alias rm&#x3D;&#39;rm -i&#39;  # 删除文件需要确认</span><br></pre></td></tr></table></figure>
<p>alias在某些方面确实提高了很大的效率，但是也是有隐患的，这点可以看我以前的一篇文章终端下肉眼看不见的东西。那么如何不要展开alias，而是用本来的意思呢？答案是使用转义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\ls</span><br><span class="line">\grep</span><br></pre></td></tr></table></figure>
<p>在命令前面加一个反斜杠后就可以了。 这里要插一段故事，前两天我在shell脚本中定义了下面的一个alias，假设位于文件util.sh：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">alias ssh&#x3D;&#39;ssh -o StrictHostKeyChecking&#x3D;no -o LogLevel&#x3D;quiet -o BatchMode&#x3D;yes&#39;</span><br></pre></td></tr></table></figure>
<p>后面这串ssh选项是为了去掉一些warning的信息，不提示输入密码等等。具体可以看ssh的文档说明。我自己测试的时候好好的，当时我同事跑得时候却依然有报Warning。我对比了下我们两个人的用法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh util.sh  # 方式一</span><br><span class="line">.&#x2F;util.sh   # 方式二</span><br></pre></td></tr></table></figure>
<p>大家应该知道，直接./util.sh执行，shell会去找脚本第一行的shebang中给定的解释器去执行改脚本，所以第二种用法相当于直接用bash来执行。那想必是bash/sh对alias是否默认展开这一点上是有区别的了。翻阅了下Bash的man手册，发现可以通过设置expand_aliases选项来打开alias展开的功能，默认在非交互式Shell下是关闭的（什么是交互式登录Shell)<br>修改下util.sh，打开这个选项就Ok了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"># Expand aliases in script</span><br><span class="line">shopt -s expand_aliases</span><br><span class="line">alias ssh&#x3D;&#39;ssh -o StrictHostKeyChecking&#x3D;no -o LogLevel&#x3D;quiet -o BatchMode&#x3D;yes&#39;</span><br></pre></td></tr></table></figure>

<h3 id="2-awk打印除第一列之外的其他列"><a href="#2-awk打印除第一列之外的其他列" class="headerlink" title="2. awk打印除第一列之外的其他列"></a>2. awk打印除第一列之外的其他列</h3><p>awk用来截取输入行中的某几列很有用，当时如果要排除某几列呢？ 例如有如下的一个文件:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat &#x2F;tmp&#x2F;test.txt</span><br><span class="line">1 2 3 4 5</span><br><span class="line">10 20 30 40 50</span><br></pre></td></tr></table></figure>
<p>可以用下面的代码解决:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &#39;&#123;$1&#x3D;&quot;&quot;;print $0&#125;&#39; &#x2F;tmp&#x2F;test.txt</span><br><span class="line"> 2 3 4 5</span><br><span class="line"> 20 30 40 50</span><br></pre></td></tr></table></figure>
<p>但是前面多了一个空格，可以用cut命令稍微调整下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ awk &#39;&#123;$1&#x3D;&quot;&quot;;print $0&#125;&#39; &#x2F;tmp&#x2F;test.txt | cut -c2-</span><br><span class="line">2 3 4 5</span><br><span class="line">20 30 40 50</span><br></pre></td></tr></table></figure>

<h3 id="3-巧用bash的命令展开功能备份文件"><a href="#3-巧用bash的命令展开功能备份文件" class="headerlink" title="3. 巧用bash的命令展开功能备份文件"></a>3. 巧用bash的命令展开功能备份文件</h3><p>假设要备份文件/your/path/to/file.list为/your/path/to/file.list.20121106，常规的方法是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp &#x2F;your&#x2F;path&#x2F;to&#x2F;file.list &#x2F;your&#x2F;path&#x2F;to&#x2F;file.list.20121106</span><br></pre></td></tr></table></figure>
<p>这样重复写上一长串的路径，是不是很麻烦，这里利用bash的展开特性可以这样做：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp &#x2F;your&#x2F;path&#x2F;to&#x2F;file.list&#123;,.20180406&#125;</span><br></pre></td></tr></table></figure>
<p>/your/path/to/file.list{,.20121106}这一部分会展开为/your/path/to/file.list /your/path/to/file.list.20121106,再将此传给cp命令，就达到了与前面同样的效果。（思路同ls *）。具体可以man bash中的Brace Expansion这一段。</p>
<h3 id="4-你知道sed的这个特性吗？"><a href="#4-你知道sed的这个特性吗？" class="headerlink" title="4. 你知道sed的这个特性吗？"></a>4. 你知道sed的这个特性吗？</h3><p>假设一个文件的每一行为一个路径：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat &#x2F;tmp&#x2F;test.txt</span><br><span class="line">&#x2F;home&#x2F;kodango&#x2F;hello</span><br><span class="line">&#x2F;home&#x2F;kodango&#x2F;hello&#x2F;world</span><br><span class="line">&#x2F;home&#x2F;kodango&#x2F;good</span><br><span class="line">&#x2F;home&#x2F;kodango&#x2F;good&#x2F;bye</span><br></pre></td></tr></table></figure>
<p>现在要把/home/kodango/good替换成/home/kodango/bad，普通的作法是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sed -n &#39;s&#x2F;\&#x2F;home\&#x2F;kodango\&#x2F;good&#x2F;\&#x2F;home\&#x2F;kodango\&#x2F;bye&#x2F;p&#39; &#x2F;tmp&#x2F;test.txt </span><br><span class="line">&#x2F;home&#x2F;kodango&#x2F;bye</span><br><span class="line">&#x2F;home&#x2F;kodango&#x2F;bye&#x2F;bye</span><br></pre></td></tr></table></figure>
<p>因为路径中的分隔符与sed的替换命令的分隔符都是’/‘，所以需要转义，非常麻烦。幸运的是，sed可以更改分隔符，例如使用#：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed -n &#39;s#&#x2F;home&#x2F;kodango&#x2F;good#&#x2F;home&#x2F;kodango&#x2F;bad#p&#39; &#x2F;tmp&#x2F;test.txt </span><br><span class="line">&#x2F;home&#x2F;kodango&#x2F;bad</span><br><span class="line">&#x2F;home&#x2F;kodango&#x2F;bad&#x2F;bye</span><br></pre></td></tr></table></figure>
<p>这样就清爽多了。 补充，如果是在地址对中使用，首个分隔符前面要加反斜杠：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sed -n &#39;\#&#x2F;home&#x2F;kodango&#x2F;#p&#39; &#x2F;tmp&#x2F;test.txt </span><br><span class="line">&#x2F;home&#x2F;kodango&#x2F;hello</span><br><span class="line">&#x2F;home&#x2F;kodango&#x2F;hello&#x2F;world</span><br><span class="line">&#x2F;home&#x2F;kodango&#x2F;good</span><br><span class="line">&#x2F;home&#x2F;kodango&#x2F;good&#x2F;bye</span><br></pre></td></tr></table></figure>

<h3 id="5-合并连续重复的字符（即squeeze操作）"><a href="#5-合并连续重复的字符（即squeeze操作）" class="headerlink" title="5. 合并连续重复的字符（即squeeze操作）"></a>5. 合并连续重复的字符（即squeeze操作）</h3><p>例如要合并一个字符串中连续的多个空格，假设字符串为’print hello, world’。 第一种方法，使用sed命令，扫描整个字符串，替换2个以上的空格为1格:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ echo &#39;print  hello,   world  &#39; | sed -r &#39;s&#x2F; &#123;2,&#125;&#x2F; &#x2F;g&#39;</span><br><span class="line">print hello, world</span><br></pre></td></tr></table></figure>
<p>第二种方法，使用tr命令的-s选项，专门就是为了合并连续重复的字符：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ echo &#39;print  hello,   world  &#39; | tr -s &#39; &#39;</span><br><span class="line">print hello, world</span><br></pre></td></tr></table></figure>
<p>第三种方法，使用awk的域赋值来完成该目的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ echo &#39;print  hello,   world  &#39; | awk &#39;$1&#x3D;$1&#39;</span><br><span class="line">print hello, world</span><br></pre></td></tr></table></figure>

<h3 id="6-将文本中某列相同的行输出到不同的文件中"><a href="#6-将文本中某列相同的行输出到不同的文件中" class="headerlink" title="6. 将文本中某列相同的行输出到不同的文件中"></a>6. 将文本中某列相同的行输出到不同的文件中</h3><p>标题有点绕口，我们以实际例子来讲解，假设我们有以下的一个文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat &#x2F;tmp&#x2F;test.txt</span><br><span class="line">a char</span><br><span class="line">1 int</span><br><span class="line">2 int</span><br><span class="line">b char</span><br><span class="line">abc string</span><br></pre></td></tr></table></figure>
<p>我们的目标是将该文本中的行按第二列的值归类，并且输出到相应的文件中，文件名为第二列的名称。例如第2行、第3行会输出到int.txt文件中，而第1行、第4行则输出到char.txt，以此类推。</p>
<p>我没有找到其它简单的方法，只找到一种用awk来处理的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">awk &#39;&#123;print $1 &gt; $2 &quot;.txt&quot;&#125;&#39; &#x2F;tmp&#x2F;test.txt</span><br></pre></td></tr></table></figure>
<p>我们来检查结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep -nH . *</span><br><span class="line">char.txt:1:a</span><br><span class="line">char.txt:2:b</span><br><span class="line">int.txt:1:1</span><br><span class="line">int.txt:2:2</span><br><span class="line">string.txt:1:abc</span><br></pre></td></tr></table></figure>
<h3 id="7-用exec命令来完成重定向"><a href="#7-用exec命令来完成重定向" class="headerlink" title="7. 用exec命令来完成重定向"></a>7. 用exec命令来完成重定向</h3><p>以一个简单的例子开始，现在需要一个脚本，它可以接受一个文件名作为参数，然后按行读取该文件的内容并打印到标准输出。如果不指定文件名，则默认从标准输入读。首先按上面的功能需求写出一个可以完成功能的脚本:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat test.sh </span><br><span class="line"></span><br><span class="line">filename&#x3D;$1</span><br><span class="line"></span><br><span class="line">if [ -z &quot;$filename&quot; ]; then</span><br><span class="line">    while read line; do</span><br><span class="line">        echo $line</span><br><span class="line">    done</span><br><span class="line">else</span><br><span class="line">    while read line; do</span><br><span class="line">        echo $line</span><br><span class="line">    done &lt; $filename</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>如果换exec来实现重定向，可以把脚本写得更优雅：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat test1.sh </span><br><span class="line"></span><br><span class="line">filename&#x3D;$1</span><br><span class="line"></span><br><span class="line">if [ -n &quot;$filename&quot; ]; then</span><br><span class="line">    exec 0&lt; $filename</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">while read line; do</span><br><span class="line">    echo $line</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>这里的关键在第5行代码，exec命令不仅可以用于执行命令，还可以用于打开、关闭或者复制文件描述符，这里就是利用exec将指定的文件名打开重定向到标准输入。类似地可以用exec &gt;$filename将文件重定向到标准输出。我们可以在命令行上做一个试验：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ exec 3&gt;&amp;1                   # 首先将fd 3重定向到标准输出，作为标准输出的一个备份</span><br><span class="line"></span><br><span class="line">$ ls &#x2F;proc&#x2F;629&#x2F;fd&#x2F;&#123;1,3&#125; -l    # 现在fd 3和fd 1指向同一个设备文件</span><br><span class="line">lrwx------ 1 kodango kodango 64 Nov 10 00:26 &#x2F;proc&#x2F;629&#x2F;fd&#x2F;1 -&gt; &#x2F;dev&#x2F;pts&#x2F;1</span><br><span class="line">lrwx------ 1 kodango kodango 64 Nov 10 00:26 &#x2F;proc&#x2F;629&#x2F;fd&#x2F;3 -&gt; &#x2F;dev&#x2F;pts&#x2F;1</span><br><span class="line"></span><br><span class="line">$ exec &gt;stdout               # 现在把标准输出重定向到stdout这个文件中</span><br><span class="line"></span><br><span class="line">$ ls &#x2F;proc&#x2F;629&#x2F;fd&#x2F;1 -l        # 如果你此刻在同一个终端下执行本命令是没有返回的</span><br><span class="line"></span><br><span class="line">$ ls &#x2F;proc&#x2F;629&#x2F;fd&#x2F;1 -l        # 现在重新打开一个终端看看，确实已经重定向到stdout这个文件</span><br><span class="line">l-wx------ 1 kodango kodango 64 Nov 10 00:26 &#x2F;proc&#x2F;629&#x2F;fd&#x2F;1 -&gt; &#x2F;home&#x2F;kodango&#x2F;stdout</span><br><span class="line"></span><br><span class="line">$ exec 1&gt;&amp;3                   # 现在重新把标准输出重定向到之前备份的fd 3上</span><br><span class="line">$ ls &#x2F;proc&#x2F;629&#x2F;fd&#x2F;&#123;1,3&#125; -l  # 现在屏幕可以看到输出了，但是fd 3这个描述符还打开，需要关闭</span><br><span class="line">lrwx------ 1 kodango kodango 64 Nov 10 00:26 &#x2F;proc&#x2F;629&#x2F;fd&#x2F;1 -&gt; &#x2F;dev&#x2F;pts&#x2F;1</span><br><span class="line">lrwx------ 1 kodango kodango 64 Nov 10 00:26 &#x2F;proc&#x2F;629&#x2F;fd&#x2F;3 -&gt; &#x2F;dev&#x2F;pts&#x2F;1</span><br><span class="line"></span><br><span class="line">$ exec 3&gt;&amp;-                   # 关闭fd 3</span><br><span class="line">$ ls &#x2F;proc&#x2F;629&#x2F;fd&#x2F;3 -l</span><br><span class="line">ls: cannot access &#x2F;proc&#x2F;629&#x2F;fd&#x2F;3: No such file or directory</span><br><span class="line"></span><br><span class="line">$ cat stdout                  # 检查stdout文件，确实有之前被吃掉的输出</span><br><span class="line">l-wx------ 1 kodango kodango 64 Nov 10 00:26 &#x2F;proc&#x2F;629&#x2F;fd&#x2F;1 -&gt; &#x2F;home&#x2F;kodango&#x2F;stdout</span><br></pre></td></tr></table></figure>
<p>这一点在while read; do xxx; done &lt; file内部仍需要从标准输入读取内容时非常有用，此时必须要将循环外部的重定向和内部的剥离开来。</p>
<h3 id="8-引号之间的区别"><a href="#8-引号之间的区别" class="headerlink" title="8. 引号之间的区别"></a>8. 引号之间的区别</h3><p>Shell中比较让人抓狂的是各种引号的处理，其中，反引号(cmd)是最容易掌握的，它其实和$(cmd)是差不多的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">引号的作用有几点，一个是为了将多个因为空格或者回车等分隔符隔开的字符串合在一起，避免被命令行解析分开，例如&quot;one two three&quot;就是一整个字符串，而不是像one two three会被解析成三个单独的字符串；另外一方面，引号可以让一些特殊符号保持原义。</span><br><span class="line"></span><br><span class="line">其中，单引号的处理是比较简单的，被单引号包括的所有字符都保留原有的意思，例如&#39;$a&#39;不会被展开, &#39;cmd&#39;也不会执行命令；而双引号，则相对比较松，在双引号中，以下几个字符$, , \依然有其特殊的含义，比如$可以用于变量展开, 反引号可以执行命令，反斜杠可以用于转义。但是，在双引号包围的字符串里，反斜杠的转义也是有限的，它只能转义$, &#96;, &quot;, 或者newline（回车）这几个字符，后面如果跟着的不是这几个字符，只不会被黑底，反斜杠会被保留，例如：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ echo &quot;\$,\&quot;,\&#96;,\&#39;,\t&quot;</span><br><span class="line">$,&quot;,&#96;,\&#39;,\t</span><br></pre></td></tr></table></figure>
<p>到此为止，其实双引号和单引号的区别已经说得差不多了。不过还可以再说几个特殊的用法，前面说过可以在双引号内部使用单引号，你有想过在单引号里面使用单引号吗？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ echo &#39;\&#39;&#39;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
<p>是不是发现不能用，因为单引号中反斜杠是没有转义的效果的，任何字符都没有特殊的含义。那就没有办法了吗？方法总是有的，可以在第一个单引号前面加个$符号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ echo $&#39;\&#39;&#39;</span><br><span class="line">&#39;</span><br></pre></td></tr></table></figure>

<h3 id="9-特殊用法-’string’"><a href="#9-特殊用法-’string’" class="headerlink" title="9. 特殊用法$’string’"></a>9. 特殊用法$’string’</h3><p>前面一点中已经介绍了 $’string’这种用法，比如 $’’’，之所以可以这样用，通俗地讲，就是在这种语法里一些转义字符串是被认可的，事实上有效地的转义底字符串列表可以看这里，例如b，’,n,f,nnn,xhh等等，是不是很熟悉。 $’string’的这个特性，其实为我们提供了一种很有用的技巧：</p>
<p>$ echo $’\x41’<br>A<br>他可以将ASCII对应的字符赋值给某个变量或者输出。</p>
<h3 id="10-用双引号比不用更加安全"><a href="#10-用双引号比不用更加安全" class="headerlink" title="10. 用双引号比不用更加安全"></a>10. 用双引号比不用更加安全</h3><p>双引号除了前面第10点讲到的去除特殊涵义的作用外，还可以避免字符串被分隔解析，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ echo &#96;ls -l&#96;</span><br><span class="line">total 4.0K -rw-r--r-- 1 kodango kodango 4 Nov 10 20:09 1 -rw-r--r-- 1 kodango kodango 0 Nov 10 20:09 2</span><br><span class="line">$ echo &quot;&#96;ls -l&#96;&quot;</span><br><span class="line">total 4.0K</span><br><span class="line">-rw-r--r-- 1 kodango kodango 4 Nov 10 20:09 1</span><br><span class="line">-rw-r--r-- 1 kodango kodango 0 Nov 10 20:09 2</span><br></pre></td></tr></table></figure>
<p>前者没有加双引号，ls -l输出行之间的回车就被吃掉了。原因是，当ls -l返回的结果传递给echo之前，会先被shell进行参数解析，而shell是用IFS定义的分隔符来分隔字符串的，一般包括n，所以它把解析后的结果再传递给echo，就成为echo “line 1….” “line 2…”这种形式了，结果就像上面一样。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">而用双引号包括起来可以避开字符串被拆开解析，因为shell认为它是一个单独的字符串。所以一般情况下，多用引号包括变量是好的，&quot;$var&quot;比$var更安全。</span><br></pre></td></tr></table></figure>

<h3 id="11-显示一个文件并且在每行开头添加行号"><a href="#11-显示一个文件并且在每行开头添加行号" class="headerlink" title="11. 显示一个文件并且在每行开头添加行号"></a>11. 显示一个文件并且在每行开头添加行号</h3><p>有两种做法，第一种借助cat和nl命令来完成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat test.txt | nl</span><br><span class="line">     1    line 1 </span><br><span class="line">     2    line 2</span><br><span class="line">$ cat -n test.txt</span><br><span class="line">     1    line 1 </span><br><span class="line">     2    line 2</span><br><span class="line">$ nl test.txt     </span><br><span class="line">     1    line 1 </span><br><span class="line">     2    line 2</span><br></pre></td></tr></table></figure>
<p>另外一种做法是用sed命令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sed &#39;&#x3D;&#39; test.txt | sed &#39;N;s&#x2F;\n&#x2F;\t&#x2F;&#39;</span><br></pre></td></tr></table></figure>
<p>还有一种方法是通过cat -n或者cat -b命令，两者的区别是后者不会给空行增加行号,nl命令特别方便,而且空行没有行号;</p>
<h3 id="12-分别输出两个文件相同的行和不同的行"><a href="#12-分别输出两个文件相同的行和不同的行" class="headerlink" title="12. 分别输出两个文件相同的行和不同的行"></a>12. 分别输出两个文件相同的行和不同的行</h3><p>假设我们有以下两个文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ echo test&#123;,2&#125;.txt;paste test&#123;,2&#125;.txt</span><br><span class="line">test.txt test2.txt</span><br><span class="line">line 1     line 11</span><br><span class="line">line 2    line 2</span><br></pre></td></tr></table></figure>
<p>如果要输出两个文件之间相同的行，只有test.txt拥有的行以及只有test2.txt拥有的行，怎么做？首先可以使用grep -f：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ grep -f test&#123;,2&#125;.txt</span><br><span class="line">line 2</span><br><span class="line">$ grep -vf test&#123;,2&#125;.txt</span><br><span class="line">line 11</span><br><span class="line">$ grep -vf test&#123;2,&#125;.txt</span><br><span class="line">line 1</span><br></pre></td></tr></table></figure>
<p>还有一种选择是comm命令，这个命令就是专门用于比较文件的： comm - compare two sorted files line by line。 使用方法也很简单，comm比较两个排序好的文件返回的结果有三列，第一列是只有在文件A中有的行，第二列是只有在文件B中有的行，第三列则是两个文件共有的行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ comm test.txt test2.txt                </span><br><span class="line">line 1 </span><br><span class="line">    line 11</span><br><span class="line">        line 2</span><br></pre></td></tr></table></figure>
<p>要得到最初要求的结果，则只需要取相应的列就可以了。comm命令非常人性化地考虑到这个需求：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ comm test.txt test2.txt -1 -2</span><br><span class="line">line 2</span><br><span class="line">$ comm test.txt test2.txt -2 -3</span><br><span class="line">line 1 </span><br><span class="line">$ comm test.txt test2.txt -1 -3</span><br><span class="line">line 11</span><br></pre></td></tr></table></figure>
<p>其中，=1, -2与-3这个参数分别表示不输出第1、2或者3列。</p>
<h3 id="13-获取被source的脚本的名称"><a href="#13-获取被source的脚本的名称" class="headerlink" title="13. 获取被source的脚本的名称"></a>13. 获取被source的脚本的名称</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一般的情况下，脚本的名称可以通过$0获取，但是这在被source导入的脚本中却不成立。假设A脚本中source了B脚本，那么它是把B的代码导入到A的环境中直接执行的，因此A和B的代码其实是在同一个执行环境下分不开的，B的代码中访问到的$0，甚至$1, $2等位置参数都是与A脚本是一致的。</span><br></pre></td></tr></table></figure>

<p>因此$0并非是被导入的脚本的名称，实际上，Bash将被source的脚本名称保存在一个叫BASH_SOURCE的数组中，该数组的第一个元素正是当前被source的脚本的名称。该变量与我在bash获取当前函数名中介绍的FUNCNAME是类似的，当一个脚本被source时，它的名称就被压入到这个数组的第一个位置上，举个实际的例子，假设有三个脚本a.sh,b.sh,c.sh，它们的内容如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat a.sh </span><br><span class="line">. .&#x2F;b.sh</span><br><span class="line">echo &quot;\$0&#x3D;$0&quot;</span><br><span class="line">echo &quot;\$&#123;BASH_SOURCE[0]&#125;&#x3D;$&#123;BASH_SOURCE[0]&#125;&quot;</span><br><span class="line">echo &quot;\$BASH_SOURCE&#x3D;($&#123;BASH_SOURCE[@]&#125;)&quot;</span><br><span class="line"></span><br><span class="line">$ cat b.sh </span><br><span class="line">. .&#x2F;c.sh</span><br><span class="line">. .&#x2F;c.sh</span><br><span class="line">echo &quot;\$0&#x3D;$0&quot;</span><br><span class="line">echo &quot;\$&#123;BASH_SOURCE[0]&#125;&#x3D;$&#123;BASH_SOURCE[0]&#125;&quot;</span><br><span class="line">echo &quot;\$BASH_SOURCE&#x3D;($&#123;BASH_SOURCE[@]&#125;)&quot;</span><br><span class="line"></span><br><span class="line">$ cat c.sh </span><br><span class="line">$ cat c.sh </span><br><span class="line">echo &quot;\$0&#x3D;$0&quot;</span><br><span class="line">echo &quot;\$&#123;BASH_SOURCE[0]&#125;&#x3D;$&#123;BASH_SOURCE[0]&#125;&quot;</span><br><span class="line">echo &quot;\$BASH_SOURCE&#x3D;($&#123;BASH_SOURCE[@]&#125;)&quot;</span><br></pre></td></tr></table></figure>
<p>现在执行a.sh这个脚本，实际的输出是（为了方便理解，我在实际的输出中加了一些注释和空行）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ bash a.sh</span><br><span class="line"># c.sh的输出</span><br><span class="line">$0&#x3D;a.sh</span><br><span class="line">$&#123;BASH_SOURCE[0]&#125;&#x3D;.&#x2F;c.sh</span><br><span class="line">$BASH_SOURCE&#x3D;(.&#x2F;c.sh .&#x2F;b.sh a.sh)</span><br><span class="line"></span><br><span class="line"># b.sh的输出</span><br><span class="line">$0&#x3D;a.sh</span><br><span class="line">$&#123;BASH_SOURCE[0]&#125;&#x3D;.&#x2F;b.sh</span><br><span class="line">$BASH_SOURCE&#x3D;(.&#x2F;b.sh a.sh)</span><br><span class="line"></span><br><span class="line"># a.sh的输出</span><br><span class="line">$0&#x3D;a.sh</span><br><span class="line">$&#123;BASH_SOURCE[0]&#125;&#x3D;a.sh</span><br><span class="line">$BASH_SOURCE&#x3D;(a.sh)</span><br></pre></td></tr></table></figure>
<p>此外，我们还可以利用BASH_SOURCE的值，在脚本中判断是被直接执行还是被导入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if [ -n &quot;$BASH_SOURCE&quot; -a &quot;$BASH_SOURCE&quot; !&#x3D; &quot;$0&quot; ]</span><br><span class="line">then</span><br><span class="line">    echo &quot;be sourced by other scripts&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;be run in shell&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h3 id="14-参数展开"><a href="#14-参数展开" class="headerlink" title="14. ${}参数展开"></a>14. ${}参数展开</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我们知道$&#123;parameter&#125;是展开变量parameter这个值，在上一篇简洁的bash编程技巧中也曾经介绍过$&#123;parameter:-word&#125;这种用法，用于给变量赋一个默认值。 事实上除此之外，参数展开还有许多形式，在此之前，首先要说明一下变量的几种值的形式：</span><br></pre></td></tr></table></figure>

<p>unset： 变量未设置，即变量从未声明，或者被unset命令重置；<br>null: 变量声明但未被赋值（var=）或者被赋值成空（var=””）；<br>not null： 变量被赋值；<br>unset和null在参数展开的时候还是有很大的区别的，以下是参数展开的各种形式：</p>
<p>${parameter:-word}：假如parameter为unset或者null，则展开后返回word的值；<br>${parameter-word}：假如parameter为unset时，则展开后返回word的值;<br>${parameter:=word}：假如parameter为unset或者null，将word赋值给parameter；<br>${parameter=word}：假如parameter为unset，将word赋值给parameter；<br>${parameter:?word}：假如parameter为unset或者null，则将word作为错误输出到标准输出；<br>${parameter?word}：假如parameter为unset，则将word作为错误输出到标准输出；<br>${parameter:+word}：假如parameter为unset或者null，则不做展开，返回为空；（刚好与:-相反）<br>${parameter:word}：假如parameter为unset，则不做展开，返回为空；（刚好与-相反）<br>上面其实准确地应该是分成2组，一组带:，一组不带:，不带:的这组更加严格，只检查unset这种情况。以:+为例子, unset的情况均无返回：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ unset var &amp;&amp; echo $&#123;var:+hello&#125;</span><br><span class="line">$ unset var &amp;&amp; echo $&#123;var+hello&#125;</span><br></pre></td></tr></table></figure>
<p>当var为空时：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ var&#x3D; &amp;&amp; echo &quot;$&#123;var:+hello&#125;&quot;</span><br><span class="line">$ var&#x3D; &amp;&amp; echo &quot;$&#123;var+hello&#125;&quot;</span><br><span class="line">hello</span><br></pre></td></tr></table></figure>
<p>当var为非空时：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ var&#x3D;1 &amp;&amp; echo &quot;$&#123;var:+hello&#125;&quot;</span><br><span class="line">hello</span><br><span class="line">$ var&#x3D;1 &amp;&amp; echo &quot;$&#123;var+hello&#125;&quot;</span><br><span class="line">hello</span><br></pre></td></tr></table></figure>
<h3 id="15-冒号的多种使用场景"><a href="#15-冒号的多种使用场景" class="headerlink" title="15. 冒号的多种使用场景"></a>15. 冒号的多种使用场景</h3><p>冒号是一个比较奇怪的符号，它的用途有很多，这里介绍几种常用的：</p>
<ol>
<li>内置命令null command：nop，表示什么都不做，也可以被当作true值使用；<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ :</span><br><span class="line">$ echo $?    # return 0</span><br></pre></td></tr></table></figure>
它也可以在循环中当作true值，例如:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while :; do   # 等价于 while true; do</span><br><span class="line">    take-some-action</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">if condition</span><br><span class="line">then :</span><br><span class="line">else </span><br><span class="line">    take-some-action</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li>
<li>占位符 冒号可以在很多场景下充当占位符，例如之前介绍的${parameter=var}，如果直接执行会报错，表示找不到命令；这时可以借用冒号来完成赋值：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">: $&#123;parameter&#x3D;var&#125;</span><br></pre></td></tr></table></figure>
同样地，可以来判断变量是否赋值：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">: $&#123;parameter1?&#125; $&#123;parameter2?&#125;</span><br></pre></td></tr></table></figure>
<h3 id="16-扩展的括号展开功能"><a href="#16-扩展的括号展开功能" class="headerlink" title="16. 扩展的括号展开功能"></a>16. 扩展的括号展开功能</h3>这个功能不能说鸡肋，也可以了解下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ echo &#123;0..3&#125;</span><br><span class="line">0 1 2 3</span><br><span class="line">$ echo &#123;z..a&#125;</span><br><span class="line">z y x w v u t s r q p o n m l k j i h g f e d c b a</span><br><span class="line">$ echo &#123;a..z&#125;</span><br><span class="line">a b c d e f g h i j k l m n o p q r s t u v w x y z</span><br></pre></td></tr></table></figure>
<h3 id="17-安全的中括号"><a href="#17-安全的中括号" class="headerlink" title="17. 安全的中括号"></a>17. 安全的中括号</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">[[]]的功能比[]更加多，使用起来也更加安全。</span><br><span class="line"></span><br><span class="line">1. 首先[[]]内部不会发生文件名展开和单词分隔。 例如：</span><br><span class="line"></span><br><span class="line">$ touch hello\ world</span><br><span class="line">$ [[ -f $file ]] &amp;&amp; echo yes</span><br><span class="line">yes</span><br><span class="line">$ [ -f $file ] &amp;&amp; echo yes</span><br><span class="line">-bash: [: hello: binary operator expected</span><br><span class="line"></span><br><span class="line">2. 进制之间自动转化 当一个十进制与八进制做比较时，会自动计算两个数的值，统一后做比较：</span><br><span class="line">$ o&#x3D;017</span><br><span class="line">$ h&#x3D;0x0f</span><br><span class="line">$ [[ $o -eq $h ]] &amp;&amp; echo yes</span><br><span class="line">yes</span><br><span class="line">$ [[ $o -eq 15 ]] &amp;&amp; echo yes</span><br><span class="line">yes</span><br><span class="line"></span><br><span class="line">3. [[]]支持&amp;&amp;，||等运算符</span><br><span class="line">$ a&#x3D;1;b&#x3D;3</span><br><span class="line">$ [[ $a &gt; 0 &amp;&amp; $b &lt; 4 ]] &amp;&amp; echo yes</span><br><span class="line">yes</span><br></pre></td></tr></table></figure>
<h3 id="18-获取Bash脚本的最后一个参数"><a href="#18-获取Bash脚本的最后一个参数" class="headerlink" title="18. 获取Bash脚本的最后一个参数"></a>18. 获取Bash脚本的最后一个参数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我们都知道可以用$0，$1等来获取传递给脚本或者函数的参数，也可以用$*或者$@获取所有的参数，但是如果我只想要获取最后一个参数呢？</span><br></pre></td></tr></table></figure>
首先，你可能想到用遍历地方法（这里为了方便，我们使用set命令来设置位置参数）：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ set -- arg1 arg2 arg3</span><br><span class="line">$ for i in $@; do :; done</span><br><span class="line">$ echo $i</span><br><span class="line">arg3</span><br></pre></td></tr></table></figure>
这里的循环什么事情都没做，我用冒号（:）完成这个任务；循环结束后, $i就是保存着最后一个参数的值。 下面是两种更加简单的方法的：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ echo $&#123;@: -1&#125;</span><br><span class="line">$ echo $&#123;!#&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">上面的第一种方法事实上就是Parameter Expansion中的$&#123;parameter:offset:length&#125;这种形式，只不过offset为-1表示最后一个元素，忽略length表明是从offset开始往后直到最后一个元素，即只取最后一个元素。这里要注意的一点是，在冒号和短横之间的空格不能少，否则就变成15. $&#123;&#125;参数展开中介绍的$&#123;parameter:-var&#125;这种用法了。</span><br><span class="line"></span><br><span class="line">而第二种方法则是indirect referencing的一种表现，#这个特殊的变量存放参数的个数，!#则是对最后一个变量的引用。</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="19-Bash中的引用-indirect-referencing"><a href="#19-Bash中的引用-indirect-referencing" class="headerlink" title="19. Bash中的引用(indirect referencing)"></a>19. Bash中的引用(indirect referencing)</h3><p>有没有想法在Bash中也可以达到C++引用的效果？你可能不知道，但是你可能曾经有这种需求，我就有过：</p>
<p>有时候，我想要一个变量存放另外一个变量的名称，然后在后面我想通过这个变量的名称引用它的值<br>例子是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ a&#x3D;b</span><br><span class="line">$ b&#x3D;1</span><br><span class="line">$ echo $a</span><br><span class="line">b</span><br><span class="line">$ eval &quot;echo \$a&quot;</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>但是利用indirect referencing的用法，你可以这样获取b的值:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ echo $&#123;!a&#125;</span><br><span class="line">1</span><br><span class="line">$ b&#x3D;2</span><br><span class="line">$ echo $&#123;!a&#125;</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p><a href="https://yq.aliyun.com/articles/68540?spm=a2c4e.11153959.teamhomeleft.71.7e4c8bc1kg1JeI" target="_blank" rel="noopener"> 原文地址</a></p>
]]></content>
      <categories>
        <category>SHELL</category>
      </categories>
      <tags>
        <tag>SHELL</tag>
      </tags>
  </entry>
  <entry>
    <title>获取所有的AWS EC2主机信息</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h2 id="获取所有的AWS-EC2主机信息"><a href="#获取所有的AWS-EC2主机信息" class="headerlink" title="获取所有的AWS EC2主机信息"></a>获取所有的AWS EC2主机信息</h2><h3 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h3><ol>
<li>本地需要安装aws cli工具,以及配置好相关的key;</li>
<li>EC2 主机需要添加Tag(环境/部门/业务);</li>
</ol>
<h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><ol>
<li>需要安装PrettyTable模块<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># pip install PrettyTable</span><br></pre></td></tr></table></figure></li>
<li>脚本内容<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># __author__ &#x3D; &quot;shuke&quot;</span><br><span class="line"># Date: 2018&#x2F;2&#x2F;7</span><br><span class="line"></span><br><span class="line">from prettytable import PrettyTable</span><br><span class="line">import subprocess</span><br><span class="line">import datetime</span><br><span class="line">import xlwt</span><br><span class="line">import json</span><br><span class="line">import sys</span><br><span class="line">import getopt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_all_aws_ec2():</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    所有的EC2实例ID</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    try:</span><br><span class="line">        command &#x3D; &quot;aws ec2 describe-instances --query &#39;Reservations[*].Instances[*].[InstanceId]&#39;&quot;</span><br><span class="line">        ret &#x3D; subprocess.getoutput(command)</span><br><span class="line">        ret &#x3D; json.loads(ret)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(&quot;ERROR: &quot;, e)</span><br><span class="line">        sys.exit(&quot;Bey Bey!&quot;)</span><br><span class="line"></span><br><span class="line">    all_aws_ec2_list &#x3D; []</span><br><span class="line">    for ec2 in ret:</span><br><span class="line">        if len(ec2) &gt; 1:</span><br><span class="line">            for item in ec2:</span><br><span class="line">                all_aws_ec2_list.append(item[0])</span><br><span class="line">        else:</span><br><span class="line">            all_aws_ec2_list.append(ec2[0][0])</span><br><span class="line">    return all_aws_ec2_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_ec2_info():</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    获取所有的 EC2 属性信息</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    try:</span><br><span class="line">        command &#x3D; &quot;aws ec2 describe-instances --query &#39;Reservations[*].Instances[*].[InstanceId,Placement.AvailabilityZone,State.Name,Tags[?Key&#x3D;&#x3D;&#96;Name&#96;].Value,PrivateIpAddress,NetworkInterfaces[0].PrivateIpAddresses[0].Association.PublicIp,SecurityGroups[0].GroupName,SecurityGroups[1].GroupName,Tags[?Key&#x3D;&#x3D;&#96;环境&#96;].Value,Tags[?Key&#x3D;&#x3D;&#96;部门&#96;].Value,Tags[?Key&#x3D;&#x3D;&#96;业务&#96;].Value,Tags[?Key&#x3D;&#x3D;&#96;备注&#96;].Value]&#39;&quot;</span><br><span class="line">        ret &#x3D; subprocess.getoutput(command)</span><br><span class="line">        all_aws_ec2_list &#x3D; json.loads(ret)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(&quot;ERROR: &quot;, e)</span><br><span class="line">        sys.exit(&quot;Bey Bey!&quot;)</span><br><span class="line">    host_info_list &#x3D; []</span><br><span class="line">    for item in all_aws_ec2_list:</span><br><span class="line">        if len(item) &gt; 1:</span><br><span class="line">            for ec2 in item:</span><br><span class="line">                host_info_list.append([ec2])</span><br><span class="line">        else:</span><br><span class="line">            host_info_list.append(item)</span><br><span class="line"></span><br><span class="line">    return host_info_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def set_style(name, height, bold&#x3D;False):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    表格样式</span><br><span class="line">    :param name:</span><br><span class="line">    :param height:</span><br><span class="line">    :param bold:</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    style &#x3D; xlwt.XFStyle()  # 初始化样式</span><br><span class="line"></span><br><span class="line">    font &#x3D; xlwt.Font()  # 为样式创建字体</span><br><span class="line">    font.name &#x3D; name  # &#39;Times New Roman&#39;</span><br><span class="line">    font.bold &#x3D; bold</span><br><span class="line">    font.color_index &#x3D; 3</span><br><span class="line">    font.height &#x3D; height</span><br><span class="line">    style.font &#x3D; font</span><br><span class="line"></span><br><span class="line">    return style</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def write_execl(filename):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    输出到excel文件中</span><br><span class="line">    :param filename:</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    f &#x3D; xlwt.Workbook()  # 创建工作簿</span><br><span class="line">    sheet1 &#x3D; f.add_sheet(&#39;AWS主机信息表&#39;, cell_overwrite_ok&#x3D;True)</span><br><span class="line">    title &#x3D; [&#39;实例ID&#39;, &#39;region&#39;, &#39;状态&#39;, &#39;Name&#39;, &#39;内网IP&#39;, &#39;公网IP&#39;, &#39;安全组-1&#39;, &#39;安全组-2&#39;, &#39;环境&#39;, &#39;部门&#39;, &#39;业务&#39;, &#39;备注&#39;]</span><br><span class="line">    # 生成第一行</span><br><span class="line">    for i in range(0, len(title)):</span><br><span class="line">        sheet1.write(0, i, title[i], set_style(&#39;简体中文&#39;, 350, True))</span><br><span class="line"></span><br><span class="line">    host_info_list &#x3D; get_ec2_info()</span><br><span class="line">    i &#x3D; 1</span><br><span class="line">    while i &lt; int(len(host_info_list) + 1):</span><br><span class="line">        for j in range(0, len(title)):</span><br><span class="line">            if isinstance(host_info_list[i - 1][0][j], list):</span><br><span class="line">                cell &#x3D; host_info_list[i - 1][0][j] if host_info_list[i - 1][0][j] else None</span><br><span class="line">            else:</span><br><span class="line">                cell &#x3D; host_info_list[i - 1][0][j]</span><br><span class="line">            sheet1.write(i, j, cell)</span><br><span class="line">        i +&#x3D; 1</span><br><span class="line"></span><br><span class="line">    f.save(filename)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def table_stdout():</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    输出为表格形式</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    table &#x3D; PrettyTable(</span><br><span class="line">        [&quot;编号&quot;, &quot;实例ID&quot;, &quot;region&quot;, &quot;状态&quot;, &quot;Name&quot;, &quot;内网IP&quot;, &quot;公网IP&quot;, &quot;安全组-1&quot;, &quot;安全组-2&quot;, &quot;环境&quot;, &quot;部门&quot;, &quot;业务&quot;, &quot;备注&quot;])</span><br><span class="line"></span><br><span class="line">    all_ec2_instance_id_list &#x3D; get_all_aws_ec2()</span><br><span class="line">    host_info_list &#x3D; get_ec2_info()</span><br><span class="line">    if len(all_ec2_instance_id_list) !&#x3D; len(host_info_list):</span><br><span class="line">        sys.exit(&quot;ERROR: 主机数量不一致，请检查!&quot;)</span><br><span class="line">    count &#x3D; 0</span><br><span class="line">    for ec2_info in host_info_list:</span><br><span class="line">        temp &#x3D; []</span><br><span class="line">        count +&#x3D; 1</span><br><span class="line">        ec2_info[0].insert(0, count)</span><br><span class="line">        for item in ec2_info[0]:</span><br><span class="line">            if isinstance(item, list):</span><br><span class="line">                temp.append(item[0] if item else None)</span><br><span class="line">            else:</span><br><span class="line">                temp.append(item)</span><br><span class="line">        table.add_row(temp)</span><br><span class="line">    table.reversesort &#x3D; True</span><br><span class="line">    print(table)</span><br><span class="line">    print(&quot;\033[0;32m%s:, AWS EC2 Total: %d\033[0m&quot; % (datetime.datetime.now(), len(all_ec2_instance_id_list)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main(argv, excel_path):</span><br><span class="line">    usage &#x3D; &quot;&quot;&quot;usage:</span><br><span class="line">        test.py -t&#x2F;--table</span><br><span class="line">        test.py -f&#x2F;--outfile</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    try:</span><br><span class="line">        opts, args &#x3D; getopt.getopt(argv, &quot;htf&quot;, [&quot;help&quot;, &quot;table&quot;, &quot;outfile&quot;])</span><br><span class="line">    except getopt.GetoptError:</span><br><span class="line">        print(usage)</span><br><span class="line">        sys.exit(2)</span><br><span class="line">    for opt, arg in opts:</span><br><span class="line">        if opt in (&quot;-h&quot;, &quot;--help&quot;):</span><br><span class="line">            print(usage)</span><br><span class="line">            sys.exit(2)</span><br><span class="line">        elif opt in (&quot;-t&quot;, &quot;--table&quot;):</span><br><span class="line">            table_stdout()</span><br><span class="line">        elif opt in (&quot;-f&quot;, &quot;--outfile&quot;):</span><br><span class="line">            write_execl(excel_path)</span><br><span class="line">        else:</span><br><span class="line">            print(usage)</span><br><span class="line">            sys.exit(2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    excel_path &#x3D; &quot;&#x2F;tmp&#x2F;AWS主机信息表-&#123;date&#125;.xlsx&quot;.format(date&#x3D;datetime.date.today())</span><br><span class="line">    main(sys.argv[1:], excel_path</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>aws</category>
      </categories>
      <tags>
        <tag>aws</tag>
      </tags>
  </entry>
  <entry>
    <title>运维知识体系</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<p><img src="%E8%BF%90%E7%BB%B4%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/%E8%BF%90%E7%BB%B4%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BBV1.0.jpg" alt="运维知识体系"></p>
]]></content>
      <categories>
        <category>SRE</category>
      </categories>
      <tags>
        <tag>SRE</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝鲸进程管理脚本参考</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<p>蓝鲸进程管理脚本参考</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line"># use bash to execute this script</span><br><span class="line">echo $BASH |grep -q &#39;bash&#39; || &#123; exec bash &quot;$0&quot; &quot;$@&quot; || exit 1; &#125;</span><br><span class="line"></span><br><span class="line"># enable extended pattern matching operators</span><br><span class="line">shopt -s extglob</span><br><span class="line"></span><br><span class="line">VERSION_BK&#x3D;&quot;1.1.1&quot;</span><br><span class="line"></span><br><span class="line">DIR_HOME&#x3D;&quot;$(readlink -f $(dirname $0))&quot;</span><br><span class="line"></span><br><span class="line">DIR_CMDB&#x3D;&quot;$DIR_HOME&#x2F;cmdb&quot;</span><br><span class="line">DIR_JOB&#x3D;&quot;$DIR_HOME&#x2F;job&quot;</span><br><span class="line">DIR_GSE&#x3D;&quot;$DIR_HOME&#x2F;gse&quot;</span><br><span class="line">DIR_ZK&#x3D;&quot;$DIR_HOME&#x2F;common&#x2F;zookeeper&#x2F;zookeeper-3.4.6&quot;</span><br><span class="line">DIR_DOWN&#x3D;&quot;$DIR_HOME&#x2F;index&#x2F;download&quot;</span><br><span class="line">DIR_SESSION&#x3D;&quot;$DIR_HOME&#x2F;.session&quot;</span><br><span class="line"></span><br><span class="line">FILE_CONF&#x3D;&quot;$DIR_HOME&#x2F;bk.conf&quot;</span><br><span class="line">FILE_LOG&#x3D;&quot;$DIR_HOME&#x2F;bk.log&quot;</span><br><span class="line"></span><br><span class="line">FILE_TPL&#x3D;&quot;$DIR_HOME&#x2F;common&#x2F;function.tpl&quot;</span><br><span class="line">FILE_FUNC&#x3D;&quot;$DIR_HOME&#x2F;common&#x2F;function&quot;</span><br><span class="line"></span><br><span class="line">FILE_SETUP&#x3D;&quot;$DIR_HOME&#x2F;init_data&#x2F;setup.sh&quot;</span><br><span class="line">FILE_INITDB&#x3D;&quot;$DIR_HOME&#x2F;init_data&#x2F;init_db.sh&quot;</span><br><span class="line"></span><br><span class="line">FILE_CRT&#x3D;&quot;$DIR_HOME&#x2F;ssl_certificates.tar.gz&quot;</span><br><span class="line">FILE_INIT&#x3D;&quot;$DIR_HOME&#x2F;.bkallowinit&quot;</span><br><span class="line">SO_libaio&#x3D;&quot;&#x2F;lib64&#x2F;libaio.so.1&quot;</span><br><span class="line"></span><br><span class="line">NGINX_LOGS&#x3D;&quot;$DIR_HOME&#x2F;common&#x2F;nginx&#x2F;logs&quot;</span><br><span class="line"></span><br><span class="line">PHP_EXE&#x3D;&quot;$DIR_HOME&#x2F;common&#x2F;php&#x2F;bin&#x2F;php&quot;</span><br><span class="line"></span><br><span class="line">MYSQL_HOME&#x3D;&quot;$DIR_HOME&#x2F;common&#x2F;mysql&quot;</span><br><span class="line">MYSQL_DATA&#x3D;&quot;$MYSQL_HOME&#x2F;data&#x2F;&quot;</span><br><span class="line">MYSQL_BIN&#x3D;&quot;$MYSQL_HOME&#x2F;bin&#x2F;mysql&quot;</span><br><span class="line">MYSOCK&#x3D;&quot;$MYSQL_HOME&#x2F;data&#x2F;mysql.sock&quot;</span><br><span class="line"></span><br><span class="line">TOMCAT_DIR&#x3D;&quot;$DIR_JOB&#x2F;apache-tomcat-7.0.19&quot;</span><br><span class="line">TOMCAT_LOGS&#x3D;&quot;$TOMCAT_DIR&#x2F;logs&quot;</span><br><span class="line">TOMCAT_BIN&#x3D;&quot;$TOMCAT_DIR&#x2F;bin&#x2F;catalina.sh&quot;</span><br><span class="line"></span><br><span class="line">JAVA_HOME&#x3D;&quot;$DIR_HOME&#x2F;common&#x2F;java&quot;</span><br><span class="line">JAVA_BIN&#x3D;&quot;$JAVA_HOME&#x2F;bin&quot;</span><br><span class="line">PATH&#x3D;$JAVA_BIN:$PATH</span><br><span class="line">CLASSPATH&#x3D;.:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar</span><br><span class="line"></span><br><span class="line">LC_ALL&#x3D;C</span><br><span class="line">LANG&#x3D;C</span><br><span class="line"></span><br><span class="line">ACTION&#x3D;&#39;@(start|stop|restart|status|summary|reload|report|init)&#39;</span><br><span class="line">MODULE&#x3D;&#39;@(all|redis-server|nginx|mysqld|zk1|zk2|zk3|gsedba|gsetask|gsebtfilesserver|yydba|gsedata|gsecacheapiserver|gseagent|cmdb|job|-*||)&#39;</span><br><span class="line">GROUP&#x3D;&#39;@(gse|zk)&#39;</span><br><span class="line"></span><br><span class="line">monit() &#123; </span><br><span class="line">    local MONIT_DIR&#x3D;&quot;$DIR_HOME&#x2F;common&#x2F;monit&quot;</span><br><span class="line">    local MONIT_BIN&#x3D;&quot;$MONIT_DIR&#x2F;bin&#x2F;monit&quot;</span><br><span class="line">    local MONIT_RC&#x3D;&quot;$MONIT_DIR&#x2F;conf&#x2F;monitrc&quot;</span><br><span class="line">    local MONIT_EXE&#x3D;&quot;$MONIT_BIN -c $MONIT_RC&quot;</span><br><span class="line">    </span><br><span class="line">    chmod 700 $MONIT_RC</span><br><span class="line">    </span><br><span class="line">    case &quot;$1&quot; in</span><br><span class="line">        self_start)</span><br><span class="line">            log &quot;Info: monit self_start...&quot;</span><br><span class="line">            $MONIT_EXE &amp;&gt;&#x2F;dev&#x2F;null</span><br><span class="line">            wait_check &quot;$MONIT_EXE summary&quot;</span><br><span class="line">            log &quot;Info: monit self_start, ok&quot;</span><br><span class="line">            ;;</span><br><span class="line">        self_stop)</span><br><span class="line">            $MONIT_EXE quit</span><br><span class="line">            ;;</span><br><span class="line">        self_reload) </span><br><span class="line">            $MONIT_EXE reload</span><br><span class="line">            ;;</span><br><span class="line">        self_restart)</span><br><span class="line">            monit self_stop</span><br><span class="line">            monit self_start</span><br><span class="line">            ;;</span><br><span class="line">        wait_stop)</span><br><span class="line">            wait_check &quot;$MONIT_EXE summary |grep -c monitored |grep -q 16&quot;</span><br><span class="line">            ;;  </span><br><span class="line">        *)</span><br><span class="line">            [[ $1 &#x3D;&#x3D; &quot;start&quot; ]] &amp;&amp; [[ $2 &#x3D;&#x3D; &quot;all&quot; ]] &amp;&amp; monit self_start</span><br><span class="line">            $MONIT_EXE &quot;$@&quot;</span><br><span class="line">            [[ $1 &#x3D;&#x3D; &quot;start&quot; ]] &amp;&amp; [[ $2 &#x3D;&#x3D; &quot;all&quot; ]] &amp;&amp; writed_ip</span><br><span class="line">            echo $1 |grep -Eq &#39;start|stop|restart&#39; &amp;&amp; &#123; sleep 3;monit summary; &#125;</span><br><span class="line">            ;;</span><br><span class="line">    esac</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">usage() &#123;</span><br><span class="line">    cat &lt;&lt;EOF</span><br><span class="line">Usage: $0 : &lt;action&gt; &lt;module&gt;</span><br><span class="line">action的取值为：(start|stop|restart|status|summary|reload|report|init)时，需要第二个参数module</span><br><span class="line">module的取值为：(all|redis-server|nginx|mysqld|zk1|zk2|zk3|gsedba|gsetask|gsebtfilesserver|yydba|gsedata|gsecacheapiserver|gseagent|cmdb|job)</span><br><span class="line"></span><br><span class="line">查看所有的进程状态：$0 summary </span><br><span class="line">EOF</span><br><span class="line">    exit 1 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo -en &quot;Current Version: $VERSION_BK \n&quot;</span><br><span class="line"></span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line">    init) </span><br><span class="line">        source $FILE_SETUP || &#123; echo -en &quot;Error: source $FILE_SETUP, failed\n&quot;;exit 1; &#125;</span><br><span class="line">        monit self_start &amp;&amp; monit unmonitor all</span><br><span class="line">        monit stop all &amp;&amp; monit wait_stop</span><br><span class="line">        monit start mysqld</span><br><span class="line">        monit -g zk start </span><br><span class="line">        init_db</span><br><span class="line">        exit $?</span><br><span class="line">        ;;</span><br><span class="line">    $ACTION)</span><br><span class="line">        : ;;</span><br><span class="line">    *)</span><br><span class="line">        usage</span><br><span class="line">        ;;</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line">source $FILE_FUNC || log_exit &quot;Error: source $FILE_FUNC, failed&quot;</span><br><span class="line"></span><br><span class="line">case &quot;$2&quot; in </span><br><span class="line">    $MODULE)</span><br><span class="line">        monit &quot;$@&quot;</span><br><span class="line">        ;;</span><br><span class="line">    $GROUP)</span><br><span class="line">        monit -g $2 $1</span><br><span class="line">        ;;</span><br><span class="line">    monit)</span><br><span class="line">        monit self_$1</span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">        usage</span><br><span class="line">        ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
        <category>SHELL</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>SHELL</tag>
      </tags>
  </entry>
  <entry>
    <title>让人想骂街的 Python 炫技操作：条件语句的七种写法</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<p>有的人说 Python 是一门入门容易，但是精通难的语言，这一点我非常赞同。</p>
<p>Python 语言里有许多（而且是越来越多）的高级特性，是 Python 发烧友们非常喜欢的。在这些人的眼里，能够写出那些一般开发者看不懂的高级特性，就是高手，就是大神。</p>
<p>但你要知道，在团队合作里，炫技是大忌。</p>
<p>为什么这么说呢？我说下自己的看法：</p>
<p>越简洁的代码，越清晰的逻辑，就越不容易出错；<br>在团队合作中，你的代码不只有你在维护，降低别人的阅读/理解代码逻辑的成本是一种良好的品德<br>简单的代码，只会用到最基本的语法糖，复杂的高级特性，会有更多的依赖（如语言的版本）<br>在这个系列里，我将总结列举一下，我所见过的那些炫技操作，今天先来个热身，写一写很简单的条件判断语句里有哪些让人想骂街的炫技操作，在这里，如果你是 Python 发烧友，你可以学到一些写出超酷的代码书写技巧，但学习归学习，希望你区分场景使用。</p>
<ol start="0">
<li>原代码<br>这是一段非常简单的通过年龄判断一个人是否成年的代码，由于代码行数过多，有些人就不太愿意这样写，因为这体现不出自己多年的 Python 功力。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if age &gt; 18:</span><br><span class="line">    return &quot;已成年&quot;</span><br><span class="line">else:</span><br><span class="line">    return &quot;未成年&quot;</span><br></pre></td></tr></table></figure>
下面我列举了六种这段代码的变异写法，一个比一个还 6 ，单独拿出来比较好理解，放在工程代码里，没用过这些学法的人，一定会看得一脸懵逼，理解了之后，又不经意大呼：卧槽，还可以这样写？，而后就要开始骂街了：这是给人看的代码？</li>
<li>第一种<br>语法:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;on_true&gt; if &lt;condition&gt; else &lt;on_false&gt;</span><br></pre></td></tr></table></figure>
例子<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; age1 &#x3D; 20</span><br><span class="line">&gt;&gt;&gt; age2 &#x3D; 17</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; msg1 &#x3D; &quot;已成年&quot; if age1 &gt; 18 else &quot;未成年&quot;</span><br><span class="line">&gt;&gt;&gt; print msg1</span><br><span class="line">已成年</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; msg2 &#x3D; &quot;已成年&quot; if age2 &gt; 18 else &quot;未成年&quot;</span><br><span class="line">&gt;&gt;&gt; print msg2</span><br><span class="line">未成年</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></li>
<li>第二种<br>语法<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;expression&gt; and &lt;on_true&gt; or &lt;on_false&gt;</span><br></pre></td></tr></table></figure>
例子<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; msg1 &#x3D; age1 &gt; 18 and &quot;已成年&quot; or &quot;未成年&quot;</span><br><span class="line">&gt;&gt;&gt; msg2 &#x3D; &quot;已成年&quot; if age2 &gt; 18 else &quot;未成年&quot;</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; print(msg1)</span><br><span class="line">已成年</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; print(msg2)</span><br><span class="line">未成年</span><br></pre></td></tr></table></figure></li>
<li>第三种<br>语法<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(&lt;on_true&gt;, &lt;on_false&gt;)[condition]</span><br></pre></td></tr></table></figure>
例子<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; msg1 &#x3D; (&quot;未成年&quot;, &quot;已成年&quot;)[age1 &gt; 18]</span><br><span class="line">&gt;&gt;&gt; print(msg1)</span><br><span class="line">已成年</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; msg2 &#x3D; (&quot;未成年&quot;, &quot;已成年&quot;)[age2 &gt; 18]</span><br><span class="line">&gt;&gt;&gt; print(msg2)</span><br><span class="line">未成年</span><br></pre></td></tr></table></figure></li>
<li>第四种<br>语法:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lambda: &lt;on_false&gt;, lambda:&lt;on_true&gt;)[&lt;condition&gt;]()</span><br></pre></td></tr></table></figure>
例子<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; msg1 &#x3D; (lambda:&quot;未成年&quot;, lambda:&quot;已成年&quot;)[age1 &gt; 18]()</span><br><span class="line">&gt;&gt;&gt; print(msg1)</span><br><span class="line">已成年</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; msg2 &#x3D; (lambda:&quot;未成年&quot;, lambda:&quot;已成年&quot;)[age2 &gt; 18]()</span><br><span class="line">&gt;&gt;&gt; print(msg2)</span><br><span class="line">未成年</span><br></pre></td></tr></table></figure></li>
<li>第五种<br>语法:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;True: &lt;on_true&gt;, False: &lt;on_false&gt;&#125;[&lt;condition&gt;]</span><br></pre></td></tr></table></figure>
例子<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; msg1 &#x3D; &#123;True: &quot;已成年&quot;, False: &quot;未成年&quot;&#125;[age1 &gt; 18]</span><br><span class="line">&gt;&gt;&gt; print(msg1)</span><br><span class="line">已成年</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; msg2 &#x3D; &#123;True: &quot;已成年&quot;, False: &quot;未成年&quot;&#125;[age2 &gt; 18]</span><br><span class="line">&gt;&gt;&gt; print(msg2)</span><br><span class="line">未成年</span><br></pre></td></tr></table></figure></li>
<li>第六种<br>语法:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">((&lt;condition&gt;) and (&lt;on_true&gt;,) or (&lt;on_false&gt;,))[0]</span><br></pre></td></tr></table></figure>
例子:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; msg1 &#x3D; ((age1 &gt; 18) and (&quot;已成年&quot;,) or (&quot;未成年&quot;,))[0]</span><br><span class="line">&gt;&gt;&gt; print(msg1)</span><br><span class="line">已成年</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; msg2 &#x3D; ((age2 &gt; 18) and (&quot;已成年&quot;,) or (&quot;未成年&quot;,))[0]</span><br><span class="line">&gt;&gt;&gt; print(msg2)</span><br><span class="line">未成年</span><br></pre></td></tr></table></figure>
以上代码，都比较简单，仔细看都能看懂，我就不做解释了。</li>
</ol>
<p>看到这里，有没有涨姿势了，学了这么久的 Python ，这么多骚操作，还真是活久见。。这六种写法里，我最推荐使用的是第一种，自己也经常在用，简洁直白，代码行还少。而其他的写法虽然能写，但是不会用，也不希望在我余生里碰到会在公共代码里用这些写法的同事。</p>
]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>PYTHON</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里巴巴 DevOps 转型后的运维平台建设</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h2 id="实战-阿里巴巴-DevOps-转型后的运维平台建设"><a href="#实战-阿里巴巴-DevOps-转型后的运维平台建设" class="headerlink" title="实战:阿里巴巴 DevOps 转型后的运维平台建设"></a>实战:阿里巴巴 DevOps 转型后的运维平台建设</h2><blockquote>
<p>导读：阿里巴巴DevOps转型之后，运维平台是如何建设的？阿里巴巴高级技术专家陈喻结合运维自身的理解，业务场景的分析和业界方法论的一些思考，得出来一些最佳实践分享给大家.</p>
</blockquote>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>“我是这个应用的 Owner”是阿里巴巴DevOps转型的重要策略，运维有了这个策略以后，PE大量的日常工作就可以释放出来，会有更多的时间去思考沉淀，去做编码，去做以前不曾做的事情。</p>
<h3 id="运维的三个阶段"><a href="#运维的三个阶段" class="headerlink" title="运维的三个阶段"></a>运维的三个阶段</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEBbf3865e31808fe00f15398bbcc41424f?method=download&shareKey=f5bd11f6b941ca6316940227c22768bc" alt="运维三个阶段">  </p>
<ol>
<li>第一阶段：黑屏，三角形是代表整个运维给用户的一些体感或者给研发的体感，人工运维，目前很多企业可能还是这样。</li>
<li>第二阶段：白屏,自动化运维，以前把脚本做成工具去弄，有什么特征，人push机器去干活，自助运维。</li>
<li>第三阶段：用户对运维体感很少，但是运维这个领域是不变的。最重要的是人机交互变少了，无屏虽说是不可能的，非常极端，但是个趋势，少量的人机交互，它有自决策、自驱动。</li>
</ol>
<h3 id="自动化运维基础"><a href="#自动化运维基础" class="headerlink" title="自动化运维基础"></a>自动化运维基础</h3><p>做自动化运维，我认为有四大基础。</p>
<h4 id="第一-运维标准与规范"><a href="#第一-运维标准与规范" class="headerlink" title="第一: 运维标准与规范"></a>第一: 运维标准与规范</h4><p>我们的标准有什么好处，让研发 follow 这个标准，标准会在工具里固化。</p>
<h4 id="第二-泛监控，运行时，静态，数据化，可视化"><a href="#第二-泛监控，运行时，静态，数据化，可视化" class="headerlink" title="第二: 泛监控，运行时，静态，数据化，可视化"></a>第二: 泛监控，运行时，静态，数据化，可视化</h4><p>泛监控，不是说传统的监控，是把线上想知道的一切都数据化，最终数据不是给人看的，是给机器去消费的，数据是我们的生产资料，不是可视化，那不是我们的目标。</p>
<h4 id="第三-CMDB"><a href="#第三-CMDB" class="headerlink" title="第三: CMDB"></a>第三: CMDB</h4><p>1.CMDB 应该放什么，一般放服务器相关的、网络相关的、应用相关的这三个维度的相关信息。<br>2.经常有人会说 CMDB 不准，数据不准是因为没有把数据生产和数据消费形成闭环，如果形成了闭环数据不准，那是因为你不用这个数据，所以不准。</p>
<h4 id="第四-高效的CI-CD"><a href="#第四-高效的CI-CD" class="headerlink" title="第四: 高效的CI/CD"></a>第四: 高效的CI/CD</h4><p>我们一定要具备快速的交付能力，主要体现这两个方面：第一，新开发的能力能不能快速上线，第二，想扩容一台机器能不能快速扩出来。这两个能力抽象出来是三块。<br>持续集成(CI)，很多人说持续集成工具不好用，效率低，其实持续集成的本质是要自动化测试。如果研发部不具备自动化测试的能力，持续集成怎么做都是失败的。<br>持续集成里最重要的一点就是要推行单元测试、集成测试还有系统测试，单测是保证自己没问题，集成测试是保证跟上下游没问题，系统测试是保证整个系统没问题。<br>持续交付(CD)，有很多人说持续交付本质是一个 Pipeline，CI的目标是什么？快速正确打一个包出来。CD的目标是什么？能够快速把一个包在不同的环境验证它是ok的，可以放到线上去，这就是持续交付要干的事。持续交付里很关键的一点我们要解决，就是它的环境一致性、配置一致性。环境一致性可以用Docker解决，Docker 本身就是一种标准化的东西。所以说第一条用 Docker，肯定是标准化的，另外一个问题，配置是不是一致性，是不是动静分离。<br>持续部署(CD)，是一种能力，这种能力非常重要，就是把一个包快速部署在你想要的地方。</p>
<p>PS：持续部署的几个痛点。</p>
<ol>
<li>对包的文件的分发，阿里有一个叫蜻蜓的产品，是做了 SP2P，在 P2P 的基础上加了一个 Super。</li>
<li>应用启动，很多应用启动的时候要两三分钟，这是很有问题的。</li>
<li>部署起来以后这个业务是不是正确的，大家一定要做一个 HealthCheck，不是运维做，是PE做，一定要把这个要求说出来，执行 HealthCheck 这个脚本。</li>
</ol>
<h3 id="运维系统的重要特性"><a href="#运维系统的重要特性" class="headerlink" title="运维系统的重要特性"></a>运维系统的重要特性</h3><p>中间件研发首先关注稳定性，其次是效率，然后是易扩展。运维研发里面的六个重要特征，每一个都非常重要，以下是我感触比较深的几个。<br><img src="https://note.youdao.com/yws/api/personal/file/WEB620101a1629a2fdfbd0c36d6564055ff?method=download&shareKey=08971d6ce40134622e0c64456099e2ae" alt="运维系统重要特性">  </p>
<ol>
<li><p>高可用<br>在做同城容灾演练的时候，我把关一切，结果发现运维系统挂了，救命的东西没有了怎么办？所以说运维系统一定要是高可用，不一定是高并发。</p>
</li>
<li><p>幂等性<br>幂等性是分布式系统设计中十分重要的概念，这个也非常重要。</p>
</li>
<li><p>可回滚<br>这个是做运维最基本的一个 sense，你做的任何操作是不是可控的。如果真正做可回滚，其实事情没有这么复杂。</p>
</li>
<li><p>高效率<br>如果你的企业发展非常快速，你的规模性效应已经来了，你的运维系统一定要具备很高效率，快速扩容、快速部署这个效率我们要追求极致。</p>
</li>
</ol>
<h3 id="研发定义运维，配置驱动变更"><a href="#研发定义运维，配置驱动变更" class="headerlink" title="研发定义运维，配置驱动变更"></a>研发定义运维，配置驱动变更</h3><ol>
<li><p>从最下面看，是我们的基础设施，提供三种能力，包括集散、存储、网络。从右下角的位置看，画的是一个泛监控，它会知道系统、应用等，在旁边标了一个字，现状，我要通过这个现状把线上的系统全部数据化，然后放到决策中心。</p>
</li>
<li><p>左上角有 CMDB，现在很多变更系统，很多强调流程。我本人是做研发出身，非常抵触流程，流程不是一个效率工具，它是阻碍效率的。</p>
</li>
<li><p>比如故障搞完以后就是一堆的流程，非常阻碍效率，是质量控制的一个工具。流程不是不要，是把流程做到系统里面去，让系统帮人做决策，而不是人在那里点。</p>
</li>
<li><p>CMDB 定义了我刚才说的目标，现状通过监控拿到了，目标也知道了，这个时候还觉得这个事情很复杂吗？我认为这看你怎么去做。想做成人工还是做成自动或者做成智能，都取决于这个地方。所以智能里一定要有数据。</p>
</li>
<li><p>举个例子，通过智能分析出目标状态是使这个应用有100个VM，但是现在状态只有80个，一看这两个不一样，要扩容20台，如果系统做得更智能一点，通过图上左边的事件中心提示我20台负载较轻的放在哪，可以调度过去，然后去做执行变更。</p>
</li>
</ol>
<p>基于这些东西得出来两个结论，“研发定义运维”，“配置驱动变更”。</p>
<h3 id="为什么是研发定义运维？"><a href="#为什么是研发定义运维？" class="headerlink" title="为什么是研发定义运维？"></a>为什么是研发定义运维？</h3><p>研发定义运维（DDO），研发最贴近业务，最应该清楚这个业务应该具备什么样的能力，只有研发才知道这个业务KPS是多少。</p>
<h3 id="为什么是配置驱动变更"><a href="#为什么是配置驱动变更" class="headerlink" title="为什么是配置驱动变更?"></a>为什么是配置驱动变更?</h3><p>配置就是把目标改变一下，你跟我说一个运维场景，我可以在这个图里面 run 起来，配置只需要改你的目标状态，比如把你的状态10VM 变成15个VM。<br>这就是”研发定义运维，配置驱动变更”前因后果的思考。</p>
<h3 id="运维工具与方法论"><a href="#运维工具与方法论" class="headerlink" title="运维工具与方法论"></a>运维工具与方法论</h3><p><img src="https://note.youdao.com/yws/api/personal/file/WEB9c904e2294e2fc84199992da72822695?method=download&shareKey=ebfc4a36f6d42bca917684b002fd174d" alt="运维工具及方法论">  </p>
<h4 id="精益发现价值"><a href="#精益发现价值" class="headerlink" title="精益发现价值"></a>精益发现价值</h4><p>价值来源于用户的需求，而不是自己的YY，我们的价值来源于用户。</p>
<p>精益对我最大的感触就是要发现价值。精益思想，什么东西是有价值的，能够对用户带来物质上的或者身体上的愉悦的东西就是有价值的。</p>
<p>今天也有人问，DevOps 团队是该拆还是该合，我想他应该首先弄清楚面对的是什么样的问题，问题的优先级是什么？如果只解决一个问题，也许并不是DevOps 团队拆不拆的问题。</p>
<h4 id="敏捷交付价值"><a href="#敏捷交付价值" class="headerlink" title="敏捷交付价值"></a>敏捷交付价值</h4><p>敏捷也是对我影响很多的。很多人谈敏捷，我们团队里也搞敏捷，敏捷是要快速交付价值，它是一系列的方法论。但是在引入的时候千万注意，别人行的东西你不一定行，你需要的东西并不一定是敏捷，要因团队而异，形成一个环，持续反馈。</p>
<h4 id="OODA环"><a href="#OODA环" class="headerlink" title="OODA环"></a>OODA环</h4><p>OODA 环，就是形成闭环，让价值快速流动。</p>
<h3 id="应用运维平台ATOM"><a href="#应用运维平台ATOM" class="headerlink" title="应用运维平台ATOM"></a>应用运维平台ATOM</h3><p>应用运维平台的基础设施是一层，二层是运维中台，最上面一块是要做的 PaaS 平台，这个平台分几步。<br><img src="https://note.youdao.com/yws/api/personal/file/WEBcf540b68ea94cc7580696604fdd19476?method=download&shareKey=0a14435fa7c2bae87259c1ca63a072ff" alt="ATOM平台产品架构">  </p>
<h4 id="第一块，预算、容量、资源、弹性"><a href="#第一块，预算、容量、资源、弹性" class="headerlink" title="第一块，预算、容量、资源、弹性"></a>第一块，预算、容量、资源、弹性</h4><p>这个是PaaS 平台上非常重要的一块，目的就是让资源快速流动起来，流向正确的方向来产生价值。资源如果常年不增不减，是有问题的。</p>
<h4 id="第二块，应用管理"><a href="#第二块，应用管理" class="headerlink" title="第二块，应用管理"></a>第二块，应用管理</h4><p>这是日常要做的操作，规模化，要快速对一个单元建站、扩容、缩容。</p>
<h4 id="第三块，数据化运营"><a href="#第三块，数据化运营" class="headerlink" title="第三块，数据化运营"></a>第三块，数据化运营</h4><p>一定要讲数据，数据不是可视化出来一些报表，是要给结论，告诉用户这个数据完了以后应该是什么，规则中心是什么，是所有运维同学日常的运维经验沉淀。</p>
<h3 id="批量腾挪工具"><a href="#批量腾挪工具" class="headerlink" title="批量腾挪工具"></a>批量腾挪工具</h3><p>批量腾挪工具-背景</p>
<ul>
<li>痛点: <ul>
<li>机房搬迁</li>
<li>机器过保替换</li>
<li>机器故障频发,替换</li>
</ul>
</li>
<li>目标:<ul>
<li>规模化,系统化资源腾挪,提升运维效率</li>
<li>减少批量腾挪投入的人力,时间资源</li>
<li>单机替换自动化处理<br>这个工具不是所有人都需要，可以解决机房的搬迁，凑框迁移。<br>弹性伸缩是我们的决策中心。它决定你的资源往哪个地方流，非常关键。<br>最后，这里是运维领域技术含量最深的一个地方，要搞机器学习、深度学习、强化学习、算法等。<br>弹性一般有水平伸缩、垂直伸缩，对线上做管理，当然我们有额度，这是比较精细化的管理。弹性有观察者模式还有自动化执行，每次弹性完以后有一个控制台，双11做全年压测的时候一般情况下不看这个。</li>
</ul>
</li>
</ul>
<p>个人觉得本文内容总结的相当好,具有很高的参考意义和价值,故做整理,方便阅读!</p>
<p><a href="https://segmentfault.com/a/1190000014088336" target="_blank" rel="noopener">原文链接</a><br><a href="http://dbaplus.cn/news-134-1876-1.html" target="_blank" rel="noopener">参考文章</a>  </p>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>DevOps</tag>
      </tags>
  </entry>
  <entry>
    <title>进程启停自定义脚本</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<p>进程启停自定义脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash </span><br><span class="line"></span><br><span class="line">usage()</span><br><span class="line">&#123; </span><br><span class="line">  echo &quot;Usage: $0 &#123;start|stop|restart|status&#125; [lineid]&quot; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">suffix&#x3D;_stable</span><br><span class="line">LINELIST&#x3D;&quot;1 2 3 4 5 6&quot;</span><br><span class="line">LINK_NUM&#x3D;3</span><br><span class="line">UNAMED_ACTIVE&#x3D;0</span><br><span class="line">PROGRAME_ACTIVE&#x3D;0</span><br><span class="line"></span><br><span class="line">start_line()</span><br><span class="line">&#123;</span><br><span class="line">	IDLIST&#x3D;$LINELIST</span><br><span class="line">	if [ ! -z $1 ]; then</span><br><span class="line">		IDLIST&#x3D;$1</span><br><span class="line">	fi</span><br><span class="line">	SELFID&#x3D;&#96;id -u&#96;</span><br><span class="line">	cd gamed</span><br><span class="line">	for LN in $IDLIST</span><br><span class="line">	do</span><br><span class="line">		PIDS&#x3D;&#96;pgrep -u $SELFID -f &quot;.&#x2F;gs$suffix gs.conf gmserver.conf config&#x2F;gsalias$LN.conf&quot;&#96;</span><br><span class="line">		if [ -z &quot;$PIDS&quot; ]; then</span><br><span class="line">			echo start line $LN</span><br><span class="line">			nohup setsid .&#x2F;gs$suffix gs.conf gmserver.conf config&#x2F;gsalias$LN.conf &amp;&gt;..&#x2F;logs&#x2F;game$LN.log &amp;</span><br><span class="line">			#nohup setsid .&#x2F;gs_asan$suffix gs.conf gmserver.conf config&#x2F;gsalias$LN.conf  &amp;&gt;..&#x2F;logs&#x2F;game$LN.log &amp;</span><br><span class="line">		else</span><br><span class="line">			echo line $LN is already running</span><br><span class="line">		fi</span><br><span class="line">		sleep 1</span><br><span class="line">	done</span><br><span class="line">	cd ..</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">status() </span><br><span class="line">&#123;</span><br><span class="line">	PROGRAME_ACTIVE&#x3D;0;</span><br><span class="line">	for LN in $LINELIST</span><br><span class="line">	do</span><br><span class="line">		check_line $LN</span><br><span class="line">		PROGRAME_ACTIVE&#x3D;&#96;expr $PROGRAME_ACTIVE + $?&#96;;</span><br><span class="line">	done</span><br><span class="line">	check_process zlogd </span><br><span class="line">	PROGRAME_ACTIVE&#x3D;&#96;expr $PROGRAME_ACTIVE + $?&#96;;</span><br><span class="line">	check_process gdeliveryd</span><br><span class="line">	PROGRAME_ACTIVE&#x3D;&#96;expr $PROGRAME_ACTIVE + $?&#96;;</span><br><span class="line">	check_process gamedbd</span><br><span class="line">	PROGRAME_ACTIVE&#x3D;&#96;expr $PROGRAME_ACTIVE + $?&#96;;</span><br><span class="line">	# check_process gonlineinfod</span><br><span class="line">	# PROGRAME_ACTIVE&#x3D;&#96;expr $PROGRAME_ACTIVE + $?&#96;;</span><br><span class="line">	if [ $UNAMED_ACTIVE -eq 1 ]; then</span><br><span class="line">		check_process unamed</span><br><span class="line">		PROGRAME_ACTIVE&#x3D;&#96;expr $PROGRAME_ACTIVE + $?&#96;;</span><br><span class="line">	fi</span><br><span class="line">	check_process glinkd</span><br><span class="line">	PROGRAME_ACTIVE&#x3D;&#96;expr $PROGRAME_ACTIVE + $?&#96;;</span><br><span class="line">	return $PROGRAME_ACTIVE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">check_process()</span><br><span class="line">&#123;</span><br><span class="line">	SELFID&#x3D;&#96;id -u&#96;</span><br><span class="line">	PIDS&#x3D;&#96;pgrep -u $SELFID -f &quot;.&#x2F;$1$suffix.*$1.conf&quot;&#96;</span><br><span class="line">	if [ ! -z &quot;$PIDS&quot; ]; then</span><br><span class="line">		echo service $1 is running, pid $PIDS</span><br><span class="line">		return 1;</span><br><span class="line">	else</span><br><span class="line">		echo service $1 is stopped.</span><br><span class="line">		return 0;</span><br><span class="line">	fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exists()</span><br><span class="line">&#123;</span><br><span class="line">	SELFID&#x3D;&#96;id -u&#96;</span><br><span class="line">	PIDS&#x3D;&#96;pgrep -u $SELFID -f &quot;.&#x2F;$1$suffix.*$1.conf&quot;&#96;</span><br><span class="line">	if [ ! -z &quot;$PIDS&quot; ]; then</span><br><span class="line">		echo service $1 is running, pid $PIDS</span><br><span class="line">		return 1</span><br><span class="line">	fi</span><br><span class="line">	return 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kill_process()</span><br><span class="line">&#123;</span><br><span class="line">	NAME&#x3D;$1</span><br><span class="line">	SIG&#x3D;$2</span><br><span class="line">	SELFID&#x3D;&#96;id -u&#96;</span><br><span class="line">	PIDS&#x3D;&#96;pgrep -u $SELFID -f &quot;.&#x2F;$NAME$suffix.*$NAME.conf&quot;&#96;</span><br><span class="line">	if [ -n &quot;$PIDS&quot; ]; then</span><br><span class="line">		for PID in $PIDS</span><br><span class="line">		do</span><br><span class="line">			kill -$SIG $PID</span><br><span class="line">			echo service $NAME pid $PID is killed.</span><br><span class="line">		done</span><br><span class="line">	else</span><br><span class="line">		echo service $NAME is not running.</span><br><span class="line">	fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">check_line()</span><br><span class="line">&#123;</span><br><span class="line">	SELFID&#x3D;&#96;id -u&#96;</span><br><span class="line">	LN&#x3D;$1</span><br><span class="line">	PIDS&#x3D;&#96;pgrep -u $SELFID -f &quot;.&#x2F;gs$suffix gs.conf gmserver.conf config&#x2F;gsalias$LN.conf&quot;&#96;</span><br><span class="line">	if [ ! -z &quot;$PIDS&quot; ]; then</span><br><span class="line">		echo line $LN is running, pid $PIDS</span><br><span class="line">		return 1;</span><br><span class="line">	else</span><br><span class="line">		echo line $LN is stopped.</span><br><span class="line">		return 0;</span><br><span class="line">	fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kill_line()</span><br><span class="line">&#123;</span><br><span class="line">	SELFID&#x3D;&#96;id -u&#96;</span><br><span class="line">	LN&#x3D;$1</span><br><span class="line">	PIDS&#x3D;&#96;pgrep -u $SELFID -f &quot;.&#x2F;gs$suffix gs.conf gmserver.conf config&#x2F;gsalias$LN.conf&quot;&#96;</span><br><span class="line">	if [ -n &quot;$PIDS&quot; ]; then</span><br><span class="line">		for PID in $PIDS</span><br><span class="line">		do</span><br><span class="line">			kill -9 $PID</span><br><span class="line">			echo line $LN pid $PID is killed.</span><br><span class="line">		done</span><br><span class="line">	else</span><br><span class="line">		echo line $LN is not running.</span><br><span class="line">	fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kill_grc()</span><br><span class="line">&#123;</span><br><span class="line">	kill -9  $(ps -ef|grep grc.jar$suffix |grep -v grep|awk &#39;&#123;print $2&#125;&#39;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">start_grc()</span><br><span class="line">&#123;</span><br><span class="line">	cd grc</span><br><span class="line">	rm -rf .&#x2F;lib</span><br><span class="line">	unzip lib.zip</span><br><span class="line">	rm -rf grc.jar$suffix</span><br><span class="line">	cp grc.jar grc.jar$suffix</span><br><span class="line">	nohup java -jar .&#x2F;grc.jar$suffix  -Xms1G -Xmx2G &gt;&gt;&#x2F;dev&#x2F;null  2&gt;&gt;&#x2F;tmp&#x2F;grc.err$suffix &amp;</span><br><span class="line">	cd ..</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">start()</span><br><span class="line">&#123;</span><br><span class="line">	mkdir -p logs</span><br><span class="line">        export LD_LIBRARY_PATH&#x3D;.:..&#x2F;..&#x2F;lib</span><br><span class="line">	ulimit -c unlimited</span><br><span class="line">	ulimit -n 4096</span><br><span class="line"></span><br><span class="line">	if [ ! -z $1 ]; then</span><br><span class="line">                start_line $1</span><br><span class="line">		return</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	exists zlogd</span><br><span class="line">	if [ $? -eq 0 ]; then</span><br><span class="line">		cd zlogd</span><br><span class="line">		echo &#39;start zlogd service&#39;</span><br><span class="line">		nohup setsid .&#x2F;zlogd$suffix zlogd.conf &amp;&gt;&#x2F;dev&#x2F;null &amp;</span><br><span class="line">		sleep 2</span><br><span class="line">		cd ..</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	exists gdeliveryd</span><br><span class="line">	if [ $? -eq 0 ]; then</span><br><span class="line">		cd gdeliveryd</span><br><span class="line">		echo &#39;start DS service&#39;</span><br><span class="line">		nohup setsid .&#x2F;gdeliveryd$suffix gdeliveryd.conf &amp;&gt;..&#x2F;logs&#x2F;gdelivery.log  &amp;</span><br><span class="line">		#nohup setsid valgrind --log-file&#x3D;..&#x2F;logs&#x2F;valgrind_ds.log .&#x2F;gdeliveryd$suffix gdeliveryd.conf &amp;&gt;..&#x2F;logs&#x2F;gdelivery.log  &amp;</span><br><span class="line">		cd ..</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	exists glinkd</span><br><span class="line">	if [ $? -eq 0 ]; then</span><br><span class="line">		cd glinkd</span><br><span class="line">		echo &#39;start LS service&#39;</span><br><span class="line">		nohup setsid .&#x2F;glinkd$suffix --ccs glinkd.conf &amp;&gt;..&#x2F;logs&#x2F;glinkd.ccs.log  &amp;</span><br><span class="line">		for ((i &#x3D; 1; i &lt;&#x3D; $LINK_NUM; i++))</span><br><span class="line">		do</span><br><span class="line">			nohup setsid .&#x2F;glinkd$suffix --cls -i $i glinkd.conf &amp;&gt;..&#x2F;logs&#x2F;glinkd.cls$i.log  &amp;</span><br><span class="line">		done</span><br><span class="line">		cd ..</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	exists gamedbd</span><br><span class="line">	if [ $? -eq 0 ]; then</span><br><span class="line">		cd gamedbd</span><br><span class="line">		echo &#39;start DB service&#39;</span><br><span class="line">		nohup setsid .&#x2F;gamedbd$suffix gamedbd.conf &amp;&gt;..&#x2F;logs&#x2F;gamedbd.log &amp;</span><br><span class="line">		cd ..</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">	if [ $UNAMED_ACTIVE -eq 1 ]; then</span><br><span class="line">		exists unamed</span><br><span class="line">		if [ $? -eq 0 ]; then</span><br><span class="line">			cd unamed</span><br><span class="line">			echo &#39;start unamed service&#39;</span><br><span class="line">			nohup setsid .&#x2F;unamed$suffix unamed.conf &amp;&gt;..&#x2F;logs&#x2F;unamed.log &amp;</span><br><span class="line">			cd ..</span><br><span class="line">		fi</span><br><span class="line">	fi</span><br><span class="line"></span><br><span class="line">#	exists gonlineinfod</span><br><span class="line">#	if [ $? -eq 0 ]; then</span><br><span class="line">#		cd gonlineinfod</span><br><span class="line">#		echo &#39;start OL service&#39;</span><br><span class="line">#		nohup setsid .&#x2F;gonlineinfod$suffix gonlineinfod.conf &amp;&gt;..&#x2F;logs&#x2F;gonlineinfod.log  &amp;</span><br><span class="line">#		cd ..</span><br><span class="line">#	fi</span><br><span class="line"></span><br><span class="line">	#start_grc</span><br><span class="line"></span><br><span class="line">	start_line</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stop()</span><br><span class="line">&#123;</span><br><span class="line">	if [ ! -z $1 ]; then</span><br><span class="line">                kill_line $1</span><br><span class="line">		return</span><br><span class="line">	fi</span><br><span class="line">	#kill_grc</span><br><span class="line">	kill_process glinkd KILL</span><br><span class="line">	kill_process gdeliveryd KILL</span><br><span class="line">	kill_process gamedbd USR1</span><br><span class="line">	#kill_process gonlineinfod KILL</span><br><span class="line">	if [ $UNAMED_ACTIVE -eq 1 ]; then</span><br><span class="line">		kill_process unamed USR1</span><br><span class="line">	fi</span><br><span class="line">        for LN in $LINELIST</span><br><span class="line">        do</span><br><span class="line">                kill_line $LN</span><br><span class="line">        done</span><br><span class="line">	kill_process zlogd KILL</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">wait()</span><br><span class="line">&#123;</span><br><span class="line">	for (( i&#x3D;0; i&lt;5; i++))</span><br><span class="line">	do</span><br><span class="line">		echo -n &quot;.&quot;</span><br><span class="line">		sleep 0.2</span><br><span class="line">	done</span><br><span class="line">	echo &quot;.&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">restart()</span><br><span class="line">&#123;</span><br><span class="line">        stop $1</span><br><span class="line">	if [ ! -z $1 ]; then</span><br><span class="line">		wait</span><br><span class="line">	else</span><br><span class="line">		PROGRAME_ACTIVE&#x3D;1;</span><br><span class="line">		while [ &quot;$PROGRAME_ACTIVE&quot; !&#x3D; &quot;0&quot; ]</span><br><span class="line">		do</span><br><span class="line">			wait</span><br><span class="line">			status</span><br><span class="line">			echo $PROGRAME_ACTIVE program is running</span><br><span class="line">		done</span><br><span class="line">	fi</span><br><span class="line">        start $1</span><br><span class="line">	wait</span><br><span class="line">	echo &#39;task accomplished&#39;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">case $1 in </span><br><span class="line">start) </span><br><span class="line">        start $2</span><br><span class="line">        ;; </span><br><span class="line">stop)</span><br><span class="line">        stop $2</span><br><span class="line">        ;; </span><br><span class="line">restart)</span><br><span class="line">        restart $2</span><br><span class="line">        ;; </span><br><span class="line">status)</span><br><span class="line">        status </span><br><span class="line">        ;; </span><br><span class="line">*) </span><br><span class="line">        usage </span><br><span class="line">        ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SHELL</category>
      </categories>
      <tags>
        <tag>SHELL</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是RESTful API以及Django RestFramework</title>
    <url>/2020/04/20/index/</url>
    <content><![CDATA[<h2 id="一-什么是RESTful-API以及Django-RestFramework"><a href="#一-什么是RESTful-API以及Django-RestFramework" class="headerlink" title="一. 什么是RESTful API以及Django RestFramework"></a>一. 什么是RESTful API以及Django RestFramework</h2><h3 id="1-协议"><a href="#1-协议" class="headerlink" title="1. 协议"></a>1. 协议</h3><p>API与用户的通信协议，总是使用HTTPS协议。</p>
<h3 id="2-域名"><a href="#2-域名" class="headerlink" title="2. 域名"></a>2. 域名</h3><ul>
<li>应该尽量将API部署在专用域名之下(存在跨域问题): <a href="https://api.example.com" target="_blank" rel="noopener">https://api.example.com</a></li>
<li>如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下: <a href="https://example.org/api/" target="_blank" rel="noopener">https://example.org/api/</a></li>
</ul>
<h3 id="3-版本"><a href="#3-版本" class="headerlink" title="3. 版本"></a>3. 版本</h3><p>应该将API的版本号放入URL: <a href="https://api.example.com/v1/" target="_blank" rel="noopener">https://api.example.com/v1/</a><br>另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。<a href="https://developer.github.com/v3/media/#request-specific-version" target="_blank" rel="noopener">GitHub Developer Guide</a>采用这种做法,跨域时会引发多次请求</p>
<h3 id="4-路径-Endpoint"><a href="#4-路径-Endpoint" class="headerlink" title="4. 路径(Endpoint)"></a>4. 路径(Endpoint)</h3><p>路径又称”终点”（endpoint），表示API的具体网址。<br>在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。<br>举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;api.example.com&#x2F;v1&#x2F;zoos</span><br><span class="line">https:&#x2F;&#x2F;api.example.com&#x2F;v1&#x2F;animals</span><br><span class="line">https:&#x2F;&#x2F;api.example.com&#x2F;v1&#x2F;employees</span><br></pre></td></tr></table></figure>

<h3 id="5-HTTP动词"><a href="#5-HTTP动词" class="headerlink" title="5. HTTP动词"></a>5. HTTP动词</h3><p>对于资源的具体操作类型，由HTTP动词表示。<br>常用的HTTP动词有下面五个(括号里是对应的SQL命令)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET（SELECT）：从服务器取出资源（一项或多项）</span><br><span class="line">POST（CREATE）：在服务器新建一个资源</span><br><span class="line">PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）</span><br><span class="line">PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）</span><br><span class="line">DELETE（DELETE）：从服务器删除资源</span><br></pre></td></tr></table></figure>
<p>还有两个不常用的HTTP动词</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HEAD：获取资源的元数据</span><br><span class="line">OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的</span><br></pre></td></tr></table></figure>
<p>下面是一些栗子:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;zoos：列出所有动物园</span><br><span class="line">POST &#x2F;zoos：新建一个动物园</span><br><span class="line">GET &#x2F;zoos&#x2F;ID：获取某个指定动物园的信息</span><br><span class="line">PUT &#x2F;zoos&#x2F;ID：更新某个指定动物园的信息（提供该动物园的全部信息）</span><br><span class="line">PATCH &#x2F;zoos&#x2F;ID：更新某个指定动物园的信息（提供该动物园的部分信息）</span><br><span class="line">DELETE &#x2F;zoos&#x2F;ID：删除某个动物园</span><br><span class="line">GET &#x2F;zoos&#x2F;ID&#x2F;animals：列出某个指定动物园的所有动物</span><br><span class="line">DELETE &#x2F;zoos&#x2F;ID&#x2F;animals&#x2F;ID：删除某个指定动物园的指定动物</span><br></pre></td></tr></table></figure>

<h3 id="6-过滤信息-Filtering"><a href="#6-过滤信息-Filtering" class="headerlink" title="6. 过滤信息(Filtering)"></a>6. 过滤信息(Filtering)</h3><p>如果记录数量很多,服务器不可能都将它们返回给用户.API应该提供参数,过滤返回结果<br>常见的参数形式如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">?limit&#x3D;10：指定返回记录的数量</span><br><span class="line">?offset&#x3D;10：指定返回记录的开始位置。</span><br><span class="line">?page&#x3D;2&amp;per_page&#x3D;100：指定第几页，以及每页的记录数。</span><br><span class="line">?sortby&#x3D;name&amp;order&#x3D;asc：指定返回结果按照哪个属性排序，以及排序顺序。</span><br><span class="line">?animal_type_id&#x3D;1：指定筛选条件</span><br></pre></td></tr></table></figure>
<p>参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。</p>
<h3 id="7-状态码-Status-Codes"><a href="#7-状态码-Status-Codes" class="headerlink" title="7. 状态码(Status Codes)"></a>7. 状态码(Status Codes)</h3><p>服务器向用户返回的状态码和提示信息，常见的有以下一些(方括号中是该状态码对应的HTTP动词)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。</span><br><span class="line">201 CREATED - [POST&#x2F;PUT&#x2F;PATCH]：用户新建或修改数据成功。</span><br><span class="line">202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）</span><br><span class="line">204 NO CONTENT - [DELETE]：用户删除数据成功。</span><br><span class="line">400 INVALID REQUEST - [POST&#x2F;PUT&#x2F;PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。</span><br><span class="line">401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。</span><br><span class="line">403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。</span><br><span class="line">404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。</span><br><span class="line">406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。</span><br><span class="line">410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。</span><br><span class="line">422 Unprocesable entity - [POST&#x2F;PUT&#x2F;PATCH] 当创建一个对象时，发生一个验证错误。</span><br><span class="line">500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功</span><br></pre></td></tr></table></figure>
<p>注意: 状态码的完全列表参见<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html" target="_blank" rel="noopener">这里</a></p>
<h3 id="8-错误处理-Error-handling"><a href="#8-错误处理-Error-handling" class="headerlink" title="8. 错误处理(Error handling)"></a>8. 错误处理(Error handling)</h3><p>如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    error: &quot;Invalid API key&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-返回结果"><a href="#9-返回结果" class="headerlink" title="9. 返回结果"></a>9. 返回结果</h3><p>针对不同操作，服务器向用户返回的结果应该符合以下规范</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;collection：返回资源对象的列表（数组）</span><br><span class="line">GET &#x2F;collection&#x2F;resource：返回单个资源对象</span><br><span class="line">POST &#x2F;collection：返回新生成的资源对象</span><br><span class="line">PUT &#x2F;collection&#x2F;resource：返回完整的资源对象</span><br><span class="line">PATCH &#x2F;collection&#x2F;resource：返回完整的资源对象</span><br><span class="line">DELETE &#x2F;collection&#x2F;resource：返回一个空文档</span><br></pre></td></tr></table></figure>

<h3 id="10-Hypermedia-API"><a href="#10-Hypermedia-API" class="headerlink" title="10. Hypermedia API"></a>10. Hypermedia API</h3><p>RESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。<br>比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;link&quot;: &#123;</span><br><span class="line">  &quot;rel&quot;:   &quot;collection https:&#x2F;&#x2F;www.example.com&#x2F;zoos&quot;,</span><br><span class="line">  &quot;href&quot;:  &quot;https:&#x2F;&#x2F;api.example.com&#x2F;zoos&quot;,</span><br><span class="line">  &quot;title&quot;: &quot;List of zoos&quot;,</span><br><span class="line">  &quot;type&quot;:  &quot;application&#x2F;vnd.yourformat+json&quot;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。<br>Hypermedia API的设计被称为HATEOAS。Github的API就是这种设计，访问api.github.com会得到一个所有可用API的网址列表。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;current_user_url&quot;: &quot;https:&#x2F;&#x2F;api.github.com&#x2F;user&quot;,</span><br><span class="line">  &quot;authorizations_url&quot;: &quot;https:&#x2F;&#x2F;api.github.com&#x2F;authorizations&quot;,</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面可以看到，如果想获取当前用户的信息，应该去访问\api.github.com/user，然后就得到了下面结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;message&quot;: &quot;Requires authentication&quot;,</span><br><span class="line">  &quot;documentation_url&quot;: &quot;https:&#x2F;&#x2F;developer.github.com&#x2F;v3&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码表示，服务器给出了提示信息，以及文档的网址</p>
<h3 id="11-其他"><a href="#11-其他" class="headerlink" title="11. 其他"></a>11. 其他</h3><ul>
<li>API的身份认证应该使用<a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="noopener">OAuth 2.0</a>框架。</li>
<li>服务器返回的数据格式，应该尽量使用JSON，避免使用XML。</li>
</ul>
<p><a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html" target="_blank" rel="noopener">RESTful API 设计指南 - 阮一峰的网络日志</a><br><a href="https://github.com/aisuhua/restful-api-design-references" target="_blank" rel="noopener">GitHub - aisuhua/restful-api-design-references: RESTful API 设计参考文献列表</a>  </p>
<h2 id="二-基于Django的实现"><a href="#二-基于Django的实现" class="headerlink" title="二. 基于Django的实现"></a>二. 基于Django的实现</h2><h3 id="2-1-路由系统"><a href="#2-1-路由系统" class="headerlink" title="2.1 路由系统"></a>2.1 路由系统</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from app01 import views</span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    url(r&#39;^users&#39;, views.UserView.as_view())</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="2-2-CBV试图"><a href="#2-2-CBV试图" class="headerlink" title="2.2 CBV试图"></a>2.2 CBV试图</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class UserView(View):</span><br><span class="line">    def get(self, request, *args, **kwargs):</span><br><span class="line">        result &#x3D; &#123;&quot;status&quot;: True, &quot;data&quot;: &quot;This is a get request&quot;, &quot;msg&quot;: None, &quot;code&quot;: 2000&#125;</span><br><span class="line">        return JsonResponse(result, status&#x3D;200)</span><br><span class="line"></span><br><span class="line">    def post(self, request, *args, **kwargs):</span><br><span class="line">        result &#x3D; &#123;&quot;status&quot;: True, &quot;data&quot;: &quot;This is a post request&quot;, &quot;msg&quot;: None, &quot;code&quot;: 2000&#125;</span><br><span class="line">        return JsonResponse(result, status&#x3D;200)</span><br></pre></td></tr></table></figure>

<h2 id="三-基于Django-Rest-Framework-框架实现"><a href="#三-基于Django-Rest-Framework-框架实现" class="headerlink" title="三. 基于Django Rest Framework 框架实现"></a>三. 基于Django Rest Framework 框架实现</h2><h3 id="3-1-基本流程"><a href="#3-1-基本流程" class="headerlink" title="3.1 基本流程"></a>3.1 基本流程</h3><p>路由:URL.py</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.conf.urls import url</span><br><span class="line">from app01 import views</span><br><span class="line"></span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    url(r&#39;^index&#39;, views.IndexView.as_view())</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>试图: views.py</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from rest_framework.views import APIView</span><br><span class="line">from rest_framework.response import Response</span><br><span class="line"></span><br><span class="line">class IndexView(APIView):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    请求到来之后，都要执行dispatch方法，dispatch方法根据请求方式不同触发反射 get&#x2F;post&#x2F;put 等方法</span><br><span class="line">    注意：APIView中的dispatch方法有好多好多的功能</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def dispatch(self, request, *args, **kwargs):</span><br><span class="line">        return super().dispatch(request, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">    def get(self, request, *args, **kwargs):</span><br><span class="line">        return Response(&#39;GET请求，响应内容&#39;)</span><br><span class="line"></span><br><span class="line">    def post(self, request, *args, **kwargs):</span><br><span class="line">        return Response(&#39;POST请求，响应内容&#39;)</span><br><span class="line"></span><br><span class="line">    def put(self, request, *args, **kwargs):</span><br><span class="line">        return Response(&#39;PUT请求，响应内容&#39;)</span><br></pre></td></tr></table></figure>
<p>⚠️ : 以上是Django rest framework框架基本流程,重要的功能是在APIView的dispatch中触发,也是框架的源码入口</p>
<h3 id="3-2-认证和授权"><a href="#3-2-认证和授权" class="headerlink" title="3.2 认证和授权"></a>3.2 认证和授权</h3><h4 id="3-2-1-基于token的验证"><a href="#3-2-1-基于token的验证" class="headerlink" title="3.2.1 基于token的验证"></a>3.2.1 基于token的验证</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">urls.py</span><br><span class="line"></span><br><span class="line">from django.contrib import admin</span><br><span class="line">from django.urls import path</span><br><span class="line">from django.conf.urls import url, include</span><br><span class="line"></span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    url(r&#39;^admin&#x2F;&#39;, admin.site.urls),</span><br><span class="line">    url(r&#39;^api&#x2F;(?P&lt;version&gt;\w+)&#x2F;&#39;, include(&#39;app01.urls&#39;)),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">$ cat app01&#x2F;urls.py </span><br><span class="line">from django.conf.urls import url</span><br><span class="line">from app01 import views</span><br><span class="line"></span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    url(r&#39;^auth&#x2F;$&#39;, views.AuthView.as_view()),</span><br><span class="line">    url(r&#39;^user&#x2F;$&#39;, views.UserView.as_view()),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat models.py </span><br><span class="line">from django.db import models</span><br><span class="line"></span><br><span class="line">class UserInfo(models.Model):</span><br><span class="line">    username &#x3D; models.CharField(max_length&#x3D;32)</span><br><span class="line">    password &#x3D; models.CharField(max_length&#x3D;64)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class UserToken(models.Model):</span><br><span class="line">    user &#x3D; models.OneToOneField(&#39;UserInfo&#39;, on_delete&#x3D;True)</span><br><span class="line">    token &#x3D; models.CharField(max_length&#x3D;64)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat views.py</span><br><span class="line">from django.shortcuts import render, HttpResponse</span><br><span class="line"></span><br><span class="line"># Create your views here.</span><br><span class="line">from django.http import JsonResponse</span><br><span class="line">from rest_framework.views import APIView</span><br><span class="line">from app01 import models</span><br><span class="line">import uuid</span><br><span class="line"></span><br><span class="line">class AuthView(APIView):</span><br><span class="line">    authentication_classes &#x3D; []    # 登录认证接口覆盖默认的toekn认证类</span><br><span class="line"></span><br><span class="line">    def post(self, request, *args, **kwargs):</span><br><span class="line">        response &#x3D; &#123;&#39;code&#39;: 1000&#125;</span><br><span class="line">        user &#x3D; request.data.get(&#39;username&#39;)</span><br><span class="line">        pwd &#x3D; request.data.get(&#39;password&#39;)</span><br><span class="line"></span><br><span class="line">        obj &#x3D; models.UserInfo.objects.filter(username&#x3D;user, password&#x3D;pwd).first()</span><br><span class="line">        if not obj:</span><br><span class="line">            response[&#39;code&#39;] &#x3D; 1001</span><br><span class="line">            response[&#39;msg&#39;] &#x3D; &#39;用户或密码错误&#39;</span><br><span class="line">            return JsonResponse(response, json_dumps_params&#x3D;&#123;&#39;ensure_ascii&#39;: False&#125;)</span><br><span class="line"></span><br><span class="line">        try:</span><br><span class="line">            token &#x3D; str(uuid.uuid4())</span><br><span class="line">            models.UserToken.objects.update_or_create(user&#x3D;obj, defaults&#x3D;&#123;&quot;token&quot;: token&#125;)</span><br><span class="line">            response[&#39;token&#39;] &#x3D; token</span><br><span class="line">        except Exception as e:</span><br><span class="line">            print(&quot;Error: &quot;, e)</span><br><span class="line">        return JsonResponse(response, json_dumps_params&#x3D;&#123;&#39;ensure_ascii&#39;: False&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class UserView(APIView):</span><br><span class="line">    def get(self, request, *args, **kwargs):</span><br><span class="line">        print(request.user)</span><br><span class="line">        print(request.auth)</span><br><span class="line">        return HttpResponse(&#39;user.get: %s&#39; % request.user)</span><br><span class="line"></span><br><span class="line">    def post(self, request, *args, **kwargs):</span><br><span class="line">        return HttpResponse(&#39;user.post&#39;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat app01&#x2F;utils&#x2F;auth.py</span><br><span class="line"></span><br><span class="line">from rest_framework.authentication import BaseAuthentication</span><br><span class="line">from rest_framework.exceptions import AuthenticationFailed</span><br><span class="line">from app01 import models</span><br><span class="line"></span><br><span class="line">class TokenAuthtication(BaseAuthentication):</span><br><span class="line">    def authenticate(self, request):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :param request:</span><br><span class="line">        :return:</span><br><span class="line">        (user,auth) 表示认证成功,并将元组分别赋值给request.user&#x2F;request.auth</span><br><span class="line">        :raise AuthenticationFailed(&#39;认证失败&#39;)  表示认证失败</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">        token &#x3D; request.query_params.get(&#39;token&#39;)</span><br><span class="line">        if not token:</span><br><span class="line">            raise AuthenticationFailed(&quot;用户Token未携带&quot;)</span><br><span class="line"></span><br><span class="line">        token_obj &#x3D; models.UserToken.objects.filter(token&#x3D;token).first()</span><br><span class="line">        if not token_obj:</span><br><span class="line">            raise AuthenticationFailed(&quot;Token已失效或错误&quot;)</span><br><span class="line">        return (token_obj.user.username, token_obj)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat settings.py</span><br><span class="line"></span><br><span class="line">REST_FRAMEWORK &#x3D; &#123;</span><br><span class="line">    &#39;DEFAULT_AUTHENTICATION_CLASSES&#39;: [&#39;app01.utils.auth.TokenAuthtication&#39;, ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>验证:</p>
<ol>
<li>首先在数据库中构造请求登录的用户名密码</li>
<li>构造数据获取token信息<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl -X POST \</span><br><span class="line">&gt;   http:&#x2F;&#x2F;127.0.0.1:8001&#x2F;api&#x2F;v1&#x2F;auth&#x2F; \</span><br><span class="line">&gt;   -H &#39;Cache-Control: no-cache&#39; \</span><br><span class="line">&gt;   -H &#39;Content-Type: application&#x2F;json&#39; \</span><br><span class="line">&gt;   -H &#39;Postman-Token: 8439ce0a-94ff-3970-c8c2-4c6bc200bb4f&#39; \</span><br><span class="line">&gt;   -d &#39;&#123;&quot;username&quot;: &quot;eric&quot;,&quot;password&quot;:&quot;123&quot;&#125;&#39;</span><br><span class="line">返回:</span><br><span class="line">&#123;&quot;code&quot;: 1000, &quot;token&quot;: &quot;4c90f696-008b-4e30-86fa-4b00b6fc9237&quot;&#125;</span><br></pre></td></tr></table></figure></li>
<li>携带token访问user接口,获取用户信息<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;   &#39;http:&#x2F;&#x2F;127.0.0.1:8001&#x2F;api&#x2F;v1&#x2F;user&#x2F;?token&#x3D;4c90f696-008b-4e30-86fa-4b00b6fc9237&#39; \</span><br><span class="line">&gt;   -H &#39;Cache-Control: no-cache&#39; \</span><br><span class="line">&gt;   -H &#39;Postman-Token: 1b4125ad-7ad1-1cca-70fd-6a00cca16d96&#39;</span><br><span class="line">返回:</span><br><span class="line">user.get: eric</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="3-2-2-基于请求头认证"><a href="#3-2-2-基于请求头认证" class="headerlink" title="3.2.2 基于请求头认证"></a>3.2.2 基于请求头认证</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat urls.py</span><br><span class="line"></span><br><span class="line">from django.contrib import admin</span><br><span class="line">from django.urls import path</span><br><span class="line">from django.conf.urls import url, include</span><br><span class="line"></span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    url(r&#39;^admin&#x2F;&#39;, admin.site.urls),</span><br><span class="line">    url(r&#39;^api&#x2F;(?P&lt;version&gt;\w+)&#x2F;&#39;, include(&#39;app01.urls&#39;)),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">$ cat app01&#x2F;urls.py </span><br><span class="line">from django.conf.urls import url</span><br><span class="line">from app01 import views</span><br><span class="line"></span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    url(r&#39;^auth&#x2F;$&#39;, views.AuthView.as_view()),</span><br><span class="line">    url(r&#39;^user&#x2F;$&#39;, views.UserView.as_view()),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat app01&#x2F;utils&#x2F;auth.py</span><br><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># __author__ &#x3D; &quot;shuke&quot;</span><br><span class="line"># Date: 2018&#x2F;6&#x2F;1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">from rest_framework.authentication import BaseAuthentication</span><br><span class="line">from rest_framework.exceptions import AuthenticationFailed</span><br><span class="line">from rest_framework import exceptions</span><br><span class="line">from app01 import models</span><br><span class="line"></span><br><span class="line">class HeaderAuthentication(BaseAuthentication):</span><br><span class="line">    def authenticate(self, request):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        用户认证，如果验证成功后返回元组： (用户,用户Token)</span><br><span class="line">        :param request:</span><br><span class="line">        :return:</span><br><span class="line">            None,表示跳过该验证；</span><br><span class="line">                如果跳过了所有认证，默认用户和Token和使用配置文件进行设置</span><br><span class="line">                self._authenticator &#x3D; None</span><br><span class="line">                if api_settings.UNAUTHENTICATED_USER:</span><br><span class="line">                    self.user &#x3D; api_settings.UNAUTHENTICATED_USER()</span><br><span class="line">                else:</span><br><span class="line">                    self.user &#x3D; None</span><br><span class="line"></span><br><span class="line">                if api_settings.UNAUTHENTICATED_TOKEN:</span><br><span class="line">                    self.auth &#x3D; api_settings.UNAUTHENTICATED_TOKEN()</span><br><span class="line">                else:</span><br><span class="line">                    self.auth &#x3D; None</span><br><span class="line">            (user,token)表示验证通过并设置用户名和Token；</span><br><span class="line">            AuthenticationFailed异常</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        import base64</span><br><span class="line">        import uuid</span><br><span class="line">        auth &#x3D; request.META.get(&#39;HTTP_AUTHORIZATION&#39;, b&#39;&#39;)</span><br><span class="line">        if auth:</span><br><span class="line">            auth &#x3D; auth.encode(&#39;utf-8&#39;)</span><br><span class="line">        auth &#x3D; auth.split()</span><br><span class="line">        if not auth or auth[0].lower() !&#x3D; b&#39;basic&#39;:</span><br><span class="line">            raise exceptions.AuthenticationFailed(&#39;验证失败&#39;)</span><br><span class="line">        if len(auth) !&#x3D; 2:</span><br><span class="line">            raise exceptions.AuthenticationFailed(&#39;验证失败&#39;)</span><br><span class="line">        username, part, password &#x3D; base64.b64decode(auth[1]).decode(&#39;utf-8&#39;).partition(&#39;:&#39;)</span><br><span class="line">        try:</span><br><span class="line">            obj &#x3D; models.UserInfo.objects.filter(username&#x3D;username, password&#x3D;password).first()</span><br><span class="line">            if not obj:</span><br><span class="line">                raise exceptions.AuthenticationFailed(&#39;用户名或密码错误&#39;)</span><br><span class="line">            token &#x3D; str(uuid.uuid4())</span><br><span class="line">            token_obj, status &#x3D; models.UserToken.objects.update_or_create(user&#x3D;obj, defaults&#x3D;&#123;&quot;token&quot;: token&#125;)</span><br><span class="line">            return (token_obj.user.username, token_obj)</span><br><span class="line">        except Exception as e:</span><br><span class="line">            print(&quot;Error: &quot;, e)</span><br><span class="line"></span><br><span class="line">    def authenticate_header(self, request):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Return a string to be used as the value of the &#96;WWW-Authenticate&#96;</span><br><span class="line">        header in a &#96;401 Unauthenticated&#96; response, or &#96;None&#96; if the</span><br><span class="line">        authentication scheme should return &#96;403 Permission Denied&#96; responses.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return &#39;Basic realm&#x3D;api&#39;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat views.py</span><br><span class="line">from django.shortcuts import render, HttpResponse</span><br><span class="line"></span><br><span class="line"># Create your views here.</span><br><span class="line">from django.http import JsonResponse</span><br><span class="line">from rest_framework.views import APIView</span><br><span class="line">from app01.utils.auth import HeaderAuthentication</span><br><span class="line">from app01 import models</span><br><span class="line">import uuid</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class AuthView(APIView):</span><br><span class="line">    authentication_classes &#x3D; []</span><br><span class="line"></span><br><span class="line">    def post(self, request, *args, **kwargs):</span><br><span class="line">        response &#x3D; &#123;&#39;code&#39;: 1000&#125;</span><br><span class="line">        user &#x3D; request.data.get(&#39;username&#39;)</span><br><span class="line">        pwd &#x3D; request.data.get(&#39;password&#39;)</span><br><span class="line"></span><br><span class="line">        obj &#x3D; models.UserInfo.objects.filter(username&#x3D;user, password&#x3D;pwd).first()</span><br><span class="line">        if not obj:</span><br><span class="line">            response[&#39;code&#39;] &#x3D; 1001</span><br><span class="line">            response[&#39;msg&#39;] &#x3D; &#39;用户或密码错误&#39;</span><br><span class="line">            return JsonResponse(response, json_dumps_params&#x3D;&#123;&#39;ensure_ascii&#39;: False&#125;)</span><br><span class="line"></span><br><span class="line">        try:</span><br><span class="line">            token &#x3D; str(uuid.uuid4())</span><br><span class="line">            models.UserToken.objects.update_or_create(user&#x3D;obj, defaults&#x3D;&#123;&quot;token&quot;: token&#125;)</span><br><span class="line">            response[&#39;token&#39;] &#x3D; token</span><br><span class="line">        except Exception as e:</span><br><span class="line">            print(&quot;Error: &quot;, e)</span><br><span class="line">        return JsonResponse(response, json_dumps_params&#x3D;&#123;&#39;ensure_ascii&#39;: False&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class UserView(APIView):</span><br><span class="line">    authentication_classes &#x3D; [HeaderAuthentication, ]</span><br><span class="line"></span><br><span class="line">    def get(self, request, *args, **kwargs):</span><br><span class="line">        print(request.user)</span><br><span class="line">        print(request.auth)</span><br><span class="line">        return HttpResponse(&#39;user.get: %s,token: %s&#39; % (request.user, request.auth))</span><br><span class="line"></span><br><span class="line">    def post(self, request, *args, **kwargs):</span><br><span class="line">        return HttpResponse(&#39;user.post&#39;)</span><br></pre></td></tr></table></figure>
<p>验证:</p>
<ol>
<li>首先在数据库中构造请求登录的用户名密码</li>
<li>构造数据获取token信息,建议使用postman进行构造测试<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl -X GET \</span><br><span class="line">  http:&#x2F;&#x2F;127.0.0.1:8001&#x2F;api&#x2F;v1&#x2F;user&#x2F; \</span><br><span class="line">  -H &#39;Authorization: Basic c2h1a2U6MTIz&#39; \</span><br><span class="line">  -H &#39;Cache-Control: no-cache&#39; \</span><br><span class="line">  -H &#39;Postman-Token: ba3f99ce-da6a-7e5f-3e0b-3c79129ecca1&#39;</span><br><span class="line">返回:</span><br><span class="line">user.get: shuke,token: 2d3af34a-1598-4d5a-af56-7f29a706a26e</span><br></pre></td></tr></table></figure>
<h4 id="3-2-3-多个认证规则"><a href="#3-2-3-多个认证规则" class="headerlink" title="3.2.3 多个认证规则"></a>3.2.3 多个认证规则</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat urls.py</span><br><span class="line"></span><br><span class="line">from django.contrib import admin</span><br><span class="line">from django.urls import path</span><br><span class="line">from django.conf.urls import url, include</span><br><span class="line"></span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    url(r&#39;^admin&#x2F;&#39;, admin.site.urls),</span><br><span class="line">    url(r&#39;^api&#x2F;(?P&lt;version&gt;\w+)&#x2F;&#39;, include(&#39;app01.urls&#39;)),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">$ cat app01&#x2F;urls.py </span><br><span class="line">from django.conf.urls import url</span><br><span class="line">from app01 import views</span><br><span class="line"></span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    url(r&#39;^auth&#x2F;$&#39;, views.AuthView.as_view()),</span><br><span class="line">    url(r&#39;^user&#x2F;$&#39;, views.UserView.as_view()),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat app01&#x2F;utils&#x2F;auth.py</span><br><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># __author__ &#x3D; &quot;shuke&quot;</span><br><span class="line"># Date: 2018&#x2F;6&#x2F;1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">from rest_framework.authentication import BaseAuthentication</span><br><span class="line">from rest_framework.exceptions import AuthenticationFailed</span><br><span class="line">from rest_framework import exceptions</span><br><span class="line">from app01 import models</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class TokenAuthtication(BaseAuthentication):</span><br><span class="line">    def authenticate(self, request):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">        :param request:</span><br><span class="line">        :return:</span><br><span class="line">        (user,auth) 表示认证成功,并将元组分别赋值给request.user&#x2F;request.auth</span><br><span class="line">        :raise AuthenticationFailed(&#39;认证失败&#39;)  表示认证失败</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">        token &#x3D; request.query_params.get(&#39;token&#39;)</span><br><span class="line">        if not token:</span><br><span class="line">            raise AuthenticationFailed(&quot;用户Token未携带&quot;)</span><br><span class="line"></span><br><span class="line">        token_obj &#x3D; models.UserToken.objects.filter(token&#x3D;token).first()</span><br><span class="line">        if not token_obj:</span><br><span class="line">            raise AuthenticationFailed(&quot;Token已失效或错误&quot;)</span><br><span class="line">        return (token_obj.user.username, token_obj)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class HeaderAuthentication(BaseAuthentication):</span><br><span class="line">    def authenticate(self, request):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        用户认证，如果验证成功后返回元组： (用户,用户Token)</span><br><span class="line">        :param request:</span><br><span class="line">        :return:</span><br><span class="line">            None,表示跳过该验证；</span><br><span class="line">                如果跳过了所有认证，默认用户和Token和使用配置文件进行设置</span><br><span class="line">                self._authenticator &#x3D; None</span><br><span class="line">                if api_settings.UNAUTHENTICATED_USER:</span><br><span class="line">                    self.user &#x3D; api_settings.UNAUTHENTICATED_USER()</span><br><span class="line">                else:</span><br><span class="line">                    self.user &#x3D; None</span><br><span class="line"></span><br><span class="line">                if api_settings.UNAUTHENTICATED_TOKEN:</span><br><span class="line">                    self.auth &#x3D; api_settings.UNAUTHENTICATED_TOKEN()</span><br><span class="line">                else:</span><br><span class="line">                    self.auth &#x3D; None</span><br><span class="line">            (user,token)表示验证通过并设置用户名和Token；</span><br><span class="line">            AuthenticationFailed异常</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        import base64</span><br><span class="line">        import uuid</span><br><span class="line">        auth &#x3D; request.META.get(&#39;HTTP_AUTHORIZATION&#39;, b&#39;&#39;)</span><br><span class="line">        if auth:</span><br><span class="line">            auth &#x3D; auth.encode(&#39;utf-8&#39;)</span><br><span class="line">        auth &#x3D; auth.split()</span><br><span class="line">        if not auth or auth[0].lower() !&#x3D; b&#39;basic&#39;:</span><br><span class="line">            raise exceptions.AuthenticationFailed(&#39;验证失败&#39;)</span><br><span class="line">        if len(auth) !&#x3D; 2:</span><br><span class="line">            raise exceptions.AuthenticationFailed(&#39;验证失败&#39;)</span><br><span class="line">        username, part, password &#x3D; base64.b64decode(auth[1]).decode(&#39;utf-8&#39;).partition(&#39;:&#39;)</span><br><span class="line">        try:</span><br><span class="line">            obj &#x3D; models.UserInfo.objects.filter(username&#x3D;username, password&#x3D;password).first()</span><br><span class="line">            if not obj:</span><br><span class="line">                raise exceptions.AuthenticationFailed(&#39;用户名或密码错误&#39;)</span><br><span class="line">            token &#x3D; str(uuid.uuid4())</span><br><span class="line">            token_obj, status &#x3D; models.UserToken.objects.update_or_create(user&#x3D;obj, defaults&#x3D;&#123;&quot;token&quot;: token&#125;)</span><br><span class="line">            return (token_obj.user.username, token_obj)</span><br><span class="line">        except Exception as e:</span><br><span class="line">            print(&quot;Error: &quot;, e)</span><br><span class="line"></span><br><span class="line">    def authenticate_header(self, request):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Return a string to be used as the value of the &#96;WWW-Authenticate&#96;</span><br><span class="line">        header in a &#96;401 Unauthenticated&#96; response, or &#96;None&#96; if the</span><br><span class="line">        authentication scheme should return &#96;403 Permission Denied&#96; responses.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return &#39;Basic realm&#x3D;api&#39;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat views.py</span><br><span class="line">from django.shortcuts import render, HttpResponse</span><br><span class="line"></span><br><span class="line"># Create your views here.</span><br><span class="line">from django.http import JsonResponse</span><br><span class="line">from rest_framework.views import APIView</span><br><span class="line">from app01.utils.auth import HeaderAuthentication, TokenAuthtication</span><br><span class="line">from app01 import models</span><br><span class="line">import uuid</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class AuthView(APIView):</span><br><span class="line">    authentication_classes &#x3D; []</span><br><span class="line"></span><br><span class="line">    def post(self, request, *args, **kwargs):</span><br><span class="line">        response &#x3D; &#123;&#39;code&#39;: 1000&#125;</span><br><span class="line">        user &#x3D; request.data.get(&#39;username&#39;)</span><br><span class="line">        pwd &#x3D; request.data.get(&#39;password&#39;)</span><br><span class="line"></span><br><span class="line">        obj &#x3D; models.UserInfo.objects.filter(username&#x3D;user, password&#x3D;pwd).first()</span><br><span class="line">        if not obj:</span><br><span class="line">            response[&#39;code&#39;] &#x3D; 1001</span><br><span class="line">            response[&#39;msg&#39;] &#x3D; &#39;用户或密码错误&#39;</span><br><span class="line">            return JsonResponse(response, json_dumps_params&#x3D;&#123;&#39;ensure_ascii&#39;: False&#125;)</span><br><span class="line"></span><br><span class="line">        try:</span><br><span class="line">            token &#x3D; str(uuid.uuid4())</span><br><span class="line">            models.UserToken.objects.update_or_create(user&#x3D;obj, defaults&#x3D;&#123;&quot;token&quot;: token&#125;)</span><br><span class="line">            response[&#39;token&#39;] &#x3D; token</span><br><span class="line">        except Exception as e:</span><br><span class="line">            print(&quot;Error: &quot;, e)</span><br><span class="line">        return JsonResponse(response, json_dumps_params&#x3D;&#123;&#39;ensure_ascii&#39;: False&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class UserView(APIView):</span><br><span class="line">    authentication_classes &#x3D; [HeaderAuthentication, TokenAuthtication]</span><br><span class="line"></span><br><span class="line">    def get(self, request, *args, **kwargs):</span><br><span class="line">        print(request.user)</span><br><span class="line">        print(request.auth)</span><br><span class="line">        return HttpResponse(&#39;user.get: %s,token: %s&#39; % (request.user, request.auth))</span><br><span class="line"></span><br><span class="line">    def post(self, request, *args, **kwargs):</span><br><span class="line">        return HttpResponse(&#39;user.post&#39;)</span><br></pre></td></tr></table></figure>
验证:</li>
<li>首先在数据库中构造请求登录的用户名密码</li>
<li>构造数据获取token信息,建议使用postman进行构造测试<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl -X GET \</span><br><span class="line">  http:&#x2F;&#x2F;127.0.0.1:8001&#x2F;api&#x2F;v1&#x2F;user&#x2F; \</span><br><span class="line">  -H &#39;Authorization: Basic c2h1a2U6MTIz&#39; \</span><br><span class="line">  -H &#39;Cache-Control: no-cache&#39; \</span><br><span class="line">  -H &#39;Postman-Token: f91805b7-c742-b713-0010-c75cdbfbb24a&#39;</span><br><span class="line">返回:</span><br><span class="line">user.get: shuke,token: 9c3ca96a-ac03-4207-aaec-20433bae6058</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="3-2-4-认证和权限"><a href="#3-2-4-认证和权限" class="headerlink" title="3.2.4 认证和权限"></a>3.2.4 认证和权限</h4><p>路由</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat urls.py</span><br><span class="line"></span><br><span class="line">from django.contrib import admin</span><br><span class="line">from django.urls import path</span><br><span class="line">from django.conf.urls import url, include</span><br><span class="line"></span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    url(r&#39;^admin&#x2F;&#39;, admin.site.urls),</span><br><span class="line">    url(r&#39;^api&#x2F;(?P&lt;version&gt;\w+)&#x2F;&#39;, include(&#39;app01.urls&#39;)),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">$ cat app01&#x2F;urls.py </span><br><span class="line">from django.conf.urls import url</span><br><span class="line">from app01 import views</span><br><span class="line"></span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    url(r&#39;^auth&#x2F;$&#39;, views.AuthView.as_view()),</span><br><span class="line">    url(r&#39;^user&#x2F;$&#39;, views.UserView.as_view()),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>model</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.db import models</span><br><span class="line"></span><br><span class="line"># Create your models here.</span><br><span class="line">from django.db import models</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class UserInfo(models.Model):</span><br><span class="line">    user_type_choices &#x3D; (</span><br><span class="line">        (1, &#39;普通用户&#39;),</span><br><span class="line">        (2, &#39;管理员&#39;),</span><br><span class="line">        (3, &#39;超级管理员&#39;),</span><br><span class="line">    )</span><br><span class="line">    username &#x3D; models.CharField(max_length&#x3D;32)</span><br><span class="line">    password &#x3D; models.CharField(max_length&#x3D;64)</span><br><span class="line">    user_type &#x3D; models.IntegerField(choices&#x3D;user_type_choices, default&#x3D;1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class UserToken(models.Model):</span><br><span class="line">    user &#x3D; models.OneToOneField(&#39;UserInfo&#39;, on_delete&#x3D;True)</span><br><span class="line">    token &#x3D; models.CharField(max_length&#x3D;64)</span><br></pre></td></tr></table></figure>
<p>认证</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat app01&#x2F;utils&#x2F;auth.py</span><br><span class="line"></span><br><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># __author__ &#x3D; &quot;shuke&quot;</span><br><span class="line"># Date: 2018&#x2F;6&#x2F;1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">from rest_framework.authentication import BaseAuthentication</span><br><span class="line">from rest_framework.exceptions import AuthenticationFailed</span><br><span class="line">from rest_framework import exceptions</span><br><span class="line">from app01 import models</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class TokenAuthtication(BaseAuthentication):</span><br><span class="line">    def authenticate(self, request):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">        :param request:</span><br><span class="line">        :return:</span><br><span class="line">        (user,auth) 表示认证成功,并将元组分别赋值给request.user&#x2F;request.auth</span><br><span class="line">        :raise AuthenticationFailed(&#39;认证失败&#39;)  表示认证失败</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">        token &#x3D; request.query_params.get(&#39;token&#39;)</span><br><span class="line">        if not token:</span><br><span class="line">            raise AuthenticationFailed(&quot;用户Token未携带&quot;)</span><br><span class="line"></span><br><span class="line">        token_obj &#x3D; models.UserToken.objects.filter(token&#x3D;token).first()</span><br><span class="line">        if not token_obj:</span><br><span class="line">            raise AuthenticationFailed(&quot;Token已失效或错误&quot;)</span><br><span class="line">        return (token_obj.user.username, token_obj)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class HeaderAuthentication(BaseAuthentication):</span><br><span class="line">    def authenticate(self, request):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        用户认证，如果验证成功后返回元组： (用户,用户Token)</span><br><span class="line">        :param request:</span><br><span class="line">        :return:</span><br><span class="line">            None,表示跳过该验证；</span><br><span class="line">                如果跳过了所有认证，默认用户和Token和使用配置文件进行设置</span><br><span class="line">                self._authenticator &#x3D; None</span><br><span class="line">                if api_settings.UNAUTHENTICATED_USER:</span><br><span class="line">                    self.user &#x3D; api_settings.UNAUTHENTICATED_USER()</span><br><span class="line">                else:</span><br><span class="line">                    self.user &#x3D; None</span><br><span class="line"></span><br><span class="line">                if api_settings.UNAUTHENTICATED_TOKEN:</span><br><span class="line">                    self.auth &#x3D; api_settings.UNAUTHENTICATED_TOKEN()</span><br><span class="line">                else:</span><br><span class="line">                    self.auth &#x3D; None</span><br><span class="line">            (user,token)表示验证通过并设置用户名和Token；</span><br><span class="line">            AuthenticationFailed异常</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        import base64</span><br><span class="line">        import uuid</span><br><span class="line">        auth &#x3D; request.META.get(&#39;HTTP_AUTHORIZATION&#39;, b&#39;&#39;)</span><br><span class="line">        if auth:</span><br><span class="line">            auth &#x3D; auth.encode(&#39;utf-8&#39;)</span><br><span class="line">        auth &#x3D; auth.split()</span><br><span class="line">        if not auth or auth[0].lower() !&#x3D; b&#39;basic&#39;:</span><br><span class="line">            raise exceptions.AuthenticationFailed(&#39;验证失败&#39;)</span><br><span class="line">        if len(auth) !&#x3D; 2:</span><br><span class="line">            raise exceptions.AuthenticationFailed(&#39;验证失败&#39;)</span><br><span class="line">        username, part, password &#x3D; base64.b64decode(auth[1]).decode(&#39;utf-8&#39;).partition(&#39;:&#39;)</span><br><span class="line">        try:</span><br><span class="line">            obj &#x3D; models.UserInfo.objects.filter(username&#x3D;username, password&#x3D;password).first()</span><br><span class="line">            if not obj:</span><br><span class="line">                raise exceptions.AuthenticationFailed(&#39;用户名或密码错误&#39;)</span><br><span class="line">            token &#x3D; str(uuid.uuid4())</span><br><span class="line">            token_obj, status &#x3D; models.UserToken.objects.update_or_create(user&#x3D;obj, defaults&#x3D;&#123;&quot;token&quot;: token&#125;)</span><br><span class="line">            return (token_obj.user.username, token_obj)</span><br><span class="line">        except Exception as e:</span><br><span class="line">            print(&quot;Error: &quot;, e)</span><br><span class="line">            raise exceptions.AuthenticationFailed(&#39;验证失败&#39;)</span><br><span class="line"></span><br><span class="line">    def authenticate_header(self, request):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Return a string to be used as the value of the &#96;WWW-Authenticate&#96;</span><br><span class="line">        header in a &#96;401 Unauthenticated&#96; response, or &#96;None&#96; if the</span><br><span class="line">        authentication scheme should return &#96;403 Permission Denied&#96; responses.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return &#39;Basic realm&#x3D;api&#39;</span><br></pre></td></tr></table></figure>
<p>权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat app01&#x2F;utils&#x2F;permission.py</span><br><span class="line"></span><br><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># __author__ &#x3D; &quot;shuke&quot;</span><br><span class="line"># Date: 2018&#x2F;6&#x2F;3</span><br><span class="line">from rest_framework.permissions import BasePermission</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class UserPermission(BasePermission):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    权限验证</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def has_permission(self, request, view):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        判断是否有权限访问当前请求</span><br><span class="line">        Return &#96;True&#96; if permission is granted, &#96;False&#96; otherwise.</span><br><span class="line">        :param request:</span><br><span class="line">        :param view:</span><br><span class="line">        :return: True有权限；False无权限</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        user_type_id &#x3D; request.auth.user.user_type</span><br><span class="line">        if user_type_id &gt; 0:</span><br><span class="line">            return True</span><br><span class="line">        return False</span><br><span class="line"></span><br><span class="line">    # GenericAPIView中get_object时调用</span><br><span class="line">    def has_object_permission(self, request, view, obj):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        视图继承GenericAPIView，并在其中使用get_object时获取对象时，触发单独对象权限验证</span><br><span class="line">        Return &#96;True&#96; if permission is granted, &#96;False&#96; otherwise.</span><br><span class="line">        :param request:</span><br><span class="line">        :param view:</span><br><span class="line">        :param obj:</span><br><span class="line">        :return: True有权限；False无权限</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        user_type_id &#x3D; request.auth.user.user_type</span><br><span class="line">        if user_type_id &gt; 0:</span><br><span class="line">            return True</span><br><span class="line">        return False</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class ManagerPermission(BasePermission):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    视图继承GenericAPIView，并在其中使用get_object时获取对象时，触发单独对象权限验证</span><br><span class="line">    Return &#96;True&#96; if permission is granted, &#96;False&#96; otherwise.</span><br><span class="line">    :param request:</span><br><span class="line">    :param view:</span><br><span class="line">    :param obj:</span><br><span class="line">    :return: True有权限；False无权限</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def has_permission(self, request, view):</span><br><span class="line">        user_type_id &#x3D; request.auth.user.user_type</span><br><span class="line">        if user_type_id &gt; 1:</span><br><span class="line">            return True</span><br><span class="line">        return False</span><br><span class="line"></span><br><span class="line">    # GenericAPIView中get_object时调用</span><br><span class="line">    def has_object_permission(self, request, view, obj):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        视图继承GenericAPIView，并在其中使用get_object时获取对象时，触发单独对象权限验证</span><br><span class="line">        Return &#96;True&#96; if permission is granted, &#96;False&#96; otherwise.</span><br><span class="line">        :param request:</span><br><span class="line">        :param view:</span><br><span class="line">        :param obj:</span><br><span class="line">        :return: True有权限；False无权限</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        user_type_id &#x3D; request.auth.user.user_type</span><br><span class="line">        if user_type_id &gt; 1:</span><br><span class="line">            return True</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure>
<p>试图函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.shortcuts import render, HttpResponse</span><br><span class="line"></span><br><span class="line"># Create your views here.</span><br><span class="line">from django.http import JsonResponse</span><br><span class="line">from rest_framework.views import APIView</span><br><span class="line">from app01.utils.auth import HeaderAuthentication, TokenAuthtication</span><br><span class="line">from app01.utils.permission import UserPermission, ManagerPermission</span><br><span class="line">from app01 import models</span><br><span class="line">import uuid</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class AuthView(APIView):</span><br><span class="line">    authentication_classes &#x3D; []</span><br><span class="line"></span><br><span class="line">    def post(self, request, *args, **kwargs):</span><br><span class="line">        response &#x3D; &#123;&#39;code&#39;: 1000&#125;</span><br><span class="line">        user &#x3D; request.data.get(&#39;username&#39;)</span><br><span class="line">        pwd &#x3D; request.data.get(&#39;password&#39;)</span><br><span class="line"></span><br><span class="line">        obj &#x3D; models.UserInfo.objects.filter(username&#x3D;user, password&#x3D;pwd).first()</span><br><span class="line">        if not obj:</span><br><span class="line">            response[&#39;code&#39;] &#x3D; 1001</span><br><span class="line">            response[&#39;msg&#39;] &#x3D; &#39;用户或密码错误&#39;</span><br><span class="line">            return JsonResponse(response, json_dumps_params&#x3D;&#123;&#39;ensure_ascii&#39;: False&#125;)</span><br><span class="line"></span><br><span class="line">        try:</span><br><span class="line">            token &#x3D; str(uuid.uuid4())</span><br><span class="line">            models.UserToken.objects.update_or_create(user&#x3D;obj, defaults&#x3D;&#123;&quot;token&quot;: token&#125;)</span><br><span class="line">            response[&#39;token&#39;] &#x3D; token</span><br><span class="line">        except Exception as e:</span><br><span class="line">            print(&quot;Error: &quot;, e)</span><br><span class="line">        return JsonResponse(response, json_dumps_params&#x3D;&#123;&#39;ensure_ascii&#39;: False&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class UserView(APIView):</span><br><span class="line">    # 认证的动作是由request.user触发</span><br><span class="line">    authentication_classes &#x3D; [HeaderAuthentication, TokenAuthtication]</span><br><span class="line"></span><br><span class="line">    # 循环执行所有的权限,当前试图只允许管理员以上权限访问</span><br><span class="line">    permission_classes &#x3D; [ManagerPermission, ]</span><br><span class="line"></span><br><span class="line">    def get(self, request, *args, **kwargs):</span><br><span class="line">        print(request.user)</span><br><span class="line">        print(request.auth)</span><br><span class="line">        return HttpResponse(&#39;user.get: %s,token: %s&#39; % (request.user, request.auth))</span><br><span class="line"></span><br><span class="line">    def post(self, request, *args, **kwargs):</span><br><span class="line">        return HttpResponse(&#39;user.post&#39;)</span><br></pre></td></tr></table></figure>
<p>验证:<br><img src="https://note.youdao.com/yws/api/personal/file/WEB9df3ae98ed15b4c4725de0cc826fabe9?method=download&shareKey=f430295de0aa74cb2fa4f45b94d245ec" alt="无访问权限"><br><img src="https://note.youdao.com/yws/api/personal/file/WEBfa5e5818486654600b9b0563e7d4c262?method=download&shareKey=a547b0c96cdd95d95323c1fdbb9b2294" alt="有访问权限"></p>
<p>全局应用权限<br>上述操作中均是对单独视图进行特殊配置，如果想要对全局进行配置，则需要再配置文件中写入即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK &#x3D; &#123;</span><br><span class="line">    &#39;UNAUTHENTICATED_USER&#39;: None,</span><br><span class="line">    &#39;UNAUTHENTICATED_TOKEN&#39;: None,</span><br><span class="line">    &#39;DEFAULT_AUTHENTICATION_CLASSES&#39;: [&#39;app01.utils.auth.HeaderAuthentication&#39;, ],</span><br><span class="line">    &quot;DEFAULT_PERMISSION_CLASSES&quot;: [</span><br><span class="line">        &quot;app01.utils.permission.ManagerPermission&quot;,</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>路由</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat urls.py</span><br><span class="line"></span><br><span class="line">from django.contrib import admin</span><br><span class="line">from django.urls import path</span><br><span class="line">from django.conf.urls import url, include</span><br><span class="line"></span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    url(r&#39;^admin&#x2F;&#39;, admin.site.urls),</span><br><span class="line">    url(r&#39;^api&#x2F;(?P&lt;version&gt;\w+)&#x2F;&#39;, include(&#39;app01.urls&#39;)),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">$ cat app01&#x2F;urls.py </span><br><span class="line">from django.conf.urls import url</span><br><span class="line">from app01 import views</span><br><span class="line"></span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    url(r&#39;^auth&#x2F;$&#39;, views.AuthView.as_view()),</span><br><span class="line">    url(r&#39;^user&#x2F;$&#39;, views.UserView.as_view()),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>试图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat views.py</span><br><span class="line"></span><br><span class="line">from rest_framework.views import APIView</span><br><span class="line">from rest_framework.response import Response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class UserView(APIView):</span><br><span class="line">    def get(self, request, *args, **kwargs):</span><br><span class="line">        # self.dispatch</span><br><span class="line">        print(request.user)</span><br><span class="line">        print(request.auth)</span><br><span class="line">        return Response(&#39;GET请求，响应内容&#39;)</span><br><span class="line"></span><br><span class="line">    def post(self, request, *args, **kwargs):</span><br><span class="line">        return Response(&#39;POST请求，响应内容&#39;)</span><br><span class="line"></span><br><span class="line">    def put(self, request, *args, **kwargs):</span><br><span class="line">        return Response(&#39;PUT请求，响应内容&#39;)</span><br></pre></td></tr></table></figure>
<h3 id="3-3-用户访问次数-频率限制"><a href="#3-3-用户访问次数-频率限制" class="headerlink" title="3.3 用户访问次数/频率限制"></a>3.3 用户访问次数/频率限制</h3><h4 id="3-3-1-基于用户IP访问限制频率"><a href="#3-3-1-基于用户IP访问限制频率" class="headerlink" title="3.3.1 基于用户IP访问限制频率"></a>3.3.1 基于用户IP访问限制频率</h4><p>路由</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat urls.py</span><br><span class="line">from django.conf.urls import url, include</span><br><span class="line">from web.views import TestView</span><br><span class="line"></span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    url(r&#39;^test&#x2F;&#39;, TestView.as_view()),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>试图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">import time</span><br><span class="line">from rest_framework.views import APIView</span><br><span class="line">from rest_framework.response import Response</span><br><span class="line"></span><br><span class="line">from rest_framework import exceptions</span><br><span class="line">from rest_framework.throttling import BaseThrottle</span><br><span class="line">from rest_framework.settings import api_settings</span><br><span class="line"></span><br><span class="line"># 保存访问记录</span><br><span class="line">RECORD &#x3D; &#123;</span><br><span class="line">    &#39;用户IP&#39;: [12312139, 12312135, 12312133, ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class TestThrottle(BaseThrottle):</span><br><span class="line">    ctime &#x3D; time.time</span><br><span class="line"></span><br><span class="line">    def get_ident(self, request):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        根据用户IP和代理IP，当做请求者的唯一IP</span><br><span class="line">        Identify the machine making the request by parsing HTTP_X_FORWARDED_FOR</span><br><span class="line">        if present and number of proxies is &gt; 0. If not use all of</span><br><span class="line">        HTTP_X_FORWARDED_FOR if it is available, if not use REMOTE_ADDR.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        xff &#x3D; request.META.get(&#39;HTTP_X_FORWARDED_FOR&#39;)</span><br><span class="line">        remote_addr &#x3D; request.META.get(&#39;REMOTE_ADDR&#39;)</span><br><span class="line">        num_proxies &#x3D; api_settings.NUM_PROXIES</span><br><span class="line"></span><br><span class="line">        if num_proxies is not None:</span><br><span class="line">            if num_proxies &#x3D;&#x3D; 0 or xff is None:</span><br><span class="line">                return remote_addr</span><br><span class="line">            addrs &#x3D; xff.split(&#39;,&#39;)</span><br><span class="line">            client_addr &#x3D; addrs[-min(num_proxies, len(addrs))]</span><br><span class="line">            return client_addr.strip()</span><br><span class="line"></span><br><span class="line">        return &#39;&#39;.join(xff.split()) if xff else remote_addr</span><br><span class="line"></span><br><span class="line">    def allow_request(self, request, view):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        是否仍然在允许范围内</span><br><span class="line">        Return &#96;True&#96; if the request should be allowed, &#96;False&#96; otherwise.</span><br><span class="line">        :param request: </span><br><span class="line">        :param view: </span><br><span class="line">        :return: True，表示可以通过；False表示已超过限制，不允许访问</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # 获取用户唯一标识（如：IP）</span><br><span class="line"></span><br><span class="line">        # 允许一分钟访问10次</span><br><span class="line">        num_request &#x3D; 10</span><br><span class="line">        time_request &#x3D; 60</span><br><span class="line"></span><br><span class="line">        now &#x3D; self.ctime()</span><br><span class="line">        ident &#x3D; self.get_ident(request)</span><br><span class="line">        self.ident &#x3D; ident</span><br><span class="line">        if ident not in RECORD:</span><br><span class="line">            RECORD[ident] &#x3D; [now, ]</span><br><span class="line">            return True</span><br><span class="line">        history &#x3D; RECORD[ident]</span><br><span class="line">        while history and history[-1] &lt;&#x3D; now - time_request:</span><br><span class="line">            history.pop()</span><br><span class="line">        if len(history) &lt; num_request:</span><br><span class="line">            history.insert(0, now)</span><br><span class="line">            return True</span><br><span class="line"></span><br><span class="line">    def wait(self):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        多少秒后可以允许继续访问</span><br><span class="line">        Optionally, return a recommended number of seconds to wait before</span><br><span class="line">        the next request.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        last_time &#x3D; RECORD[self.ident][0]</span><br><span class="line">        now &#x3D; self.ctime()</span><br><span class="line">        return int(60 + last_time - now)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class TestView(APIView):</span><br><span class="line">    throttle_classes &#x3D; [TestThrottle, ]</span><br><span class="line"></span><br><span class="line">    def get(self, request, *args, **kwargs):</span><br><span class="line">        # self.dispatch</span><br><span class="line">        print(request.user)</span><br><span class="line">        print(request.auth)</span><br><span class="line">        return Response(&#39;GET请求，响应内容&#39;)</span><br><span class="line"></span><br><span class="line">    def post(self, request, *args, **kwargs):</span><br><span class="line">        return Response(&#39;POST请求，响应内容&#39;)</span><br><span class="line"></span><br><span class="line">    def put(self, request, *args, **kwargs):</span><br><span class="line">        return Response(&#39;PUT请求，响应内容&#39;)</span><br><span class="line"></span><br><span class="line">    def throttled(self, request, wait):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        访问次数被限制时，定制错误信息</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">        class Throttled(exceptions.Throttled):</span><br><span class="line">            default_detail &#x3D; &#39;请求被限制.&#39;</span><br><span class="line">            extra_detail_singular &#x3D; &#39;请 &#123;wait&#125; 秒之后再重试.&#39;</span><br><span class="line">            extra_detail_plural &#x3D; &#39;请 &#123;wait&#125; 秒之后再重试.&#39;</span><br><span class="line">            </span><br><span class="line">        raise Throttled(wait)</span><br></pre></td></tr></table></figure>
<h4 id="3-3-2-基于用户IP控制访问频率-利用Django缓存"><a href="#3-3-2-基于用户IP控制访问频率-利用Django缓存" class="headerlink" title="3.3.2 基于用户IP控制访问频率(利用Django缓存)"></a>3.3.2 基于用户IP控制访问频率(利用Django缓存)</h4><p>全局配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK &#x3D; &#123;</span><br><span class="line">    &#39;DEFAULT_THROTTLE_RATES&#39;: &#123;</span><br><span class="line">        &#39;test_scope&#39;: &#39;10&#x2F;m&#39;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>路由</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.conf.urls import url, include</span><br><span class="line">from web.views import TestView</span><br><span class="line"></span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    url(r&#39;^test&#x2F;&#39;, TestView.as_view()),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>试图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">from rest_framework.views import APIView</span><br><span class="line">from rest_framework.response import Response</span><br><span class="line"></span><br><span class="line">from rest_framework import exceptions</span><br><span class="line">from rest_framework.throttling import SimpleRateThrottle</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class TestThrottle(SimpleRateThrottle):</span><br><span class="line"></span><br><span class="line">    # 配置文件定义的显示频率的Key</span><br><span class="line">    scope &#x3D; &quot;test_scope&quot;</span><br><span class="line"></span><br><span class="line">    def get_cache_key(self, request, view):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Should return a unique cache-key which can be used for throttling.</span><br><span class="line">        Must be overridden.</span><br><span class="line"></span><br><span class="line">        May return &#96;None&#96; if the request should not be throttled.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if not request.user:</span><br><span class="line">            ident &#x3D; self.get_ident(request)</span><br><span class="line">        else:</span><br><span class="line">            ident &#x3D; request.user</span><br><span class="line"></span><br><span class="line">        return self.cache_format % &#123;</span><br><span class="line">            &#39;scope&#39;: self.scope,</span><br><span class="line">            &#39;ident&#39;: ident</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class TestView(APIView):</span><br><span class="line">    throttle_classes &#x3D; [TestThrottle, ]</span><br><span class="line"></span><br><span class="line">    def get(self, request, *args, **kwargs):</span><br><span class="line">        # self.dispatch</span><br><span class="line">        print(request.user)</span><br><span class="line">        print(request.auth)</span><br><span class="line">        return Response(&#39;GET请求，响应内容&#39;)</span><br><span class="line"></span><br><span class="line">    def post(self, request, *args, **kwargs):</span><br><span class="line">        return Response(&#39;POST请求，响应内容&#39;)</span><br><span class="line"></span><br><span class="line">    def put(self, request, *args, **kwargs):</span><br><span class="line">        return Response(&#39;PUT请求，响应内容&#39;)</span><br><span class="line"></span><br><span class="line">    def throttled(self, request, wait):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        访问次数被限制时，定制错误信息</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">        class Throttled(exceptions.Throttled):</span><br><span class="line">            default_detail &#x3D; &#39;请求被限制.&#39;</span><br><span class="line">            extra_detail_singular &#x3D; &#39;请 &#123;wait&#125; 秒之后再重试.&#39;</span><br><span class="line">            extra_detail_plural &#x3D; &#39;请 &#123;wait&#125; 秒之后再重试.&#39;</span><br><span class="line"></span><br><span class="line">        raise Throttled(wait)</span><br></pre></td></tr></table></figure>
<h4 id="3-3-3-在试图中限制请求频率"><a href="#3-3-3-在试图中限制请求频率" class="headerlink" title="3.3.3 在试图中限制请求频率"></a>3.3.3 在试图中限制请求频率</h4><p>全局配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK &#x3D; &#123;</span><br><span class="line">    &#39;DEFAULT_THROTTLE_RATES&#39;: &#123;</span><br><span class="line">        &#39;request_scope&#39;: &#39;10&#x2F;m&#39;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>路由</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.conf.urls import url, include</span><br><span class="line">from web.views import TestView</span><br><span class="line"></span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    url(r&#39;^test&#x2F;&#39;, TestView.as_view()),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>试图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">from rest_framework.views import APIView</span><br><span class="line">from rest_framework.response import Response</span><br><span class="line"></span><br><span class="line">from rest_framework import exceptions</span><br><span class="line">from rest_framework.throttling import ScopedRateThrottle</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 继承 ScopedRateThrottle</span><br><span class="line">class TestThrottle(ScopedRateThrottle):</span><br><span class="line"></span><br><span class="line">    def get_cache_key(self, request, view):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Should return a unique cache-key which can be used for throttling.</span><br><span class="line">        Must be overridden.</span><br><span class="line"></span><br><span class="line">        May return &#96;None&#96; if the request should not be throttled.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if not request.user:</span><br><span class="line">            ident &#x3D; self.get_ident(request)</span><br><span class="line">        else:</span><br><span class="line">            ident &#x3D; request.user</span><br><span class="line"></span><br><span class="line">        return self.cache_format % &#123;</span><br><span class="line">            &#39;scope&#39;: self.scope,</span><br><span class="line">            &#39;ident&#39;: ident</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class TestView(APIView):</span><br><span class="line">    throttle_classes &#x3D; [TestThrottle, ]</span><br><span class="line"></span><br><span class="line">    # 在settings中获取 xxxxxx 对应的频率限制值</span><br><span class="line">    throttle_scope &#x3D; &quot;xxxxxx&quot;</span><br><span class="line"></span><br><span class="line">    def get(self, request, *args, **kwargs):</span><br><span class="line">        # self.dispatch</span><br><span class="line">        print(request.user)</span><br><span class="line">        print(request.auth)</span><br><span class="line">        return Response(&#39;GET请求，响应内容&#39;)</span><br><span class="line"></span><br><span class="line">    def post(self, request, *args, **kwargs):</span><br><span class="line">        return Response(&#39;POST请求，响应内容&#39;)</span><br><span class="line"></span><br><span class="line">    def put(self, request, *args, **kwargs):</span><br><span class="line">        return Response(&#39;PUT请求，响应内容&#39;)</span><br><span class="line"></span><br><span class="line">    def throttled(self, request, wait):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        访问次数被限制时，定制错误信息</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">        class Throttled(exceptions.Throttled):</span><br><span class="line">            default_detail &#x3D; &#39;请求被限制.&#39;</span><br><span class="line">            extra_detail_singular &#x3D; &#39;请 &#123;wait&#125; 秒之后再重试.&#39;</span><br><span class="line">            extra_detail_plural &#x3D; &#39;请 &#123;wait&#125; 秒之后再重试.&#39;</span><br><span class="line"></span><br><span class="line">        raise Throttled(wait)</span><br></pre></td></tr></table></figure>
<h4 id="3-3-4-匿名时用IP限制-登录时用Token限制"><a href="#3-3-4-匿名时用IP限制-登录时用Token限制" class="headerlink" title="3.3.4 匿名时用IP限制+登录时用Token限制"></a>3.3.4 匿名时用IP限制+登录时用Token限制</h4><p>全局配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK &#x3D; &#123;</span><br><span class="line">    &#39;UNAUTHENTICATED_USER&#39;: None,</span><br><span class="line">    &#39;UNAUTHENTICATED_TOKEN&#39;: None,</span><br><span class="line">    &#39;DEFAULT_THROTTLE_RATES&#39;: &#123;</span><br><span class="line">        &#39;backend_anon&#39;: &#39;10&#x2F;m&#39;,</span><br><span class="line">        &#39;backend_user&#39;: &#39;20&#x2F;m&#39;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>路由</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.conf.urls import url, include</span><br><span class="line">from web.views.s3_throttling import TestView</span><br><span class="line"></span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    url(r&#39;^test&#x2F;&#39;, TestView.as_view()),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>试图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># !&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">from rest_framework.views import APIView</span><br><span class="line">from rest_framework.response import Response</span><br><span class="line"></span><br><span class="line">from rest_framework.throttling import SimpleRateThrottle</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class BackendAnonRateThrottle(SimpleRateThrottle):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    匿名用户，根据IP进行限制</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    scope &#x3D; &quot;backend_anon&quot;</span><br><span class="line"></span><br><span class="line">    def get_cache_key(self, request, view):</span><br><span class="line">        # 用户已登录，则跳过 匿名频率限制</span><br><span class="line">        if request.user:</span><br><span class="line">            return None</span><br><span class="line"></span><br><span class="line">        return self.cache_format % &#123;</span><br><span class="line">            &#39;scope&#39;: self.scope,</span><br><span class="line">            &#39;ident&#39;: self.get_ident(request)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class BackendUserRateThrottle(SimpleRateThrottle):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    登录用户，根据用户token限制</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    scope &#x3D; &quot;backend_user&quot;</span><br><span class="line"></span><br><span class="line">    def get_ident(self, request):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        认证成功时：request.user是用户对象；request.auth是token对象</span><br><span class="line">        :param request:</span><br><span class="line">        :return:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # return request.auth.token</span><br><span class="line">        return &quot;user_token&quot;</span><br><span class="line"></span><br><span class="line">    def get_cache_key(self, request, view):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        获取缓存key</span><br><span class="line">        :param request:</span><br><span class="line">        :param view:</span><br><span class="line">        :return:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # 未登录用户，则跳过 Token限制</span><br><span class="line">        if not request.user:</span><br><span class="line">            return None</span><br><span class="line"></span><br><span class="line">        return self.cache_format % &#123;</span><br><span class="line">            &#39;scope&#39;: self.scope,</span><br><span class="line">            &#39;ident&#39;: self.get_ident(request)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class TestView(APIView):</span><br><span class="line">    throttle_classes &#x3D; [BackendAnonRateThrottle, BackendUserRateThrottle, ]</span><br><span class="line"></span><br><span class="line">    def get(self, request, *args, **kwargs):</span><br><span class="line">        # self.dispatch</span><br><span class="line">        print(request.user)</span><br><span class="line">        print(request.auth)</span><br><span class="line">        return Response(&#39;GET请求，响应内容&#39;)</span><br><span class="line"></span><br><span class="line">    def post(self, request, *args, **kwargs):</span><br><span class="line">        return Response(&#39;POST请求，响应内容&#39;)</span><br><span class="line"></span><br><span class="line">    def put(self, request, *args, **kwargs):</span><br><span class="line">        return Response(&#39;PUT请求，响应内容&#39;)</span><br></pre></td></tr></table></figure>
<h4 id="3-3-5-全局使用"><a href="#3-3-5-全局使用" class="headerlink" title="3.3.5 全局使用"></a>3.3.5 全局使用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK &#x3D; &#123;</span><br><span class="line">    &#39;DEFAULT_THROTTLE_CLASSES&#39;: [</span><br><span class="line">        &#39;api.utils.throttles.throttles.BackendAnonRateThrottle&#39;,</span><br><span class="line">        &#39;api.utils.throttles.throttles.BackendUserRateThrottle&#39;,</span><br><span class="line">    ],</span><br><span class="line">    &#39;DEFAULT_THROTTLE_RATES&#39;: &#123;</span><br><span class="line">        &#39;anon&#39;: &#39;10&#x2F;day&#39;,</span><br><span class="line">        &#39;user&#39;: &#39;10&#x2F;day&#39;,</span><br><span class="line">        &#39;backend_anon&#39;: &#39;10&#x2F;m&#39;,</span><br><span class="line">        &#39;backend_user&#39;: &#39;20&#x2F;m&#39;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-4-版本"><a href="#3-4-版本" class="headerlink" title="3.4 版本"></a>3.4 版本</h3><p>共6个类</p>
<ol>
<li>BaseVersioning</li>
<li>AcceptHeaderVersioning</li>
<li>URLPathVersioning</li>
<li>NamespaceVersioning</li>
<li>HostNameVersioning</li>
<li>QueryParameterVersioning<br>而且还可以看到BaseVersioning类是其余5个类的父类,并且这其余的5个类,每个类中都有一个determine_version方法,在项目的视图函数中导入其中任意一个类,打印versioning_class<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.shortcuts import render,HttpResponse</span><br><span class="line">from rest_framework.views import APIView</span><br><span class="line">from django.views import View</span><br><span class="line">from rest_framework.versioning import QueryParameterVersioning</span><br><span class="line"></span><br><span class="line">class UsersView(APIView):</span><br><span class="line">    versioning_class&#x3D;QueryParameterVersioning</span><br><span class="line"></span><br><span class="line">    def get(self,request,*args,**kwargs):</span><br><span class="line">        print(self.versioning_class)        #打印versioning_class</span><br><span class="line"></span><br><span class="line">        return HttpResponse(&quot;aaaa&quot;)</span><br></pre></td></tr></table></figure>
输出结果:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;class &#39;rest_framework.versioning.QueryParameterVersioning&#39;&gt;</span><br></pre></td></tr></table></figure>
所以versioning_class是一个类,并且versioning_class类中有一个determine_version方法</li>
</ol>
<h4 id="3-4-1-基于URL的GET传参方式"><a href="#3-4-1-基于URL的GET传参方式" class="headerlink" title="3.4.1 基于URL的GET传参方式"></a>3.4.1 基于URL的GET传参方式</h4><p>如：/users?version=v1<br>全局配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK &#x3D; &#123;</span><br><span class="line">    &#39;DEFAULT_VERSION&#39;: &#39;v1&#39;,            # 默认版本</span><br><span class="line">    &#39;ALLOWED_VERSIONS&#39;: [&#39;v1&#39;, &#39;v2&#39;],   # 允许的版本</span><br><span class="line">    &#39;VERSION_PARAM&#39;: &#39;version&#39;          # URL中获取值的key</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>路由</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.contrib import admin</span><br><span class="line">from django.urls import path</span><br><span class="line">from django.conf.urls import url, include</span><br><span class="line">from app01.views import TestView</span><br><span class="line"></span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    url(r&#39;^test&#x2F;&#39;, TestView.as_view(), name&#x3D;&#39;test&#39;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>试图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from rest_framework.views import APIView</span><br><span class="line">from rest_framework.response import Response</span><br><span class="line">from rest_framework.versioning import QueryParameterVersioning</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class TestView(APIView):</span><br><span class="line">    versioning_class &#x3D; QueryParameterVersioning</span><br><span class="line"></span><br><span class="line">    def get(self, request, *args, **kwargs):</span><br><span class="line">        # 获取版本</span><br><span class="line">        print(request.version)</span><br><span class="line">        # 获取版本管理的类</span><br><span class="line">        print(request.versioning_scheme)</span><br><span class="line"></span><br><span class="line">        # 反向生成URL</span><br><span class="line">        reverse_url &#x3D; request.versioning_scheme.reverse(&#39;test&#39;, request&#x3D;request)</span><br><span class="line">        print(reverse_url)</span><br><span class="line"></span><br><span class="line">        return Response(&#39;GET请求，响应内容&#39;)</span><br><span class="line"></span><br><span class="line">    def post(self, request, *args, **kwargs):</span><br><span class="line">        return Response(&#39;POST请求，响应内容&#39;)</span><br><span class="line"></span><br><span class="line">    def put(self, request, *args, **kwargs):</span><br><span class="line">        return Response(&#39;PUT请求，响应内容&#39;)</span><br></pre></td></tr></table></figure>
<h4 id="3-4-2-基于URL的正则方式"><a href="#3-4-2-基于URL的正则方式" class="headerlink" title="3.4.2 基于URL的正则方式"></a>3.4.2 基于URL的正则方式</h4><p>如: /v1/users/</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK &#x3D; &#123;</span><br><span class="line">    &#39;DEFAULT_VERSION&#39;: &#39;v1&#39;,            # 默认版本</span><br><span class="line">    &#39;ALLOWED_VERSIONS&#39;: [&#39;v1&#39;, &#39;v2&#39;],   # 允许的版本</span><br><span class="line">    &#39;VERSION_PARAM&#39;: &#39;version&#39;          # URL中获取值的key</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>路由</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.conf.urls import url, include</span><br><span class="line">from web.views import TestView</span><br><span class="line"></span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    url(r&#39;^(?P&lt;version&gt;[v1|v2]+)&#x2F;test&#x2F;&#39;, TestView.as_view(), name&#x3D;&#39;test&#39;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>试图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">from rest_framework.views import APIView</span><br><span class="line">from rest_framework.response import Response</span><br><span class="line">from rest_framework.versioning import URLPathVersioning</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class TestView(APIView):</span><br><span class="line">    versioning_class &#x3D; URLPathVersioning</span><br><span class="line"></span><br><span class="line">    def get(self, request, *args, **kwargs):</span><br><span class="line">        # 获取版本</span><br><span class="line">        print(request.version)</span><br><span class="line">        # 获取版本管理的类</span><br><span class="line">        print(request.versioning_scheme)</span><br><span class="line"></span><br><span class="line">        # 反向生成URL</span><br><span class="line">        reverse_url &#x3D; request.versioning_scheme.reverse(&#39;test&#39;, request&#x3D;request)</span><br><span class="line">        print(reverse_url)</span><br><span class="line"></span><br><span class="line">        return Response(&#39;GET请求，响应内容&#39;)</span><br><span class="line"></span><br><span class="line">    def post(self, request, *args, **kwargs):</span><br><span class="line">        return Response(&#39;POST请求，响应内容&#39;)</span><br><span class="line"></span><br><span class="line">    def put(self, request, *args, **kwargs):</span><br><span class="line">        return Response(&#39;PUT请求，响应内容&#39;)</span><br></pre></td></tr></table></figure>
<h4 id="3-4-3-基于accept请求头方式"><a href="#3-4-3-基于accept请求头方式" class="headerlink" title="3.4.3 基于accept请求头方式"></a>3.4.3 基于accept请求头方式</h4><p>如：Accept: application/json; version=1.0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK &#x3D; &#123;</span><br><span class="line">    &#39;DEFAULT_VERSION&#39;: &#39;v1&#39;,            # 默认版本</span><br><span class="line">    &#39;ALLOWED_VERSIONS&#39;: [&#39;v1&#39;, &#39;v2&#39;],   # 允许的版本</span><br><span class="line">    &#39;VERSION_PARAM&#39;: &#39;version&#39;          # URL中获取值的key</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>路由</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.conf.urls import url, include</span><br><span class="line">from web.views import TestView</span><br><span class="line"></span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    url(r&#39;^test&#x2F;&#39;, TestView.as_view(), name&#x3D;&#39;test&#39;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>试图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># !&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">from rest_framework.views import APIView</span><br><span class="line">from rest_framework.response import Response</span><br><span class="line">from rest_framework.versioning import AcceptHeaderVersioning</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class TestView(APIView):</span><br><span class="line">    versioning_class &#x3D; AcceptHeaderVersioning</span><br><span class="line"></span><br><span class="line">    def get(self, request, *args, **kwargs):</span><br><span class="line">        # 获取版本 HTTP_ACCEPT头</span><br><span class="line">        print(request.version)</span><br><span class="line">        # 获取版本管理的类</span><br><span class="line">        print(request.versioning_scheme)</span><br><span class="line">        # 反向生成URL</span><br><span class="line">        reverse_url &#x3D; request.versioning_scheme.reverse(&#39;test&#39;, request&#x3D;request)</span><br><span class="line">        print(reverse_url)</span><br><span class="line"></span><br><span class="line">        return Response(&#39;GET请求，响应内容,基于Accept请求头方式&#39;)</span><br><span class="line"></span><br><span class="line">    def post(self, request, *args, **kwargs):</span><br><span class="line">        return Response(&#39;POST请求，响应内容，基于Accept请求头方式&#39;)</span><br><span class="line"></span><br><span class="line">    def put(self, request, *args, **kwargs):</span><br><span class="line">        return Response(&#39;PUT请求，响应内容，基于Accept请求头方式&#39;)</span><br></pre></td></tr></table></figure>
<h4 id="3-4-4-基于主机名方式"><a href="#3-4-4-基于主机名方式" class="headerlink" title="3.4.4 基于主机名方式"></a>3.4.4 基于主机名方式</h4><p>如: v1.example.com</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALLOWED_HOSTS &#x3D; [&#39;*&#39;]</span><br><span class="line">REST_FRAMEWORK &#x3D; &#123;</span><br><span class="line">    &#39;DEFAULT_VERSION&#39;: &#39;v1&#39;,  # 默认版本</span><br><span class="line">    &#39;ALLOWED_VERSIONS&#39;: [&#39;v1&#39;, &#39;v2&#39;],  # 允许的版本</span><br><span class="line">    &#39;VERSION_PARAM&#39;: &#39;version&#39;  # URL中获取值的key</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>路由</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.conf.urls import url, include</span><br><span class="line">from web.views import TestView</span><br><span class="line"></span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    url(r&#39;^test&#x2F;&#39;, TestView.as_view(), name&#x3D;&#39;test&#39;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>试图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># !&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">from rest_framework.views import APIView</span><br><span class="line">from rest_framework.response import Response</span><br><span class="line">from rest_framework.versioning import HostNameVersioning</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class TestView(APIView):</span><br><span class="line">    versioning_class &#x3D; HostNameVersioning</span><br><span class="line"></span><br><span class="line">    def get(self, request, *args, **kwargs):</span><br><span class="line">        # 获取版本</span><br><span class="line">        print(request.version)</span><br><span class="line">        # 获取版本管理的类</span><br><span class="line">        print(request.versioning_scheme)</span><br><span class="line">        # 反向生成URL</span><br><span class="line">        reverse_url &#x3D; request.versioning_scheme.reverse(&#39;test&#39;, request&#x3D;request)</span><br><span class="line">        print(reverse_url)</span><br><span class="line"></span><br><span class="line">        return Response(&#39;GET请求，响应内容,基于主机名方式&#39;)</span><br><span class="line"></span><br><span class="line">    def post(self, request, *args, **kwargs):</span><br><span class="line">        return Response(&#39;POST请求，响应内容,基于主机名方式&#39;)</span><br><span class="line"></span><br><span class="line">    def put(self, request, *args, **kwargs):</span><br><span class="line">        return Response(&#39;PUT请求，响应内容,基于主机名方式&#39;)</span><br></pre></td></tr></table></figure>
<h4 id="3-4-5-基于Django路由系统的namespace"><a href="#3-4-5-基于Django路由系统的namespace" class="headerlink" title="3.4.5 基于Django路由系统的namespace"></a>3.4.5 基于Django路由系统的namespace</h4><p>如: example.com/v1/users/</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK &#x3D; &#123;</span><br><span class="line">    &#39;DEFAULT_VERSION&#39;: &#39;v1&#39;,  # 默认版本</span><br><span class="line">    &#39;ALLOWED_VERSIONS&#39;: [&#39;v1&#39;, &#39;v2&#39;],  # 允许的版本</span><br><span class="line">    &#39;VERSION_PARAM&#39;: &#39;version&#39;  # URL中获取值的key</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>路由</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.conf.urls import url, include</span><br><span class="line">from app01.views import TestView</span><br><span class="line"></span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    url(r&#39;^v1&#x2F;&#39;, ([</span><br><span class="line">                      url(r&#39;test&#x2F;&#39;, TestView.as_view(), name&#x3D;&#39;test1&#39;)</span><br><span class="line">                  ], None, &#39;v1&#39;)),</span><br><span class="line">    url(r&#39;^v2&#x2F;&#39;, ([</span><br><span class="line">                      url(r&#39;test&#x2F;&#39;, TestView.as_view(), name&#x3D;&#39;test2&#39;)</span><br><span class="line">                  ], None, &#39;v2&#39;)),</span><br><span class="line"></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>试图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># !&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">from rest_framework.views import APIView</span><br><span class="line">from rest_framework.response import Response</span><br><span class="line">from rest_framework.versioning import NamespaceVersioning</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class TestView(APIView):</span><br><span class="line">    authentication_classes &#x3D; []</span><br><span class="line">    permission_classes &#x3D; []</span><br><span class="line">    versioning_class &#x3D; NamespaceVersioning</span><br><span class="line"></span><br><span class="line">    def get(self, request, *args, **kwargs):</span><br><span class="line">        # 获取版本</span><br><span class="line">        print(request.version)</span><br><span class="line">        # 获取版本管理的类</span><br><span class="line">        print(request.versioning_scheme)</span><br><span class="line">        # 反向生成URL</span><br><span class="line">        reverse_url &#x3D; request.versioning_scheme.reverse(&#39;test1&#39;, request&#x3D;request)</span><br><span class="line">        print(reverse_url)</span><br><span class="line"></span><br><span class="line">        return Response(&#39;GET请求，响应内容,基于Django路由系统的namespace&#39;)</span><br><span class="line"></span><br><span class="line">    def post(self, request, *args, **kwargs):</span><br><span class="line">        return Response(&#39;POST请求，响应内容,基于Django路由系统的namespace&#39;)</span><br><span class="line"></span><br><span class="line">    def put(self, request, *args, **kwargs):</span><br><span class="line">        return Response(&#39;PUT请求，响应内容,基于Django路由系统的namespace&#39;)</span><br><span class="line">&#96;&#96;&#96;        </span><br><span class="line">#### 3.4.6 全局应用</span><br></pre></td></tr></table></figure>
<p>REST_FRAMEWORK = {<br>    ‘DEFAULT_VERSIONING_CLASS’:”rest_framework.versioning.URLPathVersioning”,<br>    ‘DEFAULT_VERSION’: ‘v1’,<br>    ‘ALLOWED_VERSIONS’: [‘v1’, ‘v2’],<br>    ‘VERSION_PARAM’: ‘version’<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#### 3.4.7 自定义版本控制方案</span><br><span class="line">要实现自定义版本控制方案，请继承 BaseVersioning并覆盖 .determine_version 方法。</span><br><span class="line">举个栗子</span><br><span class="line">以下示例使用自定义的 X-API-Version header 来确定所请求的版本</span><br></pre></td></tr></table></figure>
<p>class XAPIVersionScheme(versioning.BaseVersioning):<br>    def determine_version(self, request, <em>args, *</em>kwargs):<br>        return request.META.get(‘HTTP_X_API_VERSION’, None)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果你的版本控制方案基于请求 URL，则还需要更改版本化 URL 的确定方式。为了做到这一点，你应该重写类的 .reverse()方法。有关示例，请参阅源代码。</span><br><span class="line"></span><br><span class="line">### 3.5 解析器(parser)</span><br><span class="line">根据请求头content-type选择对应的解析器就请求体内容进行处理</span><br><span class="line">#### 3.5.1 仅处理请求头content-type为application&#x2F;json的请求体</span><br><span class="line">路由</span><br></pre></td></tr></table></figure>
<p>from django.conf.urls import url, include<br>from web.views.s5_parser import TestView</p>
<p>urlpatterns = [<br>    url(r’test/‘, TestView.as_view(), name=’test’),<br>]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">试图</span><br></pre></td></tr></table></figure>
<h1 id="usr-bin-env-python"><a href="#usr-bin-env-python" class="headerlink" title="!/usr/bin/env python"></a>!/usr/bin/env python</h1><h1 id="coding-utf-8"><a href="#coding-utf-8" class="headerlink" title="-- coding:utf-8 --"></a>-<em>- coding:utf-8 -</em>-</h1><p>from rest_framework.views import APIView<br>from rest_framework.response import Response<br>from rest_framework.parsers import JSONParser</p>
<p>class TestView(APIView):<br>    parser_classes = [JSONParser, ]</p>
<pre><code>def post(self, request, *args, **kwargs):
    print(request.content_type)

    # 获取请求的值，并使用对应的JSONParser进行处理
    print(request.data)

    # application/x-www-form-urlencoded 或 multipart/form-data时，request.POST中才有值
    print(request.POST)
    print(request.FILES)

    return Response(&apos;POST请求，请求内容: %s&apos; % request.data)

def put(self, request, *args, **kwargs):
    return Response(&apos;PUT请求，响应内容，解析器&apos;)</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#### 3.5.2 仅处理请求头content-type为application&#x2F;x-www-form-urlencoded的请求体</span><br><span class="line">路由</span><br></pre></td></tr></table></figure>
<p>from django.conf.urls import url, include<br>from web.views import TestView</p>
<p>urlpatterns = [<br>    url(r’test/‘, TestView.as_view(), name=’test’),<br>]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">试图</span><br></pre></td></tr></table></figure>
<p>#!/usr/bin/env python</p>
<h1 id="coding-utf-8-1"><a href="#coding-utf-8-1" class="headerlink" title="-- coding:utf-8 --"></a>-<em>- coding:utf-8 -</em>-</h1><p>from rest_framework.views import APIView<br>from rest_framework.response import Response<br>from rest_framework.request import Request<br>from rest_framework.parsers import FormParser</p>
<p>class TestView(APIView):<br>    parser_classes = [FormParser, ]</p>
<pre><code>def post(self, request, *args, **kwargs):
    print(request.content_type)

    # 获取请求的值，并使用对应的JSONParser进行处理
    print(request.data)

    # application/x-www-form-urlencoded 或 multipart/form-data时，request.POST中才有值
    print(request.POST)
    print(request.FILES)

    return Response(&apos;POST请求，响应内容&apos;)

def put(self, request, *args, **kwargs):
    return Response(&apos;PUT请求，响应内容&apos;)</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#### 3.5.3 仅处理请求头content-type为multipart&#x2F;form-data的请求体</span><br><span class="line">路由</span><br></pre></td></tr></table></figure>
<p>from django.conf.urls import url, include<br>from web.views import TestView</p>
<p>urlpatterns = [<br>    url(r’test/‘, TestView.as_view(), name=’test’),<br>]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">试图</span><br></pre></td></tr></table></figure>
<h1 id="usr-bin-env-python-1"><a href="#usr-bin-env-python-1" class="headerlink" title="!/usr/bin/env python"></a>!/usr/bin/env python</h1><h1 id="coding-utf-8-2"><a href="#coding-utf-8-2" class="headerlink" title="-- coding:utf-8 --"></a>-<em>- coding:utf-8 -</em>-</h1><p>from django.shortcuts import render<br>from rest_framework.views import APIView<br>from rest_framework.response import Response<br>from rest_framework.parsers import MultiPartParser</p>
<p>class TestView(APIView):<br>    authentication_classes = []<br>    permission_classes = []<br>    parser_classes = [MultiPartParser, ]</p>
<pre><code>def get(self, request, *args, **kwargs):
    return render(request, &apos;test.html&apos;)

def post(self, request, *args, **kwargs):
    print(request.content_type)

    # 获取请求的值，并使用对应的JSONParser进行处理
    print(request.data)
    # application/x-www-form-urlencoded 或 multipart/form-data时，request.POST中才有值
    print(request.POST)
    print(request.FILES)
    return Response(&apos;POST请求，响应内容&apos;)

def put(self, request, *args, **kwargs):
    return Response(&apos;PUT请求，响应内容&apos;)</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">模版文件</span><br></pre></td></tr></table></figure>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="shuke's Blog" type="application/atom+xml">
</head>
<body>
<form action="http://127.0.0.1:8000/test/" method="post" enctype="multipart/form-data">
    <input type="text" name="user" />
    <input type="file" name="img">

<pre><code>&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;</code></pre></form>
</body>
</html>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#### 3.5.4 仅上传文件</span><br><span class="line">路由</span><br></pre></td></tr></table></figure>
from django.conf.urls import url, include
from web.views import TestView

<p>urlpatterns = [<br>    url(r’test/(?P<filename>[^/]+)’, TestView.as_view(), name=’test’),<br>]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">试图</span><br></pre></td></tr></table></figure>
<h1 id="usr-bin-env-python-2"><a href="#usr-bin-env-python-2" class="headerlink" title="!/usr/bin/env python"></a>!/usr/bin/env python</h1><h1 id="coding-utf-8-3"><a href="#coding-utf-8-3" class="headerlink" title="-- coding:utf-8 --"></a>-<em>- coding:utf-8 -</em>-</h1><p>from rest_framework.views import APIView<br>from rest_framework.response import Response<br>from rest_framework.parsers import FileUploadParser</p>
<p>class TestView(APIView):<br>    authentication_classes = []<br>    permission_classes = []<br>    parser_classes = [FileUploadParser, ]</p>
<pre><code>def get(self, request, *args, **kwargs):
    return render(request, &apos;test.html&apos;)

def post(self, request, filename, *args, **kwargs):
    print(filename)
    print(request.content_type)

    # 获取请求的值，并使用对应的JSONParser进行处理
    print(request.data)
    # application/x-www-form-urlencoded 或 multipart/form-data时，request.POST中才有值
    print(request.POST)
    print(request.FILES)
    return Response(&apos;POST请求，响应内容&apos;)

def put(self, request, *args, **kwargs):
    return Response(&apos;PUT请求，响应内容&apos;)</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">模版文件</span><br></pre></td></tr></table></figure>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<form action="http://127.0.0.1:8000/test/f1.numbers" method="post" enctype="multipart/form-data">
    <input type="text" name="user" />
    <input type="file" name="img">

<pre><code>&lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;</code></pre></form>
</body>
</html>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#### 3.5.5 同时多个Parser</span><br><span class="line">当同时使用多个parser时，rest framework会根据请求头content-type自动进行比对，并使用对应parser</span><br><span class="line">路由</span><br></pre></td></tr></table></figure>
from django.conf.urls import url, include
from web.views import TestView

<p>urlpatterns = [<br>    url(r’test/‘, TestView.as_view(), name=’test’),<br>]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">试图</span><br></pre></td></tr></table></figure>
<h1 id="usr-bin-env-python-3"><a href="#usr-bin-env-python-3" class="headerlink" title="!/usr/bin/env python"></a>!/usr/bin/env python</h1><h1 id="coding-utf-8-4"><a href="#coding-utf-8-4" class="headerlink" title="-- coding:utf-8 --"></a>-<em>- coding:utf-8 -</em>-</h1><p>from rest_framework.views import APIView<br>from rest_framework.response import Response<br>from rest_framework.parsers import JSONParser, FormParser, MultiPartParser</p>
<p>class TestView(APIView):<br>    parser_classes = [JSONParser, FormParser, MultiPartParser, ]</p>
<pre><code>def post(self, request, *args, **kwargs):
    print(request.content_type)

    # 获取请求的值，并使用对应的JSONParser进行处理
    print(request.data)
    # application/x-www-form-urlencoded 或 multipart/form-data时，request.POST中才有值
    print(request.POST)
    print(request.FILES)
    return Response(&apos;POST请求，响应内容&apos;)

def put(self, request, *args, **kwargs):
    return Response(&apos;PUT请求，响应内容&apos;)</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#### 3.5.6 全局应用</span><br></pre></td></tr></table></figure>
<p>REST_FRAMEWORK = {<br>    ‘DEFAULT_PARSER_CLASSES’:[<br>        ‘rest_framework.parsers.JSONParser’<br>        ‘rest_framework.parsers.FormParser’<br>        ‘rest_framework.parsers.MultiPartParser’<br>    ]</p>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">路由</span><br></pre></td></tr></table></figure>
<p>from django.conf.urls import url, include<br>from web.views import TestView</p>
<p>urlpatterns = [<br>    url(r’test/‘, TestView.as_view(), name=’test’),<br>]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">试图</span><br></pre></td></tr></table></figure>
<p>#!/usr/bin/env python</p>
<h1 id="coding-utf-8-5"><a href="#coding-utf-8-5" class="headerlink" title="-- coding:utf-8 --"></a>-<em>- coding:utf-8 -</em>-</h1><p>from rest_framework.views import APIView<br>from rest_framework.response import Response</p>
<p>class TestView(APIView):<br>    def post(self, request, <em>args, *</em>kwargs):<br>        print(request.content_type)</p>
<pre><code>    # 获取请求的值，并使用对应的JSONParser进行处理
    print(request.data)
    # application/x-www-form-urlencoded 或 multipart/form-data时，request.POST中才有值
    print(request.POST)
    print(request.FILES)
    return Response(&apos;POST请求，响应内容&apos;)

def put(self, request, *args, **kwargs):
    return Response(&apos;PUT请求，响应内容&apos;)</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">⚠️ 个别特殊的值可以通过Django的request对象 request\.\_request 来进行获取</span><br><span class="line"></span><br><span class="line">### 3.6 序列化</span><br><span class="line">序列化用于对用户请求数据进行验证和数据进行序列化</span><br><span class="line">#### 3.6.1 自定义字段</span><br><span class="line">路由</span><br></pre></td></tr></table></figure>
<p>from django.conf.urls import url, include<br>from app01.views import TestView</p>
<p>urlpatterns = [<br>    url(r’^test/‘, TestView.as_view(), name=’test’),<br>]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">models</span><br></pre></td></tr></table></figure>
<p>from django.db import models</p>
<h1 id="Create-your-models-here"><a href="#Create-your-models-here" class="headerlink" title="Create your models here."></a>Create your models here.</h1><p>from django.db import models</p>
<p>class UserInfo(models.Model):<br>    user_type_choices = (<br>        (1, ‘普通用户’),<br>        (2, ‘管理员’),<br>        (3, ‘超级管理员’),<br>    )<br>    username = models.CharField(max_length=32)<br>    password = models.CharField(max_length=64)<br>    user_type = models.IntegerField(choices=user_type_choices, default=1)</p>
<p>class UserToken(models.Model):<br>    user = models.OneToOneField(‘UserInfo’, on_delete=True)<br>    token = models.CharField(max_length=64)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">试图</span><br></pre></td></tr></table></figure>
<h1 id="usr-bin-env-python-4"><a href="#usr-bin-env-python-4" class="headerlink" title="!/usr/bin/env python"></a>!/usr/bin/env python</h1><h1 id="coding-utf-8-6"><a href="#coding-utf-8-6" class="headerlink" title="-- coding:utf-8 --"></a>-<em>- coding:utf-8 -</em>-</h1><p>from rest_framework.views import APIView<br>from rest_framework.response import Response<br>from rest_framework import serializers<br>from . import models</p>
<p>class PasswordValidator(object):<br>    def <strong>init</strong>(self, base):<br>        self.base = base</p>
<pre><code>def __call__(self, value):
    if value != self.base:
        message = &apos;This field must be %s.&apos; % self.base
        raise serializers.ValidationError(message)

def set_context(self, serializer_field):
    &quot;&quot;&quot;
    This hook is called by the serializer instance,
    prior to the validation call being made.
    &quot;&quot;&quot;
    # 执行验证之前调用,serializer_fields是当前字段对象
    pass</code></pre><p>class UserSerializer(serializers.Serializer):<br>    user_type = serializers.IntegerField()<br>    username = serializers.CharField(min_length=3)<br>    password = serializers.CharField(error_messages={‘required’: ‘密码不能为空’}, validators=[PasswordValidator(‘666’)])</p>
<p>class TestView(APIView):<br>    authentication_classes = []<br>    permission_classes = []</p>
<pre><code>def get(self, request, *args, **kwargs):

    # 序列化，将数据库查询字段序列化为字典
    data_list = models.UserInfo.objects.all()
    ser = UserSerializer(instance=data_list, many=True)
    # 或
    # obj = models.UserInfo.objects.all().first()
    # ser = UserSerializer(instance=obj, many=False)
    return Response(ser.data)

def post(self, request, *args, **kwargs):
    # 验证，对请求发来的数据进行验证
    ser = UserSerializer(data=request.data)
    if ser.is_valid():
        print(ser.validated_data)
    else:
        print(ser.errors)

    return Response(&apos;POST请求，响应内容&apos;)</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST验证:</span><br></pre></td></tr></table></figure>
<p>curl -X POST <br>  <a href="http://127.0.0.1:8001/test/" target="_blank" rel="noopener">http://127.0.0.1:8001/test/</a> <br>  -H ‘Cache-Control: no-cache’ <br>  -H ‘Content-Type: application/json’ <br>  -H ‘Postman-Token: 4ea5d1d1-e3b1-38a3-19f6-25070ace2342’ <br>  -d ‘{<br>        “user_type”: 2,<br>        “username”: “python”,<br>        “password”: “666”<br>    }’</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#### 3.6.2 基于Model自动生成字段</span><br><span class="line">路由</span><br></pre></td></tr></table></figure>
<p>from django.conf.urls import url, include<br>from web.views.s6_serializers import TestView</p>
<p>urlpatterns = [<br>    url(r’test/‘, TestView.as_view(), name=’test’),<br>]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">试图</span><br></pre></td></tr></table></figure>
<p>#!/usr/bin/env python</p>
<h1 id="coding-utf-8-7"><a href="#coding-utf-8-7" class="headerlink" title="-- coding:utf-8 --"></a>-<em>- coding:utf-8 -</em>-</h1><p>from rest_framework.views import APIView<br>from rest_framework.response import Response<br>from rest_framework import serializers<br>from .. import models</p>
<p>class PasswordValidator(object):<br>    def <strong>init</strong>(self, base):<br>        self.base = str(base)</p>
<pre><code>def __call__(self, value):
    if value != self.base:
        message = &apos;This field must be %s.&apos; % self.base
        raise serializers.ValidationError(message)

def set_context(self, serializer_field):
    &quot;&quot;&quot;
    This hook is called by the serializer instance,
    prior to the validation call being made.
    &quot;&quot;&quot;
    # 执行验证之前调用,serializer_fields是当前字段对象
    pass</code></pre><p>class ModelUserSerializer(serializers.ModelSerializer):</p>
<pre><code>user = serializers.CharField(max_length=32)

class Meta:
    model = models.UserInfo
    fields = &quot;__all__&quot;
    # fields = [&apos;user&apos;, &apos;pwd&apos;, &apos;ut&apos;]
    depth = 2
    extra_kwargs = {&apos;user&apos;: {&apos;min_length&apos;: 6}, &apos;pwd&apos;: {&apos;validators&apos;: [PasswordValidator(666), ]}}
    # read_only_fields = [&apos;user&apos;]</code></pre><p>class TestView(APIView):<br>    def get(self, request, <em>args, *</em>kwargs):</p>
<pre><code>    # 序列化，将数据库查询字段序列化为字典
    data_list = models.UserInfo.objects.all()
    ser = ModelUserSerializer(instance=data_list, many=True)
    # 或
    # obj = models.UserInfo.objects.all().first()
    # ser = UserSerializer(instance=obj, many=False)
    return Response(ser.data)

def post(self, request, *args, **kwargs):
    # 验证，对请求发来的数据进行验证
    print(request.data)
    ser = ModelUserSerializer(data=request.data)
    if ser.is_valid():
        print(ser.validated_data)
    else:
        print(ser.errors)

    return Response(&apos;POST请求，响应内容&apos;)</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#### 3.6.3 生成URL</span><br><span class="line">路由</span><br></pre></td></tr></table></figure>
<p>from django.conf.urls import url, include<br>from web.views.s6_serializers import TestView</p>
<p>urlpatterns = [<br>    url(r’test/‘, TestView.as_view(), name=’test’),<br>    url(r’detail/(?P<pk>\d+)/‘, TestView.as_view(), name=’detail’),<br>]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">models</span><br></pre></td></tr></table></figure>
<p>from django.db import models</p>
<h1 id="Create-your-models-here-1"><a href="#Create-your-models-here-1" class="headerlink" title="Create your models here."></a>Create your models here.</h1><p>from django.db import models</p>
<p>class UserInfo(models.Model):<br>    user_type_choices = (<br>        (1, ‘普通用户’),<br>        (2, ‘管理员’),<br>        (3, ‘超级管理员’),<br>    )<br>    username = models.CharField(max_length=32)<br>    password = models.CharField(max_length=64)<br>    user_type = models.IntegerField(choices=user_type_choices, default=1)</p>
<p>class UserToken(models.Model):<br>    user = models.OneToOneField(‘UserInfo’, on_delete=True)<br>    token = models.CharField(max_length=64)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">试图</span><br></pre></td></tr></table></figure>
<h1 id="usr-bin-env-python-5"><a href="#usr-bin-env-python-5" class="headerlink" title="!/usr/bin/env python"></a>!/usr/bin/env python</h1><h1 id="coding-utf-8-8"><a href="#coding-utf-8-8" class="headerlink" title="-- coding:utf-8 --"></a>-<em>- coding:utf-8 -</em>-</h1><p>from rest_framework.views import APIView<br>from rest_framework.response import Response<br>from rest_framework import serializers<br>from . import models</p>
<p>class PasswordValidator(object):<br>    def <strong>init</strong>(self, base):<br>        self.base = str(base)</p>
<pre><code>def __call__(self, value):
    if value != self.base:
        message = &apos;This field must be %s.&apos; % self.base
        raise serializers.ValidationError(message)

def set_context(self, serializer_field):
    &quot;&quot;&quot;
    This hook is called by the serializer instance,
    prior to the validation call being made.
    &quot;&quot;&quot;
    # 执行验证之前调用,serializer_fields是当前字段对象
    pass</code></pre><p>class ModelUserSerializer(serializers.ModelSerializer):<br>    user_type = serializers.HyperlinkedIdentityField(view_name=’detail’)</p>
<pre><code>class Meta:
    model = models.UserInfo
    fields = &quot;__all__&quot;

    extra_kwargs = {
        &apos;username&apos;: {&apos;min_length&apos;: 6},
        &apos;pasword&apos;: {&apos;validators&apos;: [PasswordValidator(666), ]},
    }</code></pre><p>class TestView(APIView):<br>    authentication_classes = []<br>    permission_classes = []</p>
<pre><code>def get(self, request, *args, **kwargs):

    # 序列化，将数据库查询字段序列化为字典
    data_list = models.UserInfo.objects.all()
    ser = ModelUserSerializer(instance=data_list, many=True, context={&apos;request&apos;: request})
    # 或
    # obj = models.UserInfo.objects.all().first()
    # ser = UserSerializer(instance=obj, many=False)
    return Response(ser.data)

def post(self, request, *args, **kwargs):
    # 验证，对请求发来的数据进行验证
    print(request.data)
    ser = ModelUserSerializer(data=request.data)
    if ser.is_valid():
        print(ser.validated_data)
    else:
        print(ser.errors)

    return Response(&apos;POST请求，响应内容&apos;)</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">请求如下图所示:</span><br><span class="line">![images](https:&#x2F;&#x2F;note.youdao.com&#x2F;yws&#x2F;api&#x2F;personal&#x2F;file&#x2F;WEBe8cf0d66e9af86eaccbbfdc47f098d67?method&#x3D;download&amp;shareKey&#x3D;cff9deb39e5ad27072b3d2ccae7b1307)</span><br><span class="line"></span><br><span class="line">#### 3.6.4 自动生成URL</span><br><span class="line">路由</span><br></pre></td></tr></table></figure>
<p>from django.conf.urls import url, include<br>from app01.views import TestView</p>
<p>urlpatterns = [<br>    url(r’test/‘, TestView.as_view(), name=’test’),<br>    url(r’detail/(?P<pk>\d+)/‘, TestView.as_view(), name=’detail-info’),<br>]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">试图</span><br></pre></td></tr></table></figure>
<h1 id="usr-bin-env-python-6"><a href="#usr-bin-env-python-6" class="headerlink" title="!/usr/bin/env python"></a>!/usr/bin/env python</h1><h1 id="coding-utf-8-9"><a href="#coding-utf-8-9" class="headerlink" title="-- coding:utf-8 --"></a>-<em>- coding:utf-8 -</em>-</h1><p>from rest_framework.views import APIView<br>from rest_framework.response import Response<br>from rest_framework import serializers<br>from . import models</p>
<p>class PasswordValidator(object):<br>    def <strong>init</strong>(self, base):<br>        self.base = str(base)</p>
<pre><code>def __call__(self, value):
    if value != self.base:
        message = &apos;This field must be %s.&apos; % self.base
        raise serializers.ValidationError(message)

def set_context(self, serializer_field):
    &quot;&quot;&quot;
    This hook is called by the serializer instance,
    prior to the validation call being made.
    &quot;&quot;&quot;
    # 执行验证之前调用,serializer_fields是当前字段对象
    pass</code></pre><p>class ModelUserSerializer(serializers.HyperlinkedModelSerializer):<br>    ll = serializers.HyperlinkedIdentityField(view_name=’detail-info’)<br>    tt = serializers.CharField(required=False)</p>
<pre><code>class Meta:
    model = models.UserInfo
    fields = &quot;__all__&quot;
    list_serializer_class = serializers.ListSerializer

    extra_kwargs = {
        &apos;username&apos;: {&apos;min_length&apos;: 6},
        &apos;password&apos;: {&apos;validators&apos;: [PasswordValidator(666), ]},
        &apos;url&apos;: {&apos;view_name&apos;: &apos;detail-info&apos;},
        &apos;ut&apos;: {&apos;view_name&apos;: &apos;detail-info&apos;},
    }</code></pre><p>class TestView(APIView):<br>    def get(self, request, <em>args, *</em>kwargs):<br>        # # 序列化，将数据库查询字段序列化为字典<br>        data_list = models.UserInfo.objects.all()<br>        ser = ModelUserSerializer(instance=data_list, many=True, context={‘request’: request})<br>        # # 如果Many=True<br>        # # 或<br>        # # obj = models.UserInfo.objects.all().first()<br>        # # ser = UserSerializer(instance=obj, many=False)<br>        return Response(ser.data)</p>
<pre><code>def post(self, request, *args, **kwargs):
    # 验证，对请求发来的数据进行验证
    print(request.data)
    ser = ModelUserSerializer(data=request.data)
    if ser.is_valid():
        print(ser.validated_data)
    else:
        print(ser.errors)

    return Response(&apos;POST请求，响应内容&apos;)</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#### 3.7 分页</span><br><span class="line">#### 3.7.1 根据页码进行分页</span><br><span class="line">路由</span><br></pre></td></tr></table></figure>
<p>from django.conf.urls import url, include<br>from app01.views import UserViewSet</p>
<p>urlpatterns = [<br>    url(r’test/‘, UserViewSet.as_view(), name=’test’),<br>]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">试图</span><br></pre></td></tr></table></figure>
<h1 id="usr-bin-env-python-7"><a href="#usr-bin-env-python-7" class="headerlink" title="!/usr/bin/env python"></a>!/usr/bin/env python</h1><h1 id="coding-utf-8-10"><a href="#coding-utf-8-10" class="headerlink" title="-- coding:utf-8 --"></a>-<em>- coding:utf-8 -</em>-</h1><p>from rest_framework.views import APIView<br>from rest_framework import serializers<br>from . import models</p>
<p>from rest_framework.pagination import PageNumberPagination</p>
<p>class StandardResultsSetPagination(PageNumberPagination):<br>    # 默认每页显示的数据条数<br>    page_size = 1<br>    # 获取URL参数中设置的每页显示数据条数<br>    page_size_query_param = ‘page_size’</p>
<pre><code># 获取URL参数中传入的页码key
page_query_param = &apos;page&apos;

# 最大支持的每页显示的数据条数
max_page_size = 1</code></pre><p>class UserSerializer(serializers.ModelSerializer):<br>    class Meta:<br>        model = models.UserInfo<br>        fields = “<strong>all</strong>“</p>
<p>class UserViewSet(APIView):<br>    def get(self, request, <em>args, *</em>kwargs):<br>        user_list = models.UserInfo.objects.all().order_by(‘-id’)</p>
<pre><code># 实例化分页对象，获取数据库中的分页数据
paginator = StandardResultsSetPagination()
page_user_list = paginator.paginate_queryset(user_list, self.request, view=self)

# 序列化对象
serializer = UserSerializer(page_user_list, many=True)

# 生成分页和数据
response = paginator.get_paginated_response(serializer.data)
return response</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">访问验证:</span><br></pre></td></tr></table></figure>
<p><a href="http://127.0.0.1:8001/test/?page=1" target="_blank" rel="noopener">http://127.0.0.1:8001/test/?page=1</a><br><a href="http://127.0.0.1:8001/test/?page=2" target="_blank" rel="noopener">http://127.0.0.1:8001/test/?page=2</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#### 3.7.2 位置和个数进行分页</span><br><span class="line">路由</span><br></pre></td></tr></table></figure>
<p>from django.conf.urls import url, include<br>from app01.views import UserViewSet</p>
<p>urlpatterns = [<br>    url(r’test/‘, UserViewSet.as_view(), name=’test’),<br>]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">试图</span><br></pre></td></tr></table></figure>
<h1 id="usr-bin-env-python-8"><a href="#usr-bin-env-python-8" class="headerlink" title="!/usr/bin/env python"></a>!/usr/bin/env python</h1><h1 id="coding-utf-8-11"><a href="#coding-utf-8-11" class="headerlink" title="-- coding:utf-8 --"></a>-<em>- coding:utf-8 -</em>-</h1><p>from rest_framework.views import APIView<br>from rest_framework import serializers<br>from . import models</p>
<p>from rest_framework.pagination import PageNumberPagination, LimitOffsetPagination</p>
<p>class StandardResultsSetPagination(LimitOffsetPagination):<br>    # 默认每页显示的数据条数<br>    default_limit = 2<br>    # URL中传入的显示数据条数的参数<br>    limit_query_param = ‘limit’<br>    # URL中传入的数据位置的参数<br>    offset_query_param = ‘offset’<br>    # 最大每页显得条数<br>    max_limit = None</p>
<p>class UserSerializer(serializers.ModelSerializer):<br>    class Meta:<br>        model = models.UserInfo<br>        fields = “<strong>all</strong>“</p>
<p>class UserViewSet(APIView):<br>    def get(self, request, <em>args, *</em>kwargs):<br>        user_list = models.UserInfo.objects.all().order_by(‘-id’)</p>
<pre><code># 实例化分页对象，获取数据库中的分页数据
paginator = StandardResultsSetPagination()
page_user_list = paginator.paginate_queryset(user_list, self.request, view=self)

# 序列化对象
serializer = UserSerializer(page_user_list, many=True)

# 生成分页和数据
response = paginator.get_paginated_response(serializer.data)
return response</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">验证:</span><br><span class="line">![位置分页](https:&#x2F;&#x2F;note.youdao.com&#x2F;yws&#x2F;api&#x2F;personal&#x2F;file&#x2F;WEBdebc8cfb0c33b1533d1e041ed9925422?method&#x3D;download&amp;shareKey&#x3D;2b1d435332858dbe629d4c3d78b670d8)</span><br><span class="line"></span><br><span class="line">#### 3.7.3 游标分页</span><br><span class="line">路由</span><br></pre></td></tr></table></figure>
<p>from django.conf.urls import url, include<br>from app01.views import UserViewSet</p>
<p>urlpatterns = [<br>    url(r’test/‘, UserViewSet.as_view(), name=’test’),<br>]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">试图</span><br></pre></td></tr></table></figure>
<h1 id="usr-bin-env-python-9"><a href="#usr-bin-env-python-9" class="headerlink" title="!/usr/bin/env python"></a>!/usr/bin/env python</h1><h1 id="coding-utf-8-12"><a href="#coding-utf-8-12" class="headerlink" title="-- coding:utf-8 --"></a>-<em>- coding:utf-8 -</em>-</h1><p>from rest_framework.views import APIView<br>from rest_framework import serializers<br>from . import models</p>
<p>from rest_framework.pagination import PageNumberPagination, LimitOffsetPagination, CursorPagination</p>
<p>class StandardResultsSetPagination(CursorPagination):<br>    # URL传入的游标参数<br>    cursor_query_param = ‘cursor’<br>    # 默认每页显示的数据条数<br>    page_size = 10<br>    # URL传入的每页显示条数的参数<br>    page_size_query_param = ‘page_size’<br>    # 每页显示数据最大条数<br>    max_page_size = 1000</p>
<pre><code># 根据ID从大到小排列
ordering = &quot;id&quot;</code></pre><p>class UserSerializer(serializers.ModelSerializer):<br>    class Meta:<br>        model = models.UserInfo<br>        fields = “<strong>all</strong>“</p>
<p>class UserViewSet(APIView):<br>    def get(self, request, <em>args, *</em>kwargs):<br>        user_list = models.UserInfo.objects.all().order_by(‘-id’)</p>
<pre><code># 实例化分页对象，获取数据库中的分页数据
paginator = StandardResultsSetPagination()
page_user_list = paginator.paginate_queryset(user_list, self.request, view=self)

# 序列化对象
serializer = UserSerializer(page_user_list, many=True)

# 生成分页和数据
response = paginator.get_paginated_response(serializer.data)
return response</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 3.8  路由系统</span><br><span class="line">#### 3.8.1 自定义路由</span><br><span class="line">路由</span><br></pre></td></tr></table></figure>
<p>from django.conf.urls import url, include<br>from web.views import s11_render</p>
<p>urlpatterns = [<br>    url(r’^test/$’, s11_render.TestView.as_view()),<br>    url(r’^test.(?P<format>[a-z0-9]+)$’, s11_render.TestView.as_view()),<br>    url(r’^test/(?P<pk>[^/.]+)/$’, s11_render.TestView.as_view()),<br>    url(r’^test/(?P<pk>[^/.]+).(?P<format>[a-z0-9]+)$’, s11_render.TestView.as_view())<br>]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">试图</span><br></pre></td></tr></table></figure>
<p>from rest_framework.views import APIView<br>from rest_framework.response import Response<br>from .. import models</p>
<p>class TestView(APIView):<br>    def get(self, request, <em>args, *</em>kwargs):<br>        print(kwargs)<br>        print(self.renderer_classes)<br>        return Response(‘…’)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#### 3.8.2 半自动路由</span><br><span class="line">路由</span><br></pre></td></tr></table></figure>
<p>from django.conf.urls import url, include<br>from web.views import s10_generic</p>
<p>urlpatterns = [<br>    url(r’^test/$’, s10_generic.UserViewSet.as_view({‘get’: ‘list’, ‘post’: ‘create’})),<br>    url(r’^test/(?P<pk>\d+)/$’, s10_generic.UserViewSet.as_view(<br>        {‘get’: ‘retrieve’, ‘put’: ‘update’, ‘patch’: ‘partial_update’, ‘delete’: ‘destroy’})),<br>]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">试图</span><br></pre></td></tr></table></figure>
<p>#!/usr/bin/env python</p>
<h1 id="coding-utf-8-13"><a href="#coding-utf-8-13" class="headerlink" title="-- coding:utf-8 --"></a>-<em>- coding:utf-8 -</em>-</h1><p>from rest_framework.viewsets import ModelViewSet<br>from rest_framework import serializers<br>from .. import models</p>
<p>class UserSerializer(serializers.ModelSerializer):<br>    class Meta:<br>        model = models.UserInfo<br>        fields = “<strong>all</strong>“</p>
<p>class UserViewSet(ModelViewSet):<br>    queryset = models.UserInfo.objects.all()<br>    serializer_class = UserSerializer</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#### 3.8.3 全自动路由</span><br><span class="line">路由</span><br></pre></td></tr></table></figure>
<p>from django.conf.urls import url, include<br>from rest_framework import routers<br>from web.views import s10_generic</p>
<p>router = routers.DefaultRouter()<br>router.register(r’users’, s10_generic.UserViewSet)</p>
<p>urlpatterns = [<br>    url(r’^’, include(router.urls)),<br>]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">试图</span><br></pre></td></tr></table></figure>
<p>from rest_framework.viewsets import ModelViewSet<br>from rest_framework import serializers<br>from .. import models</p>
<p>class UserSerializer(serializers.ModelSerializer):<br>    class Meta:<br>        model = models.UserInfo<br>        fields = “<strong>all</strong>“</p>
<p>class UserViewSet(ModelViewSet):<br>    queryset = models.UserInfo.objects.all()<br>    serializer_class = UserSerializer</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 3.9 试图</span><br><span class="line">#### 3.9.1 GenericViewSet</span><br><span class="line">路由</span><br></pre></td></tr></table></figure>
<p>from django.conf.urls import url, include<br>from web.views.s7_viewset import TestView</p>
<p>urlpatterns = [<br>    url(r’test/‘, TestView.as_view({‘get’:’list’}), name=’test’),<br>    url(r’detail/(?P<pk>\d+)/‘, TestView.as_view({‘get’:’list’}), name=’xxxx’),<br>]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">试图</span><br></pre></td></tr></table></figure>
<p>#!/usr/bin/env python</p>
<h1 id="coding-utf-8-14"><a href="#coding-utf-8-14" class="headerlink" title="-- coding:utf-8 --"></a>-<em>- coding:utf-8 -</em>-</h1><p>from rest_framework import viewsets<br>from rest_framework.response import Response</p>
<p>class TestView(viewsets.GenericViewSet):<br>    def list(self, request, <em>args, *</em>kwargs):<br>        return Response(‘…’)</p>
<pre><code>def add(self, request, *args, **kwargs):
    pass

def delete(self, request, *args, **kwargs):
    pass

def edit(self, request, *args, **kwargs):
    pass</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#### 3.9.2 ModelViewSet(自定义URL)</span><br><span class="line">路由</span><br></pre></td></tr></table></figure>
<p>from django.conf.urls import url, include<br>from web.views import s10_generic</p>
<p>urlpatterns = [<br>    url(r’^test/$’, s10_generic.UserViewSet.as_view({‘get’: ‘list’, ‘post’: ‘create’})),<br>    url(r’^test/(?P<pk>\d+)/$’, s10_generic.UserViewSet.as_view(<br>        {‘get’: ‘retrieve’, ‘put’: ‘update’, ‘patch’: ‘partial_update’, ‘delete’: ‘destroy’})),<br>]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">试图</span><br></pre></td></tr></table></figure>
<p>#!/usr/bin/env python</p>
<h1 id="coding-utf-8-15"><a href="#coding-utf-8-15" class="headerlink" title="-- coding:utf-8 --"></a>-<em>- coding:utf-8 -</em>-</h1><p>from rest_framework.viewsets import ModelViewSet<br>from rest_framework import serializers<br>from .. import models</p>
<p>class UserSerializer(serializers.ModelSerializer):<br>    class Meta:<br>        model = models.UserInfo<br>        fields = “<strong>all</strong>“</p>
<p>class UserViewSet(ModelViewSet):<br>    queryset = models.UserInfo.objects.all()<br>    serializer_class = UserSerializer</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#### 3.9.3 ModelViewSet(rest framework路由)</span><br><span class="line">路由</span><br></pre></td></tr></table></figure>
<p>from django.conf.urls import url, include<br>from rest_framework import routers<br>from app01 import views</p>
<p>router = routers.DefaultRouter()<br>router.register(r’users’, views.UserViewSet)<br>router.register(r’groups’, views.GroupViewSet)</p>
<h1 id="Wire-up-our-API-using-automatic-URL-routing"><a href="#Wire-up-our-API-using-automatic-URL-routing" class="headerlink" title="Wire up our API using automatic URL routing."></a>Wire up our API using automatic URL routing.</h1><h1 id="Additionally-we-include-login-URLs-for-the-browsable-API"><a href="#Additionally-we-include-login-URLs-for-the-browsable-API" class="headerlink" title="Additionally, we include login URLs for the browsable API."></a>Additionally, we include login URLs for the browsable API.</h1><p>urlpatterns = [<br>    url(r’^’, include(router.urls)),<br>]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">试图</span><br></pre></td></tr></table></figure>
<p>from rest_framework import viewsets<br>from rest_framework import serializers</p>
<p>class UserSerializer(serializers.HyperlinkedModelSerializer):<br>    class Meta:<br>        model = models.User<br>        fields = (‘url’, ‘username’, ‘email’, ‘groups’)</p>
<p>class GroupSerializer(serializers.HyperlinkedModelSerializer):<br>    class Meta:<br>        model = models.Group<br>        fields = (‘url’, ‘name’)</p>
<p>class UserViewSet(viewsets.ModelViewSet):<br>    “””<br>    API endpoint that allows users to be viewed or edited.<br>    “””<br>    queryset = User.objects.all().order_by(‘-date_joined’)<br>    serializer_class = UserSerializer</p>
<p>class GroupViewSet(viewsets.ModelViewSet):<br>    “””<br>    API endpoint that allows groups to be viewed or edited.<br>    “””<br>    queryset = Group.objects.all()<br>    serializer_class = GroupSerializer</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 3.10 渲染器</span><br><span class="line">根据用户请求URL或用户可接受的类型,筛选出合适的渲染组件</span><br><span class="line">用户请求URL:</span><br><span class="line">- http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;test&#x2F;?format&#x3D;json</span><br><span class="line">- http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;test.json</span><br><span class="line">用户请求头:</span><br><span class="line">- Accept:text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8</span><br><span class="line"></span><br><span class="line">#### 3.10.1 Json</span><br><span class="line">访问URL:</span><br><span class="line">- http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;test&#x2F;?format&#x3D;json</span><br><span class="line">- http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;test.json</span><br><span class="line">- http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;test&#x2F;</span><br><span class="line">路由:</span><br></pre></td></tr></table></figure>
<p>from django.conf.urls import url, include<br>from web.views import s11_render</p>
<p>urlpatterns = [<br>    url(r’^test/$’, s11_render.TestView.as_view()),<br>    url(r’^test.(?P<format>[a-z0-9]+)’, s11_render.TestView.as_view()),<br>]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">试图:</span><br></pre></td></tr></table></figure>
<p>#!/usr/bin/env python</p>
<h1 id="coding-utf-8-16"><a href="#coding-utf-8-16" class="headerlink" title="-- coding:utf-8 --"></a>-<em>- coding:utf-8 -</em>-</h1><p>from rest_framework.views import APIView<br>from rest_framework.response import Response<br>from rest_framework import serializers</p>
<p>from rest_framework.renderers import JSONRenderer</p>
<p>from .. import models</p>
<p>class TestSerializer(serializers.ModelSerializer):<br>    class Meta:<br>        model = models.UserInfo<br>        fields = “<strong>all</strong>“</p>
<p>class TestView(APIView):<br>    renderer_classes = [JSONRenderer, ]</p>
<pre><code>def get(self, request, *args, **kwargs):
    user_list = models.UserInfo.objects.all()
    ser = TestSerializer(instance=user_list, many=True)
    return Response(ser.data)</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#### 3.10.2 表格</span><br><span class="line">访问URL:</span><br><span class="line">- http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;test&#x2F;?format&#x3D;admin</span><br><span class="line">- http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;test.admin</span><br><span class="line">- http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;test&#x2F;</span><br><span class="line">试图:</span><br></pre></td></tr></table></figure>
<p>#!/usr/bin/env python</p>
<h1 id="coding-utf-8-17"><a href="#coding-utf-8-17" class="headerlink" title="-- coding:utf-8 --"></a>-<em>- coding:utf-8 -</em>-</h1><p>from rest_framework.views import APIView<br>from rest_framework.response import Response<br>from rest_framework import serializers<br>from rest_framework.renderers import AdminRenderer<br>from . import models</p>
<p>class TestSerializer(serializers.ModelSerializer):<br>    class Meta:<br>        model = models.UserInfo<br>        fields = “<strong>all</strong>“</p>
<p>class TestView(APIView):<br>    renderer_classes = [AdminRenderer, ]</p>
<pre><code>def get(self, request, *args, **kwargs):
    user_list = models.UserInfo.objects.all()
    ser = TestSerializer(instance=user_list, many=True)
    return Response(ser.data)</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#### 3.10.3 Form表单</span><br><span class="line">访问URL:</span><br><span class="line">- http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;test&#x2F;?format&#x3D;form</span><br><span class="line">- http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;test.form</span><br><span class="line">- http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;test&#x2F;</span><br><span class="line">试图:</span><br></pre></td></tr></table></figure>
<p>#!/usr/bin/env python</p>
<h1 id="coding-utf-8-18"><a href="#coding-utf-8-18" class="headerlink" title="-- coding:utf-8 --"></a>-<em>- coding:utf-8 -</em>-</h1><p>from rest_framework.views import APIView<br>from rest_framework.response import Response<br>from rest_framework import serializers</p>
<p>from rest_framework.renderers import JSONRenderer<br>from rest_framework.renderers import AdminRenderer<br>from rest_framework.renderers import HTMLFormRendere<br>from . import models</p>
<p>class TestSerializer(serializers.ModelSerializer):<br>    class Meta:<br>        model = models.UserInfo<br>        fields = “<strong>all</strong>“</p>
<p>class TestView(APIView):<br>    renderer_classes = [HTMLFormRenderer, ]</p>
<pre><code>def get(self, request, *args, **kwargs):
    user_list = models.UserInfo.objects.all().first()
    ser = TestSerializer(instance=user_list, many=False)
    return Response(ser.data)</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#### 3.10.4 自定义显示模版</span><br><span class="line">访问URL:</span><br><span class="line">- http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;test&#x2F;?format&#x3D;html</span><br><span class="line">- http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;test.html</span><br><span class="line">- http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;test&#x2F;</span><br><span class="line">路由</span><br></pre></td></tr></table></figure>
<p>from django.conf.urls import url, include<br>from web.views import s11_render</p>
<p>urlpatterns = [<br>    url(r’^test/$’, s11_render.TestView.as_view()),<br>    url(r’^test.(?P<format>[a-z0-9]+)’, s11_render.TestView.as_view()),<br>]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">试图</span><br></pre></td></tr></table></figure>
<p>#!/usr/bin/env python</p>
<h1 id="coding-utf-8-19"><a href="#coding-utf-8-19" class="headerlink" title="-- coding:utf-8 --"></a>-<em>- coding:utf-8 -</em>-</h1><p>from rest_framework.views import APIView<br>from rest_framework.response import Response<br>from rest_framework import serializers<br>from rest_framework.renderers import TemplateHTMLRenderer<br>from . import models</p>
<p>class TestSerializer(serializers.ModelSerializer):<br>    class Meta:<br>        model = models.UserInfo<br>        fields = “<strong>all</strong>“</p>
<p>class TestView(APIView):<br>    renderer_classes = [TemplateHTMLRenderer, ]</p>
<pre><code>def get(self, request, *args, **kwargs):
    user_list = models.UserInfo.objects.all().first()
    ser = TestSerializer(instance=user_list, many=False)
    return Response(ser.data, template_name=&apos;user_detail.html&apos;)</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">模版</span><br></pre></td></tr></table></figure>
<p>$ cat user_detail.html<br><!DOCTYPE html></p>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
    
    
    
</body>
</html>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#### 3.10.5 浏览器API+JSON</span><br><span class="line">访问URL:</span><br><span class="line">- http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;test&#x2F;?format&#x3D;api</span><br><span class="line">- http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;test.api</span><br><span class="line">- http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;test&#x2F;</span><br><span class="line">试图:</span><br></pre></td></tr></table></figure>
#!/usr/bin/env python
# -*- coding:utf-8 -*-
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import serializers
from rest_framework.renderers import JSONRenderer
from rest_framework.renderers import BrowsableAPIRenderer
from . import models

<p>class TestSerializer(serializers.ModelSerializer):<br>    class Meta:<br>        model = models.UserInfo<br>        fields = “<strong>all</strong>“</p>
<p>class CustomBrowsableAPIRenderer(BrowsableAPIRenderer):<br>    def get_default_renderer(self, view):<br>        return JSONRenderer()</p>
<p>class TestView(APIView):<br>    renderer_classes = [CustomBrowsableAPIRenderer, ]</p>
<pre><code>def get(self, request, *args, **kwargs):
    user_list = models.UserInfo.objects.all().first()
    ser = TestSerializer(instance=user_list, many=False)
    return Response(ser.data, template_name=&apos;user_detail.html&apos;)</code></pre><pre><code>注意: 如果同时多个存在时,自动根据URL后缀来选择渲染器


[原文地址](http://www.cnblogs.com/wupeiqi/articles/7805382.html)





</code></pre>]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
</search>
