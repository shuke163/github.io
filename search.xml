<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>让人想骂街的 Python 炫技操作：条件语句的七种写法</title>
    <url>/2020/04/20/</url>
    <content><![CDATA[<p>有的人说 Python 是一门入门容易，但是精通难的语言，这一点我非常赞同。</p>
<p>Python 语言里有许多（而且是越来越多）的高级特性，是 Python 发烧友们非常喜欢的。在这些人的眼里，能够写出那些一般开发者看不懂的高级特性，就是高手，就是大神。</p>
<p>但你要知道，在团队合作里，炫技是大忌。</p>
<p>为什么这么说呢？我说下自己的看法：</p>
<p>越简洁的代码，越清晰的逻辑，就越不容易出错；<br>在团队合作中，你的代码不只有你在维护，降低别人的阅读/理解代码逻辑的成本是一种良好的品德<br>简单的代码，只会用到最基本的语法糖，复杂的高级特性，会有更多的依赖（如语言的版本）<br>在这个系列里，我将总结列举一下，我所见过的那些炫技操作，今天先来个热身，写一写很简单的条件判断语句里有哪些让人想骂街的炫技操作，在这里，如果你是 Python 发烧友，你可以学到一些写出超酷的代码书写技巧，但学习归学习，希望你区分场景使用。</p>
<ol start="0">
<li>原代码<br>这是一段非常简单的通过年龄判断一个人是否成年的代码，由于代码行数过多，有些人就不太愿意这样写，因为这体现不出自己多年的 Python 功力。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if age &gt; 18:</span><br><span class="line">    return &quot;已成年&quot;</span><br><span class="line">else:</span><br><span class="line">    return &quot;未成年&quot;</span><br></pre></td></tr></table></figure>
下面我列举了六种这段代码的变异写法，一个比一个还 6 ，单独拿出来比较好理解，放在工程代码里，没用过这些学法的人，一定会看得一脸懵逼，理解了之后，又不经意大呼：卧槽，还可以这样写？，而后就要开始骂街了：这是给人看的代码？</li>
<li>第一种<br>语法:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;on_true&gt; if &lt;condition&gt; else &lt;on_false&gt;</span><br></pre></td></tr></table></figure>
例子<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; age1 &#x3D; 20</span><br><span class="line">&gt;&gt;&gt; age2 &#x3D; 17</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; msg1 &#x3D; &quot;已成年&quot; if age1 &gt; 18 else &quot;未成年&quot;</span><br><span class="line">&gt;&gt;&gt; print msg1</span><br><span class="line">已成年</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; msg2 &#x3D; &quot;已成年&quot; if age2 &gt; 18 else &quot;未成年&quot;</span><br><span class="line">&gt;&gt;&gt; print msg2</span><br><span class="line">未成年</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></li>
<li>第二种<br>语法<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;expression&gt; and &lt;on_true&gt; or &lt;on_false&gt;</span><br></pre></td></tr></table></figure>
例子<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; msg1 &#x3D; age1 &gt; 18 and &quot;已成年&quot; or &quot;未成年&quot;</span><br><span class="line">&gt;&gt;&gt; msg2 &#x3D; &quot;已成年&quot; if age2 &gt; 18 else &quot;未成年&quot;</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; print(msg1)</span><br><span class="line">已成年</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; print(msg2)</span><br><span class="line">未成年</span><br></pre></td></tr></table></figure></li>
<li>第三种<br>语法<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(&lt;on_true&gt;, &lt;on_false&gt;)[condition]</span><br></pre></td></tr></table></figure>
例子<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; msg1 &#x3D; (&quot;未成年&quot;, &quot;已成年&quot;)[age1 &gt; 18]</span><br><span class="line">&gt;&gt;&gt; print(msg1)</span><br><span class="line">已成年</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; msg2 &#x3D; (&quot;未成年&quot;, &quot;已成年&quot;)[age2 &gt; 18]</span><br><span class="line">&gt;&gt;&gt; print(msg2)</span><br><span class="line">未成年</span><br></pre></td></tr></table></figure></li>
<li>第四种<br>语法:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lambda: &lt;on_false&gt;, lambda:&lt;on_true&gt;)[&lt;condition&gt;]()</span><br></pre></td></tr></table></figure>
例子<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; msg1 &#x3D; (lambda:&quot;未成年&quot;, lambda:&quot;已成年&quot;)[age1 &gt; 18]()</span><br><span class="line">&gt;&gt;&gt; print(msg1)</span><br><span class="line">已成年</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; msg2 &#x3D; (lambda:&quot;未成年&quot;, lambda:&quot;已成年&quot;)[age2 &gt; 18]()</span><br><span class="line">&gt;&gt;&gt; print(msg2)</span><br><span class="line">未成年</span><br></pre></td></tr></table></figure></li>
<li>第五种<br>语法:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;True: &lt;on_true&gt;, False: &lt;on_false&gt;&#125;[&lt;condition&gt;]</span><br></pre></td></tr></table></figure>
例子<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; msg1 &#x3D; &#123;True: &quot;已成年&quot;, False: &quot;未成年&quot;&#125;[age1 &gt; 18]</span><br><span class="line">&gt;&gt;&gt; print(msg1)</span><br><span class="line">已成年</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; msg2 &#x3D; &#123;True: &quot;已成年&quot;, False: &quot;未成年&quot;&#125;[age2 &gt; 18]</span><br><span class="line">&gt;&gt;&gt; print(msg2)</span><br><span class="line">未成年</span><br></pre></td></tr></table></figure></li>
<li>第六种<br>语法:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">((&lt;condition&gt;) and (&lt;on_true&gt;,) or (&lt;on_false&gt;,))[0]</span><br></pre></td></tr></table></figure>
例子:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; msg1 &#x3D; ((age1 &gt; 18) and (&quot;已成年&quot;,) or (&quot;未成年&quot;,))[0]</span><br><span class="line">&gt;&gt;&gt; print(msg1)</span><br><span class="line">已成年</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; msg2 &#x3D; ((age2 &gt; 18) and (&quot;已成年&quot;,) or (&quot;未成年&quot;,))[0]</span><br><span class="line">&gt;&gt;&gt; print(msg2)</span><br><span class="line">未成年</span><br></pre></td></tr></table></figure>
以上代码，都比较简单，仔细看都能看懂，我就不做解释了。</li>
</ol>
<p>看到这里，有没有涨姿势了，学了这么久的 Python ，这么多骚操作，还真是活久见。。这六种写法里，我最推荐使用的是第一种，自己也经常在用，简洁直白，代码行还少。而其他的写法虽然能写，但是不会用，也不希望在我余生里碰到会在公共代码里用这些写法的同事。</p>
]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>PYTHON</tag>
      </tags>
  </entry>
  <entry>
    <title>python的logging模块实现json格式的日志输出</title>
    <url>/2020/04/20/</url>
    <content><![CDATA[<h2 id="python的logging模块实现json格式的日志输出"><a href="#python的logging模块实现json格式的日志输出" class="headerlink" title="python的logging模块实现json格式的日志输出"></a>python的logging模块实现json格式的日志输出</h2><blockquote>
<p>想要让开发过程或者是上线后的bug无处可藏，最好的方式便是在程序运行过程中，不断收集重要的日志，以供分析使用。Python中内置的log收集模块是logging，该模块使用起来比较方便，但是美中不足的地方就是日志的格式转成json比较麻烦。于是我结合logging和另一个模块python-json-logger(pip install python-json-logger), 实现json格式的日志输出。</p>
</blockquote>
<p>以下代码可以做成模块，直接导入使用</p>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;user&#x2F;bin&#x2F;env python</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import logging, logging.config, os</span><br><span class="line">import structlog</span><br><span class="line">import traceback</span><br><span class="line">from structlog import configure, processors, stdlib, threadlocal</span><br><span class="line">from pythonjsonlogger import jsonlogger</span><br><span class="line">BASE_DIR &#x3D; BASE_DIR &#x3D; os.path.dirname(os.path.abspath(__file__))</span><br><span class="line">DEBUG &#x3D; True  # 标记是否在开发环境</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 给过滤器使用的判断</span><br><span class="line">class RequireDebugTrue(logging.Filter):</span><br><span class="line">    # 实现filter方法</span><br><span class="line">    def filter(self, record):</span><br><span class="line">        return DEBUG</span><br><span class="line"></span><br><span class="line">def get_logger():</span><br><span class="line">    LOGGING &#x3D; &#123;</span><br><span class="line">    # 基本设置</span><br><span class="line">        &#39;version&#39;: 1,  # 日志级别</span><br><span class="line">        &#39;disable_existing_loggers&#39;: False,  # 是否禁用现有的记录器</span><br><span class="line"></span><br><span class="line">    # 日志格式集合</span><br><span class="line">        &#39;formatters&#39;: &#123;</span><br><span class="line">        # 标准输出格式</span><br><span class="line">            &#39;json&#39;: &#123;</span><br><span class="line">            # [具体时间][线程名:线程ID][日志名字:日志级别名称(日志级别ID)] [输出的模块:输出的函数]:日志内容</span><br><span class="line">                &#39;format&#39;: &#39;[%(asctime)s][%(threadName)s:%(thread)d][%(name)s:%(levelname)s(%(lineno)d)]\n[%(module)s:%(funcName)s]:%(message)s&#39;,</span><br><span class="line">                &#39;class&#39;: &#39;pythonjsonlogger.jsonlogger.JsonFormatter&#39;,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    # 过滤器</span><br><span class="line">        &#39;filters&#39;: &#123;</span><br><span class="line">            &#39;require_debug_true&#39;: &#123;</span><br><span class="line">                &#39;()&#39;: RequireDebugTrue,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    # 处理器集合</span><br><span class="line">        &#39;handlers&#39;: &#123;</span><br><span class="line">        # 输出到控制台</span><br><span class="line">        # 输出到文件</span><br><span class="line">            &#39;TimeChecklog&#39;: &#123;</span><br><span class="line">                &#39;level&#39;: &#39;DEBUG&#39;,</span><br><span class="line">                &#39;class&#39;: &#39;logging.handlers.RotatingFileHandler&#39;,</span><br><span class="line">                &#39;formatter&#39;: &#39;json&#39;,</span><br><span class="line">                &#39;filename&#39;: os.path.join(&quot;.&#x2F;&quot;, &#39;TimeoutCheck.log&#39;),  # 输出位置</span><br><span class="line">                &#39;maxBytes&#39;: 1024 * 1024 * 5,  # 文件大小 5M</span><br><span class="line">                &#39;backupCount&#39;: 5,  # 备份份数</span><br><span class="line">                &#39;encoding&#39;: &#39;utf8&#39;,  # 文件编码</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    # 日志管理器集合</span><br><span class="line">        &#39;loggers&#39;: &#123;</span><br><span class="line">        # 管理器</span><br><span class="line">            &#39;proxyCheck&#39;: &#123;</span><br><span class="line">                &#39;handlers&#39;: [&#39;TimeChecklog&#39;],</span><br><span class="line">                &#39;level&#39;: &#39;DEBUG&#39;,</span><br><span class="line">                &#39;propagate&#39;: True,  # 是否传递给父记录器</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    logging.config.dictConfig(LOGGING)</span><br><span class="line">    logger &#x3D; logging.getLogger(&quot;proxyCheck&quot;)</span><br><span class="line">    return logger</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 测试用例，你可以把get_logger()封装成一个模块，from xxx import get_logger()</span><br><span class="line">logger1 &#x3D; get_logger()</span><br><span class="line">def test():</span><br><span class="line">    try:</span><br><span class="line">        a &#x3D; 1 &#x2F; 0</span><br><span class="line">    except Exception as e:</span><br><span class="line">        logger1.error(&quot;This is a error info&quot;,exc_info&#x3D;True)  # 写入错误日志</span><br><span class="line">        #如果需要添加额外的信息，使用extra关键字即可</span><br><span class="line">        logger1.error(str(traceback.format_exc()), extra&#x3D;&#123;&quot;key1&quot;: &quot;value1&quot;, &quot;key2&quot;:&quot;value2&quot;&#125;)</span><br><span class="line">        # 其他错误处理代码</span><br><span class="line">        pass</span><br><span class="line">test()</span><br></pre></td></tr></table></figure>
<h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><p>测试的结果，可以在./TimeoutCheck.log文件中看到输出的日志</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat TimeoutCheck.log</span><br><span class="line">&#123;&quot;asctime&quot;: &quot;2019-01-31 11:29:16,818&quot;, &quot;threadName&quot;: &quot;MainThread&quot;, &quot;thread&quot;: 140735830963008, &quot;name&quot;: &quot;proxyCheck&quot;, &quot;levelname&quot;: &quot;ERROR&quot;, &quot;%(lineno&quot;: null, &quot;module&quot;: &quot;log&quot;, &quot;funcName&quot;: &quot;test&quot;, &quot;message&quot;: &quot;This is a error info&quot;, &quot;exc_info&quot;: &quot;Traceback (most recent call last):\n  File \&quot;log.py\&quot;, line 74, in test\n    a &#x3D; 1 &#x2F; 0\nZeroDivisionError: division by zero&quot;&#125;</span><br><span class="line">&#123;&quot;asctime&quot;: &quot;2019-01-31 11:29:16,819&quot;, &quot;threadName&quot;: &quot;MainThread&quot;, &quot;thread&quot;: 140735830963008, &quot;name&quot;: &quot;proxyCheck&quot;, &quot;levelname&quot;: &quot;ERROR&quot;, &quot;%(lineno&quot;: null, &quot;module&quot;: &quot;log&quot;, &quot;funcName&quot;: &quot;test&quot;, &quot;message&quot;: &quot;Traceback (most recent call last):\n  File \&quot;log.py\&quot;, line 74, in test\n    a &#x3D; 1 &#x2F; 0\nZeroDivisionError: division by zero\n&quot;, &quot;key1&quot;: &quot;value1&quot;, &quot;key2&quot;: &quot;value2&quot;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="版本二"><a href="#版本二" class="headerlink" title="版本二"></a>版本二</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import json</span><br><span class="line">import datetime</span><br><span class="line">import logging</span><br><span class="line">import logging.config</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">class LogstashFormatter(logging.Formatter):</span><br><span class="line">    def __init__(self, task_name&#x3D;None):</span><br><span class="line">        self.task_name &#x3D; task_name</span><br><span class="line"></span><br><span class="line">        super(LogstashFormatter, self).__init__()</span><br><span class="line"></span><br><span class="line">    def format(self, record):</span><br><span class="line">        data &#x3D; &#123;&#39;@message&#39;: record.msg,</span><br><span class="line">                &#39;@timestamp&#39;: datetime.datetime.utcnow().strftime(&#39;%Y-%m-%dT%H:%M:%S.%fZ&#39;),</span><br><span class="line">                &#39;@type&#39;: &#39;Add log extra test&#39;&#125;</span><br><span class="line"></span><br><span class="line">        if self.task_name:</span><br><span class="line">            data[&#39;@task_name&#39;] &#x3D; self.task_name</span><br><span class="line"></span><br><span class="line">        for key, value in record.args.items():</span><br><span class="line">            data[key] &#x3D; value</span><br><span class="line"></span><br><span class="line">        return json.dumps(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">logger &#x3D; logging.getLogger(__name__)</span><br><span class="line"></span><br><span class="line">logging.config.dictConfig(&#123;</span><br><span class="line">    &#39;version&#39;: 1,</span><br><span class="line">    &#39;disable_existing_loggers&#39;: False,  # this fixes the problem</span><br><span class="line">    &#39;formatters&#39;: &#123;</span><br><span class="line">        &#39;json&#39;: &#123;</span><br><span class="line">            &#39;()&#39;: LogstashFormatter,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#39;handlers&#39;: &#123;</span><br><span class="line">        &#39;console&#39;: &#123;</span><br><span class="line">            &#39;level&#39;: &#39;DEBUG&#39;,</span><br><span class="line">            &#39;class&#39;: &#39;logging.StreamHandler&#39;,</span><br><span class="line">            &#39;formatter&#39;: &#39;json&#39;,</span><br><span class="line">            &#39;stream&#39;: sys.stdout</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#39;loggers&#39;: &#123;</span><br><span class="line">        &#39;&#39;: &#123;</span><br><span class="line">            &#39;handlers&#39;: [&#39;console&#39;],</span><br><span class="line">            &#39;level&#39;: &#39;INFO&#39;,</span><br><span class="line">            &#39;propagate&#39;: True,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">logger.info(&#39;It works!&#39;, &#123;&#39;aaa&#39;:&#39;bbbb&#39;,&#39;cccc&#39;:&#39;dddd&#39;&#125;)</span><br><span class="line"></span><br><span class="line"># output:</span><br><span class="line">&#123;&quot;@message&quot;: &quot;It works!&quot;, &quot;@timestamp&quot;: &quot;2019-01-31T02:52:24.786570Z&quot;, &quot;@type&quot;: &quot;Add log extra test&quot;, &quot;aaa&quot;: &quot;bbbb&quot;, &quot;cccc&quot;: &quot;dddd&quot;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="版本三"><a href="#版本三" class="headerlink" title="版本三"></a>版本三</h3><blockquote>
<p>此版本为优化版本,继承pythonjsonlogger.jsonlogger库中的JsonFormatter类,重写format方法</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#! &#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">@author: shuke</span><br><span class="line">@file: jsonlog.py </span><br><span class="line">@time: 2019&#x2F;01&#x2F;20 15:36</span><br><span class="line">@contact: shu_ke163@163.com</span><br><span class="line">@software:  shuke-logging</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line">import time</span><br><span class="line">import json</span><br><span class="line">import socket</span><br><span class="line">import datetime</span><br><span class="line">import logging</span><br><span class="line">import traceback</span><br><span class="line">import logging.config</span><br><span class="line">from pythonjsonlogger.jsonlogger import JsonFormatter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class JsonFormatter(JsonFormatter):</span><br><span class="line">    def __init__(self, *args, **kwargs):</span><br><span class="line">        self.host &#x3D; socket.getfqdn()</span><br><span class="line">        self.message_type &#x3D; &quot;json&quot;</span><br><span class="line">        self.version &#x3D; &quot;v1.0&quot;</span><br><span class="line">        super(JsonFormatter, self).__init__(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    def get_extra_fields(self, record):</span><br><span class="line">        # The list contains all the attributes listed in</span><br><span class="line">        # http:&#x2F;&#x2F;docs.python.org&#x2F;library&#x2F;logging.html#logrecord-attributes</span><br><span class="line">        builtin_attr_list &#x3D; [</span><br><span class="line">            &#39;args&#39;, &#39;asctime&#39;, &#39;created&#39;, &#39;exc_info&#39;, &#39;exc_text&#39;, &#39;filename&#39;, &#39;id&#39;, &#39;levelname&#39;, &#39;levelno&#39;, &#39;module&#39;,</span><br><span class="line">            &#39;msecs&#39;, &#39;msecs&#39;, &#39;message&#39;, &#39;msg&#39;, &#39;name&#39;, &#39;pathname&#39;, &#39;relativeCreated&#39;, &#39;extra&#39;]</span><br><span class="line"></span><br><span class="line">        fields &#x3D; &#123;&#125;</span><br><span class="line"></span><br><span class="line">        for key, value in record.__dict__.items():</span><br><span class="line">            if key not in builtin_attr_list:</span><br><span class="line">                fields[key] &#x3D; repr(value)</span><br><span class="line"></span><br><span class="line">        fields[&quot;project&quot;] &#x3D; &quot;WEHOST&quot;</span><br><span class="line">        fields[&quot;team&quot;] &#x3D; &quot;OPS&quot;</span><br><span class="line">        fields[&quot;department&quot;] &#x3D; &quot;IT&quot;</span><br><span class="line">        fields[&quot;log_debug&quot;] &#x3D; True</span><br><span class="line"></span><br><span class="line">        return fields</span><br><span class="line"></span><br><span class="line">    def format_timestamp(self, time):</span><br><span class="line">        return datetime.datetime.now().strftime(&#39;%Y-%m-%d %H:%M:%S %f&#39;)</span><br><span class="line"></span><br><span class="line">    def format(self, record):</span><br><span class="line">        message &#x3D; &#123;</span><br><span class="line">            &#39;@timestamp&#39;: self.format_timestamp(record.created),</span><br><span class="line">            &#39;@version&#39;: &#39;v1.0&#39;,</span><br><span class="line">            &#39;name&#39;: record.name,</span><br><span class="line">            &#39;host&#39;: self.host,</span><br><span class="line">            &#39;pathname&#39;: record.pathname,</span><br><span class="line">            &#39;levelno&#39;: record.levelno,</span><br><span class="line">            &#39;filename&#39;: record.filename,</span><br><span class="line">            &#39;module&#39;: record.module,</span><br><span class="line">            &#39;exc_info&#39;: &#39;&#39;.join(traceback.format_exception(*record.exc_info)),</span><br><span class="line">            &#39;exc_text&#39;: record.exc_text,</span><br><span class="line">            &#39;stack_info&#39;: record.stack_info,</span><br><span class="line">            &#39;created&#39;: time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time.localtime(record.created)),</span><br><span class="line">            &#39;msecs&#39;: record.msecs,</span><br><span class="line">            &#39;relativeCreated&#39;: record.relativeCreated,</span><br><span class="line">            &#39;type&#39;: self.message_type,</span><br><span class="line">            &#39;level&#39;: record.levelname,</span><br><span class="line">            &#39;message&#39;: record.getMessage(),</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        # Add extra fields</span><br><span class="line">        message.update(self.get_extra_fields(record))</span><br><span class="line"></span><br><span class="line">        return json.dumps(message, indent&#x3D;4)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_logger():</span><br><span class="line">    LOGGING &#x3D; &#123;</span><br><span class="line">        # 基本设置</span><br><span class="line">        &#39;version&#39;: 1,  # 日志级别</span><br><span class="line">        &#39;disable_existing_loggers&#39;: False,  # 是否禁用现有的记录器</span><br><span class="line"></span><br><span class="line">        # 日志格式集合</span><br><span class="line">        &#39;formatters&#39;: &#123;</span><br><span class="line">            # 标准输出格式</span><br><span class="line">            &#39;json&#39;: &#123;</span><br><span class="line">                # [具体时间][线程名:线程ID][日志名字:日志级别名称(日志级别ID)] [输出的模块:输出的函数]:日志内容</span><br><span class="line">                # &#39;format&#39;: &#39;[%(asctime)s][%(threadName)s:%(thread)d][%(name)s:%(levelname)s(%(lineno)d)]\n[%(module)s:%(funcName)s]:%(message)s&#39;,</span><br><span class="line">                # &#39;format&#39;: &#39;[%(asctime)s][%(threadName)s:%(thread)d][%(created)s:%(process)d:%(processName)s][%(relativeCreated)s:%(msecs)s][%(pathname)s:%(filename)s][%(name)s:%(levelname)s:%(lineno)d)][%(module)s:%(funcName)s]:%(message)s&#39;,</span><br><span class="line">                # &#39;()&#39;: JsonFormatter.format,</span><br><span class="line">                # &#39;class&#39;: &#39;pythonjsonlogger.jsonlogger.JsonFormatter&#39;,</span><br><span class="line">                &#39;()&#39;: JsonFormatter,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        # 处理器集合</span><br><span class="line">        &#39;handlers&#39;: &#123;</span><br><span class="line">            # 输出到控制台</span><br><span class="line">            &#39;console&#39;: &#123;</span><br><span class="line">                &#39;level&#39;: &#39;DEBUG&#39;,</span><br><span class="line">                &#39;class&#39;: &#39;logging.StreamHandler&#39;,</span><br><span class="line">                &#39;formatter&#39;: &#39;json&#39;,</span><br><span class="line">                &#39;stream&#39;: sys.stdout</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        # 日志管理器集合</span><br><span class="line">        &#39;loggers&#39;: &#123;</span><br><span class="line">            # 管理器</span><br><span class="line">            &#39;mylog&#39;: &#123;</span><br><span class="line">                &#39;handlers&#39;: [&#39;console&#39;],</span><br><span class="line">                &#39;level&#39;: &#39;DEBUG&#39;,</span><br><span class="line">                &#39;propagate&#39;: True,  # 是否传递给父记录器</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    logging.config.dictConfig(LOGGING)</span><br><span class="line">    logger &#x3D; logging.getLogger(&quot;mylog&quot;)</span><br><span class="line">    return logger</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 测试用例，你可以把get_logger()封装成一个模块，from xxx import get_logger()</span><br><span class="line">logger &#x3D; get_logger()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    try:</span><br><span class="line">        a &#x3D; 1 &#x2F; 0</span><br><span class="line">    except Exception as e:</span><br><span class="line">        # 如果需要添加额外的信息，使用extra关键字即可</span><br><span class="line">        logger.info(&quot;This is a info message&quot;, extra&#x3D;&#123;&quot;type&quot;: &quot;json&quot;, &quot;department&quot;: &quot;IT&quot;, &quot;bussiness&quot;: &quot;game&quot;&#125;,</span><br><span class="line">                    exc_info&#x3D;True)</span><br><span class="line">        logger.info(&quot;Hello World&quot;, extra&#x3D;&#123;&quot;key1&quot;: &quot;value1&quot;, &quot;key2&quot;: &quot;value2&quot;&#125;, exc_info&#x3D;True)</span><br><span class="line">        # 其他错误处理代码</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    main()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># output:</span><br><span class="line">&#123;</span><br><span class="line">    &quot;@timestamp&quot;: &quot;2019-01-31 18:53:39 581892&quot;,</span><br><span class="line">    &quot;@version&quot;: &quot;v1.0&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;mylog&quot;,</span><br><span class="line">    &quot;host&quot;: &quot;MacBooKPro&quot;,</span><br><span class="line">    &quot;pathname&quot;: &quot;jsonlog.py&quot;,</span><br><span class="line">    &quot;levelno&quot;: 20,</span><br><span class="line">    &quot;filename&quot;: &quot;jsonlog.py&quot;,</span><br><span class="line">    &quot;module&quot;: &quot;jsonlog&quot;,</span><br><span class="line">    &quot;exc_info&quot;: &quot;Traceback (most recent call last):\n  File \&quot;jsonlog.py\&quot;, line 129, in test\n    a &#x3D; 1 &#x2F; 0\nZeroDivisionError: division by zero\n&quot;,</span><br><span class="line">    &quot;exc_text&quot;: null,</span><br><span class="line">    &quot;stack_info&quot;: &quot;None&quot;,</span><br><span class="line">    &quot;created&quot;: &quot;2019-01-31 18:53:39&quot;,</span><br><span class="line">    &quot;msecs&quot;: 581.8040370941162,</span><br><span class="line">    &quot;relativeCreated&quot;: 47.5161075592041,</span><br><span class="line">    &quot;type&quot;: &quot;&#39;json&#39;&quot;,</span><br><span class="line">    &quot;level&quot;: &quot;INFO&quot;,</span><br><span class="line">    &quot;message&quot;: &quot;This is a info message&quot;,</span><br><span class="line">    &quot;lineno&quot;: &quot;133&quot;,</span><br><span class="line">    &quot;funcName&quot;: &quot;&#39;test&#39;&quot;,</span><br><span class="line">    &quot;thread&quot;: &quot;140735830963008&quot;,</span><br><span class="line">    &quot;threadName&quot;: &quot;&#39;MainThread&#39;&quot;,</span><br><span class="line">    &quot;processName&quot;: &quot;&#39;MainProcess&#39;&quot;,</span><br><span class="line">    &quot;process&quot;: &quot;83309&quot;,</span><br><span class="line">    &quot;department&quot;: &quot;IT&quot;,</span><br><span class="line">    &quot;bussiness&quot;: &quot;&#39;game&#39;&quot;,</span><br><span class="line">    &quot;project&quot;: &quot;WEHOST&quot;,</span><br><span class="line">    &quot;team&quot;: &quot;OPS&quot;,</span><br><span class="line">    &quot;log_debug&quot;: true</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;@timestamp&quot;: &quot;2019-01-31 18:53:39 582770&quot;,</span><br><span class="line">    &quot;@version&quot;: &quot;v1.0&quot;,</span><br><span class="line">    &quot;name&quot;: &quot;mylog&quot;,</span><br><span class="line">    &quot;host&quot;: &quot;MacBooKPro&quot;,</span><br><span class="line">    &quot;pathname&quot;: &quot;jsonlog.py&quot;,</span><br><span class="line">    &quot;levelno&quot;: 20,</span><br><span class="line">    &quot;filename&quot;: &quot;jsonlog.py&quot;,</span><br><span class="line">    &quot;module&quot;: &quot;jsonlog&quot;,</span><br><span class="line">    &quot;exc_info&quot;: &quot;Traceback (most recent call last):\n  File \&quot;jsonlog.py\&quot;, line 129, in test\n    a &#x3D; 1 &#x2F; 0\nZeroDivisionError: division by zero\n&quot;,</span><br><span class="line">    &quot;exc_text&quot;: null,</span><br><span class="line">    &quot;stack_info&quot;: &quot;None&quot;,</span><br><span class="line">    &quot;created&quot;: &quot;2019-01-31 18:53:39&quot;,</span><br><span class="line">    &quot;msecs&quot;: 582.7357769012451,</span><br><span class="line">    &quot;relativeCreated&quot;: 48.44784736633301,</span><br><span class="line">    &quot;type&quot;: &quot;json&quot;,</span><br><span class="line">    &quot;level&quot;: &quot;INFO&quot;,</span><br><span class="line">    &quot;message&quot;: &quot;Hello World&quot;,</span><br><span class="line">    &quot;lineno&quot;: &quot;134&quot;,</span><br><span class="line">    &quot;funcName&quot;: &quot;&#39;test&#39;&quot;,</span><br><span class="line">    &quot;thread&quot;: &quot;140735830963008&quot;,</span><br><span class="line">    &quot;threadName&quot;: &quot;&#39;MainThread&#39;&quot;,</span><br><span class="line">    &quot;processName&quot;: &quot;&#39;MainProcess&#39;&quot;,</span><br><span class="line">    &quot;process&quot;: &quot;83309&quot;,</span><br><span class="line">    &quot;key1&quot;: &quot;&#39;value1&#39;&quot;,</span><br><span class="line">    &quot;key2&quot;: &quot;&#39;value2&#39;&quot;,</span><br><span class="line">    &quot;project&quot;: &quot;WEHOST&quot;,</span><br><span class="line">    &quot;team&quot;: &quot;OPS&quot;,</span><br><span class="line">    &quot;department&quot;: &quot;IT&quot;,</span><br><span class="line">    &quot;log_debug&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到日志是json格式，这样你就可以很方便的使用grafna和kafka-&gt;logstash-&gt;es的方式进行日志收集展示了.如果需要将日志直接打到kafka中,需要使用kafka-python库,同时定义handlers进行处理.</p>
]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>PYTHON</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask知识点总结</title>
    <url>/2020/04/20/</url>
    <content><![CDATA[<blockquote class="blockquote-center">优秀的人，不是不合群，而是他们合群的人里面没有你</blockquote>


<h2 id="Python-中更优雅的日志记录方案"><a href="#Python-中更优雅的日志记录方案" class="headerlink" title="Python 中更优雅的日志记录方案"></a>Python 中更优雅的日志记录方案</h2><p>在 Python 中，一般情况下我们可能直接用自带的 logging 模块来记录日志，包括我之前的时候也是一样。在使用时我们需要配置一些 Handler、Formatter 来进行一些处理，比如把日志输出到不同的位置，或者设置一个不同的输出格式，或者设置日志分块和备份。但其实个人感觉 logging 用起来其实并不是那么好用，其实主要还是配置较为繁琐.</p>
<h2 id="常见使用"><a href="#常见使用" class="headerlink" title="常见使用"></a>常见使用</h2><p>首先看看 logging 常见的解决方案吧，我一般会配置输出到文件、控制台和 Elasticsearch。输出到控制台就仅仅是方便直接查看的；输出到文件是方便直接存储，保留所有历史记录的备份；输出到 Elasticsearch，直接将 Elasticsearch 作为存储和分析的中心，使用 Kibana 可以非常方便地分析和查看运行情况。<br>所以在这里我基本会对 logging 做如下的封装写法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mport logging</span><br><span class="line">import sys</span><br><span class="line">from os import makedirs</span><br><span class="line">from os.path import dirname, exists</span><br><span class="line"></span><br><span class="line">from cmreslogging.handlers import CMRESHandler</span><br><span class="line"></span><br><span class="line">loggers &#x3D; &#123;&#125;</span><br><span class="line"></span><br><span class="line">LOG_ENABLED &#x3D; True  # 是否开启日志</span><br><span class="line">LOG_TO_CONSOLE &#x3D; True  # 是否输出到控制台</span><br><span class="line">LOG_TO_FILE &#x3D; True  # 是否输出到文件</span><br><span class="line">LOG_TO_ES &#x3D; True  # 是否输出到 Elasticsearch</span><br><span class="line"></span><br><span class="line">LOG_PATH &#x3D; &#39;.&#x2F;runtime.log&#39;  # 日志文件路径</span><br><span class="line">LOG_LEVEL &#x3D; &#39;DEBUG&#39;  # 日志级别</span><br><span class="line">LOG_FORMAT &#x3D; &#39;%(levelname)s - %(asctime)s - process: %(process)d - %(filename)s - %(name)s - %(lineno)d - %(module)s - %(message)s&#39;  # 每条日志输出格式</span><br><span class="line">ELASTIC_SEARCH_HOST &#x3D; &#39;eshost&#39;  # Elasticsearch Host</span><br><span class="line">ELASTIC_SEARCH_PORT &#x3D; 9200  # Elasticsearch Port</span><br><span class="line">ELASTIC_SEARCH_INDEX &#x3D; &#39;runtime&#39;  # Elasticsearch Index Name</span><br><span class="line">APP_ENVIRONMENT &#x3D; &#39;dev&#39;  # 运行环境，如测试环境还是生产环境</span><br><span class="line"></span><br><span class="line">def get_logger(name&#x3D;None):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    get logger by name</span><br><span class="line">    :param name: name of logger</span><br><span class="line">    :return: logger</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    global loggers</span><br><span class="line"></span><br><span class="line">    if not name: name &#x3D; __name__</span><br><span class="line"></span><br><span class="line">    if loggers.get(name):</span><br><span class="line">        return loggers.get(name)</span><br><span class="line"></span><br><span class="line">    logger &#x3D; logging.getLogger(name)</span><br><span class="line">    logger.setLevel(LOG_LEVEL)</span><br><span class="line"></span><br><span class="line">    # 输出到控制台</span><br><span class="line">    if LOG_ENABLED and LOG_TO_CONSOLE:</span><br><span class="line">        stream_handler &#x3D; logging.StreamHandler(sys.stdout)</span><br><span class="line">        stream_handler.setLevel(level&#x3D;LOG_LEVEL)</span><br><span class="line">        formatter &#x3D; logging.Formatter(LOG_FORMAT)</span><br><span class="line">        stream_handler.setFormatter(formatter)</span><br><span class="line">        logger.addHandler(stream_handler)</span><br><span class="line"></span><br><span class="line">    # 输出到文件</span><br><span class="line">    if LOG_ENABLED and LOG_TO_FILE:</span><br><span class="line">        # 如果路径不存在，创建日志文件文件夹</span><br><span class="line">        log_dir &#x3D; dirname(log_path)</span><br><span class="line">        if not exists(log_dir): makedirs(log_dir)</span><br><span class="line">        # 添加 FileHandler</span><br><span class="line">        file_handler &#x3D; logging.FileHandler(log_path, encoding&#x3D;&#39;utf-8&#39;)</span><br><span class="line">        file_handler.setLevel(level&#x3D;LOG_LEVEL)</span><br><span class="line">        formatter &#x3D; logging.Formatter(LOG_FORMAT)</span><br><span class="line">        file_handler.setFormatter(formatter)</span><br><span class="line">        logger.addHandler(file_handler)</span><br><span class="line"></span><br><span class="line">    # 输出到 Elasticsearch</span><br><span class="line">    if LOG_ENABLED and LOG_TO_ES:</span><br><span class="line">        # 添加 CMRESHandler</span><br><span class="line">        es_handler &#x3D; CMRESHandler(hosts&#x3D;[&#123;&#39;host&#39;: ELASTIC_SEARCH_HOST, &#39;port&#39;: ELASTIC_SEARCH_PORT&#125;],</span><br><span class="line">                                  # 可以配置对应的认证权限</span><br><span class="line">                                  auth_type&#x3D;CMRESHandler.AuthType.NO_AUTH,  </span><br><span class="line">                                  es_index_name&#x3D;ELASTIC_SEARCH_INDEX,</span><br><span class="line">                                  # 一个月分一个 Index</span><br><span class="line">                                  index_name_frequency&#x3D;CMRESHandler.IndexNameFrequency.MONTHLY,</span><br><span class="line">                                  # 额外增加环境标识</span><br><span class="line">                                  es_additional_fields&#x3D;&#123;&#39;environment&#39;: APP_ENVIRONMENT&#125;  </span><br><span class="line">                                  )</span><br><span class="line">        es_handler.setLevel(level&#x3D;LOG_LEVEL)</span><br><span class="line">        formatter &#x3D; logging.Formatter(LOG_FORMAT)</span><br><span class="line">        es_handler.setFormatter(formatter)</span><br><span class="line">        logger.addHandler(es_handler)</span><br><span class="line"></span><br><span class="line">    # 保存到全局 loggers</span><br><span class="line">    loggers[name] &#x3D; logger</span><br><span class="line">    return logger</span><br></pre></td></tr></table></figure>
<p>定义完了怎么使用呢？只需要使用定义的方法获取一个 logger，然后 log 对应的内容即可:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logger &#x3D; get_logger()</span><br><span class="line">logger.debug(&#39;this is a message&#39;)</span><br></pre></td></tr></table></figure>
<p>运行结果如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DEBUG - 2019-10-11 22:27:35,923 - process: 99490 - logger.py - __main__ - 81 - logger - this is a message</span><br></pre></td></tr></table></figure>
<p>我们看看这个定义的基本实现吧。首先这里一些常量是用来定义 <code>logging</code> 模块的一些基本属性的，比如 LOG_ENABLED 代表是否开启日志功能，<code>LOG_TO_E</code>S 代表是否将日志输出到 Elasticsearch，另外还有很多其他的日志基本配置，如 <code>LOG_FORMAT</code> 配置了日志每个条目输出的基本格式，另外还有一些连接的必要信息。这些变量可以和运行时的命令行或环境变量对接起来，可以方便地实现一些开关和配置的更换。</p>
<p>然后定义了这么一个 <code>get_logger</code> 方法，接收一个参数 name。首先该方法拿到 name 之后，会到全局的 loggers 变量里面查找，loggers 变量是一个全局字典，如果有已经声明过的 logger，直接将其获取返回即可，不用再将其二次初始化。如果 loggers 里面没有找到 name 对应的 logger，那就进行创建即可。创建 logger 之后，可以为其添加各种对应的 Handler，如输出到控制台就用 StreamHandler，输出到文件就用 FileHandler 或 RotatingFileHandler，输出到 Elasticsearch 就用 CMRESHandler，分别配置好对应的信息即可。</p>
<p>最后呢，将新建的 logger 保存到全局的 loggers 里面并返回即可，这样如果有同名的 logger 便可以直接查找 loggers 直接返回了。<br>在这里依赖了额外的输出到 Elasticsearch 的包，叫做 CMRESHandler，它可以支持将日志输出到 Elasticsearch 里面，如果要使用的话可以安装一下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install CMRESHandler</span><br></pre></td></tr></table></figure>
<p>其 GitHub 地址是：<code>https://github.com/cmanaha/python-elasticsearch-logger</code>，具体的使用方式可以看看它的官方说明，如配置认证信息，配置 Index 分隔信息等等。<br>好，上面就是我之前常用的 logging 配置，通过如上的配置，我就可以实现将 logging 输出到三个位置，并可以实现对应的效果。比如输出到 Elasticsearch 之后，我就可以非常方便地使用 Kibana 来查看当前运行情况，ERROR Log 的比例等等.<br>也可以在它的基础上做更进一步的统计分析.</p>
<h2 id="loguru"><a href="#loguru" class="headerlink" title="loguru"></a>loguru</h2><p>上面的实现方式已经是一个较为可行的配置方案了。然而，我还是会感觉到有些 Handler 配起来麻烦，尤其是新建一个项目的很多时候懒得去写一些配置。即使是不用上文的配置，用最基本的几行 logging 配置，像如下的通用配置:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import logging</span><br><span class="line">logging.basicConfig(level &#x3D; logging.INFO,format &#x3D; &#39;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#39;)</span><br><span class="line">logger &#x3D; logging.getLogger(__name__)</span><br></pre></td></tr></table></figure>
<p>我也懒得去写，感觉并不是一个优雅的实现方式。<br>有需求就有动力啊，这不，就有人实现了这么一个库，叫做 loguru，可以将 log 的配置和使用更加简单和方便。<br>下面我们来看看它到底是怎么用的吧.</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先，这个库的安装方式很简单，就用基本的 pip 安装即可，Python 3 版本的安装如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install loguru</span><br></pre></td></tr></table></figure>
<p>安装完毕之后，我们就可以在项目里使用这个 loguru 库了.</p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>那么这个库怎么来用呢？我们先用一个实例感受下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from loguru import logger</span><br><span class="line"></span><br><span class="line">logger.debug(&#39;this is a debug message&#39;)</span><br></pre></td></tr></table></figure>
<p>看到了吧，不需要配置什么东西，直接引入一个 logger，然后调用其 debug 方法即可。</p>
<p>在 loguru 里面有且仅有一个主要对象，那就是 logger，loguru 里面有且仅有一个 logger，而且它已经被提前配置了一些基础信息，比如比较友好的格式化、文本颜色信息等等。</p>
<p>上面的代码运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2019-10-13 22:46:12.367 | DEBUG    | __main__:&lt;module&gt;:4 - this is a debug message</span><br></pre></td></tr></table></figure>
<p>可以看到其默认的输出格式是上面的内容，有时间、级别、模块名、行号以及日志信息，不需要手动创建 logger，直接使用即可，另外其输出还是彩色的，看起来会更加友好。</p>
<p>以上的日志信息是直接输出到控制台的，并没有输出到其他的地方，如果想要输出到其他的位置，比如存为文件，我们只需要使用一行代码声明即可。</p>
<p>例如将结果同时输出到一个 runtime.log 文件里面，可以这么写:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from loguru import logger</span><br><span class="line"></span><br><span class="line">logger.add(&#39;runtime.log&#39;)</span><br><span class="line">logger.debug(&#39;this is a debug&#39;)</span><br></pre></td></tr></table></figure>
<p>很简单吧，我们也不需要再声明一个 FileHandler 了，就一行 add 语句搞定，运行之后会发现目录下 runtime.log 里面同样出现了刚刚控制台输出的 DEBUG 信息。</p>
<p>上面就是一些基本的使用，但这还远远不够，下面我们来详细了解下它的一些功能模块.</p>
<h2 id="详细使用"><a href="#详细使用" class="headerlink" title="详细使用"></a>详细使用</h2><p>既然是日志，那么最常见的就是输出到文件了。loguru 对输出到文件的配置有非常强大的支持，比如支持输出到多个文件，分级别分别输出，过大创建新文件，过久自动删除等等。</p>
<p>下面我们分别看看这些怎样来实现，这里基本上就是 add 方法的使用介绍。因为这个 add 方法就相当于给 logger 添加了一个 Handler，它给我们暴露了许多参数来实现 Handler 的配置，下面我们来详细介绍下。<br>首先看看它的方法定义吧:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def add(</span><br><span class="line">        self,</span><br><span class="line">        sink,</span><br><span class="line">        *,</span><br><span class="line">        level&#x3D;_defaults.LOGURU_LEVEL,</span><br><span class="line">        format&#x3D;_defaults.LOGURU_FORMAT,</span><br><span class="line">        filter&#x3D;_defaults.LOGURU_FILTER,</span><br><span class="line">        colorize&#x3D;_defaults.LOGURU_COLORIZE,</span><br><span class="line">        serialize&#x3D;_defaults.LOGURU_SERIALIZE,</span><br><span class="line">        backtrace&#x3D;_defaults.LOGURU_BACKTRACE,</span><br><span class="line">        diagnose&#x3D;_defaults.LOGURU_DIAGNOSE,</span><br><span class="line">        enqueue&#x3D;_defaults.LOGURU_ENQUEUE,</span><br><span class="line">        catch&#x3D;_defaults.LOGURU_CATCH,</span><br><span class="line">        **kwargs</span><br><span class="line">    ):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>
<p>看看它的源代码，它支持这么多的参数，如 level、format、filter、color 等等。</p>
<blockquote>
<p>sink<br>另外我们还注意到它有个非常重要的参数 sink，我们看看官方文档：<code>https://loguru.readthedocs.io/en/stable/api/logger.html#sink</code>，可以了解到通过 sink 我们可以传入多种不同的数据结构，汇总如下:</p>
</blockquote>
<ul>
<li>sink 可以传入一个 file 对象，例如 sys.stderr 或者 open(‘file.log’, ‘w’) 都可以。</li>
<li>sink 可以直接传入一个 str 字符串或者 pathlib.Path 对象，其实就是代表文件路径的，如果识别到是这种类型，它会自动创建对应路径的日志文件并将日志输出进去。</li>
<li>sink 可以是一个方法，可以自行定义输出实现。</li>
<li>sink 可以是一个 logging 模块的 Handler，比如 FileHandler、StreamHandler 等等，或者上文中我们提到的 CMRESHandler 照样也是可以的，这样就可以实现自定义 Handler 的配置。</li>
<li>sink 还可以是一个自定义的类，具体的实现规范可以参见官方文档.<br>所以说，刚才我们所演示的输出到文件，仅仅给它传了一个 str 字符串路径，他就给我们创建了一个日志文件，就是这个原理。</li>
</ul>
<blockquote>
<blockquote>
<p>format, filter, level<br>下面我们再了解下它的其他参数，例如 format、filter、level 等等。<br>其实它们的概念和格式和 logging 模块都是基本一样的了，例如这里使用 format、filter、level 来规定输出的格式:</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logger.add(&#39;runtime.log&#39;, format&#x3D;&quot;&#123;time&#125; &#123;level&#125; &#123;message&#125;&quot;, filter&#x3D;&quot;my_module&quot;, level&#x3D;&quot;INFO&quot;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>删除sink<br>另外添加 sink 之后我们也可以对其进行删除，相当于重新刷新并写入新的内容。<br>删除的时候根据刚刚 add 方法返回的 id 进行删除即可，看下面的例子:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from loguru import logger</span><br><span class="line"></span><br><span class="line">trace &#x3D; logger.add(&#39;runtime.log&#39;)</span><br><span class="line">logger.debug(&#39;this is a debug message&#39;)</span><br><span class="line">logger.remove(trace)</span><br><span class="line">logger.debug(&#39;this is another debug message&#39;)</span><br></pre></td></tr></table></figure>
<p>看这里，我们首先 add 了一个 sink，然后获取它的返回值，赋值为 trace。随后输出了一条日志，然后将 trace 变量传给 remove 方法，再次输出一条日志，看看结果是怎样的。<br>控制台输出如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">019-10-13 23:18:26.469 | DEBUG    | __main__:&lt;module&gt;:4 - this is a debug message</span><br><span class="line">2019-10-13 23:18:26.469 | DEBUG    | __main__:&lt;module&gt;:6 - this is another debug message</span><br></pre></td></tr></table></figure>
<p>日志文件 runtime.log 内容如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2019-10-13 23:18:26.469 | DEBUG    | __main__:&lt;module&gt;:4 - this is a debug message</span><br></pre></td></tr></table></figure>
<p>可以发现，在调用 remove 方法之后，确实将历史 log 删除了。<br>这样我们就可以实现日志的刷新重新写入操作。</p>
<blockquote>
<p>rotation 配置<br>用了 loguru 我们还可以非常方便地使用 rotation 配置，比如我们想一天输出一个日志文件，或者文件太大了自动分隔日志文件，我们可以直接使用 add 方法的 rotation 参数进行配置。<br>我们看看下面的例子：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logger.add(&#39;runtime_&#123;time&#125;.log&#39;, rotation&#x3D;&quot;500 MB&quot;)</span><br></pre></td></tr></table></figure>
<p>通过这样的配置我们就可以实现每 500MB 存储一个文件，每个 log 文件过大就会新创建一个 log 文件。我们在配置 log 名字时加上了一个 time 占位符，这样在生成时可以自动将时间替换进去，生成一个文件名包含时间的 log 文件。<br>另外我们也可以使用 rotation 参数实现定时创建 log 文件，例如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logger.add(&#39;runtime_&#123;time&#125;.log&#39;, rotation&#x3D;&#39;00:00&#39;)</span><br></pre></td></tr></table></figure>
<p>这样就可以实现每天 0 点新创建一个 log 文件输出了。<br>另外我们也可以配置 log 文件的循环时间，比如每隔一周创建一个 log 文件，写法如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logger.add(&#39;runtime_&#123;time&#125;.log&#39;, rotation&#x3D;&#39;1 week&#39;)</span><br></pre></td></tr></table></figure>
<p>这样我们就可以实现一周创建一个 log 文件了。</p>
<blockquote>
<p>retention 配置<br>很多情况下，一些非常久远的 log 对我们来说并没有什么用处了，它白白占据了一些存储空间，不清除掉就会非常浪费。retention 这个参数可以配置日志的最长保留时间。<br>比如我们想要设置日志文件最长保留 10 天，可以这么来配置:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logger.add(&#39;runtime.log&#39;, retention&#x3D;&#39;10 days&#39;)</span><br></pre></td></tr></table></figure>
<p>这样 log 文件里面就会保留最新 10 天的 log，妈妈再也不用担心 log 沉积的问题啦。</p>
<blockquote>
<p>compression 配置<br>loguru 还可以配置文件的压缩格式，比如使用 zip 文件格式保存，示例如下:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logger.add(&#39;runtime.log&#39;, compression&#x3D;&#39;zip&#39;)</span><br></pre></td></tr></table></figure>
<p>这样可以更加节省存储空间。</p>
<blockquote>
<p>字符串格式化<br>loguru 在输出 log 的时候还提供了非常友好的字符串格式化功能，像这样:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logger.info(&#39;If you are using Python &#123;&#125;, prefer &#123;feature&#125; of course!&#39;, 3.6, feature&#x3D;&#39;f-strings&#39;)</span><br></pre></td></tr></table></figure>
<p>这样在添加参数就非常方便了。</p>
<blockquote>
<p>Traceback 记录<br>在很多情况下，如果遇到运行错误，而我们在打印输出 log 的时候万一不小心没有配置好 Traceback 的输出，很有可能我们就没法追踪错误所在了。<br>但用了 loguru 之后，我们用它提供的装饰器就可以直接进行 Traceback 的记录，类似这样的配置即可:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@logger.catch</span><br><span class="line">def my_function(x, y, z):</span><br><span class="line">    # An error? It&#39;s caught anyway!</span><br><span class="line">    return 1 &#x2F; (x + y + z)</span><br></pre></td></tr></table></figure>
<p>我们做个测试，我们在调用时三个参数都传入 0，直接引发除以 0 的错误，看看会出现什么情况:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">my_function(0, 0, 0)</span><br></pre></td></tr></table></figure>
<p>运行完毕之后，可以发现 log 里面就出现了 Traceback 信息，而且给我们输出了当时的变量值，真的是不能再赞了！结果如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; File &quot;run.py&quot;, line 15, in &lt;module&gt;</span><br><span class="line">    my_function(0, 0, 0)</span><br><span class="line">    └ &lt;function my_function at 0x1171dd510&gt;</span><br><span class="line"></span><br><span class="line">  File &quot;&#x2F;private&#x2F;var&#x2F;py&#x2F;logurutest&#x2F;demo5.py&quot;, line 13, in my_function</span><br><span class="line">    return 1 &#x2F; (x + y + z)</span><br><span class="line">                │   │   └ 0</span><br><span class="line">                │   └ 0</span><br><span class="line">                └ 0</span><br><span class="line"></span><br><span class="line">ZeroDivisionError: division by zero</span><br></pre></td></tr></table></figure>
<p>因此，用 loguru 可以非常方便地实现日志追踪，debug 效率可能要高上十倍了？<br>另外 loguru 还有很多很多强大的功能，这里就不再一一展开讲解了，更多的内容大家可以看看 loguru 的官方文档详细了解一下：<code>https://loguru.readthedocs.io/en/stable/index.html</code><br>看完之后，是时候把自己的 logging 模块替换成 loguru 啦！</p>
]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>PYTHON</tag>
      </tags>
  </entry>
  <entry>
    <title>一些有用的Python库</title>
    <url>/2020/04/20/</url>
    <content><![CDATA[<h2 id="一些有用的Python库"><a href="#一些有用的Python库" class="headerlink" title="一些有用的Python库"></a>一些有用的Python库</h2><h3 id="环境管理"><a href="#环境管理" class="headerlink" title="环境管理"></a>环境管理</h3><p>管理 Python 版本和环境的工具</p>
<ul>
<li><p>p – 非常简单的交互式 python 版本管理工具。</p>
</li>
<li><p>pyenv – 简单的 Python 版本管理工具。</p>
</li>
<li><p>Vex – 可以在虚拟环境中执行命令。</p>
</li>
<li><p>virtualenv – 创建独立 Python 环境的工具。</p>
</li>
<li><p>virtualenvwrapper- virtualenv 的一组扩展。</p>
</li>
</ul>
<h3 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h3><p>管理包和依赖的工具</p>
<ul>
<li><p>pip – Python 包和依赖关系管理工具。</p>
</li>
<li><p>pip-tools – 保证 Python 包依赖关系更新的一组工具。</p>
</li>
<li><p>conda – 跨平台，Python 二进制包管理工具。</p>
</li>
<li><p>Curdling – 管理 Python 包的命令行工具。</p>
</li>
<li><p>wheel – Python 分发的新标准，意在取代 eggs。</p>
</li>
</ul>
<h3 id="包仓库"><a href="#包仓库" class="headerlink" title="包仓库"></a>包仓库</h3><p>本地 PyPI 仓库服务和代理。</p>
<ul>
<li><p>warehouse – 下一代 PyPI。</p>
</li>
<li><p>Warehousebandersnatch – PyPA 提供的 PyPI 镜像工具。</p>
</li>
<li><p>devpi – PyPI 服务和打包/测试/分发工具。</p>
</li>
<li><p>localshop – 本地 PyPI 服务(自定义包并且自动对 PyPI 镜像)。</p>
</li>
</ul>
<h2 id="分发"><a href="#分发" class="headerlink" title="分发"></a>分发</h2><p>打包为可执行文件以便分发。</p>
<ul>
<li><p>PyInstaller – 将 Python 程序转换成独立的执行文件(跨平台)。</p>
</li>
<li><p>dh-virtualenv – 构建并将 virtualenv 虚拟环境作为一个 Debian 包来发布。</p>
</li>
<li><p>Nuitka – 将脚本、模块、包编译成可执行文件或扩展模块。</p>
</li>
<li><p>py2app – 将 Python 脚本变为独立软件包(Mac OS X)。</p>
</li>
<li><p>py2exe – 将 Python 脚本变为独立软件包(Windows)。</p>
</li>
<li><p>pynsist – 一个用来创建 Windows 安装程序的工具，可以在安装程序中打包 Python本身。</p>
</li>
</ul>
<h2 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h2><p>将源码编译成软件。</p>
<ul>
<li><p>buildout – 一个构建系统，从多个组件来创建，组装和部署应用。</p>
</li>
<li><p>BitBake – 针对嵌入式 Linux 的类似 make 的构建工具。</p>
</li>
<li><p>fabricate – 对任何语言自动找到依赖关系的构建工具。</p>
</li>
<li><p>PlatformIO – 多平台命令行构建工具。</p>
</li>
<li><p>PyBuilder – 纯 Python 实现的持续化构建工具。</p>
</li>
<li><p>SCons – 软件构建工具。</p>
</li>
</ul>
<h2 id="交互式解析器"><a href="#交互式解析器" class="headerlink" title="交互式解析器"></a>交互式解析器</h2><p>交互式 Python 解析器。</p>
<ul>
<li><p>IPython – 功能丰富的工具，非常有效的使用交互式 Python。</p>
</li>
<li><p>bpython- 界面丰富的 Python 解析器。</p>
</li>
<li><p>ptpython – 高级交互式Python解析器， 构建于python-prompt-toolkit 之上。</p>
</li>
</ul>
<p>文件管理和 MIME(多用途的网际邮件扩充协议)类型检测。</p>
<ul>
<li><p>imghdr – (Python 标准库)检测图片类型。</p>
</li>
<li><p>mimetypes – (Python 标准库)将文件名映射为 MIME 类型。</p>
</li>
<li><p>path.py – 对 os.path 进行封装的模块。</p>
</li>
<li><p>pathlib – (Python3.4+ 标准库)跨平台的、面向对象的路径操作库。</p>
</li>
<li><p>python-magic- 文件类型检测的第三方库 libmagic 的 Python 接口。</p>
</li>
<li><p>Unipath- 用面向对象的方式操作文件和目录</p>
</li>
<li><p>watchdog – 管理文件系统事件的 API 和 shell 工具</p>
</li>
</ul>
<h2 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h2><p>操作日期和时间的类库。</p>
<ul>
<li><p>arrow- 更好的 Python 日期时间操作类库。</p>
</li>
<li><p>Chronyk – Python 3 的类库，用于解析手写格式的时间和日期。</p>
</li>
<li><p>dateutil – Python datetime 模块的扩展。</p>
</li>
<li><p>delorean- 解决 Python 中有关日期处理的棘手问题的库。</p>
</li>
<li><p>moment – 一个用来处理时间和日期的Python库。灵感来自于Moment.js。</p>
</li>
<li><p>PyTime – 一个简单易用的Python模块，用于通过字符串来操作日期/时间。</p>
</li>
<li><p>pytz – 现代以及历史版本的世界时区定义。将时区数据库引入Python。</p>
</li>
<li><p>when.py – 提供用户友好的函数来帮助用户进行常用的日期和时间操作。</p>
</li>
</ul>
<h2 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h2><p>用于解析和操作文本的库。</p>
<ol>
<li>通用</li>
</ol>
<ul>
<li><p>chardet – 字符编码检测器，兼容 Python2 和 Python3。</p>
</li>
<li><p>difflib – (Python 标准库)帮助我们进行差异化比较。</p>
</li>
<li><p>ftfy – 让Unicode文本更完整更连贯。</p>
</li>
<li><p>fuzzywuzzy – 模糊字符串匹配。</p>
</li>
<li><p>Levenshtein – 快速计算编辑距离以及字符串的相似度。</p>
</li>
<li><p>pangu.py – 在中日韩语字符和数字字母之间添加空格。</p>
</li>
<li><p>pyfiglet -figlet 的 Python实现。</p>
</li>
<li><p>shortuuid – 一个生成器库，用以生成简洁的，明白的，URL 安全的 UUID。</p>
</li>
<li><p>unidecode – Unicode 文本的 ASCII 转换形式 。</p>
</li>
<li><p>uniout – 打印可读的字符，而不是转义的字符串。</p>
</li>
<li><p>xpinyin – 一个用于把汉字转换为拼音的库。</p>
</li>
</ul>
<ol start="2">
<li>Slug化</li>
</ol>
<ul>
<li><p>awesome-slugify – 一个 Python slug 化库，可以保持 Unicode。</p>
</li>
<li><p>python-slugify – Python slug 化库，可以把 unicode 转化为 ASCII。</p>
</li>
<li><p>unicode-slugify – 一个 slug 工具，可以生成 unicode slugs ,需要依赖 Django 。</p>
</li>
</ul>
<ol start="3">
<li>解析器</li>
</ol>
<ul>
<li><p>phonenumbers – 解析，格式化，储存，验证电话号码。</p>
</li>
<li><p>PLY – lex 和 yacc 解析工具的 Python 实现。</p>
</li>
<li><p>Pygments – 通用语法高亮工具。</p>
</li>
<li><p>pyparsing – 生成通用解析器的框架。</p>
</li>
<li><p>python-nameparser – 把一个人名分解为几个独立的部分。</p>
</li>
<li><p>python-user-agents – 浏览器 user agent 解析器。</p>
</li>
<li><p>sqlparse – 一个无验证的 SQL 解析器。</p>
</li>
</ul>
<h2 id="特殊文本格式处理"><a href="#特殊文本格式处理" class="headerlink" title="特殊文本格式处理"></a>特殊文本格式处理</h2><ul>
<li>一些用来解析和操作特殊文本格式的库。</li>
</ul>
<ol>
<li><p>通用<br>tablib – 一个用来处理中表格数据的模块。</p>
</li>
<li><p>Office</p>
</li>
</ol>
<ul>
<li><p>Marmir – 把输入的Python 数据结构转换为电子表单。</p>
</li>
<li><p>openpyxl – 一个用来读写 Excel 2010 xlsx/xlsm/xltx/xltm 文件的库。</p>
</li>
<li><p>python-docx – 读取，查询以及修改 Microsoft Word 2007/2008 docx 文件。</p>
</li>
<li><p>unoconv – 在 LibreOffice/OpenOffice 支持的任意文件格式之间进行转换。</p>
</li>
<li><p>XlsxWriter – 一个用于创建 Excel .xlsx 文件的 Python 模块。</p>
</li>
<li><p>xlwings – 一个使得在 Excel 中方便调用 Python 的库(反之亦然)，基于 BSD 协议。</p>
</li>
<li><p>xlwt / xlrd – 读写 Excel 文件的数据和格式信息。</p>
</li>
<li><p>relatorio – 模板化OpenDocument 文件。</p>
</li>
</ul>
<ol start="3">
<li>PDF</li>
</ol>
<ul>
<li><p>PDFMiner – 一个用于从PDF文档中抽取信息的工具。</p>
</li>
<li><p>PyPDF2 – 一个可以分割，合并和转换 PDF 页面的库。</p>
</li>
<li><p>ReportLab – 快速创建富文本 PDF 文档。</p>
</li>
</ul>
<ol start="4">
<li>Markdown</li>
</ol>
<ul>
<li><p>Mistune – 快速并且功能齐全的纯 Python 实现的 Markdown 解析器。</p>
</li>
<li><p>Python-Markdown – John Gruber’s Markdown 的 Python 版实现。</p>
</li>
</ul>
<ol start="5">
<li>YAML</li>
</ol>
<ul>
<li>PyYAML – Python 版本的 YAML 解析器。</li>
</ul>
<ol start="6">
<li>CSV</li>
</ol>
<ul>
<li>csvkit – 用于转换和操作 CSV 的工具。</li>
</ul>
<ol start="7">
<li>Archive</li>
</ol>
<ul>
<li>unp – 一个用来方便解包归档文件的命令行工具。</li>
</ul>
<h2 id="自然语言处理"><a href="#自然语言处理" class="headerlink" title="自然语言处理"></a>自然语言处理</h2><p>用来处理人类语言的库。</p>
<ul>
<li><p>NLTK – 一个先进的平台，用以构建处理人类语言数据的 Python 程序。</p>
</li>
<li><p>jieba – 中文分词工具。</p>
</li>
<li><p>langid.py – 独立的语言识别系统。</p>
</li>
<li><p>Pattern – Python 网络信息挖掘模块。</p>
</li>
<li><p>SnowNLP – 一个用来处理中文文本的库。</p>
</li>
<li><p>TextBlob – 为进行普通自然语言处理任务提供一致的 API。</p>
</li>
<li><p>TextGrocery – 一简单高效的短文本分类工具，基于 LibLinear 和 Jieba。</p>
</li>
</ul>
<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>用以生成项目文档的库。</p>
<ul>
<li><p>Sphinx – Python 文档生成器。</p>
</li>
<li><p>awesome-sphinxdoc</p>
</li>
<li><p>MkDocs – 对 Markdown 友好的文档生成器。</p>
</li>
<li><p>pdoc – 一个可以替换Epydoc 的库，可以自动生成 Python 库的 API 文档。</p>
</li>
<li><p>Pycco – 文学编程(literate-programming)风格的文档生成器。</p>
</li>
</ul>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>用来保存和解析配置的库。</p>
<ul>
<li><p>config – logging 模块作者写的分级配置模块。</p>
</li>
<li><p>ConfigObj – INI 文件解析器，带验证功能。</p>
</li>
<li><p>ConfigParser – (Python 标准库) INI 文件解析器。</p>
</li>
<li><p>profig – 通过多种格式进行配置，具有数值转换功能。</p>
</li>
<li><p>python-decouple – 将设置和代码完全隔离。</p>
</li>
</ul>
<h2 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h2><p>用于创建命令行程序的库。</p>
<ol>
<li>命令行程序开发</li>
</ol>
<ul>
<li><p>cement – Python 的命令行程序框架。</p>
</li>
<li><p>click – 一个通过组合的方式来创建精美命令行界面的包。</p>
</li>
<li><p>cliff – 一个用于创建命令行程序的框架，可以创建具有多层命令的命令行程序。</p>
</li>
<li><p>clint – Python 命令行程序工具。</p>
</li>
<li><p>colorama – 跨平台彩色终端文本。</p>
</li>
<li><p>docopt – Python 风格的命令行参数解析器。</p>
</li>
<li><p>Gooey – 一条命令，将命令行程序变成一个 GUI 程序。</p>
</li>
<li><p>python-prompt-toolkit – 一个用于构建强大的交互式命令行程序的库。</p>
</li>
</ul>
<ol start="2">
<li>生产力工具</li>
</ol>
<ul>
<li><p>aws-cli – Amazon Web Services 的通用命令行界面。</p>
</li>
<li><p>bashplotlib – 在终端中进行基本绘图。</p>
</li>
<li><p>caniusepython3 – 判断是哪个项目妨碍你你移植到 Python 3。</p>
</li>
<li><p>cookiecutter – 从 cookiecutters(项目模板)创建项目的一个命令行工具。</p>
</li>
<li><p>doitlive – 一个用来在终端中进行现场演示的工具。</p>
</li>
<li><p>howdoi – 通过命令行获取即时的编程问题解答。</p>
</li>
<li><p>httpie – 一个命令行HTTP 客户端，cURL 的替代品，易用性更好。</p>
</li>
<li><p>PathPicker – 从bash输出中选出文件。</p>
</li>
<li><p>percol – 向UNIX shell 传统管道概念中加入交互式选择功能。</p>
</li>
<li><p>SAWS – 一个加强版的 AWS 命令行。</p>
</li>
<li><p>thefuck – 修正你之前的命令行指令。</p>
</li>
<li><p>mycli – 一个 MySQL 命令行客户端，具有自动补全和语法高亮功能。</p>
</li>
<li><p>pgcli – Postgres 命令行工具，具有自动补全和语法高亮功能。</p>
</li>
</ul>
<h2 id="下载器"><a href="#下载器" class="headerlink" title="下载器"></a>下载器</h2><p>用来进行下载的库.</p>
<ul>
<li><p>s3cmd – 一个用来管理Amazon S3 和 CloudFront 的命令行工具。</p>
</li>
<li><p>s4cmd – 超级 S3 命令行工具，性能更加强劲。</p>
</li>
<li><p>you-get – 一个 YouTube/Youku/Niconico 视频下载器，使用 Python3 编写。</p>
</li>
<li><p>youtube-dl – 一个小巧的命令行程序，用来下载 YouTube 视频。</p>
</li>
</ul>
<h2 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h2><p>用来操作图像的库.</p>
<ul>
<li><p>pillow – Pillow 是一个更加易用版的 PIL。</p>
</li>
<li><p>hmap – 图像直方图映射。</p>
</li>
<li><p>imgSeek – 一个使用视觉相似性搜索一组图片集合的项目。</p>
</li>
<li><p>nude.py – 裸体检测。</p>
</li>
<li><p>pyBarcode – 不借助 PIL 库在 Python 程序中生成条形码。</p>
</li>
<li><p>pygram – 类似 Instagram 的图像滤镜。</p>
</li>
<li><p>python-qrcode – 一个纯 Python 实现的二维码生成器。</p>
</li>
<li><p>Quads – 基于四叉树的计算机艺术。</p>
</li>
<li><p>scikit-image – 一个用于(科学)图像处理的 Python 库。</p>
</li>
<li><p>thumbor – 一个小型图像服务，具有剪裁，尺寸重设和翻转功能。</p>
</li>
<li><p>wand – MagickWand的Python 绑定。MagickWand 是 ImageMagick的 C API 。</p>
</li>
</ul>
<h2 id="OCR"><a href="#OCR" class="headerlink" title="OCR"></a>OCR</h2><p>光学字符识别库。</p>
<ul>
<li><p>pyocr – Tesseract 和 Cuneiform 的一个封装(wrapper)。</p>
</li>
<li><p>pytesseract – Google Tesseract OCR 的另一个封装(wrapper)。</p>
</li>
<li><p>python-tesseract – Google Tesseract OCR 的一个包装类。</p>
</li>
</ul>
<h2 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h2><p>用来操作音频的库</p>
<ul>
<li><p>audiolazy -Python 的数字信号处理包。</p>
</li>
<li><p>audioread – 交叉库 (GStreamer + Core Audio + MAD + FFmpeg) 音频解码。</p>
</li>
<li><p>beets – 一个音乐库管理工具及 MusicBrainz 标签添加工具</p>
</li>
<li><p>dejavu – 音频指纹提取和识别</p>
</li>
<li><p>django-elastic-transcoder – Django + Amazon Elastic Transcoder。</p>
</li>
<li><p>eyeD3 – 一个用来操作音频文件的工具，具体来讲就是包含 ID3 元信息的 MP3 文件。</p>
</li>
<li><p>id3reader – 一个用来读取 MP3 元数据的 Python 模块。</p>
</li>
<li><p>m3u8 – 一个用来解析 m3u8 文件的模块。</p>
</li>
<li><p>mutagen – 一个用来处理音频元数据的 Python 模块。</p>
</li>
<li><p>pydub – 通过简单、简洁的高层接口来操作音频文件。</p>
</li>
<li><p>pyechonest – Echo Nest API 的 Python 客户端</p>
</li>
<li><p>talkbox – 一个用来处理演讲/信号的 Python 库</p>
</li>
<li><p>TimeSide – 开源 web 音频处理框架。</p>
</li>
<li><p>tinytag – 一个用来读取MP3, OGG, FLAC 以及 Wave 文件音乐元数据的库。</p>
</li>
<li><p>mingus – 一个高级音乐理论和曲谱包，支持 MIDI 文件和回放功能。</p>
</li>
</ul>
<h2 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h2><p>用来操作视频和GIF的库。</p>
<ul>
<li><p>moviepy – 一个用来进行基于脚本的视频编辑模块，适用于多种格式，包括动图 GIFs。</p>
</li>
<li><p>scikit-video – SciPy 视频处理常用程序。</p>
</li>
</ul>
<h2 id="地理位置"><a href="#地理位置" class="headerlink" title="地理位置"></a>地理位置</h2><p>地理编码地址以及用来处理经纬度的库。</p>
<ul>
<li><p>GeoDjango – 世界级地理图形 web 框架。</p>
</li>
<li><p>GeoIP – MaxMind GeoIP Legacy 数据库的 Python API。</p>
</li>
<li><p>geojson – GeoJSON 的 Python 绑定及工具。</p>
</li>
<li><p>geopy – Python 地址编码工具箱。</p>
</li>
<li><p>pygeoip – 纯 Python GeoIP API。</p>
</li>
<li><p>django-countries – 一个 Django 应用程序，提供用于表格的国家选择功能，国旗图标静态文件以及模型中的国家字段。</p>
</li>
</ul>
<p><a href="https://mp.weixin.qq.com/s/Jnf1jaHQo8s2R_ioNrLk6A" target="_blank" rel="noopener">原文链接</a></p>
]]></content>
      <categories>
        <category>PYTHON</category>
      </categories>
      <tags>
        <tag>PYTHON</tag>
      </tags>
  </entry>
</search>
